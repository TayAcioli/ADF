/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation, Input, EventEmitter, Output } from '@angular/core';
import { NodesApiService } from '@alfresco/adf-core';
import { PermissionDisplayModel } from '../../models/permission.model';
import { NodePermissionService } from '../../services/node-permission.service';
var PermissionListComponent = /** @class */ (function () {
    function PermissionListComponent(nodeService, nodePermissionService) {
        this.nodeService = nodeService;
        this.nodePermissionService = nodePermissionService;
        /**
         * ID of the node whose permissions you want to show.
         */
        this.nodeId = '';
        /**
         * Emitted when the permission is updated.
         */
        this.update = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    PermissionListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.fetchNodePermissions();
    };
    /**
     * @return {?}
     */
    PermissionListComponent.prototype.reload = /**
     * @return {?}
     */
    function () {
        this.fetchNodePermissions();
    };
    /**
     * @return {?}
     */
    PermissionListComponent.prototype.fetchNodePermissions = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.nodeService.getNode(this.nodeId).subscribe(function (node) {
            _this.actualNode = node;
            _this.permissionList = _this.getPermissionList(node);
            _this.nodePermissionService.getNodeRoles(node).subscribe(function (settableList) {
                _this.settableRoles = settableList;
            });
        });
    };
    /**
     * @param {?} node
     * @return {?}
     */
    PermissionListComponent.prototype.getPermissionList = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        /** @type {?} */
        var allPermissions = [];
        if (node.permissions.locallySet) {
            node.permissions.locallySet.map(function (element) {
                /** @type {?} */
                var permission = new PermissionDisplayModel(element);
                allPermissions.push(permission);
            });
        }
        if (node.permissions.inherited) {
            node.permissions.inherited.map(function (element) {
                /** @type {?} */
                var permissionInherited = new PermissionDisplayModel(element);
                permissionInherited.isInherited = true;
                allPermissions.push(permissionInherited);
            });
        }
        return allPermissions;
    };
    /**
     * @param {?} event
     * @param {?} permissionRow
     * @return {?}
     */
    PermissionListComponent.prototype.saveNewRole = /**
     * @param {?} event
     * @param {?} permissionRow
     * @return {?}
     */
    function (event, permissionRow) {
        var _this = this;
        /** @type {?} */
        var updatedPermissionRole = this.buildUpdatedPermission(event.value, permissionRow);
        this.nodePermissionService.updatePermissionRole(this.actualNode, updatedPermissionRole)
            .subscribe(function (node) {
            _this.update.emit(updatedPermissionRole);
        });
    };
    /**
     * @param {?} newRole
     * @param {?} permissionRow
     * @return {?}
     */
    PermissionListComponent.prototype.buildUpdatedPermission = /**
     * @param {?} newRole
     * @param {?} permissionRow
     * @return {?}
     */
    function (newRole, permissionRow) {
        /** @type {?} */
        var permissionRole = {};
        permissionRole.accessStatus = permissionRow.accessStatus;
        permissionRole.name = newRole;
        permissionRole.authorityId = permissionRow.authorityId;
        return permissionRole;
    };
    /**
     * @param {?} permissionRow
     * @return {?}
     */
    PermissionListComponent.prototype.removePermission = /**
     * @param {?} permissionRow
     * @return {?}
     */
    function (permissionRow) {
        var _this = this;
        this.nodePermissionService.removePermission(this.actualNode, permissionRow).subscribe(function (node) {
            _this.update.emit(node);
        }, function (error) { return _this.error.emit(error); });
    };
    PermissionListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-permission-list',
                    template: "<div id=\"adf-permission-display-container\" class=\"adf-display-permission-container\">\n\n    <div *ngIf=\"!permissionList || !permissionList.length\" id=\"adf-no-permissions-template\">\n        <div #ref>\n            <ng-content select=\"adf-no-permission-template\"></ng-content>\n        </div>\n\n        <p *ngIf=\"ref.children.length == 0\">\n            {{ 'PERMISSION_MANAGER.PERMISSION_DISPLAY.NO_PERMISSIONS' | translate }}\n        </p>\n    </div>\n\n    <adf-datatable [rows]=\"permissionList\" class=\"adf-datatable-permission\" *ngIf=\"permissionList && permissionList.length\">\n        <data-columns>\n            <data-column key=\"icon\" type=\"icon\" [sortable]=\"false\">\n            </data-column>\n            <data-column title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.AUTHORITY_ID' | translate}}\" key=\"authorityId\"></data-column>\n            <data-column title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.ROLE' | translate}}\" key=\"name\">\n                <ng-template let-entry=\"$implicit\">\n                    <mat-form-field *ngIf=\"!entry.row.getValue('isInherited') else show_only_label\">\n                        <mat-select id=\"adf-select-role-permission\"\n                                    [placeholder]=\"entry.data.getValue(entry.row, entry.col)\"\n                                    value=\"{{entry.data.getValue(entry.row, entry.col)}}\"\n                                    (selectionChange)=\"saveNewRole($event, entry.row.obj)\">\n                          <mat-option *ngFor=\"let role of settableRoles\" [value]=\"role\">\n                            {{ role }}\n                          </mat-option>\n                        </mat-select>\n                      </mat-form-field>\n                      <ng-template #show_only_label>\n                          <span>{{entry.data.getValue(entry.row, entry.col)}}</span>\n                      </ng-template>\n                </ng-template>\n            </data-column>\n            <data-column title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}\" key=\"isInherited\">\n                <ng-template let-entry=\"$implicit\">\n                    <mat-chip-list>\n                        <mat-chip *ngIf=\"!!entry.data.getValue(entry.row, entry.col) else locally_set_chip\"\n                                id=\"adf-permission-inherited-label\"\n                                color=\"primary\" selected=\"true\">{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}</mat-chip>\n                    </mat-chip-list>\n                    <ng-template #locally_set_chip>\n                            <mat-chip-list>\n                                    <mat-chip id=\"adf-permission-locallyset-label\"\n                                              color=\"accent\" selected=\"true\">\n                                              {{'PERMISSION_MANAGER.PERMISSION_DISPLAY.LOCALLY_SET' | translate}}\n                                    </mat-chip>\n                            </mat-chip-list>\n                    </ng-template>\n                </ng-template>\n            </data-column>\n            <data-column key=\"delete\">\n            <ng-template let-entry=\"$implicit\">\n                <button *ngIf=\"!entry.row.getValue('isInherited')\" mat-icon-button color=\"primary\" (click)=\"removePermission(entry.row.obj)\">\n                    <mat-icon>highlight_off</mat-icon>\n                </button>\n            </ng-template>\n        </data-column>\n        </data-columns>\n    </adf-datatable>\n</div>\n\n",
                    encapsulation: ViewEncapsulation.None,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    PermissionListComponent.ctorParameters = function () { return [
        { type: NodesApiService },
        { type: NodePermissionService }
    ]; };
    PermissionListComponent.propDecorators = {
        nodeId: [{ type: Input }],
        update: [{ type: Output }],
        error: [{ type: Output }]
    };
    return PermissionListComponent;
}());
export { PermissionListComponent };
if (false) {
    /**
     * ID of the node whose permissions you want to show.
     * @type {?}
     */
    PermissionListComponent.prototype.nodeId;
    /**
     * Emitted when the permission is updated.
     * @type {?}
     */
    PermissionListComponent.prototype.update;
    /**
     * Emitted when an error occurs.
     * @type {?}
     */
    PermissionListComponent.prototype.error;
    /** @type {?} */
    PermissionListComponent.prototype.permissionList;
    /** @type {?} */
    PermissionListComponent.prototype.settableRoles;
    /** @type {?} */
    PermissionListComponent.prototype.actualNode;
    /** @type {?} */
    PermissionListComponent.prototype.nodeService;
    /** @type {?} */
    PermissionListComponent.prototype.nodePermissionService;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVybWlzc2lvbi1saXN0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy8iLCJzb3VyY2VzIjpbInBlcm1pc3Npb24tbWFuYWdlci9jb21wb25lbnRzL3Blcm1pc3Npb24tbGlzdC9wZXJtaXNzaW9uLWxpc3QuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsS0FBSyxFQUFVLFlBQVksRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEcsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRXJELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHdDQUF3QyxDQUFDOztJQTBCM0UsaUNBQW9CLFdBQTRCLEVBQzVCO1FBREEsZ0JBQVcsR0FBWCxXQUFXLENBQWlCO1FBQzVCLDBCQUFxQixHQUFyQixxQkFBcUI7Ozs7c0JBZnhCLEVBQUU7Ozs7c0JBSXVCLElBQUksWUFBWSxFQUFFOzs7O3FCQUlqQyxJQUFJLFlBQVksRUFBRTtLQVM1Qzs7OztJQUVELDBDQUFROzs7SUFBUjtRQUNJLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO0tBQy9COzs7O0lBRUQsd0NBQU07OztJQUFOO1FBQ0ksSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7S0FDL0I7Ozs7SUFFTyxzREFBb0I7Ozs7O1FBQ3hCLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBQyxJQUE0QjtZQUN6RSxLQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztZQUN2QixLQUFJLENBQUMsY0FBYyxHQUFHLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNuRCxLQUFJLENBQUMscUJBQXFCLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxVQUFDLFlBQXNCO2dCQUMzRSxLQUFJLENBQUMsYUFBYSxHQUFJLFlBQVksQ0FBQzthQUN0QyxDQUFDLENBQUM7U0FDTixDQUFDLENBQUM7Ozs7OztJQUdDLG1EQUFpQjs7OztjQUFDLElBQTRCOztRQUNsRCxJQUFJLGNBQWMsR0FBNkIsRUFBRSxDQUFDO1FBQ2xELElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUU7WUFDN0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFVBQUMsT0FBTzs7Z0JBQ3BDLElBQUksVUFBVSxHQUFHLElBQUksc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3JELGNBQWMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDbkMsQ0FBQyxDQUFDO1NBQ047UUFDRCxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFO1lBQzVCLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFDLE9BQU87O2dCQUNuQyxJQUFJLG1CQUFtQixHQUFHLElBQUksc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQzlELG1CQUFtQixDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7Z0JBQ3ZDLGNBQWMsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQzthQUM1QyxDQUFDLENBQUM7U0FDTjtRQUNELE9BQU8sY0FBYyxDQUFDOzs7Ozs7O0lBRzFCLDZDQUFXOzs7OztJQUFYLFVBQVksS0FBVSxFQUFFLGFBQXFDO1FBQTdELGlCQU1DOztRQUxHLElBQUkscUJBQXFCLEdBQXNCLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ3ZHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLHFCQUFxQixDQUFDO2FBQ2xGLFNBQVMsQ0FBQyxVQUFDLElBQTRCO1lBQ3BDLEtBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7U0FDM0MsQ0FBQyxDQUFDO0tBQ1Y7Ozs7OztJQUVPLHdEQUFzQjs7Ozs7Y0FBQyxPQUFlLEVBQUUsYUFBcUM7O1FBQ2pGLElBQUksY0FBYyxHQUFzQixFQUFFLENBQUM7UUFDM0MsY0FBYyxDQUFDLFlBQVksR0FBRyxhQUFhLENBQUMsWUFBWSxDQUFDO1FBQ3pELGNBQWMsQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDO1FBQzlCLGNBQWMsQ0FBQyxXQUFXLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQztRQUN2RCxPQUFPLGNBQWMsQ0FBQzs7Ozs7O0lBRzFCLGtEQUFnQjs7OztJQUFoQixVQUFpQixhQUFxQztRQUF0RCxpQkFJQztRQUhHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLGFBQWEsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxVQUFDLElBQUk7WUFDdkYsS0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDMUIsRUFBRSxVQUFDLEtBQUssSUFBSyxPQUFBLEtBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUF0QixDQUFzQixDQUFDLENBQUM7S0FDekM7O2dCQXJGSixTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLHFCQUFxQjtvQkFDL0IsaWdIQUErQztvQkFFL0MsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7O2lCQUN4Qzs7OztnQkFWUSxlQUFlO2dCQUdmLHFCQUFxQjs7O3lCQVd6QixLQUFLO3lCQUlMLE1BQU07d0JBSU4sTUFBTTs7a0NBeENYOztTQTZCYSx1QkFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9uLCBJbnB1dCwgT25Jbml0LCBFdmVudEVtaXR0ZXIsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTm9kZXNBcGlTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IE1pbmltYWxOb2RlRW50cnlFbnRpdHksIFBlcm1pc3Npb25FbGVtZW50IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IFBlcm1pc3Npb25EaXNwbGF5TW9kZWwgfSBmcm9tICcuLi8uLi9tb2RlbHMvcGVybWlzc2lvbi5tb2RlbCc7XG5pbXBvcnQgeyBOb2RlUGVybWlzc2lvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9ub2RlLXBlcm1pc3Npb24uc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXBlcm1pc3Npb24tbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3Blcm1pc3Npb24tbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vcGVybWlzc2lvbi1saXN0LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBQZXJtaXNzaW9uTGlzdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvKiogSUQgb2YgdGhlIG5vZGUgd2hvc2UgcGVybWlzc2lvbnMgeW91IHdhbnQgdG8gc2hvdy4gKi9cbiAgICBASW5wdXQoKVxuICAgIG5vZGVJZDogc3RyaW5nID0gJyc7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSBwZXJtaXNzaW9uIGlzIHVwZGF0ZWQuICovXG4gICAgQE91dHB1dCgpXG4gICAgdXBkYXRlOiBFdmVudEVtaXR0ZXI8UGVybWlzc2lvbkVsZW1lbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMuICovXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgcGVybWlzc2lvbkxpc3Q6IFBlcm1pc3Npb25EaXNwbGF5TW9kZWxbXTtcbiAgICBzZXR0YWJsZVJvbGVzOiBhbnlbXTtcbiAgICBhY3R1YWxOb2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBub2RlU2VydmljZTogTm9kZXNBcGlTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgbm9kZVBlcm1pc3Npb25TZXJ2aWNlOiBOb2RlUGVybWlzc2lvblNlcnZpY2UpIHtcblxuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmZldGNoTm9kZVBlcm1pc3Npb25zKCk7XG4gICAgfVxuXG4gICAgcmVsb2FkKCkge1xuICAgICAgICB0aGlzLmZldGNoTm9kZVBlcm1pc3Npb25zKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmZXRjaE5vZGVQZXJtaXNzaW9ucygpIHtcbiAgICAgICAgdGhpcy5ub2RlU2VydmljZS5nZXROb2RlKHRoaXMubm9kZUlkKS5zdWJzY3JpYmUoKG5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0dWFsTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25MaXN0ID0gdGhpcy5nZXRQZXJtaXNzaW9uTGlzdChub2RlKTtcbiAgICAgICAgICAgIHRoaXMubm9kZVBlcm1pc3Npb25TZXJ2aWNlLmdldE5vZGVSb2xlcyhub2RlKS5zdWJzY3JpYmUoKHNldHRhYmxlTGlzdDogc3RyaW5nW10pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRhYmxlUm9sZXMgPSAgc2V0dGFibGVMaXN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0UGVybWlzc2lvbkxpc3Qobm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSk6IFBlcm1pc3Npb25EaXNwbGF5TW9kZWxbXSB7XG4gICAgICAgIGxldCBhbGxQZXJtaXNzaW9uczogUGVybWlzc2lvbkRpc3BsYXlNb2RlbFtdID0gW107XG4gICAgICAgIGlmIChub2RlLnBlcm1pc3Npb25zLmxvY2FsbHlTZXQpIHtcbiAgICAgICAgICAgIG5vZGUucGVybWlzc2lvbnMubG9jYWxseVNldC5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcGVybWlzc2lvbiA9IG5ldyBQZXJtaXNzaW9uRGlzcGxheU1vZGVsKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGFsbFBlcm1pc3Npb25zLnB1c2gocGVybWlzc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5wZXJtaXNzaW9ucy5pbmhlcml0ZWQpIHtcbiAgICAgICAgICAgIG5vZGUucGVybWlzc2lvbnMuaW5oZXJpdGVkLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwZXJtaXNzaW9uSW5oZXJpdGVkID0gbmV3IFBlcm1pc3Npb25EaXNwbGF5TW9kZWwoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbkluaGVyaXRlZC5pc0luaGVyaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWxsUGVybWlzc2lvbnMucHVzaChwZXJtaXNzaW9uSW5oZXJpdGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxQZXJtaXNzaW9ucztcbiAgICB9XG5cbiAgICBzYXZlTmV3Um9sZShldmVudDogYW55LCBwZXJtaXNzaW9uUm93OiBQZXJtaXNzaW9uRGlzcGxheU1vZGVsKSB7XG4gICAgICAgIGxldCB1cGRhdGVkUGVybWlzc2lvblJvbGU6IFBlcm1pc3Npb25FbGVtZW50ID0gdGhpcy5idWlsZFVwZGF0ZWRQZXJtaXNzaW9uKGV2ZW50LnZhbHVlLCBwZXJtaXNzaW9uUm93KTtcbiAgICAgICAgdGhpcy5ub2RlUGVybWlzc2lvblNlcnZpY2UudXBkYXRlUGVybWlzc2lvblJvbGUodGhpcy5hY3R1YWxOb2RlLCB1cGRhdGVkUGVybWlzc2lvblJvbGUpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUuZW1pdCh1cGRhdGVkUGVybWlzc2lvblJvbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBidWlsZFVwZGF0ZWRQZXJtaXNzaW9uKG5ld1JvbGU6IHN0cmluZywgcGVybWlzc2lvblJvdzogUGVybWlzc2lvbkRpc3BsYXlNb2RlbCk6IFBlcm1pc3Npb25FbGVtZW50IHtcbiAgICAgICAgbGV0IHBlcm1pc3Npb25Sb2xlOiBQZXJtaXNzaW9uRWxlbWVudCA9IHt9O1xuICAgICAgICBwZXJtaXNzaW9uUm9sZS5hY2Nlc3NTdGF0dXMgPSBwZXJtaXNzaW9uUm93LmFjY2Vzc1N0YXR1cztcbiAgICAgICAgcGVybWlzc2lvblJvbGUubmFtZSA9IG5ld1JvbGU7XG4gICAgICAgIHBlcm1pc3Npb25Sb2xlLmF1dGhvcml0eUlkID0gcGVybWlzc2lvblJvdy5hdXRob3JpdHlJZDtcbiAgICAgICAgcmV0dXJuIHBlcm1pc3Npb25Sb2xlO1xuICAgIH1cblxuICAgIHJlbW92ZVBlcm1pc3Npb24ocGVybWlzc2lvblJvdzogUGVybWlzc2lvbkRpc3BsYXlNb2RlbCkge1xuICAgICAgICB0aGlzLm5vZGVQZXJtaXNzaW9uU2VydmljZS5yZW1vdmVQZXJtaXNzaW9uKHRoaXMuYWN0dWFsTm9kZSwgcGVybWlzc2lvblJvdykuc3Vic2NyaWJlKChub2RlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5vZGUpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHRoaXMuZXJyb3IuZW1pdChlcnJvcikpO1xuICAgIH1cblxufVxuIl19