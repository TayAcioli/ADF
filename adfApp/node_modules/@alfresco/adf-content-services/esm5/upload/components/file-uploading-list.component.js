/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as tslib_1 from "tslib";
import { FileUploadStatus, NodesApiService, TranslationService, UploadService } from '@alfresco/adf-core';
import { Component, ContentChild, Input, Output, TemplateRef, EventEmitter } from '@angular/core';
import { forkJoin, of } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
var FileUploadingListComponent = /** @class */ (function () {
    function FileUploadingListComponent(uploadService, nodesApi, translateService) {
        this.uploadService = uploadService;
        this.nodesApi = nodesApi;
        this.translateService = translateService;
        this.FileUploadStatus = FileUploadStatus;
        this.files = [];
        /**
         * Emitted when a file in the list has an error.
         */
        this.error = new EventEmitter();
    }
    /**
     * Cancel file upload
     *
     * @param file File model to cancel upload for.
     *
     * @memberOf FileUploadingListComponent
     */
    /**
     * Cancel file upload
     *
     * \@memberOf FileUploadingListComponent
     * @param {?} file File model to cancel upload for.
     *
     * @return {?}
     */
    FileUploadingListComponent.prototype.cancelFile = /**
     * Cancel file upload
     *
     * \@memberOf FileUploadingListComponent
     * @param {?} file File model to cancel upload for.
     *
     * @return {?}
     */
    function (file) {
        this.uploadService.cancelUpload(file);
    };
    /**
     * @param {?} file
     * @return {?}
     */
    FileUploadingListComponent.prototype.removeFile = /**
     * @param {?} file
     * @return {?}
     */
    function (file) {
        var _this = this;
        this.deleteNode(file)
            .subscribe(function () {
            if (file.status === FileUploadStatus.Error) {
                _this.notifyError(file);
            }
            _this.uploadService.cancelUpload(file);
        });
    };
    /**
     * Call the appropriate method for each file, depending on state
     */
    /**
     * Call the appropriate method for each file, depending on state
     * @return {?}
     */
    FileUploadingListComponent.prototype.cancelAllFiles = /**
     * Call the appropriate method for each file, depending on state
     * @return {?}
     */
    function () {
        var _this = this;
        this.getUploadingFiles()
            .forEach(function (file) { return _this.uploadService.cancelUpload(file); });
        /** @type {?} */
        var deletedFiles = this.files
            .filter(function (file) { return file.status === FileUploadStatus.Complete; })
            .map(function (file) { return _this.deleteNode(file); });
        forkJoin.apply(void 0, tslib_1.__spread(deletedFiles)).subscribe(function (files) {
            var _a;
            /** @type {?} */
            var errors = files
                .filter(function (file) { return file.status === FileUploadStatus.Error; });
            if (errors.length) {
                _this.notifyError.apply(_this, tslib_1.__spread(errors));
            }
            (_a = _this.uploadService).cancelUpload.apply(_a, tslib_1.__spread(files));
        });
    };
    /**
     * Checks if all the files are uploaded false if there is at least one file in Progress | Starting | Pending
     */
    /**
     * Checks if all the files are uploaded false if there is at least one file in Progress | Starting | Pending
     * @return {?}
     */
    FileUploadingListComponent.prototype.isUploadCompleted = /**
     * Checks if all the files are uploaded false if there is at least one file in Progress | Starting | Pending
     * @return {?}
     */
    function () {
        return !this.isUploadCancelled() &&
            Boolean(this.files.length) &&
            !this.files
                .some(function (_a) {
                var status = _a.status;
                return status === FileUploadStatus.Starting ||
                    status === FileUploadStatus.Progress ||
                    status === FileUploadStatus.Pending;
            });
    };
    /**
     * Check if all the files are Cancelled | Aborted | Error. false if there is at least one file in uploading states
     */
    /**
     * Check if all the files are Cancelled | Aborted | Error. false if there is at least one file in uploading states
     * @return {?}
     */
    FileUploadingListComponent.prototype.isUploadCancelled = /**
     * Check if all the files are Cancelled | Aborted | Error. false if there is at least one file in uploading states
     * @return {?}
     */
    function () {
        return !!this.files.length &&
            this.files
                .every(function (_a) {
                var status = _a.status;
                return status === FileUploadStatus.Aborted ||
                    status === FileUploadStatus.Cancelled ||
                    status === FileUploadStatus.Deleted;
            });
    };
    /**
     * @param {?} file
     * @return {?}
     */
    FileUploadingListComponent.prototype.deleteNode = /**
     * @param {?} file
     * @return {?}
     */
    function (file) {
        var id = file.data.entry.id;
        return this.nodesApi
            .deleteNode(id, { permanent: true })
            .pipe(map(function () {
            file.status = FileUploadStatus.Deleted;
            return file;
        }), catchError(function () {
            file.status = FileUploadStatus.Error;
            return of(file);
        }));
    };
    /**
     * @param {...?} files
     * @return {?}
     */
    FileUploadingListComponent.prototype.notifyError = /**
     * @param {...?} files
     * @return {?}
     */
    function () {
        var files = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            files[_i] = arguments[_i];
        }
        /** @type {?} */
        var messageError = null;
        if (files.length === 1) {
            messageError = this.translateService
                .instant('FILE_UPLOAD.MESSAGES.REMOVE_FILE_ERROR', { fileName: files[0].name });
        }
        else {
            messageError = this.translateService
                .instant('FILE_UPLOAD.MESSAGES.REMOVE_FILES_ERROR', { total: files.length });
        }
        this.error.emit(messageError);
    };
    /**
     * @return {?}
     */
    FileUploadingListComponent.prototype.getUploadingFiles = /**
     * @return {?}
     */
    function () {
        return this.files.filter(function (item) {
            if (item.status === FileUploadStatus.Pending ||
                item.status === FileUploadStatus.Progress ||
                item.status === FileUploadStatus.Starting) {
                return item;
            }
        });
    };
    FileUploadingListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-file-uploading-list',
                    template: "<div class=\"upload-list\">\n    <ng-template\n        ngFor\n        [ngForOf]=\"files\"\n        [ngForTemplate]=\"template\">\n    </ng-template>\n</div>\n",
                    styles: [":host{display:flex;flex-direction:column}"]
                }] }
    ];
    /** @nocollapse */
    FileUploadingListComponent.ctorParameters = function () { return [
        { type: UploadService },
        { type: NodesApiService },
        { type: TranslationService }
    ]; };
    FileUploadingListComponent.propDecorators = {
        template: [{ type: ContentChild, args: [TemplateRef,] }],
        files: [{ type: Input }],
        error: [{ type: Output }]
    };
    return FileUploadingListComponent;
}());
export { FileUploadingListComponent };
if (false) {
    /** @type {?} */
    FileUploadingListComponent.prototype.FileUploadStatus;
    /** @type {?} */
    FileUploadingListComponent.prototype.template;
    /** @type {?} */
    FileUploadingListComponent.prototype.files;
    /**
     * Emitted when a file in the list has an error.
     * @type {?}
     */
    FileUploadingListComponent.prototype.error;
    /** @type {?} */
    FileUploadingListComponent.prototype.uploadService;
    /** @type {?} */
    FileUploadingListComponent.prototype.nodesApi;
    /** @type {?} */
    FileUploadingListComponent.prototype.translateService;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS11cGxvYWRpbmctbGlzdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvIiwic291cmNlcyI6WyJ1cGxvYWQvY29tcG9uZW50cy9maWxlLXVwbG9hZGluZy1saXN0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUFhLGdCQUFnQixFQUFFLGVBQWUsRUFBRSxrQkFBa0IsRUFBRSxhQUFhLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNySCxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEcsT0FBTyxFQUFjLFFBQVEsRUFBRSxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDaEQsT0FBTyxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7SUFxQjdDLG9DQUNZLGVBQ0EsVUFDQTtRQUZBLGtCQUFhLEdBQWIsYUFBYTtRQUNiLGFBQVEsR0FBUixRQUFRO1FBQ1IscUJBQWdCLEdBQWhCLGdCQUFnQjtnQ0FmVCxnQkFBZ0I7cUJBTWQsRUFBRTs7OztxQkFJSSxJQUFJLFlBQVksRUFBRTtLQU01QztJQUVEOzs7Ozs7T0FNRzs7Ozs7Ozs7O0lBQ0gsK0NBQVU7Ozs7Ozs7O0lBQVYsVUFBVyxJQUFlO1FBQ3RCLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3pDOzs7OztJQUVELCtDQUFVOzs7O0lBQVYsVUFBVyxJQUFlO1FBQTFCLGlCQVNDO1FBUkcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7YUFDaEIsU0FBUyxDQUFDO1lBQ1AsSUFBSyxJQUFJLENBQUMsTUFBTSxLQUFLLGdCQUFnQixDQUFDLEtBQUssRUFBRTtnQkFDekMs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XG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBGaWxlTW9kZWwsIEZpbGVVcGxvYWRTdGF0dXMsIE5vZGVzQXBpU2VydmljZSwgVHJhbnNsYXRpb25TZXJ2aWNlLCBVcGxvYWRTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBJbnB1dCwgT3V0cHV0LCBUZW1wbGF0ZVJlZiwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmb3JrSm9pbiwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtZmlsZS11cGxvYWRpbmctbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2ZpbGUtdXBsb2FkaW5nLWxpc3QuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2ZpbGUtdXBsb2FkaW5nLWxpc3QuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBGaWxlVXBsb2FkaW5nTGlzdENvbXBvbmVudCB7XG5cbiAgICBGaWxlVXBsb2FkU3RhdHVzID0gRmlsZVVwbG9hZFN0YXR1cztcblxuICAgIEBDb250ZW50Q2hpbGQoVGVtcGxhdGVSZWYpXG4gICAgdGVtcGxhdGU6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgZmlsZXM6IEZpbGVNb2RlbFtdID0gW107XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGEgZmlsZSBpbiB0aGUgbGlzdCBoYXMgYW4gZXJyb3IuICovXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgdXBsb2FkU2VydmljZTogVXBsb2FkU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBub2Rlc0FwaTogTm9kZXNBcGlTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0aW9uU2VydmljZSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbCBmaWxlIHVwbG9hZFxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGUgRmlsZSBtb2RlbCB0byBjYW5jZWwgdXBsb2FkIGZvci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBGaWxlVXBsb2FkaW5nTGlzdENvbXBvbmVudFxuICAgICAqL1xuICAgIGNhbmNlbEZpbGUoZmlsZTogRmlsZU1vZGVsKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBsb2FkU2VydmljZS5jYW5jZWxVcGxvYWQoZmlsZSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlRmlsZShmaWxlOiBGaWxlTW9kZWwpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kZWxldGVOb2RlKGZpbGUpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIGZpbGUuc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5RXJyb3IoZmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy51cGxvYWRTZXJ2aWNlLmNhbmNlbFVwbG9hZChmaWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBmb3IgZWFjaCBmaWxlLCBkZXBlbmRpbmcgb24gc3RhdGVcbiAgICAgKi9cbiAgICBjYW5jZWxBbGxGaWxlcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5nZXRVcGxvYWRpbmdGaWxlcygpXG4gICAgICAgICAgICAuZm9yRWFjaCgoZmlsZSkgPT4gdGhpcy51cGxvYWRTZXJ2aWNlLmNhbmNlbFVwbG9hZChmaWxlKSk7XG5cbiAgICAgICAgY29uc3QgZGVsZXRlZEZpbGVzID0gdGhpcy5maWxlc1xuICAgICAgICAgICAgLmZpbHRlcigoZmlsZSkgPT4gZmlsZS5zdGF0dXMgPT09IEZpbGVVcGxvYWRTdGF0dXMuQ29tcGxldGUpXG4gICAgICAgICAgICAubWFwKChmaWxlKSA9PiB0aGlzLmRlbGV0ZU5vZGUoZmlsZSkpO1xuXG4gICAgICAgIGZvcmtKb2luKC4uLmRlbGV0ZWRGaWxlcylcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGZpbGVzOiBGaWxlTW9kZWxbXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGZpbGVzXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGZpbGUpID0+IGZpbGUuc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLkVycm9yKTtcblxuICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5RXJyb3IoLi4uZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UuY2FuY2VsVXBsb2FkKC4uLmZpbGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhbGwgdGhlIGZpbGVzIGFyZSB1cGxvYWRlZCBmYWxzZSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZmlsZSBpbiBQcm9ncmVzcyB8IFN0YXJ0aW5nIHwgUGVuZGluZ1xuICAgICAqL1xuICAgIGlzVXBsb2FkQ29tcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICAgcmV0dXJuICF0aGlzLmlzVXBsb2FkQ2FuY2VsbGVkKCkgJiZcbiAgICAgICAgICAgIEJvb2xlYW4odGhpcy5maWxlcy5sZW5ndGgpICYmXG4gICAgICAgICAgICAhdGhpcy5maWxlc1xuICAgICAgICAgICAgICAgIC5zb21lKCh7c3RhdHVzfSkgPT5cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLlN0YXJ0aW5nIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9PT0gRmlsZVVwbG9hZFN0YXR1cy5Qcm9ncmVzcyB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPT09IEZpbGVVcGxvYWRTdGF0dXMuUGVuZGluZ1xuICAgICAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYWxsIHRoZSBmaWxlcyBhcmUgQ2FuY2VsbGVkIHwgQWJvcnRlZCB8IEVycm9yLiBmYWxzZSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZmlsZSBpbiB1cGxvYWRpbmcgc3RhdGVzXG4gICAgICovXG4gICAgaXNVcGxvYWRDYW5jZWxsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZmlsZXMubGVuZ3RoICYmXG4gICAgICAgICAgICB0aGlzLmZpbGVzXG4gICAgICAgICAgICAgICAgLmV2ZXJ5KCh7c3RhdHVzfSkgPT5cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLkFib3J0ZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLkNhbmNlbGxlZCB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPT09IEZpbGVVcGxvYWRTdGF0dXMuRGVsZXRlZFxuICAgICAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkZWxldGVOb2RlKGZpbGU6IEZpbGVNb2RlbCk6IE9ic2VydmFibGU8RmlsZU1vZGVsPiB7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IGZpbGUuZGF0YS5lbnRyeTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc0FwaVxuICAgICAgICAgICAgLmRlbGV0ZU5vZGUoaWQsIHsgcGVybWFuZW50OiB0cnVlIH0pXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmaWxlLnN0YXR1cyA9IEZpbGVVcGxvYWRTdGF0dXMuRGVsZXRlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2F0Y2hFcnJvcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUuc3RhdHVzID0gRmlsZVVwbG9hZFN0YXR1cy5FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKGZpbGUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgbm90aWZ5RXJyb3IoLi4uZmlsZXM6IEZpbGVNb2RlbFtdKSB7XG4gICAgICAgIGxldCBtZXNzYWdlRXJyb3I6IHN0cmluZyA9IG51bGw7XG5cbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbWVzc2FnZUVycm9yID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlXG4gICAgICAgICAgICAgICAgLmluc3RhbnQoXG4gICAgICAgICAgICAgICAgICAgICdGSUxFX1VQTE9BRC5NRVNTQUdFUy5SRU1PVkVfRklMRV9FUlJPUicsXG4gICAgICAgICAgICAgICAgICAgIHsgZmlsZU5hbWU6IGZpbGVzWzBdLm5hbWV9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2VFcnJvciA9IHRoaXMudHJhbnNsYXRlU2VydmljZVxuICAgICAgICAgICAgICAgIC5pbnN0YW50KFxuICAgICAgICAgICAgICAgICAgICAnRklMRV9VUExPQUQuTUVTU0FHRVMuUkVNT1ZFX0ZJTEVTX0VSUk9SJyxcbiAgICAgICAgICAgICAgICAgICAgeyB0b3RhbDogZmlsZXMubGVuZ3RoIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lcnJvci5lbWl0KG1lc3NhZ2VFcnJvcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRVcGxvYWRpbmdGaWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEZpbGVVcGxvYWRTdGF0dXMuUGVuZGluZyB8fFxuICAgICAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLlByb2dyZXNzIHx8XG4gICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEZpbGVVcGxvYWRTdGF0dXMuU3RhcnRpbmdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=