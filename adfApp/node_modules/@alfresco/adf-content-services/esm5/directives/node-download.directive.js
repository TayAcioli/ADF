/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Directive, Input, HostListener } from '@angular/core';
import { MatDialog } from '@angular/material';
import { AlfrescoApiService } from '@alfresco/adf-core';
import { DownloadZipDialogComponent } from '../dialogs/download-zip.dialog';
var NodeDownloadDirective = /** @class */ (function () {
    function NodeDownloadDirective(apiService, dialog) {
        this.apiService = apiService;
        this.dialog = dialog;
    }
    /**
     * @return {?}
     */
    NodeDownloadDirective.prototype.onClick = /**
     * @return {?}
     */
    function () {
        this.downloadNodes(this.nodes);
    };
    /**
     * Downloads multiple selected nodes.
     * Packs result into a .ZIP archive if there is more than one node selected.
     * @param selection Multiple selected nodes to download
     */
    /**
     * Downloads multiple selected nodes.
     * Packs result into a .ZIP archive if there is more than one node selected.
     * @param {?} selection Multiple selected nodes to download
     * @return {?}
     */
    NodeDownloadDirective.prototype.downloadNodes = /**
     * Downloads multiple selected nodes.
     * Packs result into a .ZIP archive if there is more than one node selected.
     * @param {?} selection Multiple selected nodes to download
     * @return {?}
     */
    function (selection) {
        if (!selection || selection.length === 0) {
            return;
        }
        if (selection.length === 1) {
            this.downloadNode(selection[0]);
        }
        else {
            this.downloadZip(selection);
        }
    };
    /**
     * Downloads a single node.
     * Packs result into a .ZIP archive is the node is a Folder.
     * @param node Node to download
     */
    /**
     * Downloads a single node.
     * Packs result into a .ZIP archive is the node is a Folder.
     * @param {?} node Node to download
     * @return {?}
     */
    NodeDownloadDirective.prototype.downloadNode = /**
     * Downloads a single node.
     * Packs result into a .ZIP archive is the node is a Folder.
     * @param {?} node Node to download
     * @return {?}
     */
    function (node) {
        if (node && node.entry) {
            /** @type {?} */
            var entry = node.entry;
            if (entry.isFile) {
                this.downloadFile(node);
            }
            if (entry.isFolder) {
                this.downloadZip([node]);
            }
            // Check if there's nodeId for Shared Files
            if (!entry.isFile && !entry.isFolder && (/** @type {?} */ (entry)).nodeId) {
                this.downloadFile(node);
            }
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    NodeDownloadDirective.prototype.downloadFile = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (node && node.entry) {
            /** @type {?} */
            var contentApi = this.apiService.getInstance().content;
            /** @type {?} */
            var id = (/** @type {?} */ (node.entry)).nodeId || node.entry.id;
            /** @type {?} */
            var url = contentApi.getContentUrl(id, true);
            /** @type {?} */
            var fileName = node.entry.name;
            this.download(url, fileName);
        }
    };
    /**
     * @param {?} selection
     * @return {?}
     */
    NodeDownloadDirective.prototype.downloadZip = /**
     * @param {?} selection
     * @return {?}
     */
    function (selection) {
        if (selection && selection.length > 0) {
            /** @type {?} */
            var nodeIds = selection.map(function (node) { return (node.entry.nodeId || node.entry.id); });
            this.dialog.open(DownloadZipDialogComponent, {
                width: '600px',
                disableClose: true,
                data: {
                    nodeIds: nodeIds
                }
            });
        }
    };
    /**
     * @param {?} url
     * @param {?} fileName
     * @return {?}
     */
    NodeDownloadDirective.prototype.download = /**
     * @param {?} url
     * @param {?} fileName
     * @return {?}
     */
    function (url, fileName) {
        if (url && fileName) {
            /** @type {?} */
            var link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    };
    NodeDownloadDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[adfNodeDownload]'
                },] }
    ];
    /** @nocollapse */
    NodeDownloadDirective.ctorParameters = function () { return [
        { type: AlfrescoApiService },
        { type: MatDialog }
    ]; };
    NodeDownloadDirective.propDecorators = {
        nodes: [{ type: Input, args: ['adfNodeDownload',] }],
        onClick: [{ type: HostListener, args: ['click',] }]
    };
    return NodeDownloadDirective;
}());
export { NodeDownloadDirective };
if (false) {
    /**
     * Nodes to download.
     * @type {?}
     */
    NodeDownloadDirective.prototype.nodes;
    /** @type {?} */
    NodeDownloadDirective.prototype.apiService;
    /** @type {?} */
    NodeDownloadDirective.prototype.dialog;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS1kb3dubG9hZC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvIiwic291cmNlcyI6WyJkaXJlY3RpdmVzL25vZGUtZG93bmxvYWQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMvRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFOUMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFeEQsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7O0lBaUJ4RSwrQkFDWSxZQUNBO1FBREEsZUFBVSxHQUFWLFVBQVU7UUFDVixXQUFNLEdBQU4sTUFBTTtLQUNqQjs7OztJQVBELHVDQUFPOzs7SUFEUDtRQUVJLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ2xDO0lBT0Q7Ozs7T0FJRzs7Ozs7OztJQUNILDZDQUFhOzs7Ozs7SUFBYixVQUFjLFNBQW1DO1FBQzdDLElBQUksQ0FBQyxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDdEMsT0FBTztTQUNWO1FBRUQsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN4QixJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ25DO2FBQU07WUFDSCxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQy9CO0tBQ0o7SUFFRDs7OztPQUlHOzs7Ozs7O0lBQ0gsNENBQVk7Ozs7OztJQUFaLFVBQWEsSUFBdUI7UUFDaEMsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTs7WUFDcEIsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUV6QixJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUU7Z0JBQ2QsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUMzQjtZQUVELElBQUksS0FBSyxDQUFDLFFBQVEsRUFBRTtnQkFDaEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDNUI7O1lBR0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxJQUFJLG1CQUFPLEtBQUssRUFBQyxDQUFDLE1BQU0sRUFBRTtnQkFDMUQsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUMzQjtTQUNKO0tBQ0o7Ozs7O0lBRU8sNENBQVk7Ozs7Y0FBQyxJQUF1QjtRQUN4QyxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFOztZQUNwQixJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQzs7WUFFekQsSUFBTSxFQUFFLEdBQUcsbUJBQU8sSUFBSSxDQUFDLEtBQUssRUFBQyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQzs7WUFFdEQsSUFBTSxHQUFHLEdBQUcsVUFBVSxDQUFDLGFBQWEsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7O1lBQy9DLElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO1lBRWpDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQ2hDOzs7Ozs7SUFHRywyQ0FBVzs7OztjQUFDLFNBQW1DO1FBQ25ELElBQUksU0FBUyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFOztZQUVuQyxJQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQUMsSUFBUyxJQUFLLE9BQUEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFwQyxDQUFvQyxDQUFDLENBQUM7WUFFbkYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsMEJBQTBCLEVBQUU7Z0JBQ3pDLEtBQUssRUFBRSxPQUFPO2dCQUNkLFlBQVksRUFBRSxJQUFJO2dCQUNsQixJQUFJLEVBQUU7b0JBQ0YsT0FBTyxTQUFBO2lCQUNWO2FBQ0osQ0FBQyxDQUFDO1NBQ047Ozs7Ozs7SUFHRyx3Q0FBUTs7Ozs7Y0FBQyxHQUFXLEVBQUUsUUFBZ0I7UUFDMUMsSUFBSSxHQUFHLElBQUksUUFBUSxFQUFFOztZQUNqQixJQUFNLElBQUksR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRXpDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztZQUM1QixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztZQUN6QixJQUFJLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztZQUVoQixRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDYixRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNuQzs7O2dCQXBHUixTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLG1CQUFtQjtpQkFDaEM7Ozs7Z0JBTlEsa0JBQWtCO2dCQUZsQixTQUFTOzs7d0JBYWIsS0FBSyxTQUFDLGlCQUFpQjswQkFHdkIsWUFBWSxTQUFDLE9BQU87O2dDQWxDekI7O1NBMkJhLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0RGlhbG9nIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRpdHkgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuaW1wb3J0IHsgRG93bmxvYWRaaXBEaWFsb2dDb21wb25lbnQgfSBmcm9tICcuLi9kaWFsb2dzL2Rvd25sb2FkLXppcC5kaWFsb2cnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1thZGZOb2RlRG93bmxvYWRdJ1xufSlcbmV4cG9ydCBjbGFzcyBOb2RlRG93bmxvYWREaXJlY3RpdmUge1xuXG4gICAgLyoqIE5vZGVzIHRvIGRvd25sb2FkLiAqL1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnB1dC1yZW5hbWVcbiAgICBASW5wdXQoJ2FkZk5vZGVEb3dubG9hZCcpXG4gICAgbm9kZXM6IE1pbmltYWxOb2RlRW50aXR5W107XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gICAgb25DbGljaygpIHtcbiAgICAgICAgdGhpcy5kb3dubG9hZE5vZGVzKHRoaXMubm9kZXMpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBkaWFsb2c6IE1hdERpYWxvZykge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBtdWx0aXBsZSBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKiBQYWNrcyByZXN1bHQgaW50byBhIC5aSVAgYXJjaGl2ZSBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIG5vZGUgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHNlbGVjdGlvbiBNdWx0aXBsZSBzZWxlY3RlZCBub2RlcyB0byBkb3dubG9hZFxuICAgICAqL1xuICAgIGRvd25sb2FkTm9kZXMoc2VsZWN0aW9uOiBBcnJheTxNaW5pbWFsTm9kZUVudGl0eT4pIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWROb2RlKHNlbGVjdGlvblswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRvd25sb2FkWmlwKHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBzaW5nbGUgbm9kZS5cbiAgICAgKiBQYWNrcyByZXN1bHQgaW50byBhIC5aSVAgYXJjaGl2ZSBpcyB0aGUgbm9kZSBpcyBhIEZvbGRlci5cbiAgICAgKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGRvd25sb2FkXG4gICAgICovXG4gICAgZG93bmxvYWROb2RlKG5vZGU6IE1pbmltYWxOb2RlRW50aXR5KSB7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUuZW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gbm9kZS5lbnRyeTtcblxuICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW50cnkuaXNGb2xkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkWmlwKFtub2RlXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3Mgbm9kZUlkIGZvciBTaGFyZWQgRmlsZXNcbiAgICAgICAgICAgIGlmICghZW50cnkuaXNGaWxlICYmICFlbnRyeS5pc0ZvbGRlciAmJiAoPGFueT4gZW50cnkpLm5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb3dubG9hZEZpbGUobm9kZTogTWluaW1hbE5vZGVFbnRpdHkpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5lbnRyeSkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudEFwaSA9IHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLmNvbnRlbnQ7XG4gICAgICAgICAgICAvLyBub2RlSWQgZm9yIFNoYXJlZCBub2RlXG4gICAgICAgICAgICBjb25zdCBpZCA9ICg8YW55PiBub2RlLmVudHJ5KS5ub2RlSWQgfHwgbm9kZS5lbnRyeS5pZDtcblxuICAgICAgICAgICAgY29uc3QgdXJsID0gY29udGVudEFwaS5nZXRDb250ZW50VXJsKGlkLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gbm9kZS5lbnRyeS5uYW1lO1xuXG4gICAgICAgICAgICB0aGlzLmRvd25sb2FkKHVybCwgZmlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb3dubG9hZFppcChzZWxlY3Rpb246IEFycmF5PE1pbmltYWxOb2RlRW50aXR5Pikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBub2RlSWQgZm9yIFNoYXJlZCBub2RlXG4gICAgICAgICAgICBjb25zdCBub2RlSWRzID0gc2VsZWN0aW9uLm1hcCgobm9kZTogYW55KSA9PiAobm9kZS5lbnRyeS5ub2RlSWQgfHwgbm9kZS5lbnRyeS5pZCkpO1xuXG4gICAgICAgICAgICB0aGlzLmRpYWxvZy5vcGVuKERvd25sb2FkWmlwRGlhbG9nQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICc2MDBweCcsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUNsb3NlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb3dubG9hZCh1cmw6IHN0cmluZywgZmlsZU5hbWU6IHN0cmluZykge1xuICAgICAgICBpZiAodXJsICYmIGZpbGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXG4gICAgICAgICAgICBsaW5rLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBsaW5rLmRvd25sb2FkID0gZmlsZU5hbWU7XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICAgICAgICBsaW5rLmNsaWNrKCk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19