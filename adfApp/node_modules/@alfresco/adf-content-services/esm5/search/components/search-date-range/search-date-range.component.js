/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation } from '@angular/core';
import { FormControl, Validators, FormGroup } from '@angular/forms';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material/core';
import { MomentDateAdapter, MOMENT_DATE_FORMATS } from '@alfresco/adf-core';
import { LiveErrorStateMatcher } from '../../forms/live-error-state-matcher';
import { UserPreferencesService, UserPreferenceValues } from '@alfresco/adf-core';
/** @type {?} */
var DEFAULT_FORMAT_DATE = 'DD/MM/YYYY';
var ɵ0 = MOMENT_DATE_FORMATS;
var SearchDateRangeComponent = /** @class */ (function () {
    function SearchDateRangeComponent(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.matcher = new LiveErrorStateMatcher();
        this.datePickerDateFormat = DEFAULT_FORMAT_DATE;
    }
    /**
     * @return {?}
     */
    SearchDateRangeComponent.prototype.getFromValidationMessage = /**
     * @return {?}
     */
    function () {
        return this.from.hasError('invalidOnChange') || this.hasParseError(this.from) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.from.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                this.from.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                    '';
    };
    /**
     * @return {?}
     */
    SearchDateRangeComponent.prototype.getToValidationMessage = /**
     * @return {?}
     */
    function () {
        return this.to.hasError('invalidOnChange') || this.hasParseError(this.to) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.to.hasError('matDatepickerMin') ? 'SEARCH.FILTER.VALIDATION.NO-DAYS' :
                this.to.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                    this.to.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                        '';
    };
    /**
     * @return {?}
     */
    SearchDateRangeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.settings) {
            this.datePickerDateFormat = this.settings["dateFormat"] || DEFAULT_FORMAT_DATE;
        }
        /** @type {?} */
        var theCustomDateAdapter = /** @type {?} */ (/** @type {?} */ (this.dateAdapter));
        theCustomDateAdapter.overrideDisplyaFormat = this.datePickerDateFormat;
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe(function (locale) {
            _this.setLocale(locale);
        });
        /** @type {?} */
        var validators = Validators.compose([
            Validators.required
        ]);
        this.from = new FormControl('', validators);
        this.to = new FormControl('', validators);
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        });
        this.maxDate = this.dateAdapter.today().startOf('day');
    };
    /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    SearchDateRangeComponent.prototype.apply = /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    function (model, isValid) {
        if (isValid && this.id && this.context && this.settings && this.settings.field) {
            /** @type {?} */
            var start = moment(model.from).startOf('day').format();
            /** @type {?} */
            var end = moment(model.to).endOf('day').format();
            this.context.queryFragments[this.id] = this.settings.field + ":['" + start + "' TO '" + end + "']";
            this.context.update();
        }
    };
    /**
     * @return {?}
     */
    SearchDateRangeComponent.prototype.reset = /**
     * @return {?}
     */
    function () {
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    };
    /**
     * @param {?} event
     * @param {?} formControl
     * @return {?}
     */
    SearchDateRangeComponent.prototype.onChangedHandler = /**
     * @param {?} event
     * @param {?} formControl
     * @return {?}
     */
    function (event, formControl) {
        /** @type {?} */
        var inputValue = event.srcElement.value;
        /** @type {?} */
        var formatDate = this.dateAdapter.parse(inputValue, this.datePickerDateFormat);
        if (formatDate && formatDate.isValid()) {
            formControl.setValue(formatDate);
        }
        else if (formatDate) {
            formControl.setErrors({
                'invalidOnChange': true
            });
        }
        else {
            formControl.setErrors({
                'required': true
            });
        }
    };
    /**
     * @param {?} locale
     * @return {?}
     */
    SearchDateRangeComponent.prototype.setLocale = /**
     * @param {?} locale
     * @return {?}
     */
    function (locale) {
        this.dateAdapter.setLocale(locale);
        moment.locale(locale);
    };
    /**
     * @param {?} formControl
     * @return {?}
     */
    SearchDateRangeComponent.prototype.hasParseError = /**
     * @param {?} formControl
     * @return {?}
     */
    function (formControl) {
        return formControl.hasError('matDatepickerParse') && formControl.getError('matDatepickerParse').text;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchDateRangeComponent.prototype.forcePlaceholder = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.srcElement.click();
    };
    SearchDateRangeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-search-date-range',
                    template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"from\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM-DATE' | translate }}\"\n                [matDatepicker]=\"fromDatepicker\"\n                [max]=\"maxDate\"\n                (focusout)=\"onChangedHandler($event, from)\">\n        <mat-datepicker-toggle matSuffix [for]=\"fromDatepicker\"></mat-datepicker-toggle>\n        <mat-datepicker #fromDatepicker></mat-datepicker>\n        <mat-error *ngIf=\"from.invalid\">\n            {{ getFromValidationMessage() | translate: { requiredFormat: datePickerDateFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"to\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO-DATE' | translate }}\"\n                [matDatepicker]=\"toDatepicker\"\n                [min]=\"from.value\"\n                [max]=\"maxDate\"\n                (focusout)=\"onChangedHandler($event, to)\">\n        <mat-datepicker-toggle matSuffix [for]=\"toDatepicker\"></mat-datepicker-toggle>\n        <mat-datepicker #toDatepicker></mat-datepicker>\n        <mat-error *ngIf=\"to.invalid\">\n            {{ getToValidationMessage() | translate: { requiredFormat: datePickerDateFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <div class=\"facet-buttons facet-buttons--topSpace\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"reset()\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                    providers: [
                        { provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE] },
                        { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                    ],
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-search-date-range' },
                    styles: [".adf-search-date-range>form{display:inline-flex;flex-direction:column;width:100%}"]
                }] }
    ];
    /** @nocollapse */
    SearchDateRangeComponent.ctorParameters = function () { return [
        { type: DateAdapter },
        { type: UserPreferencesService }
    ]; };
    return SearchDateRangeComponent;
}());
export { SearchDateRangeComponent };
if (false) {
    /** @type {?} */
    SearchDateRangeComponent.prototype.from;
    /** @type {?} */
    SearchDateRangeComponent.prototype.to;
    /** @type {?} */
    SearchDateRangeComponent.prototype.form;
    /** @type {?} */
    SearchDateRangeComponent.prototype.matcher;
    /** @type {?} */
    SearchDateRangeComponent.prototype.id;
    /** @type {?} */
    SearchDateRangeComponent.prototype.settings;
    /** @type {?} */
    SearchDateRangeComponent.prototype.context;
    /** @type {?} */
    SearchDateRangeComponent.prototype.maxDate;
    /** @type {?} */
    SearchDateRangeComponent.prototype.datePickerDateFormat;
    /** @type {?} */
    SearchDateRangeComponent.prototype.dateAdapter;
    /** @type {?} */
    SearchDateRangeComponent.prototype.userPreferencesService;
}
export { ɵ0 };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzLyIsInNvdXJjZXMiOlsic2VhcmNoL2NvbXBvbmVudHMvc2VhcmNoLWRhdGUtcmFuZ2Uvc2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBVSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckUsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDcEUsT0FBTyxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUs1RSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUU3RSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7QUFJbEYsSUFBTSxtQkFBbUIsR0FBVyxZQUFZLENBQUM7U0FRSCxtQkFBbUI7O0lBbUI3RCxrQ0FBb0IsV0FBZ0MsRUFDaEM7UUFEQSxnQkFBVyxHQUFYLFdBQVcsQ0FBcUI7UUFDaEMsMkJBQXNCLEdBQXRCLHNCQUFzQjt1QkFUaEMsSUFBSSxxQkFBcUIsRUFBRTtvQ0FNZCxtQkFBbUI7S0FJekM7Ozs7SUFFRCwyREFBd0I7OztJQUF4QjtRQUNJLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsdUNBQXVDLENBQUMsQ0FBQztZQUNySCxJQUFJ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LENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUN6Qjs7Ozs7SUFFRCxnREFBYTs7OztJQUFiLFVBQWMsV0FBVztRQUNyQixPQUFPLFdBQVcsQ0FBQyxRQUFRLENBQUMsb0JBQW9CLENBQUMsSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLG9CQUFvQixDQUFDLENBQUMsSUFBSSxDQUFDO0tBQ3hHOzs7OztJQUVELG1EQUFnQjs7OztJQUFoQixVQUFpQixLQUFVO1FBQ3ZCLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7S0FDNUI7O2dCQXZISixTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLHVCQUF1QjtvQkFDakMsZ2hFQUFpRDtvQkFFakQsU0FBUyxFQUFFO3dCQUNQLEVBQUMsT0FBTyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUM7d0JBQzVFLEVBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFFBQVEsSUFBcUIsRUFBQztxQkFDN0Q7b0JBQ0QsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7b0JBQ3JDLElBQUksRUFBRSxFQUFFLEtBQUssRUFBRSx1QkFBdUIsRUFBRTs7aUJBQzNDOzs7O2dCQXhCUSxXQUFXO2dCQVFYLHNCQUFzQjs7bUNBM0IvQjs7U0E0Q2Esd0JBQXdCIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgT25Jbml0LCBDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgVmFsaWRhdG9ycywgRm9ybUdyb3VwIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRGF0ZUFkYXB0ZXIsIE1BVF9EQVRFX0ZPUk1BVFMsIE1BVF9EQVRFX0xPQ0FMRSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2NvcmUnO1xuaW1wb3J0IHsgTW9tZW50RGF0ZUFkYXB0ZXIsIE1PTUVOVF9EQVRFX0ZPUk1BVFMgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5pbXBvcnQgeyBTZWFyY2hXaWRnZXQgfSBmcm9tICcuLi8uLi9zZWFyY2gtd2lkZ2V0LmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hXaWRnZXRTZXR0aW5ncyB9IGZyb20gJy4uLy4uL3NlYXJjaC13aWRnZXQtc2V0dGluZ3MuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaFF1ZXJ5QnVpbGRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZWFyY2gtcXVlcnktYnVpbGRlci5zZXJ2aWNlJztcbmltcG9ydCB7IExpdmVFcnJvclN0YXRlTWF0Y2hlciB9IGZyb20gJy4uLy4uL2Zvcm1zL2xpdmUtZXJyb3Itc3RhdGUtbWF0Y2hlcic7XG5pbXBvcnQgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgVXNlclByZWZlcmVuY2VzU2VydmljZSwgVXNlclByZWZlcmVuY2VWYWx1ZXMgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5kZWNsYXJlIGxldCBtb21lbnQ6IGFueTtcblxuY29uc3QgREVGQVVMVF9GT1JNQVRfREFURTogc3RyaW5nID0gJ0REL01NL1lZWVknO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1zZWFyY2gtZGF0ZS1yYW5nZScsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NlYXJjaC1kYXRlLXJhbmdlLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9zZWFyY2gtZGF0ZS1yYW5nZS5jb21wb25lbnQuc2NzcyddLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogRGF0ZUFkYXB0ZXIsIHVzZUNsYXNzOiBNb21lbnREYXRlQWRhcHRlciwgZGVwczogW01BVF9EQVRFX0xPQ0FMRV19LFxuICAgICAgICB7cHJvdmlkZTogTUFUX0RBVEVfRk9STUFUUywgdXNlVmFsdWU6IE1PTUVOVF9EQVRFX0ZPUk1BVFN9XG4gICAgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGhvc3Q6IHsgY2xhc3M6ICdhZGYtc2VhcmNoLWRhdGUtcmFuZ2UnIH1cbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50IGltcGxlbWVudHMgU2VhcmNoV2lkZ2V0LCBPbkluaXQge1xuXG4gICAgZnJvbTogRm9ybUNvbnRyb2w7XG4gICAgdG86IEZvcm1Db250cm9sO1xuXG4gICAgZm9ybTogRm9ybUdyb3VwO1xuICAgIG1hdGNoZXIgPSBuZXcgTGl2ZUVycm9yU3RhdGVNYXRjaGVyKCk7XG5cbiAgICBpZDogc3RyaW5nO1xuICAgIHNldHRpbmdzPzogU2VhcmNoV2lkZ2V0U2V0dGluZ3M7XG4gICAgY29udGV4dD86IFNlYXJjaFF1ZXJ5QnVpbGRlclNlcnZpY2U7XG4gICAgbWF4RGF0ZTogYW55O1xuICAgIGRhdGVQaWNrZXJEYXRlRm9ybWF0ID0gREVGQVVMVF9GT1JNQVRfREFURTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0ZUFkYXB0ZXI6IERhdGVBZGFwdGVyPE1vbWVudD4sXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSB1c2VyUHJlZmVyZW5jZXNTZXJ2aWNlOiBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgZ2V0RnJvbVZhbGlkYXRpb25NZXNzYWdlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20uaGFzRXJyb3IoJ2ludmFsaWRPbkNoYW5nZScpIHx8IHRoaXMuaGFzUGFyc2VFcnJvcih0aGlzLmZyb20pID8gJ1NFQVJDSC5GSUxURVIuVkFMSURBVElPTi5JTlZBTElELURBVEUnIDpcbiAgICAgICAgICAgIHRoaXMuZnJvbS5oYXNFcnJvcignbWF0RGF0ZXBpY2tlck1heCcpID8gJ1NFQVJDSC5GSUxURVIuVkFMSURBVElPTi5CRVlPTkQtTUFYLURBVEUnIDpcbiAgICAgICAgICAgIHRoaXMuZnJvbS5oYXNFcnJvcigncmVxdWlyZWQnKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uUkVRVUlSRUQtVkFMVUUnIDpcbiAgICAgICAgICAgICcnO1xuICAgIH1cblxuICAgIGdldFRvVmFsaWRhdGlvbk1lc3NhZ2UoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8uaGFzRXJyb3IoJ2ludmFsaWRPbkNoYW5nZScpIHx8IHRoaXMuaGFzUGFyc2VFcnJvcih0aGlzLnRvKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uSU5WQUxJRC1EQVRFJyA6XG4gICAgICAgICAgICB0aGlzLnRvLmhhc0Vycm9yKCdtYXREYXRlcGlja2VyTWluJykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLk5PLURBWVMnIDpcbiAgICAgICAgICAgIHRoaXMudG8uaGFzRXJyb3IoJ21hdERhdGVwaWNrZXJNYXgnKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uQkVZT05ELU1BWC1EQVRFJyA6XG4gICAgICAgICAgICB0aGlzLnRvLmhhc0Vycm9yKCdyZXF1aXJlZCcpID8gJ1NFQVJDSC5GSUxURVIuVkFMSURBVElPTi5SRVFVSVJFRC1WQUxVRScgOlxuICAgICAgICAgICAgJyc7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGVQaWNrZXJEYXRlRm9ybWF0ID0gdGhpcy5zZXR0aW5ncy5kYXRlRm9ybWF0IHx8IERFRkFVTFRfRk9STUFUX0RBVEU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhlQ3VzdG9tRGF0ZUFkYXB0ZXIgPSA8TW9tZW50RGF0ZUFkYXB0ZXI+IDxhbnk+IHRoaXMuZGF0ZUFkYXB0ZXI7XG4gICAgICAgIHRoZUN1c3RvbURhdGVBZGFwdGVyLm92ZXJyaWRlRGlzcGx5YUZvcm1hdCA9IHRoaXMuZGF0ZVBpY2tlckRhdGVGb3JtYXQ7XG5cbiAgICAgICAgdGhpcy51c2VyUHJlZmVyZW5jZXNTZXJ2aWNlLnNlbGVjdChVc2VyUHJlZmVyZW5jZVZhbHVlcy5Mb2NhbGUpLnN1YnNjcmliZSgobG9jYWxlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldExvY2FsZShsb2NhbGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB2YWxpZGF0b3JzID0gVmFsaWRhdG9ycy5jb21wb3NlKFtcbiAgICAgICAgICAgIFZhbGlkYXRvcnMucmVxdWlyZWRcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdGhpcy5mcm9tID0gbmV3IEZvcm1Db250cm9sKCcnLCB2YWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy50byA9IG5ldyBGb3JtQ29udHJvbCgnJywgdmFsaWRhdG9ycyk7XG5cbiAgICAgICAgdGhpcy5mb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgICAgICB0bzogdGhpcy50b1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1heERhdGUgPSB0aGlzLmRhdGVBZGFwdGVyLnRvZGF5KCkuc3RhcnRPZignZGF5Jyk7XG4gICAgfVxuXG4gICAgYXBwbHkobW9kZWw6IHsgZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nIH0sIGlzVmFsaWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKGlzVmFsaWQgJiYgdGhpcy5pZCAmJiB0aGlzLmNvbnRleHQgJiYgdGhpcy5zZXR0aW5ncyAmJiB0aGlzLnNldHRpbmdzLmZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG1vbWVudChtb2RlbC5mcm9tKS5zdGFydE9mKCdkYXknKS5mb3JtYXQoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IG1vbWVudChtb2RlbC50bykuZW5kT2YoJ2RheScpLmZvcm1hdCgpO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucXVlcnlGcmFnbWVudHNbdGhpcy5pZF0gPSBgJHt0aGlzLnNldHRpbmdzLmZpZWxkfTpbJyR7c3RhcnR9JyBUTyAnJHtlbmR9J11gO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZm9ybS5yZXNldCh7XG4gICAgICAgICAgICBmcm9tOiAnJyxcbiAgICAgICAgICAgIHRvOiAnJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuaWQgJiYgdGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucXVlcnlGcmFnbWVudHNbdGhpcy5pZF0gPSAnJztcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ2hhbmdlZEhhbmRsZXIoZXZlbnQ6IGFueSwgZm9ybUNvbnRyb2w6IEZvcm1Db250cm9sKSB7XG4gICAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSBldmVudC5zcmNFbGVtZW50LnZhbHVlO1xuXG4gICAgICAgIGNvbnN0IGZvcm1hdERhdGUgPSB0aGlzLmRhdGVBZGFwdGVyLnBhcnNlKGlucHV0VmFsdWUsIHRoaXMuZGF0ZVBpY2tlckRhdGVGb3JtYXQpO1xuICAgICAgICBpZiAoZm9ybWF0RGF0ZSAmJiBmb3JtYXREYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgZm9ybUNvbnRyb2wuc2V0VmFsdWUoZm9ybWF0RGF0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0RGF0ZSkge1xuICAgICAgICAgICAgZm9ybUNvbnRyb2wuc2V0RXJyb3JzKHtcbiAgICAgICAgICAgICAgICAnaW52YWxpZE9uQ2hhbmdlJzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtQ29udHJvbC5zZXRFcnJvcnMoe1xuICAgICAgICAgICAgICAgICdyZXF1aXJlZCc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgICAgICB0aGlzLmRhdGVBZGFwdGVyLnNldExvY2FsZShsb2NhbGUpO1xuICAgICAgICBtb21lbnQubG9jYWxlKGxvY2FsZSk7XG4gICAgfVxuXG4gICAgaGFzUGFyc2VFcnJvcihmb3JtQ29udHJvbCkge1xuICAgICAgICByZXR1cm4gZm9ybUNvbnRyb2wuaGFzRXJyb3IoJ21hdERhdGVwaWNrZXJQYXJzZScpICYmIGZvcm1Db250cm9sLmdldEVycm9yKCdtYXREYXRlcGlja2VyUGFyc2UnKS50ZXh0O1xuICAgIH1cblxuICAgIGZvcmNlUGxhY2Vob2xkZXIoZXZlbnQ6IGFueSkge1xuICAgICAgICBldmVudC5zcmNFbGVtZW50LmNsaWNrKCk7XG4gICAgfVxuXG59XG4iXX0=