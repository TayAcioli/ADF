/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Directive, Input, HostListener } from '@angular/core';
import { MatDialog } from '@angular/material';
import { AlfrescoApiService } from '@alfresco/adf-core';
import { DownloadZipDialogComponent } from '../dialogs/download-zip.dialog';
export class NodeDownloadDirective {
    /**
     * @param {?} apiService
     * @param {?} dialog
     */
    constructor(apiService, dialog) {
        this.apiService = apiService;
        this.dialog = dialog;
    }
    /**
     * @return {?}
     */
    onClick() {
        this.downloadNodes(this.nodes);
    }
    /**
     * Downloads multiple selected nodes.
     * Packs result into a .ZIP archive if there is more than one node selected.
     * @param {?} selection Multiple selected nodes to download
     * @return {?}
     */
    downloadNodes(selection) {
        if (!selection || selection.length === 0) {
            return;
        }
        if (selection.length === 1) {
            this.downloadNode(selection[0]);
        }
        else {
            this.downloadZip(selection);
        }
    }
    /**
     * Downloads a single node.
     * Packs result into a .ZIP archive is the node is a Folder.
     * @param {?} node Node to download
     * @return {?}
     */
    downloadNode(node) {
        if (node && node.entry) {
            /** @type {?} */
            const entry = node.entry;
            if (entry.isFile) {
                this.downloadFile(node);
            }
            if (entry.isFolder) {
                this.downloadZip([node]);
            }
            // Check if there's nodeId for Shared Files
            if (!entry.isFile && !entry.isFolder && (/** @type {?} */ (entry)).nodeId) {
                this.downloadFile(node);
            }
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    downloadFile(node) {
        if (node && node.entry) {
            /** @type {?} */
            const contentApi = this.apiService.getInstance().content;
            /** @type {?} */
            const id = (/** @type {?} */ (node.entry)).nodeId || node.entry.id;
            /** @type {?} */
            const url = contentApi.getContentUrl(id, true);
            /** @type {?} */
            const fileName = node.entry.name;
            this.download(url, fileName);
        }
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    downloadZip(selection) {
        if (selection && selection.length > 0) {
            /** @type {?} */
            const nodeIds = selection.map((node) => (node.entry.nodeId || node.entry.id));
            this.dialog.open(DownloadZipDialogComponent, {
                width: '600px',
                disableClose: true,
                data: {
                    nodeIds
                }
            });
        }
    }
    /**
     * @param {?} url
     * @param {?} fileName
     * @return {?}
     */
    download(url, fileName) {
        if (url && fileName) {
            /** @type {?} */
            const link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }
}
NodeDownloadDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adfNodeDownload]'
            },] }
];
/** @nocollapse */
NodeDownloadDirective.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: MatDialog }
];
NodeDownloadDirective.propDecorators = {
    nodes: [{ type: Input, args: ['adfNodeDownload',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
if (false) {
    /**
     * Nodes to download.
     * @type {?}
     */
    NodeDownloadDirective.prototype.nodes;
    /** @type {?} */
    NodeDownloadDirective.prototype.apiService;
    /** @type {?} */
    NodeDownloadDirective.prototype.dialog;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS1kb3dubG9hZC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvIiwic291cmNlcyI6WyJkaXJlY3RpdmVzL25vZGUtZG93bmxvYWQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMvRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFOUMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFeEQsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFLNUUsTUFBTTs7Ozs7SUFZRixZQUNZLFlBQ0E7UUFEQSxlQUFVLEdBQVYsVUFBVTtRQUNWLFdBQU0sR0FBTixNQUFNO0tBQ2pCOzs7O0lBUEQsT0FBTztRQUNILElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ2xDOzs7Ozs7O0lBWUQsYUFBYSxDQUFDLFNBQW1DO1FBQzdDLElBQUksQ0FBQyxTQUFTLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDdEMsT0FBTztTQUNWO1FBRUQsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN4QixJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ25DO2FBQU07WUFDSCxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQy9CO0tBQ0o7Ozs7Ozs7SUFPRCxZQUFZLENBQUMsSUFBdUI7UUFDaEMsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTs7WUFDcEIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUV6QixJQUFJLEtBQUssQ0FBQyxNQUFNLEVBQUU7Z0JBQ2QsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUMzQjtZQUVELElBQUksS0FBSyxDQUFDLFFBQVEsRUFBRTtnQkFDaEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDNUI7O1lBR0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxJQUFJLG1CQUFPLEtBQUssRUFBQyxDQUFDLE1BQU0sRUFBRTtnQkFDMUQsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUMzQjtTQUNKO0tBQ0o7Ozs7O0lBRU8sWUFBWSxDQUFDLElBQXVCO1FBQ3hDLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7O1lBQ3BCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDOztZQUV6RCxNQUFNLEVBQUUsR0FBRyxtQkFBTyxJQUFJLENBQUMsS0FBSyxFQUFDLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDOztZQUV0RCxNQUFNLEdBQUcsR0FBRyxVQUFVLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQzs7WUFDL0MsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7WUFFakMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDaEM7Ozs7OztJQUdHLFdBQVcsQ0FBQyxTQUFtQztRQUNuRCxJQUFJLFNBQVMsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTs7WUFFbkMsTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFbkYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsMEJBQTBCLEVBQUU7Z0JBQ3pDLEtBQUssRUFBRSxPQUFPO2dCQUNkLFlBQVksRUFBRSxJQUFJO2dCQUNsQixJQUFJLEVBQUU7b0JBQ0YsT0FBTztpQkFDVjthQUNKLENBQUMsQ0FBQztTQUNOOzs7Ozs7O0lBR0csUUFBUSxDQUFDLEdBQVcsRUFBRSxRQUFnQjtRQUMxQyxJQUFJLEdBQUcsSUFBSSxRQUFRLEVBQUU7O1lBQ2pCLE1BQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFekMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1lBQzVCLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1lBQ3pCLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO1lBRWhCLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2hDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNiLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ25DOzs7O1lBcEdSLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsbUJBQW1CO2FBQ2hDOzs7O1lBTlEsa0JBQWtCO1lBRmxCLFNBQVM7OztvQkFhYixLQUFLLFNBQUMsaUJBQWlCO3NCQUd2QixZQUFZLFNBQUMsT0FBTyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0RGlhbG9nIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRpdHkgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuaW1wb3J0IHsgRG93bmxvYWRaaXBEaWFsb2dDb21wb25lbnQgfSBmcm9tICcuLi9kaWFsb2dzL2Rvd25sb2FkLXppcC5kaWFsb2cnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1thZGZOb2RlRG93bmxvYWRdJ1xufSlcbmV4cG9ydCBjbGFzcyBOb2RlRG93bmxvYWREaXJlY3RpdmUge1xuXG4gICAgLyoqIE5vZGVzIHRvIGRvd25sb2FkLiAqL1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnB1dC1yZW5hbWVcbiAgICBASW5wdXQoJ2FkZk5vZGVEb3dubG9hZCcpXG4gICAgbm9kZXM6IE1pbmltYWxOb2RlRW50aXR5W107XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gICAgb25DbGljaygpIHtcbiAgICAgICAgdGhpcy5kb3dubG9hZE5vZGVzKHRoaXMubm9kZXMpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBkaWFsb2c6IE1hdERpYWxvZykge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBtdWx0aXBsZSBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKiBQYWNrcyByZXN1bHQgaW50byBhIC5aSVAgYXJjaGl2ZSBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIG5vZGUgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHNlbGVjdGlvbiBNdWx0aXBsZSBzZWxlY3RlZCBub2RlcyB0byBkb3dubG9hZFxuICAgICAqL1xuICAgIGRvd25sb2FkTm9kZXMoc2VsZWN0aW9uOiBBcnJheTxNaW5pbWFsTm9kZUVudGl0eT4pIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWROb2RlKHNlbGVjdGlvblswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRvd25sb2FkWmlwKHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBzaW5nbGUgbm9kZS5cbiAgICAgKiBQYWNrcyByZXN1bHQgaW50byBhIC5aSVAgYXJjaGl2ZSBpcyB0aGUgbm9kZSBpcyBhIEZvbGRlci5cbiAgICAgKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGRvd25sb2FkXG4gICAgICovXG4gICAgZG93bmxvYWROb2RlKG5vZGU6IE1pbmltYWxOb2RlRW50aXR5KSB7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUuZW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gbm9kZS5lbnRyeTtcblxuICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW50cnkuaXNGb2xkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkWmlwKFtub2RlXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3Mgbm9kZUlkIGZvciBTaGFyZWQgRmlsZXNcbiAgICAgICAgICAgIGlmICghZW50cnkuaXNGaWxlICYmICFlbnRyeS5pc0ZvbGRlciAmJiAoPGFueT4gZW50cnkpLm5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb3dubG9hZEZpbGUobm9kZTogTWluaW1hbE5vZGVFbnRpdHkpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5lbnRyeSkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudEFwaSA9IHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLmNvbnRlbnQ7XG4gICAgICAgICAgICAvLyBub2RlSWQgZm9yIFNoYXJlZCBub2RlXG4gICAgICAgICAgICBjb25zdCBpZCA9ICg8YW55PiBub2RlLmVudHJ5KS5ub2RlSWQgfHwgbm9kZS5lbnRyeS5pZDtcblxuICAgICAgICAgICAgY29uc3QgdXJsID0gY29udGVudEFwaS5nZXRDb250ZW50VXJsKGlkLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gbm9kZS5lbnRyeS5uYW1lO1xuXG4gICAgICAgICAgICB0aGlzLmRvd25sb2FkKHVybCwgZmlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb3dubG9hZFppcChzZWxlY3Rpb246IEFycmF5PE1pbmltYWxOb2RlRW50aXR5Pikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBub2RlSWQgZm9yIFNoYXJlZCBub2RlXG4gICAgICAgICAgICBjb25zdCBub2RlSWRzID0gc2VsZWN0aW9uLm1hcCgobm9kZTogYW55KSA9PiAobm9kZS5lbnRyeS5ub2RlSWQgfHwgbm9kZS5lbnRyeS5pZCkpO1xuXG4gICAgICAgICAgICB0aGlzLmRpYWxvZy5vcGVuKERvd25sb2FkWmlwRGlhbG9nQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICc2MDBweCcsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUNsb3NlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb3dubG9hZCh1cmw6IHN0cmluZywgZmlsZU5hbWU6IHN0cmluZykge1xuICAgICAgICBpZiAodXJsICYmIGZpbGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXG4gICAgICAgICAgICBsaW5rLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBsaW5rLmRvd25sb2FkID0gZmlsZU5hbWU7XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICAgICAgICBsaW5rLmNsaWNrKCk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19