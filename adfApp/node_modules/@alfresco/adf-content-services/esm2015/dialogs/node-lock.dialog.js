/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import moment from 'moment-es6';
import { Component, Inject, Optional } from '@angular/core';
import { MAT_DIALOG_DATA, MatDialogRef } from '@angular/material';
import { FormBuilder } from '@angular/forms';
import { AlfrescoApiService } from '@alfresco/adf-core';
export class NodeLockDialogComponent {
    /**
     * @param {?} formBuilder
     * @param {?} dialog
     * @param {?} alfrescoApi
     * @param {?} data
     */
    constructor(formBuilder, dialog, alfrescoApi, data) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.alfrescoApi = alfrescoApi;
        this.data = data;
        this.node = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        const { node } = this.data;
        this.nodeName = node.name;
        this.form = this.formBuilder.group({
            isLocked: node.isLocked || false,
            allowOwner: node.properties['cm:lockType'] === 'WRITE_LOCK',
            isTimeLock: !!node.properties['cm:expiryDate'],
            time: !!node.properties['cm:expiryDate'] ? moment(node.properties['cm:expiryDate']) : moment()
        });
    }
    /**
     * @return {?}
     */
    get lockTimeInSeconds() {
        if (this.form.value.isTimeLock) {
            /** @type {?} */
            let duration = moment.duration(moment(this.form.value.time).diff(moment()));
            return duration.asSeconds();
        }
        return 0;
    }
    /**
     * @return {?}
     */
    get nodeBodyLock() {
        return {
            'timeToExpire': this.lockTimeInSeconds,
            'type': this.form.value.allowOwner ? 'ALLOW_OWNER_CHANGES' : 'FULL',
            'lifetime': 'PERSISTENT'
        };
    }
    /**
     * @return {?}
     */
    toggleLock() {
        const { alfrescoApi: { nodesApi }, data: { node } } = this;
        if (this.form.value.isLocked) {
            return nodesApi.lockNode(node.id, this.nodeBodyLock);
        }
        return nodesApi.unlockNode(node.id);
    }
    /**
     * @return {?}
     */
    submit() {
        this.toggleLock()
            .then(node => {
            this.data.node.isLocked = this.form.value.isLocked;
            this.dialog.close(node.entry);
        })
            .catch(error => this.data.onError(error));
    }
}
NodeLockDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-node-lock',
                template: "<h2 mat-dialog-title>\n    {{ 'CORE.FILE_DIALOG.FILE_LOCK' | translate }}\n</h2>\n\n<mat-dialog-content>\n    <br />\n    <form [formGroup]=\"form\" (submit)=\"submit()\">\n        <mat-checkbox class=\"adf-lock-file-name\" [formControl]=\"form.controls['isLocked']\" ngDefaultControl>\n            {{ 'CORE.FILE_DIALOG.FILE_LOCK_CHECKBOX' | translate }} <strong>\"{{ nodeName }}\"</strong>\n        </mat-checkbox>\n\n        <br />\n\n        <div *ngIf=\"form.value.isLocked\">\n            <mat-checkbox class=\"adf-lock-file-name\" [formControl]=\"form.controls['allowOwner']\" ngDefaultControl>\n                {{ 'CORE.FILE_DIALOG.ALLOW_OTHERS_CHECKBOX' | translate }}\n            </mat-checkbox>\n\n            <br />\n\n            <mat-checkbox class=\"adf-lock-file-name\" [formControl]=\"form.controls['isTimeLock']\" ngDefaultControl>\n                {{ 'CORE.FILE_DIALOG.TIME_LOCK_CHECKBOX' | translate }}\n            </mat-checkbox>\n\n            <br />\n\n            <mat-form-field *ngIf=\"form.value.isTimeLock\">\n                <mat-datetimepicker-toggle [for]=\"datetimePicker\" matSuffix></mat-datetimepicker-toggle>\n                <mat-datetimepicker #datetimePicker type=\"datetime\" openOnFocus=\"true\" timeInterval=\"1\"></mat-datetimepicker>\n                <input matInput [formControl]=\"form.controls['time']\" [matDatetimepicker]=\"datetimePicker\" required autocomplete=\"false\">\n            </mat-form-field>\n        </div>\n    </form>\n    <br />\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-dialog-buttons\">\n    <span class=\"adf-fill-remaining-space\"></span>\n\n    <button mat-button mat-dialog-close>\n        {{ 'CORE.FILE_DIALOG.CANCEL_BUTTON.LABEL' | translate }}\n    </button>\n\n    <button class=\"adf-dialog-action-button\" mat-button (click)=\"submit()\">\n        {{ 'CORE.FILE_DIALOG.SAVE_BUTTON.LABEL' | translate }}\n    </button>\n</mat-dialog-actions>\n",
                styles: [".adf-fill-remaining-space{flex:1 1 auto}.adf-full-width,.adf-lock-file-name .mat-checkbox-layout{width:100%}.adf-lock-file-name .mat-checkbox-label{text-overflow:ellipsis;overflow:hidden}.adf-lock-file-name .mat-checkbox-inner-container{margin:auto 8px auto 0}"]
            }] }
];
/** @nocollapse */
NodeLockDialogComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: MatDialogRef },
    { type: AlfrescoApiService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
if (false) {
    /** @type {?} */
    NodeLockDialogComponent.prototype.form;
    /** @type {?} */
    NodeLockDialogComponent.prototype.node;
    /** @type {?} */
    NodeLockDialogComponent.prototype.nodeName;
    /** @type {?} */
    NodeLockDialogComponent.prototype.formBuilder;
    /** @type {?} */
    NodeLockDialogComponent.prototype.dialog;
    /** @type {?} */
    NodeLockDialogComponent.prototype.alfrescoApi;
    /** @type {?} */
    NodeLockDialogComponent.prototype.data;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS1sb2NrLmRpYWxvZy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy8iLCJzb3VyY2VzIjpbImRpYWxvZ3Mvbm9kZS1sb2NrLmRpYWxvZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxPQUFPLE1BQU0sTUFBTSxZQUFZLENBQUM7QUFFaEMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQVUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxlQUFlLEVBQUUsWUFBWSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbEUsT0FBTyxFQUFFLFdBQVcsRUFBYSxNQUFNLGdCQUFnQixDQUFDO0FBR3hELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBT3hELE1BQU07Ozs7Ozs7SUFNRixZQUNZLGFBQ0QsUUFDQyxhQUdELElBQVM7UUFMUixnQkFBVyxHQUFYLFdBQVc7UUFDWixXQUFNLEdBQU4sTUFBTTtRQUNMLGdCQUFXLEdBQVgsV0FBVztRQUdaLFNBQUksR0FBSixJQUFJLENBQUs7b0JBVFcsSUFBSTtLQVUvQjs7OztJQUVKLFFBQVE7UUFDSixNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUMzQixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFFMUIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQztZQUMvQixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsSUFBSSxLQUFLO1lBQ2hDLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxLQUFLLFlBQVk7WUFDM0QsVUFBVSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQztZQUM5QyxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRTtTQUNqRyxDQUFDLENBQUM7S0FDTjs7OztRQUVXLGlCQUFpQjtRQUN6QixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRTs7WUFDNUIsSUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUM1RSxPQUFPLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztTQUMvQjtRQUVELE9BQU8sQ0FBQyxDQUFDOzs7OztRQUdELFlBQVk7UUFDcEIsT0FBTztZQUNILGNBQWMsRUFBRSxJQUFJLENBQUMsaUJBQWlCO1lBQ3RDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxNQUFNO1lBQ25FLFVBQVUsRUFBRSxZQUFZO1NBQzNCLENBQUM7Ozs7O0lBR0UsVUFBVTtRQUNkLE1BQU0sRUFBRSxXQUFXLEVBQUUsRUFBRSxRQUFRLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQztRQUUzRCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRTtZQUMxQixPQUFPLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDeEQ7UUFFRCxPQUFPLFFBQVEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDOzs7OztJQUd4QyxNQUFNO1FBQ0YsSUFBSSxDQUFDLFVBQVUsRUFBRTthQUNaLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNULElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUM7WUFDbkQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ2pDLENBQUM7YUFDRCxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0tBQ2pEOzs7WUFsRUosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxlQUFlO2dCQUV6Qiw2NURBQXNDOzthQUN6Qzs7OztZQVRRLFdBQVc7WUFETSxZQUFZO1lBSTdCLGtCQUFrQjs0Q0FpQmxCLFFBQVEsWUFDUixNQUFNLFNBQUMsZUFBZSIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50LWVzNic7XG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5qZWN0LCBPbkluaXQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNQVRfRElBTE9HX0RBVEEsIE1hdERpYWxvZ1JlZiB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCB7IEZvcm1CdWlsZGVyLCBGb3JtR3JvdXAgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IE1pbmltYWxOb2RlRW50cnlFbnRpdHksIE5vZGVFbnRyeSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBBbGZyZXNjb0FwaVNlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1ub2RlLWxvY2snLFxuICAgIHN0eWxlVXJsczogWycuL2ZvbGRlci5kaWFsb2cuc2NzcyddLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9ub2RlLWxvY2suZGlhbG9nLmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIE5vZGVMb2NrRGlhbG9nQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIGZvcm06IEZvcm1Hcm91cDtcbiAgICBub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5ID0gbnVsbDtcbiAgICBub2RlTmFtZTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgZm9ybUJ1aWxkZXI6IEZvcm1CdWlsZGVyLFxuICAgICAgICBwdWJsaWMgZGlhbG9nOiBNYXREaWFsb2dSZWY8Tm9kZUxvY2tEaWFsb2dDb21wb25lbnQ+LFxuICAgICAgICBwcml2YXRlIGFsZnJlc2NvQXBpOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgIEBPcHRpb25hbCgpXG4gICAgICAgIEBJbmplY3QoTUFUX0RJQUxPR19EQVRBKVxuICAgICAgICBwdWJsaWMgZGF0YTogYW55XG4gICAgKSB7fVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZSB9ID0gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZS5uYW1lO1xuXG4gICAgICAgIHRoaXMuZm9ybSA9IHRoaXMuZm9ybUJ1aWxkZXIuZ3JvdXAoe1xuICAgICAgICAgICAgaXNMb2NrZWQ6IG5vZGUuaXNMb2NrZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICBhbGxvd093bmVyOiBub2RlLnByb3BlcnRpZXNbJ2NtOmxvY2tUeXBlJ10gPT09ICdXUklURV9MT0NLJyxcbiAgICAgICAgICAgIGlzVGltZUxvY2s6ICEhbm9kZS5wcm9wZXJ0aWVzWydjbTpleHBpcnlEYXRlJ10sXG4gICAgICAgICAgICB0aW1lOiAhIW5vZGUucHJvcGVydGllc1snY206ZXhwaXJ5RGF0ZSddID8gbW9tZW50KG5vZGUucHJvcGVydGllc1snY206ZXhwaXJ5RGF0ZSddKSA6IG1vbWVudCgpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IGxvY2tUaW1lSW5TZWNvbmRzKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLmZvcm0udmFsdWUuaXNUaW1lTG9jaykge1xuICAgICAgICAgICAgbGV0IGR1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKG1vbWVudCh0aGlzLmZvcm0udmFsdWUudGltZSkuZGlmZihtb21lbnQoKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGR1cmF0aW9uLmFzU2Vjb25kcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgbm9kZUJvZHlMb2NrKCk6IG9iamVjdCB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZVRvRXhwaXJlJzogdGhpcy5sb2NrVGltZUluU2Vjb25kcyxcbiAgICAgICAgICAgICd0eXBlJzogdGhpcy5mb3JtLnZhbHVlLmFsbG93T3duZXIgPyAnQUxMT1dfT1dORVJfQ0hBTkdFUycgOiAnRlVMTCcsXG4gICAgICAgICAgICAnbGlmZXRpbWUnOiAnUEVSU0lTVEVOVCdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZUxvY2soKTogUHJvbWlzZTxOb2RlRW50cnk+IHtcbiAgICAgICAgY29uc3QgeyBhbGZyZXNjb0FwaTogeyBub2Rlc0FwaSB9LCBkYXRhOiB7IG5vZGUgfSB9ID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5mb3JtLnZhbHVlLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXNBcGkubG9ja05vZGUobm9kZS5pZCwgdGhpcy5ub2RlQm9keUxvY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGVzQXBpLnVubG9ja05vZGUobm9kZS5pZCk7XG4gICAgfVxuXG4gICAgc3VibWl0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnRvZ2dsZUxvY2soKVxuICAgICAgICAgICAgLnRoZW4obm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLm5vZGUuaXNMb2NrZWQgPSB0aGlzLmZvcm0udmFsdWUuaXNMb2NrZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFsb2cuY2xvc2Uobm9kZS5lbnRyeSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHRoaXMuZGF0YS5vbkVycm9yKGVycm9yKSk7XG4gICAgfVxufVxuIl19