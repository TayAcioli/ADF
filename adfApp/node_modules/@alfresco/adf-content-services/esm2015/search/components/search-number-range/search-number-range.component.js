/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation } from '@angular/core';
import { FormControl, Validators, FormGroup } from '@angular/forms';
import { LiveErrorStateMatcher } from '../../forms/live-error-state-matcher';
export class SearchNumberRangeComponent {
    constructor() {
        this.matcher = new LiveErrorStateMatcher();
        this.format = '[{FROM} TO {TO}]';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            this.field = this.settings.field;
            this.format = this.settings["format"] || '[{FROM} TO {TO}]';
        }
        this.validators = Validators.compose([
            Validators.required,
            Validators.pattern(/^-?(0|[1-9]\d*)?$/),
            Validators.min(0)
        ]);
        this.from = new FormControl('', this.validators);
        this.to = new FormControl('', this.validators);
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        }, this.formValidator);
    }
    /**
     * @param {?} formGroup
     * @return {?}
     */
    formValidator(formGroup) {
        return parseInt(formGroup.get('from').value, 10) < parseInt(formGroup.get('to').value, 10) ? null : { 'mismatch': true };
    }
    /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    apply(model, isValid) {
        if (isValid && this.id && this.context && this.field) {
            /** @type {?} */
            const map = new Map();
            map.set('FROM', model.from);
            map.set('TO', model.to);
            /** @type {?} */
            const value = this.formatString(this.format, map);
            this.context.queryFragments[this.id] = `${this.field}:${value}`;
            this.context.update();
        }
    }
    /**
     * @param {?} str
     * @param {?} map
     * @return {?}
     */
    formatString(str, map) {
        /** @type {?} */
        let result = str;
        map.forEach((value, key) => {
            /** @type {?} */
            const expr = new RegExp('{' + key + '}', 'gm');
            result = result.replace(expr, value);
        });
        return result;
    }
    /**
     * @return {?}
     */
    reset() {
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    }
}
SearchNumberRangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-number-range',
                template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n\n    <mat-form-field>\n        <input\n            matInput [formControl]=\"from\" [errorStateMatcher]=\"matcher\"\n            placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM' | translate }}\"\n            autocomplete=\"off\">\n        <mat-error *ngIf=\"from.hasError('pattern') || from.hasError('min')\">\n            {{ 'SEARCH.FILTER.VALIDATION.INVALID-FORMAT' | translate }}\n        </mat-error>\n        <mat-error *ngIf=\"from.hasError('required')\">\n            {{ 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' | translate }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input\n            matInput [formControl]=\"to\" [errorStateMatcher]=\"matcher\"\n            placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO' | translate }}\"\n            autocomplete=\"off\">\n        <mat-error *ngIf=\"to.hasError('pattern') || to.hasError('min')\">\n            {{ 'SEARCH.FILTER.VALIDATION.INVALID-FORMAT' | translate }}\n        </mat-error>\n        <mat-error *ngIf=\"to.hasError('required')\">\n            {{ 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' | translate }}\n        </mat-error>\n    </mat-form-field>\n\n\n    <div class=\"facet-buttons\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"reset()\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-number-range' },
                styles: [".adf-search-number-range>form{display:inline-flex;flex-direction:column;width:100%}"]
            }] }
];
if (false) {
    /** @type {?} */
    SearchNumberRangeComponent.prototype.from;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.to;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.form;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.matcher;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.id;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.settings;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.context;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.field;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.format;
    /** @type {?} */
    SearchNumberRangeComponent.prototype.validators;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLW51bWJlci1yYW5nZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvIiwic291cmNlcyI6WyJzZWFyY2gvY29tcG9uZW50cy9zZWFyY2gtbnVtYmVyLXJhbmdlL3NlYXJjaC1udW1iZXItcmFuZ2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBVSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckUsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFJcEUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFTN0UsTUFBTTs7dUJBTVEsSUFBSSxxQkFBcUIsRUFBRTtzQkFPNUIsa0JBQWtCOzs7OztJQUkzQixRQUFRO1FBRUosSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2YsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztZQUNqQyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLGNBQVcsa0JBQWtCLENBQUM7U0FDNUQ7UUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUM7WUFDakMsVUFBVSxDQUFDLFFBQVE7WUFDbkIsVUFBVSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQztZQUN2QyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUNwQixDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksV0FBVyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDakQsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLFdBQVcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRS9DLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxTQUFTLENBQUM7WUFDdEIsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFO1NBQ2QsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDMUI7Ozs7O0lBRUQsYUFBYSxDQUFDLFNBQW9CO1FBQzlCLE9BQU8sUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFDLFVBQVUsRUFBRSxJQUFJLEVBQUMsQ0FBQztLQUMxSDs7Ozs7O0lBRUQsS0FBSyxDQUFDLEtBQW1DLEVBQUUsT0FBZ0I7UUFDdkQsSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7O1lBQ2xELE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO1lBQ3RDLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM1QixHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7O1lBRXhCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztZQUVsRCxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssRUFBRSxDQUFDO1lBQ2hFLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDekI7S0FDSjs7Ozs7O0lBRU8sWUFBWSxDQUFDLEdBQVcsRUFBRSxHQUF3Qjs7UUFDdEQsSUFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDO1FBRWpCLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEVBQUU7O1lBQ3ZCLE1BQU0sSUFBSSxHQUFHLElBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQy9DLE1BQU0sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztTQUN4QyxDQUFDLENBQUM7UUFFSCxPQUFPLE1BQU0sQ0FBQzs7Ozs7SUFHbEIsS0FBSztRQUNELElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ1osSUFBSSxFQUFFLEVBQUU7WUFDUixFQUFFLEVBQUUsRUFBRTtTQUNULENBQUMsQ0FBQztRQUVILElBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDMUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUN6QjtLQUNKOzs7WUFwRkosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSx5QkFBeUI7Z0JBQ25DLGdtREFBbUQ7Z0JBRW5ELGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2dCQUNyQyxJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUseUJBQXlCLEVBQUU7O2FBQzdDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgT25Jbml0LCBDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgVmFsaWRhdG9ycywgRm9ybUdyb3VwIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU2VhcmNoV2lkZ2V0IH0gZnJvbSAnLi4vLi4vc2VhcmNoLXdpZGdldC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoV2lkZ2V0U2V0dGluZ3MgfSBmcm9tICcuLi8uLi9zZWFyY2gtd2lkZ2V0LXNldHRpbmdzLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VhcmNoLXF1ZXJ5LWJ1aWxkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBMaXZlRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICcuLi8uLi9mb3Jtcy9saXZlLWVycm9yLXN0YXRlLW1hdGNoZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1zZWFyY2gtbnVtYmVyLXJhbmdlJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2VhcmNoLW51bWJlci1yYW5nZS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vc2VhcmNoLW51bWJlci1yYW5nZS5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgaG9zdDogeyBjbGFzczogJ2FkZi1zZWFyY2gtbnVtYmVyLXJhbmdlJyB9XG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaE51bWJlclJhbmdlQ29tcG9uZW50IGltcGxlbWVudHMgU2VhcmNoV2lkZ2V0LCBPbkluaXQge1xuXG4gICAgZnJvbTogRm9ybUNvbnRyb2w7XG4gICAgdG86IEZvcm1Db250cm9sO1xuXG4gICAgZm9ybTogRm9ybUdyb3VwO1xuICAgIG1hdGNoZXIgPSBuZXcgTGl2ZUVycm9yU3RhdGVNYXRjaGVyKCk7XG5cbiAgICBpZDogc3RyaW5nO1xuICAgIHNldHRpbmdzPzogU2VhcmNoV2lkZ2V0U2V0dGluZ3M7XG4gICAgY29udGV4dD86IFNlYXJjaFF1ZXJ5QnVpbGRlclNlcnZpY2U7XG5cbiAgICBmaWVsZDogc3RyaW5nO1xuICAgIGZvcm1hdCA9ICdbe0ZST019IFRPIHtUT31dJztcblxuICAgIHZhbGlkYXRvcnM6IFZhbGlkYXRvcnM7XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5maWVsZCA9IHRoaXMuc2V0dGluZ3MuZmllbGQ7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdCA9IHRoaXMuc2V0dGluZ3MuZm9ybWF0IHx8ICdbe0ZST019IFRPIHtUT31dJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmFsaWRhdG9ycyA9IFZhbGlkYXRvcnMuY29tcG9zZShbXG4gICAgICAgICAgICBWYWxpZGF0b3JzLnJlcXVpcmVkLFxuICAgICAgICAgICAgVmFsaWRhdG9ycy5wYXR0ZXJuKC9eLT8oMHxbMS05XVxcZCopPyQvKSxcbiAgICAgICAgICAgIFZhbGlkYXRvcnMubWluKDApXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHRoaXMuZnJvbSA9IG5ldyBGb3JtQ29udHJvbCgnJywgdGhpcy52YWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy50byA9IG5ldyBGb3JtQ29udHJvbCgnJywgdGhpcy52YWxpZGF0b3JzKTtcblxuICAgICAgICB0aGlzLmZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvXG4gICAgICAgIH0sIHRoaXMuZm9ybVZhbGlkYXRvcik7XG4gICAgfVxuXG4gICAgZm9ybVZhbGlkYXRvcihmb3JtR3JvdXA6IEZvcm1Hcm91cCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoZm9ybUdyb3VwLmdldCgnZnJvbScpLnZhbHVlLCAxMCkgPCBwYXJzZUludChmb3JtR3JvdXAuZ2V0KCd0bycpLnZhbHVlLCAxMCkgPyBudWxsIDogeydtaXNtYXRjaCc6IHRydWV9O1xuICAgIH1cblxuICAgIGFwcGx5KG1vZGVsOiB7IGZyb206IHN0cmluZywgdG86IHN0cmluZyB9LCBpc1ZhbGlkOiBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkICYmIHRoaXMuaWQgJiYgdGhpcy5jb250ZXh0ICYmIHRoaXMuZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgICAgICAgICBtYXAuc2V0KCdGUk9NJywgbW9kZWwuZnJvbSk7XG4gICAgICAgICAgICBtYXAuc2V0KCdUTycsIG1vZGVsLnRvKTtcblxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmZvcm1hdFN0cmluZyh0aGlzLmZvcm1hdCwgbWFwKTtcblxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnF1ZXJ5RnJhZ21lbnRzW3RoaXMuaWRdID0gYCR7dGhpcy5maWVsZH06JHt2YWx1ZX1gO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmb3JtYXRTdHJpbmcoc3RyOiBzdHJpbmcsIG1hcDogTWFwPHN0cmluZywgc3RyaW5nPik6IHN0cmluZyB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzdHI7XG5cbiAgICAgICAgbWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSBuZXcgUmVnRXhwKCd7JyArIGtleSArICd9JywgJ2dtJyk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShleHByLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZm9ybS5yZXNldCh7XG4gICAgICAgICAgICBmcm9tOiAnJyxcbiAgICAgICAgICAgIHRvOiAnJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5pZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5xdWVyeUZyYWdtZW50c1t0aGlzLmlkXSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19