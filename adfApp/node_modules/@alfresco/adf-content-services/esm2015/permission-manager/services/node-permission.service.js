/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { of, from, throwError } from 'rxjs';
import { AlfrescoApiService, SearchService, NodesApiService, TranslationService } from '@alfresco/adf-core';
import { switchMap, map } from 'rxjs/operators';
export class NodePermissionService {
    /**
     * @param {?} apiService
     * @param {?} searchApiService
     * @param {?} nodeService
     * @param {?} translation
     */
    constructor(apiService, searchApiService, nodeService, translation) {
        this.apiService = apiService;
        this.searchApiService = searchApiService;
        this.nodeService = nodeService;
        this.translation = translation;
    }
    /**
     * Gets a list of roles for the current node.
     * @param {?} node The target node
     * @return {?} Array of strings representing the roles
     */
    getNodeRoles(node) {
        /** @type {?} */
        const retrieveSiteQueryBody = this.buildRetrieveSiteQueryBody(node.path.elements);
        return this.searchApiService.searchByQueryBody(retrieveSiteQueryBody)
            .pipe(switchMap((siteNodeList) => {
            if (siteNodeList.list.entries.length > 0) {
                /** @type {?} */
                let siteName = siteNodeList.list.entries[0].entry.name;
                return this.getGroupMembersBySiteName(siteName);
            }
            else {
                return of(node.permissions.settable);
            }
        }));
    }
    /**
     * Updates the permission role for a node.
     * @param {?} node Target node
     * @param {?} updatedPermissionRole Permission role to update or add
     * @return {?} Node with updated permission
     */
    updatePermissionRole(node, updatedPermissionRole) {
        /** @type {?} */
        let permissionBody = { permissions: { locallySet: [] } };
        /** @type {?} */
        const index = node.permissions.locallySet.map((permission) => permission.authorityId).indexOf(updatedPermissionRole.authorityId);
        permissionBody.permissions.locallySet = permissionBody.permissions.locallySet.concat(node.permissions.locallySet);
        if (index !== -1) {
            permissionBody.permissions.locallySet[index] = updatedPermissionRole;
        }
        else {
            permissionBody.permissions.locallySet.push(updatedPermissionRole);
        }
        return this.nodeService.updateNode(node.id, permissionBody);
    }
    /**
     * Update permissions for a node.
     * @param {?} nodeId ID of the target node
     * @param {?} permissionList New permission settings
     * @return {?} Node with updated permissions
     */
    updateNodePermissions(nodeId, permissionList) {
        return this.nodeService.getNode(nodeId).pipe(switchMap(node => {
            return this.getNodeRoles(node).pipe(switchMap((nodeRoles) => of({ node, nodeRoles })));
        }), switchMap(({ node, nodeRoles }) => this.updateLocallySetPermissions(node, permissionList, nodeRoles)));
    }
    /**
     * Updates the locally set permissions for a node.
     * @param {?} node ID of the target node
     * @param {?} nodes Permission settings
     * @param {?} nodeRole Permission role
     * @return {?} Node with updated permissions
     */
    updateLocallySetPermissions(node, nodes, nodeRole) {
        /** @type {?} */
        let permissionBody = { permissions: { locallySet: [] } };
        /** @type {?} */
        const permissionList = this.transformNodeToPermissionElement(nodes, nodeRole[0]);
        /** @type {?} */
        const duplicatedPermissions = this.getDuplicatedPermissions(node.permissions.locallySet, permissionList);
        if (duplicatedPermissions.length > 0) {
            /** @type {?} */
            const list = duplicatedPermissions.map((permission) => 'authority -> ' + permission.authorityId + ' / role -> ' + permission.name).join(', ');
            /** @type {?} */
            const duplicatePermissionMessage = this.translation.instant('PERMISSION_MANAGER.ERROR.DUPLICATE-PERMISSION', { list });
            return throwError(duplicatePermissionMessage);
        }
        permissionBody.permissions.locallySet = node.permissions.locallySet ? node.permissions.locallySet.concat(permissionList) : permissionList;
        return this.nodeService.updateNode(node.id, permissionBody);
    }
    /**
     * @param {?} nodeLocallySet
     * @param {?} permissionListAdded
     * @return {?}
     */
    getDuplicatedPermissions(nodeLocallySet, permissionListAdded) {
        /** @type {?} */
        let duplicatePermissions = [];
        if (nodeLocallySet) {
            permissionListAdded.forEach((permission) => {
                /** @type {?} */
                const duplicate = nodeLocallySet.find((localPermission) => this.isEqualPermission(localPermission, permission));
                if (duplicate) {
                    duplicatePermissions.push(duplicate);
                }
            });
        }
        return duplicatePermissions;
    }
    /**
     * @param {?} oldPermission
     * @param {?} newPermission
     * @return {?}
     */
    isEqualPermission(oldPermission, newPermission) {
        return oldPermission.accessStatus === newPermission.accessStatus &&
            oldPermission.authorityId === newPermission.authorityId &&
            oldPermission.name === newPermission.name;
    }
    /**
     * @param {?} nodes
     * @param {?} nodeRole
     * @return {?}
     */
    transformNodeToPermissionElement(nodes, nodeRole) {
        return nodes.map((node) => {
            /** @type {?} */
            let newPermissionElement = /** @type {?} */ ({
                'authorityId': node.entry.properties['cm:authorityName'] ?
                    node.entry.properties['cm:authorityName'] :
                    node.entry.properties['cm:userName'],
                'name': nodeRole,
                'accessStatus': 'ALLOWED'
            });
            return newPermissionElement;
        });
    }
    /**
     * Removes a permission setting from a node.
     * @param {?} node ID of the target node
     * @param {?} permissionToRemove Permission setting to remove
     * @return {?} Node with modified permissions
     */
    removePermission(node, permissionToRemove) {
        /** @type {?} */
        let permissionBody = { permissions: { locallySet: [] } };
        /** @type {?} */
        const index = node.permissions.locallySet.map((permission) => permission.authorityId).indexOf(permissionToRemove.authorityId);
        if (index !== -1) {
            node.permissions.locallySet.splice(index, 1);
            permissionBody.permissions.locallySet = node.permissions.locallySet;
            return this.nodeService.updateNode(node.id, permissionBody);
        }
    }
    /**
     * @param {?} siteName
     * @return {?}
     */
    getGroupMembersBySiteName(siteName) {
        /** @type {?} */
        const groupName = 'GROUP_site_' + siteName;
        return this.getGroupMemeberByGroupName(groupName)
            .pipe(map((res) => {
            /** @type {?} */
            let displayResult = [];
            res.list.entries.forEach((member) => {
                displayResult.push(this.formattedRoleName(member.entry.displayName, 'site_' + siteName));
            });
            return displayResult;
        }));
    }
    /**
     * Gets all members related to a group name.
     * @param {?} groupName Name of group to look for members
     * @param {?=} opts Extra options supported by JSAPI
     * @return {?} List of members
     */
    getGroupMemeberByGroupName(groupName, opts) {
        return from(this.apiService.groupsApi.getGroupMembers(groupName, opts));
    }
    /**
     * @param {?} displayName
     * @param {?} siteName
     * @return {?}
     */
    formattedRoleName(displayName, siteName) {
        return displayName.replace(siteName + '_', '');
    }
    /**
     * @param {?} nodePath
     * @return {?}
     */
    buildRetrieveSiteQueryBody(nodePath) {
        /** @type {?} */
        const pathNames = nodePath.map((node) => 'name: "' + node.name + '"');
        /** @type {?} */
        const buildedPathNames = pathNames.join(' OR ');
        return {
            'query': {
                'query': buildedPathNames
            },
            'paging': {
                'maxItems': 100,
                'skipCount': 0
            },
            'include': ['aspectNames', 'properties'],
            'filterQueries': [
                {
                    'query': "TYPE:'st:site'"
                }
            ]
        };
    }
}
NodePermissionService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NodePermissionService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: SearchService },
    { type: NodesApiService },
    { type: TranslationService }
];
if (false) {
    /** @type {?} */
    NodePermissionService.prototype.apiService;
    /** @type {?} */
    NodePermissionService.prototype.searchApiService;
    /** @type {?} */
    NodePermissionService.prototype.nodeService;
    /** @type {?} */
    NodePermissionService.prototype.translation;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS1wZXJtaXNzaW9uLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvIiwic291cmNlcyI6WyJwZXJtaXNzaW9uLW1hbmFnZXIvc2VydmljZXMvbm9kZS1wZXJtaXNzaW9uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQWMsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDeEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUU1RyxPQUFPLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBR2hELE1BQU07Ozs7Ozs7SUFFRixZQUFvQixVQUE4QixFQUM5QixrQkFDQSxhQUNBO1FBSEEsZUFBVSxHQUFWLFVBQVUsQ0FBb0I7UUFDOUIscUJBQWdCLEdBQWhCLGdCQUFnQjtRQUNoQixnQkFBVyxHQUFYLFdBQVc7UUFDWCxnQkFBVyxHQUFYLFdBQVc7S0FDOUI7Ozs7OztJQU9ELFlBQVksQ0FBQyxJQUE0Qjs7UUFDckMsTUFBTSxxQkFBcUIsR0FBYyxJQUFJLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM3RixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxxQkFBcUIsQ0FBQzthQUNoRSxJQUFJLENBQ0QsU0FBUyxDQUFDLENBQUMsWUFBaUIsRUFBRSxFQUFFO1lBQzVCLElBQUssWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRzs7Z0JBQ3hDLElBQUksUUFBUSxHQUFHLFlBQVksQ0FB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YUFDNUI7WUFDRCxRQUFRLEVBQUU7Z0JBQ04sVUFBVSxFQUFFLEdBQUc7Z0JBQ2YsV0FBVyxFQUFFLENBQUM7YUFDakI7WUFDRCxTQUFTLEVBQUUsQ0FBQyxhQUFhLEVBQUUsWUFBWSxDQUFDO1lBQ3hDLGVBQWUsRUFBRTtnQkFDYjtvQkFDSSxPQUFPLEVBQ0gsZ0JBQWdCO2lCQUN2QjthQUNKO1NBQ0osQ0FBQzs7OztZQWxMVCxVQUFVOzs7O1lBSkYsa0JBQWtCO1lBQUUsYUFBYTtZQUFFLGVBQWU7WUFBRSxrQkFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgZnJvbSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlLCBTZWFyY2hTZXJ2aWNlLCBOb2Rlc0FwaVNlcnZpY2UsIFRyYW5zbGF0aW9uU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBRdWVyeUJvZHksIE1pbmltYWxOb2RlRW50cnlFbnRpdHksIE1pbmltYWxOb2RlRW50aXR5LCBQYXRoRWxlbWVudCwgR3JvdXBNZW1iZXJFbnRyeSwgR3JvdXBzUGFnaW5nLCBHcm91cE1lbWJlclBhZ2luZywgUGVybWlzc2lvbkVsZW1lbnQgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgc3dpdGNoTWFwLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOb2RlUGVybWlzc2lvblNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBzZWFyY2hBcGlTZXJ2aWNlOiBTZWFyY2hTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgbm9kZVNlcnZpY2U6IE5vZGVzQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHRyYW5zbGF0aW9uOiBUcmFuc2xhdGlvblNlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiByb2xlcyBmb3IgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgcm9sZXNcbiAgICAgKi9cbiAgICBnZXROb2RlUm9sZXMobm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSk6IE9ic2VydmFibGU8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3QgcmV0cmlldmVTaXRlUXVlcnlCb2R5OiBRdWVyeUJvZHkgPSB0aGlzLmJ1aWxkUmV0cmlldmVTaXRlUXVlcnlCb2R5KG5vZGUucGF0aC5lbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaEFwaVNlcnZpY2Uuc2VhcmNoQnlRdWVyeUJvZHkocmV0cmlldmVTaXRlUXVlcnlCb2R5KVxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgc3dpdGNoTWFwKChzaXRlTm9kZUxpc3Q6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHNpdGVOb2RlTGlzdC5saXN0LmVudHJpZXMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXRlTmFtZSA9IHNpdGVOb2RlTGlzdC5saXN0LmVudHJpZXNbMF0uZW50cnkubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEdyb3VwTWVtYmVyc0J5U2l0ZU5hbWUoc2l0ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKG5vZGUucGVybWlzc2lvbnMuc2V0dGFibGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcGVybWlzc2lvbiByb2xlIGZvciBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGUgVGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0gdXBkYXRlZFBlcm1pc3Npb25Sb2xlIFBlcm1pc3Npb24gcm9sZSB0byB1cGRhdGUgb3IgYWRkXG4gICAgICogQHJldHVybnMgTm9kZSB3aXRoIHVwZGF0ZWQgcGVybWlzc2lvblxuICAgICAqL1xuICAgIHVwZGF0ZVBlcm1pc3Npb25Sb2xlKG5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHksIHVwZGF0ZWRQZXJtaXNzaW9uUm9sZTogUGVybWlzc2lvbkVsZW1lbnQpOiBPYnNlcnZhYmxlPE1pbmltYWxOb2RlRW50cnlFbnRpdHk+IHtcbiAgICAgICAgbGV0IHBlcm1pc3Npb25Cb2R5ID0geyBwZXJtaXNzaW9uczogeyBsb2NhbGx5U2V0OiBbXX0gfTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBub2RlLnBlcm1pc3Npb25zLmxvY2FsbHlTZXQubWFwKChwZXJtaXNzaW9uKSA9PiBwZXJtaXNzaW9uLmF1dGhvcml0eUlkKS5pbmRleE9mKHVwZGF0ZWRQZXJtaXNzaW9uUm9sZS5hdXRob3JpdHlJZCk7XG4gICAgICAgIHBlcm1pc3Npb25Cb2R5LnBlcm1pc3Npb25zLmxvY2FsbHlTZXQgPSBwZXJtaXNzaW9uQm9keS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0LmNvbmNhdChub2RlLnBlcm1pc3Npb25zLmxvY2FsbHlTZXQpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBwZXJtaXNzaW9uQm9keS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0W2luZGV4XSA9IHVwZGF0ZWRQZXJtaXNzaW9uUm9sZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcm1pc3Npb25Cb2R5LnBlcm1pc3Npb25zLmxvY2FsbHlTZXQucHVzaCh1cGRhdGVkUGVybWlzc2lvblJvbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVTZXJ2aWNlLnVwZGF0ZU5vZGUobm9kZS5pZCwgcGVybWlzc2lvbkJvZHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwZXJtaXNzaW9ucyBmb3IgYSBub2RlLlxuICAgICAqIEBwYXJhbSBub2RlSWQgSUQgb2YgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb25MaXN0IE5ldyBwZXJtaXNzaW9uIHNldHRpbmdzXG4gICAgICogQHJldHVybnMgTm9kZSB3aXRoIHVwZGF0ZWQgcGVybWlzc2lvbnNcbiAgICAgKi9cbiAgICB1cGRhdGVOb2RlUGVybWlzc2lvbnMobm9kZUlkOiBzdHJpbmcsIHBlcm1pc3Npb25MaXN0OiBNaW5pbWFsTm9kZUVudGl0eVtdKTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiB7XG4gICAgICAgcmV0dXJuIHRoaXMubm9kZVNlcnZpY2UuZ2V0Tm9kZShub2RlSWQpLnBpcGUoXG4gICAgICAgICAgIHN3aXRjaE1hcChub2RlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROb2RlUm9sZXMobm9kZSkucGlwZShcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoTWFwKChub2RlUm9sZXMpID0+IG9mKHtub2RlLCBub2RlUm9sZXN9KSApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc3dpdGNoTWFwKCh7bm9kZSwgbm9kZVJvbGVzfSkgPT4gdGhpcy51cGRhdGVMb2NhbGx5U2V0UGVybWlzc2lvbnMobm9kZSwgcGVybWlzc2lvbkxpc3QsIG5vZGVSb2xlcykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbG9jYWxseSBzZXQgcGVybWlzc2lvbnMgZm9yIGEgbm9kZS5cbiAgICAgKiBAcGFyYW0gbm9kZSBJRCBvZiB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZXMgUGVybWlzc2lvbiBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSBub2RlUm9sZSBQZXJtaXNzaW9uIHJvbGVcbiAgICAgKiBAcmV0dXJucyBOb2RlIHdpdGggdXBkYXRlZCBwZXJtaXNzaW9uc1xuICAgICAqL1xuICAgIHVwZGF0ZUxvY2FsbHlTZXRQZXJtaXNzaW9ucyhub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5LCBub2RlczogTWluaW1hbE5vZGVFbnRpdHlbXSwgbm9kZVJvbGU6IHN0cmluZ1tdKTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiB7XG4gICAgICAgIGxldCBwZXJtaXNzaW9uQm9keSA9IHsgcGVybWlzc2lvbnM6IHsgbG9jYWxseVNldDogW119IH07XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25MaXN0ID0gdGhpcy50cmFuc2Zvcm1Ob2RlVG9QZXJtaXNzaW9uRWxlbWVudChub2Rlcywgbm9kZVJvbGVbMF0pO1xuICAgICAgICBjb25zdCBkdXBsaWNhdGVkUGVybWlzc2lvbnMgPSB0aGlzLmdldER1cGxpY2F0ZWRQZXJtaXNzaW9ucyhub2RlLnBlcm1pc3Npb25zLmxvY2FsbHlTZXQsIHBlcm1pc3Npb25MaXN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZWRQZXJtaXNzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gZHVwbGljYXRlZFBlcm1pc3Npb25zLm1hcCgocGVybWlzc2lvbikgPT4gJ2F1dGhvcml0eSAtPiAnICsgcGVybWlzc2lvbi5hdXRob3JpdHlJZCArICcgLyByb2xlIC0+ICcgKyBwZXJtaXNzaW9uLm5hbWUpLmpvaW4oJywgJyk7XG4gICAgICAgICAgICBjb25zdCBkdXBsaWNhdGVQZXJtaXNzaW9uTWVzc2FnZTogc3RyaW5nID0gdGhpcy50cmFuc2xhdGlvbi5pbnN0YW50KCdQRVJNSVNTSU9OX01BTkFHRVIuRVJST1IuRFVQTElDQVRFLVBFUk1JU1NJT04nLCAge2xpc3R9KTtcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGR1cGxpY2F0ZVBlcm1pc3Npb25NZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBwZXJtaXNzaW9uQm9keS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0ID0gbm9kZS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0ID8gbm9kZS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0LmNvbmNhdChwZXJtaXNzaW9uTGlzdCkgOiBwZXJtaXNzaW9uTGlzdDtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZVNlcnZpY2UudXBkYXRlTm9kZShub2RlLmlkLCBwZXJtaXNzaW9uQm9keSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXREdXBsaWNhdGVkUGVybWlzc2lvbnMobm9kZUxvY2FsbHlTZXQ6IFBlcm1pc3Npb25FbGVtZW50W10sIHBlcm1pc3Npb25MaXN0QWRkZWQ6IFBlcm1pc3Npb25FbGVtZW50W10pOiBQZXJtaXNzaW9uRWxlbWVudFtdIHtcbiAgICAgICAgbGV0IGR1cGxpY2F0ZVBlcm1pc3Npb25zOiBQZXJtaXNzaW9uRWxlbWVudFtdID0gW107XG4gICAgICAgIGlmIChub2RlTG9jYWxseVNldCkge1xuICAgICAgICAgICAgcGVybWlzc2lvbkxpc3RBZGRlZC5mb3JFYWNoKChwZXJtaXNzaW9uOiBQZXJtaXNzaW9uRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IG5vZGVMb2NhbGx5U2V0LmZpbmQoKGxvY2FsUGVybWlzc2lvbikgPT4gdGhpcy5pc0VxdWFsUGVybWlzc2lvbihsb2NhbFBlcm1pc3Npb24sIHBlcm1pc3Npb24pKTtcbiAgICAgICAgICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZVBlcm1pc3Npb25zLnB1c2goZHVwbGljYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHVwbGljYXRlUGVybWlzc2lvbnM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0VxdWFsUGVybWlzc2lvbihvbGRQZXJtaXNzaW9uOiBQZXJtaXNzaW9uRWxlbWVudCwgbmV3UGVybWlzc2lvbjogUGVybWlzc2lvbkVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIG9sZFBlcm1pc3Npb24uYWNjZXNzU3RhdHVzID09PSBuZXdQZXJtaXNzaW9uLmFjY2Vzc1N0YXR1cyAmJlxuICAgICAgICAgICAgICAgb2xkUGVybWlzc2lvbi5hdXRob3JpdHlJZCA9PT0gbmV3UGVybWlzc2lvbi5hdXRob3JpdHlJZCAmJlxuICAgICAgICAgICAgICAgb2xkUGVybWlzc2lvbi5uYW1lID09PSBuZXdQZXJtaXNzaW9uLm5hbWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0cmFuc2Zvcm1Ob2RlVG9QZXJtaXNzaW9uRWxlbWVudChub2RlczogTWluaW1hbE5vZGVFbnRpdHlbXSwgbm9kZVJvbGU6IGFueSk6IFBlcm1pc3Npb25FbGVtZW50W10ge1xuICAgICAgICByZXR1cm4gbm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3UGVybWlzc2lvbkVsZW1lbnQ6IFBlcm1pc3Npb25FbGVtZW50ID0gPFBlcm1pc3Npb25FbGVtZW50PiB7XG4gICAgICAgICAgICAgICAgJ2F1dGhvcml0eUlkJzogbm9kZS5lbnRyeS5wcm9wZXJ0aWVzWydjbTphdXRob3JpdHlOYW1lJ10gP1xuICAgICAgICAgICAgICAgICAgICBub2RlLmVudHJ5LnByb3BlcnRpZXNbJ2NtOmF1dGhvcml0eU5hbWUnXSA6XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZW50cnkucHJvcGVydGllc1snY206dXNlck5hbWUnXSxcbiAgICAgICAgICAgICAgICAnbmFtZSc6IG5vZGVSb2xlLFxuICAgICAgICAgICAgICAgICdhY2Nlc3NTdGF0dXMnOiAnQUxMT1dFRCdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3UGVybWlzc2lvbkVsZW1lbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBwZXJtaXNzaW9uIHNldHRpbmcgZnJvbSBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGUgSUQgb2YgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb25Ub1JlbW92ZSBQZXJtaXNzaW9uIHNldHRpbmcgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybnMgTm9kZSB3aXRoIG1vZGlmaWVkIHBlcm1pc3Npb25zXG4gICAgICovXG4gICAgcmVtb3ZlUGVybWlzc2lvbihub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5LCBwZXJtaXNzaW9uVG9SZW1vdmU6IFBlcm1pc3Npb25FbGVtZW50KTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiB7XG4gICAgICAgIGxldCBwZXJtaXNzaW9uQm9keSA9IHsgcGVybWlzc2lvbnM6IHsgbG9jYWxseVNldDogW10gfSB9O1xuICAgICAgICBjb25zdCBpbmRleCA9IG5vZGUucGVybWlzc2lvbnMubG9jYWxseVNldC5tYXAoKHBlcm1pc3Npb24pID0+IHBlcm1pc3Npb24uYXV0aG9yaXR5SWQpLmluZGV4T2YocGVybWlzc2lvblRvUmVtb3ZlLmF1dGhvcml0eUlkKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgbm9kZS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBwZXJtaXNzaW9uQm9keS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0ID0gbm9kZS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZVNlcnZpY2UudXBkYXRlTm9kZShub2RlLmlkLCBwZXJtaXNzaW9uQm9keSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEdyb3VwTWVtYmVyc0J5U2l0ZU5hbWUoc2l0ZU5hbWU6IHN0cmluZyk6IE9ic2VydmFibGU8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3QgZ3JvdXBOYW1lID0gJ0dST1VQX3NpdGVfJyArIHNpdGVOYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcm91cE1lbWViZXJCeUdyb3VwTmFtZShncm91cE5hbWUpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKHJlczogR3JvdXBzUGFnaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXNwbGF5UmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXMubGlzdC5lbnRyaWVzLmZvckVhY2goKG1lbWJlcjogR3JvdXBNZW1iZXJFbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheVJlc3VsdC5wdXNoKHRoaXMuZm9ybWF0dGVkUm9sZU5hbWUobWVtYmVyLmVudHJ5LmRpc3BsYXlOYW1lLCAnc2l0ZV8nICsgc2l0ZU5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXNwbGF5UmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIG1lbWJlcnMgcmVsYXRlZCB0byBhIGdyb3VwIG5hbWUuXG4gICAgICogQHBhcmFtIGdyb3VwTmFtZSBOYW1lIG9mIGdyb3VwIHRvIGxvb2sgZm9yIG1lbWJlcnNcbiAgICAgKiBAcGFyYW0gb3B0cyBFeHRyYSBvcHRpb25zIHN1cHBvcnRlZCBieSBKU0FQSVxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgbWVtYmVyc1xuICAgICAqL1xuICAgIGdldEdyb3VwTWVtZWJlckJ5R3JvdXBOYW1lKGdyb3VwTmFtZTogc3RyaW5nLCBvcHRzPzogYW55KTogT2JzZXJ2YWJsZTxHcm91cE1lbWJlclBhZ2luZz4ge1xuICAgICAgICByZXR1cm4gZnJvbTxHcm91cE1lbWJlclBhZ2luZz4odGhpcy5hcGlTZXJ2aWNlLmdyb3Vwc0FwaS5nZXRHcm91cE1lbWJlcnMoZ3JvdXBOYW1lLCBvcHRzKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmb3JtYXR0ZWRSb2xlTmFtZShkaXNwbGF5TmFtZSwgc2l0ZU5hbWUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gZGlzcGxheU5hbWUucmVwbGFjZShzaXRlTmFtZSArICdfJywgJycpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYnVpbGRSZXRyaWV2ZVNpdGVRdWVyeUJvZHkobm9kZVBhdGg6IFBhdGhFbGVtZW50W10pOiBRdWVyeUJvZHkge1xuICAgICAgICBjb25zdCBwYXRoTmFtZXMgPSBub2RlUGF0aC5tYXAoKG5vZGU6IFBhdGhFbGVtZW50KSA9PiAnbmFtZTogXCInICsgbm9kZS5uYW1lICsgJ1wiJyk7XG4gICAgICAgIGNvbnN0IGJ1aWxkZWRQYXRoTmFtZXMgPSBwYXRoTmFtZXMuam9pbignIE9SICcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3F1ZXJ5Jzoge1xuICAgICAgICAgICAgICAgICdxdWVyeSc6IGJ1aWxkZWRQYXRoTmFtZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncGFnaW5nJzoge1xuICAgICAgICAgICAgICAgICdtYXhJdGVtcyc6IDEwMCxcbiAgICAgICAgICAgICAgICAnc2tpcENvdW50JzogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdpbmNsdWRlJzogWydhc3BlY3ROYW1lcycsICdwcm9wZXJ0aWVzJ10sXG4gICAgICAgICAgICAnZmlsdGVyUXVlcmllcyc6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICdxdWVyeSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlRZUEU6J3N0OnNpdGUnXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXG59XG4iXX0=