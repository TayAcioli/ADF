/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation, EventEmitter, Input, Output } from '@angular/core';
import { NodePermissionService } from '../../services/node-permission.service';
import { NodesApiService, ContentService, PermissionsEnum } from '@alfresco/adf-core';
export class AddPermissionComponent {
    /**
     * @param {?} nodePermissionService
     * @param {?} nodeApiService
     * @param {?} contentService
     */
    constructor(nodePermissionService, nodeApiService, contentService) {
        this.nodePermissionService = nodePermissionService;
        this.nodeApiService = nodeApiService;
        this.contentService = contentService;
        /**
         * Emitted when the node is updated successfully.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs during the update.
         */
        this.error = new EventEmitter();
        this.selectedItems = [];
        this.nodeApiService.getNode(this.nodeId).subscribe((node) => this.currentNode = node);
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    onSelect(selection) {
        this.selectedItems = selection;
    }
    /**
     * @return {?}
     */
    isAddEnabled() {
        return this.contentService.hasPermission(this.currentNode, PermissionsEnum.UPDATEPERMISSIONS) &&
            this.selectedItems.length !== 0;
    }
    /**
     * @return {?}
     */
    applySelection() {
        if (this.contentService.hasPermission(this.currentNode, PermissionsEnum.UPDATEPERMISSIONS)) {
            this.nodePermissionService.updateNodePermissions(this.nodeId, this.selectedItems)
                .subscribe((node) => {
                this.success.emit(node);
            }, (error) => {
                this.error.emit(error);
            });
        }
    }
}
AddPermissionComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-add-permission',
                template: "<adf-add-permission-panel\n    (select)=\"onSelect($event)\">\n</adf-add-permission-panel>\n<div id=\"adf-add-permission-actions\">\n   <button mat-button\n          id=\"adf-add-permission-action-button\"\n          class=\"adf-permission-action\"\n          [disabled]=\"!isAddEnabled()\"\n          (click)=\"applySelection()\">\n     {{'PERMISSION_MANAGER.ADD-PERMISSION.ADD-ACTION' | translate}}\n    </button>\n</div>\n\n\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
AddPermissionComponent.ctorParameters = () => [
    { type: NodePermissionService },
    { type: NodesApiService },
    { type: ContentService }
];
AddPermissionComponent.propDecorators = {
    nodeId: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};
if (false) {
    /**
     * ID of the target node.
     * @type {?}
     */
    AddPermissionComponent.prototype.nodeId;
    /**
     * Emitted when the node is updated successfully.
     * @type {?}
     */
    AddPermissionComponent.prototype.success;
    /**
     * Emitted when an error occurs during the update.
     * @type {?}
     */
    AddPermissionComponent.prototype.error;
    /** @type {?} */
    AddPermissionComponent.prototype.selectedItems;
    /** @type {?} */
    AddPermissionComponent.prototype.currentNode;
    /** @type {?} */
    AddPermissionComponent.prototype.currentNodeRoles;
    /** @type {?} */
    AddPermissionComponent.prototype.nodePermissionService;
    /** @type {?} */
    AddPermissionComponent.prototype.nodeApiService;
    /** @type {?} */
    AddPermissionComponent.prototype.contentService;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRkLXBlcm1pc3Npb24uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzLyIsInNvdXJjZXMiOlsicGVybWlzc2lvbi1tYW5hZ2VyL2NvbXBvbmVudHMvYWRkLXBlcm1pc3Npb24vYWRkLXBlcm1pc3Npb24uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFMUYsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFDL0UsT0FBTyxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFRdEYsTUFBTTs7Ozs7O0lBa0JGLFlBQW9CLHFCQUE0QyxFQUM1QyxnQkFDQTtRQUZBLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBdUI7UUFDNUMsbUJBQWMsR0FBZCxjQUFjO1FBQ2QsbUJBQWMsR0FBZCxjQUFjOzs7O3VCQVpjLElBQUksWUFBWSxFQUFFOzs7O3FCQUl2QyxJQUFJLFlBQVksRUFBRTs2QkFFUixFQUFFO1FBT25DLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLENBQUM7S0FDekY7Ozs7O0lBRUQsUUFBUSxDQUFDLFNBQThCO1FBQ25DLElBQUksQ0FBQyxhQUFhLEdBQUcsU0FBUyxDQUFDO0tBQ2xDOzs7O0lBRUQsWUFBWTtRQUNSLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxlQUFlLENBQUMsaUJBQWlCLENBQUM7WUFDckYsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0tBQzNDOzs7O0lBRUQsY0FBYztRQUNWLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxlQUFlLENBQUMsaUJBQWlCLENBQUMsRUFBRTtZQUN4RixJQUFJLENBQUMscUJBQXFCLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDO2lCQUM1RSxTQUFTLENBQ04sQ0FBQyxJQUFJLEVBQUUsRUFBRTtnQkFDTCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUMzQixFQUNELENBQUMsS0FBSyxFQUFFLEVBQUU7Z0JBQ04sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDMUIsQ0FBQyxDQUFDO1NBQ2Q7S0FDSjs7O1lBbERKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsb0JBQW9CO2dCQUM5Qix5YkFBOEM7Z0JBRTlDLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJOzthQUN4Qzs7OztZQVJRLHFCQUFxQjtZQUNyQixlQUFlO1lBQUUsY0FBYzs7O3FCQVduQyxLQUFLO3NCQUlMLE1BQU07b0JBSU4sTUFBTSIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb24sIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRpdHksIE1pbmltYWxOb2RlRW50cnlFbnRpdHkgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgTm9kZVBlcm1pc3Npb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbm9kZS1wZXJtaXNzaW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgTm9kZXNBcGlTZXJ2aWNlLCBDb250ZW50U2VydmljZSwgUGVybWlzc2lvbnNFbnVtIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtYWRkLXBlcm1pc3Npb24nLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9hZGQtcGVybWlzc2lvbi5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vYWRkLXBlcm1pc3Npb24uY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIEFkZFBlcm1pc3Npb25Db21wb25lbnQge1xuXG4gICAgLyoqIElEIG9mIHRoZSB0YXJnZXQgbm9kZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIG5vZGVJZDogc3RyaW5nO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgbm9kZSBpcyB1cGRhdGVkIHN1Y2Nlc3NmdWxseS4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBzdWNjZXNzOiBFdmVudEVtaXR0ZXI8TWluaW1hbE5vZGVFbnRyeUVudGl0eT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgdGhlIHVwZGF0ZS4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBlcnJvcjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBzZWxlY3RlZEl0ZW1zOiBNaW5pbWFsTm9kZUVudGl0eVtdID0gW107XG4gICAgY3VycmVudE5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHk7XG4gICAgY3VycmVudE5vZGVSb2xlczogc3RyaW5nW107XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5vZGVQZXJtaXNzaW9uU2VydmljZTogTm9kZVBlcm1pc3Npb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgbm9kZUFwaVNlcnZpY2U6IE5vZGVzQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNvbnRlbnRTZXJ2aWNlOiBDb250ZW50U2VydmljZSkge1xuICAgICAgICB0aGlzLm5vZGVBcGlTZXJ2aWNlLmdldE5vZGUodGhpcy5ub2RlSWQpLnN1YnNjcmliZSgobm9kZSkgPT4gdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGUpO1xuICAgIH1cblxuICAgIG9uU2VsZWN0KHNlbGVjdGlvbjogTWluaW1hbE5vZGVFbnRpdHlbXSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXMgPSBzZWxlY3Rpb247XG4gICAgfVxuXG4gICAgaXNBZGRFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50U2VydmljZS5oYXNQZXJtaXNzaW9uKHRoaXMuY3VycmVudE5vZGUsIFBlcm1pc3Npb25zRW51bS5VUERBVEVQRVJNSVNTSU9OUykgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoICE9PSAwO1xuICAgIH1cblxuICAgIGFwcGx5U2VsZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50U2VydmljZS5oYXNQZXJtaXNzaW9uKHRoaXMuY3VycmVudE5vZGUsIFBlcm1pc3Npb25zRW51bS5VUERBVEVQRVJNSVNTSU9OUykpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZVBlcm1pc3Npb25TZXJ2aWNlLnVwZGF0ZU5vZGVQZXJtaXNzaW9ucyh0aGlzLm5vZGVJZCwgdGhpcy5zZWxlY3RlZEl0ZW1zKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgICAgICAgIChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3MuZW1pdChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yLmVtaXQoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIl19