/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewChild, ViewEncapsulation } from '@angular/core';
import { MatSelect } from '@angular/material';
import { BreadcrumbComponent } from './breadcrumb.component';
export class DropdownBreadcrumbComponent extends BreadcrumbComponent {
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["folderNode"]) {
            /** @type {?} */
            let node = null;
            node = this.transform ? this.transform(changes["folderNode"].currentValue) : changes["folderNode"].currentValue;
            this.route = this.parseRoute(node);
        }
        if (changes["transform"]) {
            /** @type {?} */
            let node = this.transform ? this.transform(this.folderNode) : this.folderNode;
            this.route = this.parseRoute(node);
        }
        this.recalculateNodes();
    }
    /**
     * Calculate the current and previous nodes from the route array
     * @return {?}
     */
    recalculateNodes() {
        this.currentNode = this.route[this.route.length - 1];
        this.previousNodes = this.route.slice(0, this.route.length - 1).reverse();
    }
    /**
     * Opens the node picker menu
     * @return {?}
     */
    open() {
        if (this.dropdown) {
            this.dropdown.open();
        }
    }
    /**
     * Return if route has more than one element (means: we are not in the root directory)
     * @return {?}
     */
    hasPreviousNodes() {
        return this.previousNodes.length > 0;
    }
}
DropdownBreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dropdown-breadcrumb',
                template: "<ng-container *ngIf=\"route.length > 0\">\n\n    <button\n        tabindex=\"0\"\n        class=\"adf-dropdown-breadcrumb-trigger\"\n        (click)=\"open()\"\n        data-automation-id=\"dropdown-breadcrumb-trigger\">\n        <mat-icon [class.isRoot]=\"!hasPreviousNodes()\">folder</mat-icon>\n    </button>\n    <mat-icon class=\"adf-dropdown-breadcrumb-item-chevron\">chevron_right</mat-icon>\n\n    <mat-select\n        #dropdown\n        *ngIf=\"hasPreviousNodes()\"\n        class=\"adf-dropdown-breadcrumb-path\"\n        tabindex=\"0\"\n        data-automation-id=\"dropdown-breadcrumb-path\" >\n\n        <mat-option\n            *ngFor=\"let node of previousNodes;\"\n            (click)=\"onRoutePathClick(node, $event)\"\n            class=\"adf-dropdown-breadcrumb-path-option\"\n            tabindex=\"0\"\n            data-automation-class=\"dropdown-breadcrumb-path-option\">\n            {{ node.name | translate }}\n        </mat-option>\n    </mat-select>\n\n    <span\n        class=\"adf-current-folder\"\n        [class.isRoot]=\"!hasPreviousNodes()\"\n        data-automation-id=\"current-folder\">{{ currentNode.name }}</span>\n</ng-container>\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-dropdown-breadcrumb'
                },
                styles: [""]
            }] }
];
DropdownBreadcrumbComponent.propDecorators = {
    dropdown: [{ type: ViewChild, args: ['dropdown',] }]
};
if (false) {
    /** @type {?} */
    DropdownBreadcrumbComponent.prototype.dropdown;
    /** @type {?} */
    DropdownBreadcrumbComponent.prototype.currentNode;
    /** @type {?} */
    DropdownBreadcrumbComponent.prototype.previousNodes;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24tYnJlYWRjcnVtYi5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvIiwic291cmNlcyI6WyJicmVhZGNydW1iL2Ryb3Bkb3duLWJyZWFkY3J1bWIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQTRCLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNsRyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFOUMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFXN0QsTUFBTSxrQ0FBbUMsU0FBUSxtQkFBbUI7Ozs7O0lBUWhFLFdBQVcsQ0FBQyxPQUFzQjtRQUM5QixJQUFJLE9BQU8sZ0JBQWE7O1lBQ3BCLElBQUksSUFBSSxHQUEyQixJQUFJLENBQUM7WUFDeEMsSUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxlQUFZLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLGVBQVksWUFBWSxDQUFDO1lBQzFHLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN0QztRQUVELElBQUksT0FBTyxlQUFZOztZQUNuQixJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUM5RSxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDdEM7UUFDRCxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztLQUMzQjs7Ozs7SUFLUyxnQkFBZ0I7UUFDdEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0tBQzdFOzs7OztJQUtELElBQUk7UUFDQSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDZixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ3hCO0tBQ0o7Ozs7O0lBS0QsZ0JBQWdCO1FBQ1osT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7S0FDeEM7OztZQXJESixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLHlCQUF5QjtnQkFDbkMsZ3FDQUFtRDtnQkFFbkQsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7Z0JBQ3JDLElBQUksRUFBRTtvQkFDRixPQUFPLEVBQUUseUJBQXlCO2lCQUNyQzs7YUFDSjs7O3VCQUdJLFNBQVMsU0FBQyxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMsIFZpZXdDaGlsZCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1hdFNlbGVjdCB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCB7IFBhdGhFbGVtZW50RW50aXR5LCBNaW5pbWFsTm9kZUVudHJ5RW50aXR5IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IEJyZWFkY3J1bWJDb21wb25lbnQgfSBmcm9tICcuL2JyZWFkY3J1bWIuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtZHJvcGRvd24tYnJlYWRjcnVtYicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2Ryb3Bkb3duLWJyZWFkY3J1bWIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2Ryb3Bkb3duLWJyZWFkY3J1bWIuY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ2FkZi1kcm9wZG93bi1icmVhZGNydW1iJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgRHJvcGRvd25CcmVhZGNydW1iQ29tcG9uZW50IGV4dGVuZHMgQnJlYWRjcnVtYkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG5cbiAgICBAVmlld0NoaWxkKCdkcm9wZG93bicpXG4gICAgZHJvcGRvd246IE1hdFNlbGVjdDtcblxuICAgIGN1cnJlbnROb2RlOiBQYXRoRWxlbWVudEVudGl0eTtcbiAgICBwcmV2aW91c05vZGVzOiBQYXRoRWxlbWVudEVudGl0eVtdO1xuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICBpZiAoY2hhbmdlcy5mb2xkZXJOb2RlKSB7XG4gICAgICAgICAgICBsZXQgbm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSA9IG51bGw7XG4gICAgICAgICAgICBub2RlID0gdGhpcy50cmFuc2Zvcm0gPyB0aGlzLnRyYW5zZm9ybShjaGFuZ2VzLmZvbGRlck5vZGUuY3VycmVudFZhbHVlKSA6IGNoYW5nZXMuZm9sZGVyTm9kZS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJvdXRlID0gdGhpcy5wYXJzZVJvdXRlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMudHJhbnNmb3JtID8gdGhpcy50cmFuc2Zvcm0odGhpcy5mb2xkZXJOb2RlKSA6IHRoaXMuZm9sZGVyTm9kZTtcbiAgICAgICAgICAgIHRoaXMucm91dGUgPSB0aGlzLnBhcnNlUm91dGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZU5vZGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjdXJyZW50IGFuZCBwcmV2aW91cyBub2RlcyBmcm9tIHRoZSByb3V0ZSBhcnJheVxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZWNhbGN1bGF0ZU5vZGVzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gdGhpcy5yb3V0ZVt0aGlzLnJvdXRlLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLnByZXZpb3VzTm9kZXMgPSB0aGlzLnJvdXRlLnNsaWNlKDAsIHRoaXMucm91dGUubGVuZ3RoIC0gMSkucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBub2RlIHBpY2tlciBtZW51XG4gICAgICovXG4gICAgb3BlbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZHJvcGRvd24pIHtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24ub3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGlmIHJvdXRlIGhhcyBtb3JlIHRoYW4gb25lIGVsZW1lbnQgKG1lYW5zOiB3ZSBhcmUgbm90IGluIHRoZSByb290IGRpcmVjdG9yeSlcbiAgICAgKi9cbiAgICBoYXNQcmV2aW91c05vZGVzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91c05vZGVzLmxlbmd0aCA+IDA7XG4gICAgfVxufVxuIl19