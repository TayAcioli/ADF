/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { AlfrescoApiService, LogService } from '@alfresco/adf-core';
import { EventEmitter, Injectable, Output } from '@angular/core';
import { from, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
export class TagService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        /**
         * Emitted when tag information is updated.
         */
        this.refresh = new EventEmitter();
    }
    /**
     * Gets a list of tags added to a node.
     * @param {?} nodeId ID of the target node
     * @return {?} TagPaging object (defined in JSAPI) containing the tags
     */
    getTagsByNodeId(nodeId) {
        return from(this.apiService.getInstance().core.tagsApi.getNodeTags(nodeId)).pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Gets a list of all the tags already defined in the repository.
     * @param {?=} opts Options supported by JSAPI
     * @return {?} TagPaging object (defined in JSAPI) containing the tags
     */
    getAllTheTags(opts) {
        return from(this.apiService.getInstance().core.tagsApi.getTags(opts))
            .pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Adds a tag to a node.
     * @param {?} nodeId ID of the target node
     * @param {?} tagName Name of the tag to add
     * @return {?} TagEntry object (defined in JSAPI) with details of the new tag
     */
    addTag(nodeId, tagName) {
        /** @type {?} */
        const alfrescoApi = this.apiService.getInstance();
        /** @type {?} */
        const tagBody = new alfrescoApi.core.TagBody();
        tagBody.tag = tagName;
        /** @type {?} */
        let promiseAdd = from(this.apiService.getInstance().core.tagsApi.addTag(nodeId, tagBody));
        promiseAdd.subscribe((data) => {
            this.refresh.emit(data);
        }, (err) => {
            this.handleError(err);
        });
        return promiseAdd;
    }
    /**
     * Removes a tag from a node.
     * @param {?} nodeId ID of the target node
     * @param {?} tag Name of the tag to remove
     * @return {?} Null object when the operation completes
     */
    removeTag(nodeId, tag) {
        /** @type {?} */
        const promiseRemove = from(this.apiService.getInstance().core.tagsApi.removeTag(nodeId, tag));
        promiseRemove.subscribe((data) => {
            this.refresh.emit(data);
        }, (err) => {
            this.handleError(err);
        });
        return promiseRemove;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
TagService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TagService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
TagService.propDecorators = {
    refresh: [{ type: Output }]
};
if (false) {
    /**
     * Emitted when tag information is updated.
     * @type {?}
     */
    TagService.prototype.refresh;
    /** @type {?} */
    TagService.prototype.apiService;
    /** @type {?} */
    TagService.prototype.logService;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFnLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvIiwic291cmNlcyI6WyJ0YWcvc2VydmljZXMvdGFnLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUFFLGtCQUFrQixFQUFFLFVBQVUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNqRSxPQUFPLEVBQWMsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNwRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFJNUMsTUFBTTs7Ozs7SUFNRixZQUFvQixVQUE4QixFQUM5QjtRQURBLGVBQVUsR0FBVixVQUFVLENBQW9CO1FBQzlCLGVBQVUsR0FBVixVQUFVOzs7O3VCQUhwQixJQUFJLFlBQVksRUFBRTtLQUkzQjs7Ozs7O0lBT0QsZUFBZSxDQUFDLE1BQWM7UUFDMUIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDNUUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUMzQyxDQUFDO0tBQ0w7Ozs7OztJQU9ELGFBQWEsQ0FBQyxJQUFVO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDaEUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3ZEOzs7Ozs7O0lBUUQsTUFBTSxDQUFDLE1BQWMsRUFBRSxPQUFlOztRQUNsQyxNQUFNLFdBQVcsR0FBUSxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDOztRQUN2RCxNQUFNLE9BQU8sR0FBRyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDL0MsT0FBTyxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUM7O1FBRXRCLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBRTFGLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUMxQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMzQixFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDUCxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3pCLENBQUMsQ0FBQztRQUVILE9BQU8sVUFBVSxDQUFDO0tBQ3JCOzs7Ozs7O0lBUUQsU0FBUyxDQUFDLE1BQWMsRUFBRSxHQUFXOztRQUNqQyxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUU5RixhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDN0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0IsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQ1AsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN6QixDQUFDLENBQUM7UUFFSCxPQUFPLGFBQWEsQ0FBQztLQUN4Qjs7Ozs7SUFFTyxXQUFXLENBQUMsS0FBVTtRQUMxQixJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM3QixPQUFPLFVBQVUsQ0FBQyxLQUFLLElBQUksY0FBYyxDQUFDLENBQUM7Ozs7WUExRWxELFVBQVU7Ozs7WUFORixrQkFBa0I7WUFBRSxVQUFVOzs7c0JBVWxDLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBbGZyZXNjb0FwaVNlcnZpY2UsIExvZ1NlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBJbmplY3RhYmxlLCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIGZyb20sIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUYWdQYWdpbmcgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVGFnU2VydmljZSB7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRhZyBpbmZvcm1hdGlvbiBpcyB1cGRhdGVkLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHJlZnJlc2ggPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGxvZ1NlcnZpY2U6IExvZ1NlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiB0YWdzIGFkZGVkIHRvIGEgbm9kZS5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIElEIG9mIHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIEByZXR1cm5zIFRhZ1BhZ2luZyBvYmplY3QgKGRlZmluZWQgaW4gSlNBUEkpIGNvbnRhaW5pbmcgdGhlIHRhZ3NcbiAgICAgKi9cbiAgICBnZXRUYWdzQnlOb2RlSWQobm9kZUlkOiBzdHJpbmcpOiBhbnkge1xuICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5jb3JlLnRhZ3NBcGkuZ2V0Tm9kZVRhZ3Mobm9kZUlkKSkucGlwZShcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBhbGwgdGhlIHRhZ3MgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSByZXBvc2l0b3J5LlxuICAgICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgc3VwcG9ydGVkIGJ5IEpTQVBJXG4gICAgICogQHJldHVybnMgVGFnUGFnaW5nIG9iamVjdCAoZGVmaW5lZCBpbiBKU0FQSSkgY29udGFpbmluZyB0aGUgdGFnc1xuICAgICAqL1xuICAgIGdldEFsbFRoZVRhZ3Mob3B0cz86IGFueSk6IE9ic2VydmFibGU8VGFnUGFnaW5nPiB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLmNvcmUudGFnc0FwaS5nZXRUYWdzKG9wdHMpKVxuICAgICAgICAgICAgLnBpcGUoY2F0Y2hFcnJvcihlcnIgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRhZyB0byBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGVJZCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0gdGFnTmFtZSBOYW1lIG9mIHRoZSB0YWcgdG8gYWRkXG4gICAgICogQHJldHVybnMgVGFnRW50cnkgb2JqZWN0IChkZWZpbmVkIGluIEpTQVBJKSB3aXRoIGRldGFpbHMgb2YgdGhlIG5ldyB0YWdcbiAgICAgKi9cbiAgICBhZGRUYWcobm9kZUlkOiBzdHJpbmcsIHRhZ05hbWU6IHN0cmluZyk6IGFueSB7XG4gICAgICAgIGNvbnN0IGFsZnJlc2NvQXBpOiBhbnkgPSB0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgY29uc3QgdGFnQm9keSA9IG5ldyBhbGZyZXNjb0FwaS5jb3JlLlRhZ0JvZHkoKTtcbiAgICAgICAgdGFnQm9keS50YWcgPSB0YWdOYW1lO1xuXG4gICAgICAgIGxldCBwcm9taXNlQWRkID0gZnJvbSh0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5jb3JlLnRhZ3NBcGkuYWRkVGFnKG5vZGVJZCwgdGFnQm9keSkpO1xuXG4gICAgICAgIHByb21pc2VBZGQuc3Vic2NyaWJlKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2guZW1pdChkYXRhKTtcbiAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZUFkZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdGFnIGZyb20gYSBub2RlLlxuICAgICAqIEBwYXJhbSBub2RlSWQgSUQgb2YgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIHRhZyBOYW1lIG9mIHRoZSB0YWcgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybnMgTnVsbCBvYmplY3Qgd2hlbiB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlc1xuICAgICAqL1xuICAgIHJlbW92ZVRhZyhub2RlSWQ6IHN0cmluZywgdGFnOiBzdHJpbmcpOiBhbnkge1xuICAgICAgICBjb25zdCBwcm9taXNlUmVtb3ZlID0gZnJvbSh0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5jb3JlLnRhZ3NBcGkucmVtb3ZlVGFnKG5vZGVJZCwgdGFnKSk7XG5cbiAgICAgICAgcHJvbWlzZVJlbW92ZS5zdWJzY3JpYmUoKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaC5lbWl0KGRhdGEpO1xuICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcm9taXNlUmVtb3ZlO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlRXJyb3IoZXJyb3I6IGFueSkge1xuICAgICAgICB0aGlzLmxvZ1NlcnZpY2UuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvciB8fCAnU2VydmVyIGVycm9yJyk7XG4gICAgfVxufVxuIl19