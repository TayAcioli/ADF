/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { AlfrescoApiService, AuthenticationService, ContentService, LogService, ThumbnailService } from '@alfresco/adf-core';
import { Injectable } from '@angular/core';
import { from, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
export class DocumentListService {
    /**
     * @param {?} authService
     * @param {?} contentService
     * @param {?} apiService
     * @param {?} logService
     * @param {?} thumbnailService
     */
    constructor(authService, contentService, apiService, logService, thumbnailService) {
        this.contentService = contentService;
        this.apiService = apiService;
        this.logService = logService;
        this.thumbnailService = thumbnailService;
    }
    /**
     * @param {?} folder
     * @param {?=} opts
     * @param {?=} includeFields
     * @return {?}
     */
    getNodesPromise(folder, opts, includeFields = []) {
        /** @type {?} */
        let rootNodeId = DocumentListService.ROOT_ID;
        if (opts && opts.rootFolderId) {
            rootNodeId = opts.rootFolderId;
        }
        /** @type {?} */
        let includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames', ...includeFields]
            .filter((element, index, array) => index === array.indexOf(element));
        /** @type {?} */
        let params = {
            includeSource: true,
            include: includeFieldsRequest
        };
        if (folder) {
            params.relativePath = folder;
        }
        if (opts) {
            if (opts.maxItems) {
                params.maxItems = opts.maxItems;
            }
            if (opts.skipCount) {
                params.skipCount = opts.skipCount;
            }
        }
        return this.apiService.getInstance().nodes.getNodeChildren(rootNodeId, params);
    }
    /**
     * Deletes a node.
     * @param {?} nodeId ID of the node to delete
     * @return {?} Empty response when the operation is complete
     */
    deleteNode(nodeId) {
        return from(this.apiService.getInstance().nodes.deleteNode(nodeId));
    }
    /**
     * Copy a node to destination node
     *
     * @param {?} nodeId The id of the node to be copied
     * @param {?} targetParentId The id of the folder where the node will be copied
     * @return {?} NodeEntry for the copied node
     */
    copyNode(nodeId, targetParentId) {
        return from(this.apiService.getInstance().nodes.copyNode(nodeId, { targetParentId })).pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Moves a node to destination node.
     *
     * @param {?} nodeId The id of the node to be moved
     * @param {?} targetParentId The id of the folder where the node will be moved
     * @return {?} NodeEntry for the moved node
     */
    moveNode(nodeId, targetParentId) {
        return from(this.apiService.getInstance().nodes.moveNode(nodeId, { targetParentId })).pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Creates a new folder in the path.
     * @param {?} name Folder name
     * @param {?} parentId Parent folder ID
     * @return {?} Details of the created folder node
     */
    createFolder(name, parentId) {
        return from(this.apiService.getInstance().nodes.createFolder(name, '/', parentId))
            .pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Gets the folder node with the specified relative name path below the root node.
     * @param {?} folder Path to folder.
     * @param {?=} opts Options.
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    getFolder(folder, opts, includeFields = []) {
        return from(this.getNodesPromise(folder, opts, includeFields))
            .pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Gets a node via its node ID.
     * @param {?} nodeId ID of the target node
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    getNode(nodeId, includeFields = []) {
        /** @type {?} */
        let includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', ...includeFields]
            .filter((element, index, array) => index === array.indexOf(element));
        /** @type {?} */
        let opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return this.contentService.getNode(nodeId, opts);
    }
    /**
     * Gets a folder node via its node ID.
     * @deprecated 2.3.0
     * @param {?} nodeId ID of the folder node
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    getFolderNode(nodeId, includeFields = []) {
        /** @type {?} */
        let includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames', ...includeFields]
            .filter((element, index, array) => index === array.indexOf(element));
        /** @type {?} */
        let opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return from(this.apiService.getInstance().nodes.getNodeInfo(nodeId, opts));
    }
    /**
     * Get thumbnail URL for the given document node.
     * @param {?} node Node to get URL for.
     * @return {?} Thumbnail URL string
     */
    getDocumentThumbnailUrl(node) {
        return this.thumbnailService.getDocumentThumbnailUrl(node);
    }
    /**
     * Gets the icon that represents a MIME type.
     * @param {?} mimeType MIME type to get the icon for
     * @return {?} Path to the icon file
     */
    getMimeTypeIcon(mimeType) {
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    /**
     * Gets a default icon for MIME types with no specific icon.
     * @return {?} Path to the icon file
     */
    getDefaultMimeTypeIcon() {
        return this.thumbnailService.getDefaultMimeTypeIcon();
    }
    /**
     * Checks if a node has the specified permission.
     * @deprecated 2.3.0 - use the equivalent in the content service
     * @param {?} node Target node
     * @param {?} permission Permission level to query
     * @return {?} True if the node has the permission, false otherwise
     */
    hasPermission(node, permission) {
        return this.contentService.hasPermission(node, permission);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
DocumentListService.ROOT_ID = '-root-';
DocumentListService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DocumentListService.ctorParameters = () => [
    { type: AuthenticationService },
    { type: ContentService },
    { type: AlfrescoApiService },
    { type: LogService },
    { type: ThumbnailService }
];
if (false) {
    /** @type {?} */
    DocumentListService.ROOT_ID;
    /** @type {?} */
    DocumentListService.prototype.contentService;
    /** @type {?} */
    DocumentListService.prototype.apiService;
    /** @type {?} */
    DocumentListService.prototype.logService;
    /** @type {?} */
    DocumentListService.prototype.thumbnailService;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9jdW1lbnQtbGlzdC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzLyIsInNvdXJjZXMiOlsiZG9jdW1lbnQtbGlzdC9zZXJ2aWNlcy9kb2N1bWVudC1saXN0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUNILGtCQUFrQixFQUFFLHFCQUFxQixFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQ3BELGdCQUFnQixFQUNwQyxNQUFNLG9CQUFvQixDQUFDO0FBRTVCLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFjLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDcEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRzVDLE1BQU07Ozs7Ozs7O0lBSUYsWUFBWSxXQUFrQyxFQUMxQixnQkFDQSxZQUNBLFlBQ0E7UUFIQSxtQkFBYyxHQUFkLGNBQWM7UUFDZCxlQUFVLEdBQVYsVUFBVTtRQUNWLGVBQVUsR0FBVixVQUFVO1FBQ1YscUJBQWdCLEdBQWhCLGdCQUFnQjtLQUNuQzs7Ozs7OztJQUVPLGVBQWUsQ0FBQyxNQUFjLEVBQUUsSUFBVSxFQUFFLGdCQUEwQixFQUFFOztRQUU1RSxJQUFJLFVBQVUsR0FBRyxtQkFBbUIsQ0FBQyxPQUFPLENBQUM7UUFDN0MsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUMzQixVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztTQUNsQzs7UUFFRCxJQUFJLG9CQUFvQixHQUFHLENBQUMsTUFBTSxFQUFFLFlBQVksRUFBRSxxQkFBcUIsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLEdBQUcsYUFBYSxDQUFDO2FBQ25ILE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxF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QUFPLElBQUksQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztLQUM5RDs7Ozs7SUFFTyxXQUFXLENBQUMsS0FBVTtRQUMxQixJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM3QixPQUFPLFVBQVUsQ0FBQyxLQUFLLElBQUksY0FBYyxDQUFDLENBQUM7Ozs4QkFuTDlCLFFBQVE7O1lBSDVCLFVBQVU7Ozs7WUFUYSxxQkFBcUI7WUFBRSxjQUFjO1lBQXpELGtCQUFrQjtZQUF5QyxVQUFVO1lBQ3BELGdCQUFnQiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgQWxmcmVzY29BcGlTZXJ2aWNlLCBBdXRoZW50aWNhdGlvblNlcnZpY2UsIENvbnRlbnRTZXJ2aWNlLCBMb2dTZXJ2aWNlLFxuICAgIFBlcm1pc3Npb25zRW51bSwgVGh1bWJuYWlsU2VydmljZVxufSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudGl0eSwgTWluaW1hbE5vZGVFbnRyeUVudGl0eSwgIE5vZGVFbnRyeSwgTm9kZVBhZ2luZyB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmcm9tLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRG9jdW1lbnRMaXN0U2VydmljZSB7XG5cbiAgICBzdGF0aWMgUk9PVF9JRCA9ICctcm9vdC0nO1xuXG4gICAgY29uc3RydWN0b3IoYXV0aFNlcnZpY2U6IEF1dGhlbnRpY2F0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNvbnRlbnRTZXJ2aWNlOiBDb250ZW50U2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGxvZ1NlcnZpY2U6IExvZ1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSB0aHVtYm5haWxTZXJ2aWNlOiBUaHVtYm5haWxTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXROb2Rlc1Byb21pc2UoZm9sZGVyOiBzdHJpbmcsIG9wdHM/OiBhbnksIGluY2x1ZGVGaWVsZHM6IHN0cmluZ1tdID0gW10pOiBQcm9taXNlPE5vZGVQYWdpbmc+IHtcblxuICAgICAgICBsZXQgcm9vdE5vZGVJZCA9IERvY3VtZW50TGlzdFNlcnZpY2UuUk9PVF9JRDtcbiAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy5yb290Rm9sZGVySWQpIHtcbiAgICAgICAgICAgIHJvb3ROb2RlSWQgPSBvcHRzLnJvb3RGb2xkZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbmNsdWRlRmllbGRzUmVxdWVzdCA9IFsncGF0aCcsICdwcm9wZXJ0aWVzJywgJ2FsbG93YWJsZU9wZXJhdGlvbnMnLCAncGVybWlzc2lvbnMnLCAnYXNwZWN0TmFtZXMnLCAuLi5pbmNsdWRlRmllbGRzXVxuICAgICAgICAgICAgLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBpbmRleCA9PT0gYXJyYXkuaW5kZXhPZihlbGVtZW50KSk7XG5cbiAgICAgICAgbGV0IHBhcmFtczogYW55ID0ge1xuICAgICAgICAgICAgaW5jbHVkZVNvdXJjZTogdHJ1ZSxcbiAgICAgICAgICAgIGluY2x1ZGU6IGluY2x1ZGVGaWVsZHNSZXF1ZXN0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGZvbGRlcikge1xuICAgICAgICAgICAgcGFyYW1zLnJlbGF0aXZlUGF0aCA9IGZvbGRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5tYXhJdGVtcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5tYXhJdGVtcyA9IG9wdHMubWF4SXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5za2lwQ291bnQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2tpcENvdW50ID0gb3B0cy5za2lwQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkubm9kZXMuZ2V0Tm9kZUNoaWxkcmVuKHJvb3ROb2RlSWQsIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGVJZCBJRCBvZiB0aGUgbm9kZSB0byBkZWxldGVcbiAgICAgKiBAcmV0dXJucyBFbXB0eSByZXNwb25zZSB3aGVuIHRoZSBvcGVyYXRpb24gaXMgY29tcGxldGVcbiAgICAgKi9cbiAgICBkZWxldGVOb2RlKG5vZGVJZDogc3RyaW5nKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkubm9kZXMuZGVsZXRlTm9kZShub2RlSWQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGEgbm9kZSB0byBkZXN0aW5hdGlvbiBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZUlkIFRoZSBpZCBvZiB0aGUgbm9kZSB0byBiZSBjb3BpZWRcbiAgICAgKiBAcGFyYW0gdGFyZ2V0UGFyZW50SWQgVGhlIGlkIG9mIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5vZGUgd2lsbCBiZSBjb3BpZWRcbiAgICAgKiBAcmV0dXJucyBOb2RlRW50cnkgZm9yIHRoZSBjb3BpZWQgbm9kZVxuICAgICAqL1xuICAgIGNvcHlOb2RlKG5vZGVJZDogc3RyaW5nLCB0YXJnZXRQYXJlbnRJZDogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLm5vZGVzLmNvcHlOb2RlKG5vZGVJZCwgeyB0YXJnZXRQYXJlbnRJZCB9KSkucGlwZShcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIG5vZGUgdG8gZGVzdGluYXRpb24gbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlSWQgVGhlIGlkIG9mIHRoZSBub2RlIHRvIGJlIG1vdmVkXG4gICAgICogQHBhcmFtIHRhcmdldFBhcmVudElkIFRoZSBpZCBvZiB0aGUgZm9sZGVyIHdoZXJlIHRoZSBub2RlIHdpbGwgYmUgbW92ZWRcbiAgICAgKiBAcmV0dXJucyBOb2RlRW50cnkgZm9yIHRoZSBtb3ZlZCBub2RlXG4gICAgICovXG4gICAgbW92ZU5vZGUobm9kZUlkOiBzdHJpbmcsIHRhcmdldFBhcmVudElkOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkubm9kZXMubW92ZU5vZGUobm9kZUlkLCB7IHRhcmdldFBhcmVudElkIH0pKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnIgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZm9sZGVyIGluIHRoZSBwYXRoLlxuICAgICAqIEBwYXJhbSBuYW1lIEZvbGRlciBuYW1lXG4gICAgICogQHBhcmFtIHBhcmVudElkIFBhcmVudCBmb2xkZXIgSURcbiAgICAgKiBAcmV0dXJucyBEZXRhaWxzIG9mIHRoZSBjcmVhdGVkIGZvbGRlciBub2RlXG4gICAgICovXG4gICAgY3JlYXRlRm9sZGVyKG5hbWU6IHN0cmluZywgcGFyZW50SWQ6IHN0cmluZyk6IE9ic2VydmFibGU8TWluaW1hbE5vZGVFbnRpdHk+IHtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkubm9kZXMuY3JlYXRlRm9sZGVyKG5hbWUsICcvJywgcGFyZW50SWQpKVxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnIgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmb2xkZXIgbm9kZSB3aXRoIHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgbmFtZSBwYXRoIGJlbG93IHRoZSByb290IG5vZGUuXG4gICAgICogQHBhcmFtIGZvbGRlciBQYXRoIHRvIGZvbGRlci5cbiAgICAgKiBAcGFyYW0gb3B0cyBPcHRpb25zLlxuICAgICAqIEBwYXJhbSBpbmNsdWRlRmllbGRzIEV4dHJhIGluZm9ybWF0aW9uIHRvIGluY2x1ZGUgKGF2YWlsYWJsZSBvcHRpb25zIGFyZSBcImFzcGVjdE5hbWVzXCIsIFwiaXNMaW5rXCIgYW5kIFwiYXNzb2NpYXRpb25cIilcbiAgICAgKiBAcmV0dXJucyBEZXRhaWxzIG9mIHRoZSBmb2xkZXJcbiAgICAgKi9cbiAgICBnZXRGb2xkZXIoZm9sZGVyOiBzdHJpbmcsIG9wdHM/OiBhbnksIGluY2x1ZGVGaWVsZHM6IHN0cmluZ1tdID0gW10pOiBPYnNlcnZhYmxlPE5vZGVQYWdpbmc+IHtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5nZXROb2Rlc1Byb21pc2UoZm9sZGVyLCBvcHRzLCBpbmNsdWRlRmllbGRzKSlcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIG5vZGUgdmlhIGl0cyBub2RlIElELlxuICAgICAqIEBwYXJhbSBub2RlSWQgSUQgb2YgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIGluY2x1ZGVGaWVsZHMgRXh0cmEgaW5mb3JtYXRpb24gdG8gaW5jbHVkZSAoYXZhaWxhYmxlIG9wdGlvbnMgYXJlIFwiYXNwZWN0TmFtZXNcIiwgXCJpc0xpbmtcIiBhbmQgXCJhc3NvY2lhdGlvblwiKVxuICAgICAqIEByZXR1cm5zIERldGFpbHMgb2YgdGhlIGZvbGRlclxuICAgICAqL1xuICAgIGdldE5vZGUobm9kZUlkOiBzdHJpbmcsIGluY2x1ZGVGaWVsZHM6IHN0cmluZ1tdID0gW10pOiBPYnNlcnZhYmxlPE5vZGVFbnRyeT4ge1xuXG4gICAgICAgIGxldCBpbmNsdWRlRmllbGRzUmVxdWVzdCA9IFsncGF0aCcsICdwcm9wZXJ0aWVzJywgJ2FsbG93YWJsZU9wZXJhdGlvbnMnLCAncGVybWlzc2lvbnMnLCAuLi5pbmNsdWRlRmllbGRzXVxuICAgICAgICAgICAgLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBpbmRleCA9PT0gYXJyYXkuaW5kZXhPZihlbGVtZW50KSk7XG5cbiAgICAgICAgbGV0IG9wdHM6IGFueSA9IHtcbiAgICAgICAgICAgIGluY2x1ZGVTb3VyY2U6IHRydWUsXG4gICAgICAgICAgICBpbmNsdWRlOiBpbmNsdWRlRmllbGRzUmVxdWVzdFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRTZXJ2aWNlLmdldE5vZGUobm9kZUlkLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgZm9sZGVyIG5vZGUgdmlhIGl0cyBub2RlIElELlxuICAgICAqIEBkZXByZWNhdGVkIDIuMy4wXG4gICAgICogQHBhcmFtIG5vZGVJZCBJRCBvZiB0aGUgZm9sZGVyIG5vZGVcbiAgICAgKiBAcGFyYW0gaW5jbHVkZUZpZWxkcyBFeHRyYSBpbmZvcm1hdGlvbiB0byBpbmNsdWRlIChhdmFpbGFibGUgb3B0aW9ucyBhcmUgXCJhc3BlY3ROYW1lc1wiLCBcImlzTGlua1wiIGFuZCBcImFzc29jaWF0aW9uXCIpXG4gICAgICogQHJldHVybnMgRGV0YWlscyBvZiB0aGUgZm9sZGVyXG4gICAgICovXG4gICAgZ2V0Rm9sZGVyTm9kZShub2RlSWQ6IHN0cmluZywgaW5jbHVkZUZpZWxkczogc3RyaW5nW10gPSBbXSk6IE9ic2VydmFibGU8TWluaW1hbE5vZGVFbnRyeUVudGl0eT4ge1xuXG4gICAgICAgIGxldCBpbmNsdWRlRmllbGRzUmVxdWVzdCA9IFsncGF0aCcsICdwcm9wZXJ0aWVzJywgJ2FsbG93YWJsZU9wZXJhdGlvbnMnLCAncGVybWlzc2lvbnMnLCAnYXNwZWN0TmFtZXMnLCAuLi5pbmNsdWRlRmllbGRzXVxuICAgICAgICAgICAgLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBpbmRleCA9PT0gYXJyYXkuaW5kZXhPZihlbGVtZW50KSk7XG5cbiAgICAgICAgbGV0IG9wdHM6IGFueSA9IHtcbiAgICAgICAgICAgIGluY2x1ZGVTb3VyY2U6IHRydWUsXG4gICAgICAgICAgICBpbmNsdWRlOiBpbmNsdWRlRmllbGRzUmVxdWVzdFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLm5vZGVzLmdldE5vZGVJbmZvKG5vZGVJZCwgb3B0cykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGh1bWJuYWlsIFVSTCBmb3IgdGhlIGdpdmVuIGRvY3VtZW50IG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGUgTm9kZSB0byBnZXQgVVJMIGZvci5cbiAgICAgKiBAcmV0dXJucyBUaHVtYm5haWwgVVJMIHN0cmluZ1xuICAgICAqL1xuICAgIGdldERvY3VtZW50VGh1bWJuYWlsVXJsKG5vZGU6IE1pbmltYWxOb2RlRW50aXR5KTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGh1bWJuYWlsU2VydmljZS5nZXREb2N1bWVudFRodW1ibmFpbFVybChub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpY29uIHRoYXQgcmVwcmVzZW50cyBhIE1JTUUgdHlwZS5cbiAgICAgKiBAcGFyYW0gbWltZVR5cGUgTUlNRSB0eXBlIHRvIGdldCB0aGUgaWNvbiBmb3JcbiAgICAgKiBAcmV0dXJucyBQYXRoIHRvIHRoZSBpY29uIGZpbGVcbiAgICAgKi9cbiAgICBnZXRNaW1lVHlwZUljb24obWltZVR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnRodW1ibmFpbFNlcnZpY2UuZ2V0TWltZVR5cGVJY29uKG1pbWVUeXBlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgZGVmYXVsdCBpY29uIGZvciBNSU1FIHR5cGVzIHdpdGggbm8gc3BlY2lmaWMgaWNvbi5cbiAgICAgKiBAcmV0dXJucyBQYXRoIHRvIHRoZSBpY29uIGZpbGVcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0TWltZVR5cGVJY29uKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnRodW1ibmFpbFNlcnZpY2UuZ2V0RGVmYXVsdE1pbWVUeXBlSWNvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIG5vZGUgaGFzIHRoZSBzcGVjaWZpZWQgcGVybWlzc2lvbi5cbiAgICAgKiBAZGVwcmVjYXRlZCAyLjMuMCAtIHVzZSB0aGUgZXF1aXZhbGVudCBpbiB0aGUgY29udGVudCBzZXJ2aWNlXG4gICAgICogQHBhcmFtIG5vZGUgVGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0gcGVybWlzc2lvbiBQZXJtaXNzaW9uIGxldmVsIHRvIHF1ZXJ5XG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm9kZSBoYXMgdGhlIHBlcm1pc3Npb24sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGhhc1Blcm1pc3Npb24obm9kZTogYW55LCBwZXJtaXNzaW9uOiBQZXJtaXNzaW9uc0VudW0gfCBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFNlcnZpY2UuaGFzUGVybWlzc2lvbihub2RlLCBwZXJtaXNzaW9uKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUVycm9yKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhpcy5sb2dTZXJ2aWNlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZXJyb3IgfHwgJ1NlcnZlciBlcnJvcicpO1xuICAgIH1cbn1cbiJdfQ==