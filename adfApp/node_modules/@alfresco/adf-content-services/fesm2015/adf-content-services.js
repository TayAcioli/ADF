import { Component, Inject, ViewEncapsulation, Directive, Input, HostListener, NgModule, Injectable, Optional, EventEmitter, Output, ElementRef, Renderer2, ContentChild, NgZone, ViewChild, TemplateRef, ChangeDetectorRef, forwardRef, ViewChildren, ViewContainerRef, ComponentFactoryResolver, ChangeDetectionStrategy } from '@angular/core';
import { MAT_DIALOG_DATA, MatDialogRef, MatDialog, MatButtonModule, MatChipsModule, MatDialogModule, MatIconModule, MatCardModule, MatInputModule, MatListModule, MatMenuModule, MatOptionModule, MatProgressBarModule, MatProgressSpinnerModule, MatRippleModule, MatExpansionModule, MatSelectModule, MatCheckboxModule, MatDatepickerModule, MatSlideToggleModule, MatRadioModule, MatSliderModule, MatListItem } from '@angular/material';
import { LogService, AlfrescoApiService, AuthenticationService, ContentService, ThumbnailService, SitesService, TranslationService, PermissionsEnum, CoreModule, ObjectDataTableAdapter, ObjectUtils, DataSorting, BaseEvent, DisplayMode, ObjectDataColumn, AppConfigService, DataColumnListComponent, UserPreferencesService, FileUploadStatus, NodesApiService, UploadService, FileModel, EXTENDIBLE_COMPONENT, FileUtils, NotificationService, SearchService, MomentDateAdapter, MOMENT_DATE_FORMATS, UserPreferenceValues, HighlightDirective, CardViewDateItemModel, CardViewTextItemModel, FileSizePipe, CardViewBoolItemModel, CardViewDatetimeItemModel, CardViewIntItemModel, CardViewFloatItemModel, CardViewUpdateService, SearchConfigurationService, SharedLinksApiService, TRANSLATION_PROVIDER } from '@alfresco/adf-core';
import { from, throwError, Subject, Observable, of, BehaviorSubject, forkJoin, merge, fromEvent, defer } from 'rxjs';
import { catchError, switchMap, map, debounceTime, filter, takeUntil, takeWhile, tap, skip } from 'rxjs/operators';
import 'alfresco-js-api';
import moment$1 from 'moment-es6';
import { FormBuilder, FormsModule, ReactiveFormsModule, NG_VALUE_ACCESSOR, FormControl, Validators, FormGroup } from '@angular/forms';
import { CommonModule, DOCUMENT } from '@angular/common';
import { FlexLayoutModule } from '@angular/flex-layout';
import { __awaiter } from 'tslib';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { ENTER, ESCAPE } from '@angular/cdk/keycodes';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material/core';
import { MatDatetimepickerModule } from '@mat-datetimepicker/core';
import { MatMomentDatetimeModule } from '@mat-datetimepicker/moment';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DownloadZipDialogComponent {
    /**
     * @param {?} apiService
     * @param {?} dialogRef
     * @param {?} data
     * @param {?} logService
     */
    constructor(apiService, dialogRef, data, logService) {
        this.apiService = apiService;
        this.dialogRef = dialogRef;
        this.data = data;
        this.logService = logService;
        this.cancelled = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.data && this.data.nodeIds && this.data.nodeIds.length > 0) {
            if (!this.cancelled) {
                this.downloadZip(this.data.nodeIds);
            }
            else {
                this.logService.log('Cancelled');
            }
        }
    }
    /**
     * @return {?}
     */
    cancelDownload() {
        this.cancelled = true;
        this.dialogRef.close(false);
    }
    /**
     * @param {?} nodeIds
     * @return {?}
     */
    downloadZip(nodeIds) {
        if (nodeIds && nodeIds.length > 0) {
            /** @type {?} */
            const promise = this.apiService.getInstance().core.downloadsApi.createDownload({ nodeIds });
            promise.on('progress', progress => this.logService.log('Progress', progress));
            promise.on('error', error => this.logService.error('Error', error));
            promise.on('abort', data => this.logService.log('Abort', data));
            promise.on('success', (data) => {
                if (data && data.entry && data.entry.id) {
                    /** @type {?} */
                    const url = this.apiService.getInstance().content.getContentUrl(data.entry.id, true);
                    this.apiService.getInstance().core.nodesApi.getNode(data.entry.id).then((downloadNode) => {
                        this.logService.log(downloadNode);
                        /** @type {?} */
                        const fileName = downloadNode.entry.name;
                        this.waitAndDownload(data.entry.id, url, fileName);
                    });
                }
            });
        }
    }
    /**
     * @param {?} downloadId
     * @param {?} url
     * @param {?} fileName
     * @return {?}
     */
    waitAndDownload(downloadId, url, fileName) {
        if (this.cancelled) {
            return;
        }
        this.apiService.getInstance().core.downloadsApi.getDownload(downloadId).then((downloadEntry) => {
            if (downloadEntry.entry) {
                if (downloadEntry.entry.status === 'DONE') {
                    this.download(url, fileName);
                }
                else {
                    setTimeout(() => {
                        this.waitAndDownload(downloadId, url, fileName);
                    }, 1000);
                }
            }
        });
    }
    /**
     * @param {?} url
     * @param {?} fileName
     * @return {?}
     */
    download(url, fileName) {
        if (url && fileName) {
            /** @type {?} */
            const link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        this.dialogRef.close(true);
    }
}
DownloadZipDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-download-zip-dialog',
                template: "<h1 matDialogTitle>{{ 'CORE.DIALOG.DOWNLOAD_ZIP.TITLE' | translate }}</h1>\n<div mat-dialog-content>\n    <mat-progress-bar color=\"primary\" mode=\"indeterminate\"></mat-progress-bar>\n</div>\n<div mat-dialog-actions>\n    <span class=\"spacer\"></span>\n    <button mat-button color=\"primary\" (click)=\"cancelDownload()\">\n        {{ 'CORE.DIALOG.DOWNLOAD_ZIP.ACTIONS.CANCEL' | translate }}\n    </button>\n</div>\n",
                host: { 'class': 'adf-download-zip-dialog' },
                encapsulation: ViewEncapsulation.None,
                styles: [".spacer{flex:1 1 auto}.adf-download-zip-dialog .mat-dialog-actions .mat-button-wrapper{text-transform:uppercase}"]
            }] }
];
/** @nocollapse */
DownloadZipDialogComponent.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: LogService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NodeDownloadDirective {
    /**
     * @param {?} apiService
     * @param {?} dialog
     */
    constructor(apiService, dialog) {
        this.apiService = apiService;
        this.dialog = dialog;
    }
    /**
     * @return {?}
     */
    onClick() {
        this.downloadNodes(this.nodes);
    }
    /**
     * Downloads multiple selected nodes.
     * Packs result into a .ZIP archive if there is more than one node selected.
     * @param {?} selection Multiple selected nodes to download
     * @return {?}
     */
    downloadNodes(selection) {
        if (!selection || selection.length === 0) {
            return;
        }
        if (selection.length === 1) {
            this.downloadNode(selection[0]);
        }
        else {
            this.downloadZip(selection);
        }
    }
    /**
     * Downloads a single node.
     * Packs result into a .ZIP archive is the node is a Folder.
     * @param {?} node Node to download
     * @return {?}
     */
    downloadNode(node) {
        if (node && node.entry) {
            /** @type {?} */
            const entry = node.entry;
            if (entry.isFile) {
                this.downloadFile(node);
            }
            if (entry.isFolder) {
                this.downloadZip([node]);
            }
            // Check if there's nodeId for Shared Files
            if (!entry.isFile && !entry.isFolder && (/** @type {?} */ (entry)).nodeId) {
                this.downloadFile(node);
            }
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    downloadFile(node) {
        if (node && node.entry) {
            /** @type {?} */
            const contentApi = this.apiService.getInstance().content;
            /** @type {?} */
            const id = (/** @type {?} */ (node.entry)).nodeId || node.entry.id;
            /** @type {?} */
            const url = contentApi.getContentUrl(id, true);
            /** @type {?} */
            const fileName = node.entry.name;
            this.download(url, fileName);
        }
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    downloadZip(selection) {
        if (selection && selection.length > 0) {
            /** @type {?} */
            const nodeIds = selection.map((node) => (node.entry.nodeId || node.entry.id));
            this.dialog.open(DownloadZipDialogComponent, {
                width: '600px',
                disableClose: true,
                data: {
                    nodeIds
                }
            });
        }
    }
    /**
     * @param {?} url
     * @param {?} fileName
     * @return {?}
     */
    download(url, fileName) {
        if (url && fileName) {
            /** @type {?} */
            const link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }
}
NodeDownloadDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adfNodeDownload]'
            },] }
];
/** @nocollapse */
NodeDownloadDirective.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: MatDialog }
];
NodeDownloadDirective.propDecorators = {
    nodes: [{ type: Input, args: ['adfNodeDownload',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function modules() {
    return [
        MatButtonModule,
        MatChipsModule,
        MatDialogModule,
        MatIconModule,
        MatCardModule,
        MatInputModule,
        MatListModule,
        MatProgressSpinnerModule,
        MatProgressBarModule,
        MatRippleModule,
        MatMenuModule,
        MatOptionModule,
        MatExpansionModule,
        MatSelectModule,
        MatCheckboxModule,
        MatDatepickerModule,
        MatSlideToggleModule,
        MatRadioModule,
        MatSliderModule
    ];
}
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                imports: modules(),
                exports: modules()
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DocumentListService {
    /**
     * @param {?} authService
     * @param {?} contentService
     * @param {?} apiService
     * @param {?} logService
     * @param {?} thumbnailService
     */
    constructor(authService, contentService, apiService, logService, thumbnailService) {
        this.contentService = contentService;
        this.apiService = apiService;
        this.logService = logService;
        this.thumbnailService = thumbnailService;
    }
    /**
     * @param {?} folder
     * @param {?=} opts
     * @param {?=} includeFields
     * @return {?}
     */
    getNodesPromise(folder, opts, includeFields = []) {
        /** @type {?} */
        let rootNodeId = DocumentListService.ROOT_ID;
        if (opts && opts.rootFolderId) {
            rootNodeId = opts.rootFolderId;
        }
        /** @type {?} */
        let includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames', ...includeFields]
            .filter((element, index, array) => index === array.indexOf(element));
        /** @type {?} */
        let params = {
            includeSource: true,
            include: includeFieldsRequest
        };
        if (folder) {
            params.relativePath = folder;
        }
        if (opts) {
            if (opts.maxItems) {
                params.maxItems = opts.maxItems;
            }
            if (opts.skipCount) {
                params.skipCount = opts.skipCount;
            }
        }
        return this.apiService.getInstance().nodes.getNodeChildren(rootNodeId, params);
    }
    /**
     * Deletes a node.
     * @param {?} nodeId ID of the node to delete
     * @return {?} Empty response when the operation is complete
     */
    deleteNode(nodeId) {
        return from(this.apiService.getInstance().nodes.deleteNode(nodeId));
    }
    /**
     * Copy a node to destination node
     *
     * @param {?} nodeId The id of the node to be copied
     * @param {?} targetParentId The id of the folder where the node will be copied
     * @return {?} NodeEntry for the copied node
     */
    copyNode(nodeId, targetParentId) {
        return from(this.apiService.getInstance().nodes.copyNode(nodeId, { targetParentId })).pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Moves a node to destination node.
     *
     * @param {?} nodeId The id of the node to be moved
     * @param {?} targetParentId The id of the folder where the node will be moved
     * @return {?} NodeEntry for the moved node
     */
    moveNode(nodeId, targetParentId) {
        return from(this.apiService.getInstance().nodes.moveNode(nodeId, { targetParentId })).pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Creates a new folder in the path.
     * @param {?} name Folder name
     * @param {?} parentId Parent folder ID
     * @return {?} Details of the created folder node
     */
    createFolder(name, parentId) {
        return from(this.apiService.getInstance().nodes.createFolder(name, '/', parentId))
            .pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Gets the folder node with the specified relative name path below the root node.
     * @param {?} folder Path to folder.
     * @param {?=} opts Options.
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    getFolder(folder, opts, includeFields = []) {
        return from(this.getNodesPromise(folder, opts, includeFields))
            .pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Gets a node via its node ID.
     * @param {?} nodeId ID of the target node
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    getNode(nodeId, includeFields = []) {
        /** @type {?} */
        let includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', ...includeFields]
            .filter((element, index, array) => index === array.indexOf(element));
        /** @type {?} */
        let opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return this.contentService.getNode(nodeId, opts);
    }
    /**
     * Gets a folder node via its node ID.
     * @deprecated 2.3.0
     * @param {?} nodeId ID of the folder node
     * @param {?=} includeFields Extra information to include (available options are "aspectNames", "isLink" and "association")
     * @return {?} Details of the folder
     */
    getFolderNode(nodeId, includeFields = []) {
        /** @type {?} */
        let includeFieldsRequest = ['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames', ...includeFields]
            .filter((element, index, array) => index === array.indexOf(element));
        /** @type {?} */
        let opts = {
            includeSource: true,
            include: includeFieldsRequest
        };
        return from(this.apiService.getInstance().nodes.getNodeInfo(nodeId, opts));
    }
    /**
     * Get thumbnail URL for the given document node.
     * @param {?} node Node to get URL for.
     * @return {?} Thumbnail URL string
     */
    getDocumentThumbnailUrl(node) {
        return this.thumbnailService.getDocumentThumbnailUrl(node);
    }
    /**
     * Gets the icon that represents a MIME type.
     * @param {?} mimeType MIME type to get the icon for
     * @return {?} Path to the icon file
     */
    getMimeTypeIcon(mimeType) {
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    /**
     * Gets a default icon for MIME types with no specific icon.
     * @return {?} Path to the icon file
     */
    getDefaultMimeTypeIcon() {
        return this.thumbnailService.getDefaultMimeTypeIcon();
    }
    /**
     * Checks if a node has the specified permission.
     * @deprecated 2.3.0 - use the equivalent in the content service
     * @param {?} node Target node
     * @param {?} permission Permission level to query
     * @return {?} True if the node has the permission, false otherwise
     */
    hasPermission(node, permission) {
        return this.contentService.hasPermission(node, permission);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
DocumentListService.ROOT_ID = '-root-';
DocumentListService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DocumentListService.ctorParameters = () => [
    { type: AuthenticationService },
    { type: ContentService },
    { type: AlfrescoApiService },
    { type: LogService },
    { type: ThumbnailService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentNodeSelectorComponent {
    /**
     * @param {?} data
     */
    constructor(data) {
        this.data = data;
        /**
         * @deprecated in 2.1.0
         */
        this.title = null;
        /**
         * @deprecated in 2.1.0
         */
        this.currentFolderId = null;
        /**
         * @deprecated in 2.1.0
         */
        this.dropdownHideMyFiles = false;
        /**
         * @deprecated in 2.1.0
         */
        this.dropdownSiteList = null;
        /**
         * @deprecated in 2.1.0
         */
        this.rowFilter = null;
        /**
         * @deprecated in 2.1.0
         */
        this.imageResolver = null;
        this.buttonActionName = data.actionName ? `NODE_SELECTOR.${data.actionName.toUpperCase()}` : 'NODE_SELECTOR.CHOOSE';
    }
    /**
     * @return {?}
     */
    close() {
        this.data.select.complete();
    }
    /**
     * @param {?} nodeList
     * @return {?}
     */
    onSelect(nodeList) {
        this.chosenNode = nodeList;
    }
    /**
     * @return {?}
     */
    onClick() {
        this.data.select.next(this.chosenNode);
        this.data.select.complete();
    }
}
ContentNodeSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-node-selector',
                template: "<header\n    mat-dialog-title\n    data-automation-id=\"content-node-selector-title\">{{title || data?.title}}\n</header>\n\n<mat-dialog-content>\n    <adf-content-node-selector-panel\n        [currentFolderId]=\"currentFolderId || data?.currentFolderId\"\n        [dropdownHideMyFiles]=\"dropdownHideMyFiles || data?.dropdownHideMyFiles\"\n        [dropdownSiteList]=\"dropdownSiteList || data?.dropdownSiteList\"\n        [rowFilter]=\"rowFilter || data?.rowFilter\"\n        [imageResolver]=\"imageResolver || data?.imageResolver\"\n        [isSelectionValid]=\"data?.isSelectionValid\"\n        [breadcrumbTransform]=\"data?.breadcrumbTransform\"\n        (select)=\"onSelect($event)\">\n    </adf-content-node-selector-panel>\n</mat-dialog-content>\n\n<mat-dialog-actions align=\"end\">\n    <button\n        mat-button\n        (click)=\"close()\"\n        data-automation-id=\"content-node-selector-actions-cancel\">{{ 'NODE_SELECTOR.CANCEL' | translate }}\n    </button>\n\n    <button mat-button\n        [disabled]=\"!chosenNode\"\n        class=\"choose-action\"\n        (click)=\"onClick()\"\n        data-automation-id=\"content-node-selector-actions-choose\">{{ buttonActionName | translate }}\n    </button>\n</mat-dialog-actions>\n\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
ContentNodeSelectorComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
ContentNodeSelectorComponent.propDecorators = {
    title: [{ type: Input }],
    currentFolderId: [{ type: Input }],
    dropdownHideMyFiles: [{ type: Input }],
    dropdownSiteList: [{ type: Input }],
    rowFilter: [{ type: Input }],
    imageResolver: [{ type: Input }],
    pageSize: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NodeLockDialogComponent {
    /**
     * @param {?} formBuilder
     * @param {?} dialog
     * @param {?} alfrescoApi
     * @param {?} data
     */
    constructor(formBuilder, dialog, alfrescoApi, data) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.alfrescoApi = alfrescoApi;
        this.data = data;
        this.node = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        const { node } = this.data;
        this.nodeName = node.name;
        this.form = this.formBuilder.group({
            isLocked: node.isLocked || false,
            allowOwner: node.properties['cm:lockType'] === 'WRITE_LOCK',
            isTimeLock: !!node.properties['cm:expiryDate'],
            time: !!node.properties['cm:expiryDate'] ? moment$1(node.properties['cm:expiryDate']) : moment$1()
        });
    }
    /**
     * @return {?}
     */
    get lockTimeInSeconds() {
        if (this.form.value.isTimeLock) {
            /** @type {?} */
            let duration = moment$1.duration(moment$1(this.form.value.time).diff(moment$1()));
            return duration.asSeconds();
        }
        return 0;
    }
    /**
     * @return {?}
     */
    get nodeBodyLock() {
        return {
            'timeToExpire': this.lockTimeInSeconds,
            'type': this.form.value.allowOwner ? 'ALLOW_OWNER_CHANGES' : 'FULL',
            'lifetime': 'PERSISTENT'
        };
    }
    /**
     * @return {?}
     */
    toggleLock() {
        const { alfrescoApi: { nodesApi }, data: { node } } = this;
        if (this.form.value.isLocked) {
            return nodesApi.lockNode(node.id, this.nodeBodyLock);
        }
        return nodesApi.unlockNode(node.id);
    }
    /**
     * @return {?}
     */
    submit() {
        this.toggleLock()
            .then(node => {
            this.data.node.isLocked = this.form.value.isLocked;
            this.dialog.close(node.entry);
        })
            .catch(error => this.data.onError(error));
    }
}
NodeLockDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-node-lock',
                template: "<h2 mat-dialog-title>\n    {{ 'CORE.FILE_DIALOG.FILE_LOCK' | translate }}\n</h2>\n\n<mat-dialog-content>\n    <br />\n    <form [formGroup]=\"form\" (submit)=\"submit()\">\n        <mat-checkbox class=\"adf-lock-file-name\" [formControl]=\"form.controls['isLocked']\" ngDefaultControl>\n            {{ 'CORE.FILE_DIALOG.FILE_LOCK_CHECKBOX' | translate }} <strong>\"{{ nodeName }}\"</strong>\n        </mat-checkbox>\n\n        <br />\n\n        <div *ngIf=\"form.value.isLocked\">\n            <mat-checkbox class=\"adf-lock-file-name\" [formControl]=\"form.controls['allowOwner']\" ngDefaultControl>\n                {{ 'CORE.FILE_DIALOG.ALLOW_OTHERS_CHECKBOX' | translate }}\n            </mat-checkbox>\n\n            <br />\n\n            <mat-checkbox class=\"adf-lock-file-name\" [formControl]=\"form.controls['isTimeLock']\" ngDefaultControl>\n                {{ 'CORE.FILE_DIALOG.TIME_LOCK_CHECKBOX' | translate }}\n            </mat-checkbox>\n\n            <br />\n\n            <mat-form-field *ngIf=\"form.value.isTimeLock\">\n                <mat-datetimepicker-toggle [for]=\"datetimePicker\" matSuffix></mat-datetimepicker-toggle>\n                <mat-datetimepicker #datetimePicker type=\"datetime\" openOnFocus=\"true\" timeInterval=\"1\"></mat-datetimepicker>\n                <input matInput [formControl]=\"form.controls['time']\" [matDatetimepicker]=\"datetimePicker\" required autocomplete=\"false\">\n            </mat-form-field>\n        </div>\n    </form>\n    <br />\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-dialog-buttons\">\n    <span class=\"adf-fill-remaining-space\"></span>\n\n    <button mat-button mat-dialog-close>\n        {{ 'CORE.FILE_DIALOG.CANCEL_BUTTON.LABEL' | translate }}\n    </button>\n\n    <button class=\"adf-dialog-action-button\" mat-button (click)=\"submit()\">\n        {{ 'CORE.FILE_DIALOG.SAVE_BUTTON.LABEL' | translate }}\n    </button>\n</mat-dialog-actions>\n",
                styles: [".adf-fill-remaining-space{flex:1 1 auto}.adf-full-width,.adf-lock-file-name .mat-checkbox-layout{width:100%}.adf-lock-file-name .mat-checkbox-label{text-overflow:ellipsis;overflow:hidden}.adf-lock-file-name .mat-checkbox-inner-container{margin:auto 8px auto 0}"]
            }] }
];
/** @nocollapse */
NodeLockDialogComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: MatDialogRef },
    { type: AlfrescoApiService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentNodeDialogService {
    /**
     * @param {?} dialog
     * @param {?} contentService
     * @param {?} documentListService
     * @param {?} siteService
     * @param {?} translation
     */
    constructor(dialog, contentService, documentListService, siteService, translation) {
        this.dialog = dialog;
        this.contentService = contentService;
        this.documentListService = documentListService;
        this.siteService = siteService;
        this.translation = translation;
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * Opens a file browser at a chosen folder location.
     * @param {?} folderNodeId ID of the folder to use
     * @return {?} Information about the selected file(s)
     */
    openFileBrowseDialogByFolderId(folderNodeId) {
        return this.documentListService.getFolderNode(folderNodeId).pipe(switchMap((node) => {
            return this.openUploadFileDialog('Choose', node);
        }));
    }
    /**
     * Opens a lock node dialog.
     * @param {?} contentEntry Node to lock
     * @return {?} Error/status message (if any)
     */
    openLockNodeDialog(contentEntry) {
        /** @type {?} */
        const observable = new Subject();
        if (this.contentService.hasPermission(contentEntry, PermissionsEnum.LOCK)) {
            this.dialog.open(NodeLockDialogComponent, {
                data: {
                    node: contentEntry,
                    onError: (error) => {
                        this.error.emit(error);
                        observable.error(error);
                    }
                },
                width: '400px'
            });
        }
        else {
            observable.error('OPERATION.FAIL.NODE.NO_PERMISSION');
        }
        return observable;
    }
    /**
     * Opens a file browser at a chosen site location.
     * @return {?} Information about the selected file(s)
     */
    openFileBrowseDialogBySite() {
        return this.siteService.getSites().pipe(switchMap((response) => {
            return this.openFileBrowseDialogByFolderId(response.list.entries[0].entry.guid);
        }));
    }
    /**
     * Opens a folder browser at a chosen site location.
     * @return {?} Information about the selected folder(s)
     */
    openFolderBrowseDialogBySite() {
        return this.siteService.getSites().pipe(switchMap((response) => {
            return this.openFolderBrowseDialogByFolderId(response.list.entries[0].entry.guid);
        }));
    }
    /**
     * Opens a folder browser at a chosen folder location.
     * @param {?} folderNodeId ID of the folder to use
     * @return {?} Information about the selected folder(s)
     */
    openFolderBrowseDialogByFolderId(folderNodeId) {
        return this.documentListService.getFolderNode(folderNodeId).pipe(switchMap((node) => {
            return this.openUploadFolderDialog('Choose', node);
        }));
    }
    /**
     * Opens a dialog to copy or move an item to a new location.
     * @param {?} action Name of the action (eg, "Copy" or "Move") to show in the title
     * @param {?} contentEntry Item to be copied or moved
     * @param {?=} permission Permission for the operation
     * @return {?} Information about files that were copied/moved
     */
    openCopyMoveDialog(action, contentEntry, permission) {
        if (this.contentService.hasPermission(contentEntry, permission)) {
            /** @type {?} */
            const select = new Subject();
            select.subscribe({
                complete: this.close.bind(this)
            });
            /** @type {?} */
            const title = this.getTitleTranslation(action, contentEntry.name);
            /** @type {?} */
            const data = {
                title: title,
                actionName: action,
                currentFolderId: contentEntry.parentId,
                imageResolver: this.imageResolver.bind(this),
                rowFilter: this.rowFilter.bind(this, contentEntry.id),
                isSelectionValid: this.isCopyMoveSelectionValid.bind(this),
                select: select
            };
            this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
            return select;
        }
        else {
            /** @type {?} */
            let errors = new Error(JSON.stringify({ error: { statusCode: 403 } }));
            return throwError(errors);
        }
    }
    /**
     * Gets the translation of the dialog title.
     * @param {?} action Name of the action to display in the dialog title
     * @param {?} name Name of the item on which the action is being performed
     * @return {?} Translated version of the title
     */
    getTitleTranslation(action, name) {
        return this.translation.instant(`NODE_SELECTOR.${action.toUpperCase()}_ITEM`, { name });
    }
    /**
     * Opens a dialog to choose folders to upload.
     * @param {?} action Name of the action to show in the title
     * @param {?} contentEntry  Item to upload
     * @return {?} Information about the chosed folder(s)
     */
    openUploadFolderDialog(action, contentEntry) {
        /** @type {?} */
        const select = new Subject();
        select.subscribe({
            complete: this.close.bind(this)
        });
        /** @type {?} */
        const data = {
            title: `${action} '${contentEntry.name}' to ...`,
            actionName: action,
            currentFolderId: contentEntry.id,
            imageResolver: this.imageResolver.bind(this),
            isSelectionValid: this.hasPermissionOnNodeFolder.bind(this),
            rowFilter: this.rowFilter.bind(this, contentEntry.id),
            select: select
        };
        this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
        return select;
    }
    /**
     * Opens a dialog to choose a file to upload.
     * @param {?} action Name of the action to show in the title
     * @param {?} contentEntry Item to upload
     * @return {?} Information about the chosen file(s)
     */
    openUploadFileDialog(action, contentEntry) {
        /** @type {?} */
        const select = new Subject();
        select.subscribe({
            complete: this.close.bind(this)
        });
        /** @type {?} */
        const data = {
            title: `${action} '${contentEntry.name}' to ...`,
            actionName: action,
            currentFolderId: contentEntry.id,
            imageResolver: this.imageResolver.bind(this),
            isSelectionValid: this.isNodeFile.bind(this),
            select: select
        };
        this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '630px');
        return select;
    }
    /**
     * @param {?} data
     * @param {?} currentPanelClass
     * @param {?} chosenWidth
     * @return {?}
     */
    openContentNodeDialog(data, currentPanelClass, chosenWidth) {
        this.dialog.open(ContentNodeSelectorComponent, { data, panelClass: currentPanelClass, width: chosenWidth });
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    imageResolver(row, col) {
        /** @type {?} */
        const entry = row.node.entry;
        if (!this.contentService.hasPermission(entry, 'create')) {
            return this.documentListService.getMimeTypeIcon('disable/folder');
        }
        return null;
    }
    /**
     * @param {?} currentNodeId
     * @param {?} row
     * @return {?}
     */
    rowFilter(currentNodeId, row) {
        /** @type {?} */
        const node = row.node.entry;
        if (node.id === currentNodeId || node.isFile) {
            return false;
        }
        else {
            return true;
        }
    }
    /**
     * @param {?} entry
     * @return {?}
     */
    isNodeFile(entry) {
        return entry.isFile;
    }
    /**
     * @param {?} entry
     * @return {?}
     */
    hasPermissionOnNodeFolder(entry) {
        return this.isNodeFolder(entry) && this.contentService.hasPermission(entry, 'create');
    }
    /**
     * @param {?} entry
     * @return {?}
     */
    isNodeFolder(entry) {
        return entry.isFolder;
    }
    /**
     * @param {?} entry
     * @return {?}
     */
    isCopyMoveSelectionValid(entry) {
        return this.hasEntityCreatePermission(entry) && !this.isSite(entry);
    }
    /**
     * @param {?} entry
     * @return {?}
     */
    hasEntityCreatePermission(entry) {
        return this.contentService.hasPermission(entry, 'create');
    }
    /**
     * @param {?} entry
     * @return {?}
     */
    isSite(entry) {
        return !!entry.guid || entry.nodeType === 'st:site' || entry.nodeType === 'st:sites';
    }
    /**
     * Closes the currently open dialog.
     * @return {?}
     */
    close() {
        this.dialog.closeAll();
    }
}
ContentNodeDialogService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ContentNodeDialogService.ctorParameters = () => [
    { type: MatDialog },
    { type: ContentService },
    { type: DocumentListService },
    { type: SitesService },
    { type: TranslationService }
];
ContentNodeDialogService.propDecorators = {
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NodeLockDirective {
    /**
     * @param {?} element
     * @param {?} renderer
     * @param {?} contentService
     * @param {?} contentNodeDialogService
     */
    constructor(element, renderer, contentService, contentNodeDialogService) {
        this.element = element;
        this.renderer = renderer;
        this.contentService = contentService;
        this.contentNodeDialogService = contentNodeDialogService;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        event.preventDefault();
        this.contentNodeDialogService.openLockNodeDialog(this.node);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const hasPermission = this.contentService.hasPermission(this.node, PermissionsEnum.LOCK);
        this.renderer.setProperty(this.element.nativeElement, 'disabled', !hasPermission);
    }
}
NodeLockDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-node-lock]'
            },] }
];
/** @nocollapse */
NodeLockDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ContentService },
    { type: ContentNodeDialogService }
];
NodeLockDirective.propDecorators = {
    node: [{ type: Input, args: ['adf-node-lock',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentDirectiveModule {
}
ContentDirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    NodeDownloadDirective,
                    NodeLockDirective
                ],
                exports: [
                    NodeDownloadDirective,
                    NodeLockDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RatingService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * Gets the current user's rating for a node.
     * @param {?} nodeId Node to get the rating from
     * @param {?} ratingType Type of rating (can be "likes" or "fiveStar")
     * @return {?} The rating value
     */
    getRating(nodeId, ratingType) {
        return from(this.apiService.getInstance().core.ratingsApi.getRating(nodeId, ratingType))
            .pipe(catchError(this.handleError));
    }
    /**
     * Adds the current user's rating for a node.
     * @param {?} nodeId Target node for the rating
     * @param {?} ratingType Type of rating (can be "likes" or "fiveStar")
     * @param {?} vote Rating value (boolean for "likes", numeric 0..5 for "fiveStar")
     * @return {?} Details about the rating, including the new value
     */
    postRating(nodeId, ratingType, vote) {
        /** @type {?} */
        let ratingBody = {
            'id': ratingType,
            'myRating': vote
        };
        return from(this.apiService.getInstance().core.ratingsApi.rate(nodeId, ratingBody))
            .pipe(catchError(this.handleError));
    }
    /**
     * Removes the current user's rating for a node.
     * @param {?} nodeId Target node
     * @param {?} ratingType Type of rating to remove (can be "likes" or "fiveStar")
     * @return {?} Null response indicating that the operation is complete
     */
    deleteRating(nodeId, ratingType) {
        return from(this.apiService.getInstance().core.ratingsApi.removeRating(nodeId, ratingType))
            .pipe(catchError(this.handleError));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        console.error(error);
        return throwError(error || 'Server error');
    }
}
RatingService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RatingService.ctorParameters = () => [
    { type: AlfrescoApiService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RatingComponent {
    /**
     * @param {?} ratingService
     */
    constructor(ratingService) {
        this.ratingService = ratingService;
        this.average = 0;
        this.ratingType = 'fiveStar';
        /**
         * Emitted when the "vote" gets changed.
         */
        this.changeVote = new EventEmitter();
        this.stars = [];
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        /** @type {?} */
        let ratingObserver = this.ratingService.getRating(this.nodeId, this.ratingType);
        ratingObserver.subscribe((data) => {
            if (data.entry.aggregate) {
                this.average = data.entry.aggregate.average;
                this.calculateStars();
            }
        });
        return ratingObserver;
    }
    /**
     * @return {?}
     */
    calculateStars() {
        this.stars = [];
        for (let i = 0; i < 5; i++) {
            if (i < this.average) {
                this.stars.push({ fill: true });
            }
            else {
                this.stars.push({ fill: false });
            }
        }
        this.changeVote.emit(this.average);
    }
    /**
     * @param {?} vote
     * @return {?}
     */
    updateVote(vote) {
        this.ratingService.postRating(this.nodeId, this.ratingType, vote).subscribe((data) => {
            if (data.entry.aggregate) {
                if (this.average !== data.entry.aggregate.average) {
                    this.average = data.entry.aggregate.average;
                    this.calculateStars();
                }
            }
        });
    }
}
RatingComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-rating',
                template: "<mat-list id=\"adf-rating-container\" class=\"adf-rating-container\">\n    <mat-list-item class=\"adf-rating-star\" *ngFor=\"let currentRate of stars; let idx = index\">\n            <span id=\"adf-rate-{{idx}}\">\n                <mat-icon id=\"adf-grey-star-{{idx}}\" *ngIf=\"currentRate.fill\" class=\"adf-colored-star\"\n                         (click)=\"updateVote(idx + 1)\">star_rate\n                </mat-icon>\n                <mat-icon id=\"adf-colored-star-{{idx}}\" *ngIf=\"!currentRate.fill\" class=\"adf-grey-star\"\n                         (click)=\"updateVote(idx + 1)\">star_border\n                </mat-icon>\n            </span>\n    </mat-list-item>\n</mat-list>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-rating-container{overflow:hidden;width:100%}.adf-rating-container .adf-rating-star{float:left;transition:.3s;padding:1px;cursor:pointer}.adf-rating-container .adf-rating-star .mat-list-item-content{padding:0 2px!important}.adf-rating-container .adf-colored-star{color:#ffe944}.adf-rating-container .adf-grey-star{color:grey}.adf-rating-container .adf-stars-container{padding:0!important;margin:0!important;display:inline-block}.adf-rating-container .adf-rating-star:hover{-webkit-transform:rotate(13deg) scale(1.2);transform:rotate(13deg) scale(1.2)}"]
            }] }
];
/** @nocollapse */
RatingComponent.ctorParameters = () => [
    { type: RatingService }
];
RatingComponent.propDecorators = {
    nodeId: [{ type: Input }],
    changeVote: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class LikeComponent {
    /**
     * @param {?} ratingService
     */
    constructor(ratingService) {
        this.ratingService = ratingService;
        /**
         * Emitted when the "vote" gets changed.
         */
        this.changeVote = new EventEmitter();
        this.likesCounter = 0;
        this.ratingType = 'likes';
        this.isLike = false;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.clean();
        this.ratingService.getRating(this.nodeId, this.ratingType).subscribe((data) => {
            if (data.entry.aggregate) {
                this.likesCounter = data.entry.aggregate.numberOfRatings;
                if (data.entry.ratedAt) {
                    this.isLike = true;
                }
            }
        });
    }
    /**
     * @return {?}
     */
    likeClick() {
        if (this.isLike) {
            this.ratingService.deleteRating(this.nodeId, this.ratingType).subscribe(() => {
                this.likesCounter -= 1;
                this.isLike = false;
                this.changeVote.emit(this.likesCounter);
            });
        }
        else {
            this.ratingService.postRating(this.nodeId, this.ratingType, true).subscribe((data) => {
                this.likesCounter = data.entry.aggregate.numberOfRatings;
                this.isLike = true;
                this.changeVote.emit(this.likesCounter);
            });
        }
    }
    /**
     * @return {?}
     */
    clean() {
        this.isLike = false;
        this.likesCounter = 0;
    }
}
LikeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-like',
                template: "<div id=\"adf-like-container\" class=\"adf-like-container\">\n    <div class=\"adf-like\">\n        <span id=\"adf-like-{{nodeId}}\" [ngClass]=\"{'adf-like-select': isLike ,'adf-like-grey': !isLike  }\"\n              (click)=\"likeClick()\">\n            <mat-icon>thumb_up</mat-icon>\n        </span>\n    </div>\n    <div id=\"adf-like-counter\" class=\"adf-like-counter\">{{likesCounter}}</div>\n    <div class=\"adf-left\" *ngIf=\"likesCounter<=1\">Like</div>\n    <div class=\"adf-left\" *ngIf=\"likesCounter>1\">Likes</div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-like-container{overflow:hidden;width:100%}.adf-like-container .adf-like{padding:5px;cursor:pointer;float:left;margin:5px 0 5px 5px}.adf-like-container .adf-like-select{cursor:pointer;color:#2196f3}.adf-like-container .adf-like-grey,.adf-like-container .adf-like-select:hover{cursor:pointer;color:grey}.adf-like-container .adf-like-grey:hover{cursor:pointer;color:#2196f3}.adf-like-container .adf-like-counter{float:left;padding:13px 0 0}.adf-like-container .adf-left{float:left;padding:13px 0 0 4px}"]
            }] }
];
/** @nocollapse */
LikeComponent.ctorParameters = () => [
    { type: RatingService }
];
LikeComponent.propDecorators = {
    nodeId: [{ type: Input }],
    changeVote: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SocialModule {
}
SocialModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                exports: [
                    RatingComponent,
                    LikeComponent
                ],
                declarations: [
                    RatingComponent,
                    LikeComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TagService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        /**
         * Emitted when tag information is updated.
         */
        this.refresh = new EventEmitter();
    }
    /**
     * Gets a list of tags added to a node.
     * @param {?} nodeId ID of the target node
     * @return {?} TagPaging object (defined in JSAPI) containing the tags
     */
    getTagsByNodeId(nodeId) {
        return from(this.apiService.getInstance().core.tagsApi.getNodeTags(nodeId)).pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Gets a list of all the tags already defined in the repository.
     * @param {?=} opts Options supported by JSAPI
     * @return {?} TagPaging object (defined in JSAPI) containing the tags
     */
    getAllTheTags(opts) {
        return from(this.apiService.getInstance().core.tagsApi.getTags(opts))
            .pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Adds a tag to a node.
     * @param {?} nodeId ID of the target node
     * @param {?} tagName Name of the tag to add
     * @return {?} TagEntry object (defined in JSAPI) with details of the new tag
     */
    addTag(nodeId, tagName) {
        /** @type {?} */
        const alfrescoApi = this.apiService.getInstance();
        /** @type {?} */
        const tagBody = new alfrescoApi.core.TagBody();
        tagBody.tag = tagName;
        /** @type {?} */
        let promiseAdd = from(this.apiService.getInstance().core.tagsApi.addTag(nodeId, tagBody));
        promiseAdd.subscribe((data) => {
            this.refresh.emit(data);
        }, (err) => {
            this.handleError(err);
        });
        return promiseAdd;
    }
    /**
     * Removes a tag from a node.
     * @param {?} nodeId ID of the target node
     * @param {?} tag Name of the tag to remove
     * @return {?} Null object when the operation completes
     */
    removeTag(nodeId, tag) {
        /** @type {?} */
        const promiseRemove = from(this.apiService.getInstance().core.tagsApi.removeTag(nodeId, tag));
        promiseRemove.subscribe((data) => {
            this.refresh.emit(data);
        }, (err) => {
            this.handleError(err);
        });
        return promiseRemove;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
TagService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TagService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
TagService.propDecorators = {
    refresh: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * This component, provide a list of the tags relative a node with actions button to add or remove new tag
 */
class TagActionsComponent {
    /**
     * @param {?} tagService
     * @param {?} translateService
     */
    constructor(tagService, translateService) {
        this.tagService = tagService;
        this.translateService = translateService;
        /**
         * Emitted when a tag is added successfully.
         */
        this.successAdd = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when an action is chosen.
         */
        this.result = new EventEmitter();
        this.disableAddTag = true;
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.tagService.refresh.subscribe(() => {
            this.refreshTag();
        }));
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        return this.refreshTag();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(subscription => subscription.unsubscribe());
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    refreshTag() {
        if (this.nodeId) {
            this.tagService.getTagsByNodeId(this.nodeId).subscribe((data) => {
                this.tagsEntries = data.list.entries;
                this.disableAddTag = false;
                this.result.emit(this.tagsEntries);
            }, () => {
                this.tagsEntries = null;
                this.disableAddTag = true;
                this.result.emit(this.tagsEntries);
            });
        }
    }
    /**
     * @return {?}
     */
    addTag() {
        if (this.searchTag(this.newTagName)) {
            this.translateService.get('TAG.MESSAGES.EXIST').subscribe((error) => {
                this.errorMsg = error;
            });
            this.error.emit(this.errorMsg);
        }
        else {
            this.tagService.addTag(this.nodeId, this.newTagName).subscribe(() => {
                this.newTagName = '';
                this.successAdd.emit(this.nodeId);
            });
        }
    }
    /**
     * @param {?} searchTagName
     * @return {?}
     */
    searchTag(searchTagName) {
        if (this.tagsEntries) {
            return this.tagsEntries.find((currentTag) => {
                return (searchTagName === currentTag.entry.tag);
            });
        }
    }
    /**
     * @return {?}
     */
    cleanErrorMsg() {
        this.errorMsg = '';
    }
    /**
     * @param {?} tag
     * @return {?}
     */
    removeTag(tag) {
        this.tagService.removeTag(this.nodeId, tag);
    }
}
TagActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tag-node-actions-list',
                template: "<mat-list>\n    <mat-list-item *ngFor=\"let currentEntry of tagsEntries; let idx = index\">\n        <div class=\"adf-tag-actions-container\" id=\"tag_delete_{{currentEntry.entry.tag}}\" (click)=\"removeTag(currentEntry.entry.id)\">\n            <div class=\"adf-tag-actions-delete-text\" id=\"tag_name_{{currentEntry.entry.tag}}\">\n                {{currentEntry.entry.tag}}\n            </div>\n            <mat-icon class=\"adf-tag-actions-delete-icon\">delete</mat-icon>\n        </div>\n    </mat-list-item>\n</mat-list>\n<table class=\"adf-full-width\" cellspacing=\"0\">\n    <tr>\n        <td>\n            <mat-form-field class=\"adf-full-width\">\n                <input matInput placeholder=\"{{'TAG.LABEL.NEWTAG' | translate }}\"\n                       type=\"text\"\n                       (keypress)=\"cleanErrorMsg()\"\n                       [(ngModel)]=\"newTagName\"\n                       id=\"new-tag-text\"/>\n                <mat-hint data-automation-id=\"errorMessage\" *ngIf=\"error\" [ngStyle]=\"{'color': 'red'}\" align=\"start\">{{errorMsg}}</mat-hint>\n            </mat-form-field>\n        </td>\n        <td>\n            <button class=\"adf-full-width\" color=\"primary\" id=\"add-tag\" (click)=\"addTag()\" [disabled]=\"disableAddTag\"\n                    mat-raised-button>\n                {{'TAG.BUTTON.ADD' | translate }}\n            </button>\n        </td>\n    </tr>\n</table>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-full-width{width:100%}.adf-tag-actions-delete-icon{float:right;cursor:pointer}.adf-tag-actions-delete-text{font-size:16px;float:left}.adf-tag-actions-container{padding:8px 0;height:20px}"]
            }] }
];
/** @nocollapse */
TagActionsComponent.ctorParameters = () => [
    { type: TagService },
    { type: TranslationService }
];
TagActionsComponent.propDecorators = {
    nodeId: [{ type: Input }],
    successAdd: [{ type: Output }],
    error: [{ type: Output }],
    result: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This component provide a list of all the tag inside the ECM
 */
class TagListComponent {
    /**
     * Constructor
     * @param {?} tagService
     */
    constructor(tagService) {
        this.tagService = tagService;
        /**
         * Emitted when a tag is selected.
         */
        this.result = new EventEmitter();
        /**
         * Array of tags that are displayed
         */
        this.tagsEntries = [];
        /**
         * Number of items per iteration
         */
        this.size = 10;
        this.isLoading = false;
        this.isSizeMinimum = true;
        this.defaultPagination = {
            skipCount: 0,
            maxItems: this.size,
            hasMoreItems: false
        };
        this.pagination = this.defaultPagination;
        this.tagService.refresh.subscribe(() => {
            this.tagsEntries = [];
            this.refreshTag(this.defaultPagination);
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        return this.refreshTag(this.defaultPagination);
    }
    /**
     * @param {?=} opts
     * @return {?}
     */
    refreshTag(opts) {
        this.tagService.getAllTheTags(opts).subscribe((tags) => {
            this.tagsEntries = this.tagsEntries.concat(tags.list.entries);
            this.pagination = tags.list.pagination;
            this.result.emit(this.tagsEntries);
            this.isLoading = false;
        });
    }
    /**
     * @return {?}
     */
    loadMoreTags() {
        if (this.pagination.hasMoreItems) {
            this.isLoading = true;
            this.isSizeMinimum = false;
            this.refreshTag({
                skipCount: this.pagination.skipCount + this.pagination.count,
                maxItems: this.size
            });
        }
    }
    /**
     * @return {?}
     */
    loadLessTags() {
        this.isSizeMinimum = false;
        this.tagsEntries = this.tagsEntries.slice(0, this.tagsEntries.length - this.pagination.count);
        this.pagination.skipCount = this.pagination.skipCount - this.pagination.count;
        this.pagination.hasMoreItems = true;
        if (this.tagsEntries.length <= this.size) {
            this.isSizeMinimum = true;
        }
    }
}
TagListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tag-list',
                template: "<mat-chip-list class=\"adf-tag-chips-list\">\n    <div class=\"adf-list-tag\" *ngFor=\"let currentEntry of tagsEntries; let idx = index\">\n        <mat-chip class=\"adf-primary-background-color\">\n            <span id=\"tag_name_{{idx}}\">{{currentEntry.entry.tag}}</span>\n        </mat-chip>\n    </div>\n</mat-chip-list>\n\n<div class=\"adf-tag-list-controls\">\n    <button\n        *ngIf=\"!isSizeMinimum\"\n        [disabled]=\"isLoading\"\n        data-automation-id=\"show-fewer-tags\"\n        mat-icon-button\n        (click)=\"loadLessTags()\">\n        <mat-icon>keyboard_arrow_up</mat-icon>\n    </button>\n    <button\n        *ngIf=\"pagination.hasMoreItems\"\n        [disabled]=\"isLoading\"\n        data-automation-id=\"show-more-tags\"\n        mat-icon-button\n        (click)=\"loadMoreTags()\">\n        <mat-icon>keyboard_arrow_down</mat-icon>\n    </button>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-tag-chips-list,.adf-tag-chips-list div{display:flex;flex-direction:column}.adf-list-tag{display:block;font-size:16px}.adf-tag-list-controls{margin-top:30px;display:flex;justify-content:center}"]
            }] }
];
/** @nocollapse */
TagListComponent.ctorParameters = () => [
    { type: TagService }
];
TagListComponent.propDecorators = {
    result: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * This component, ShowNodeTag a list of the tag on relative a node
 */
class TagNodeListComponent {
    /**
     * Constructor
     * @param {?} tagService
     */
    constructor(tagService) {
        this.tagService = tagService;
        /**
         * Show delete button
         */
        this.showDelete = true;
        /**
         * Emitted when a tag is selected.
         */
        this.results = new EventEmitter();
        this.tagService.refresh.subscribe(() => {
            this.refreshTag();
        });
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        return this.refreshTag();
    }
    /**
     * @return {?}
     */
    refreshTag() {
        if (this.nodeId) {
            this.tagService.getTagsByNodeId(this.nodeId).subscribe((data) => {
                this.tagsEntries = data.list.entries;
                this.results.emit(this.tagsEntries);
            });
        }
    }
    /**
     * @param {?} tag
     * @return {?}
     */
    removeTag(tag) {
        this.tagService.removeTag(this.nodeId, tag).subscribe(() => {
            this.refreshTag();
        });
    }
}
TagNodeListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tag-node-list',
                template: "<mat-chip-list>\n    <mat-chip class=\"adf-tag-chips adf-primary-background-color\" *ngFor=\"let currentEntry of tagsEntries; let idx = index\">\n        <span id=\"tag_name_{{idx}}\">{{currentEntry.entry.tag}}</span>\n        <button *ngIf=\"showDelete\" class=\"adf-tag-chips-delete\" id=\"tag_chips_delete_{{currentEntry.entry.tag}}\" type=\"button\" (click)=\"removeTag(currentEntry.entry.id)\">\n            <mat-icon class=\"adf-tag-chips-delete-icon adf-primary-contrast-text-color\" matChipRemove>cancel</mat-icon>\n        </button>\n    </mat-chip>\n</mat-chip-list>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-tag-chips-delete{overflow:visible;cursor:pointer;height:17px;width:20px;float:right;border:0;background:0 0;padding:0;margin:-1px 0 0 10px}.adf-tag-chips-delete-icon{font-size:20px;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:20px;width:20px}"]
            }] }
];
/** @nocollapse */
TagNodeListComponent.ctorParameters = () => [
    { type: TagService }
];
TagNodeListComponent.propDecorators = {
    nodeId: [{ type: Input }],
    showDelete: [{ type: Input }],
    results: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TagModule {
}
TagModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CoreModule.forChild()
                ],
                exports: [
                    TagActionsComponent,
                    TagListComponent,
                    TagNodeListComponent
                ],
                declarations: [
                    TagActionsComponent,
                    TagListComponent,
                    TagNodeListComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * <adf-webscript-get [scriptPath]="string"
 *                         [scriptArgs]="Object"
 *                         [contextRoot]="string"
 *                         [servicePath]="string"
 *                         [contentType]="JSON|HTML|DATATABLE"
 *                         (success)="customMethod($event)>
 * </adf-webscript-get>
 *
 * This component, provide a get webscript viewer
 *
 * \@InputParam {string} scriptPath path to Web Script (as defined by Web Script)
 * \@InputParam {Object} scriptArgs arguments to pass to Web Script
 * \@InputParam {string} contextRoot path where application is deployed default value 'alfresco'
 * \@InputParam {string} servicePath path where Web Script service is mapped default value 'service'
 * \@InputParam {string} contentType JSON | HTML | DATATABLE | TEXT
 *
 * \@Output - success - The event is emitted when the data are recived
 *
 */
class WebscriptComponent {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        /**
         * Toggles whether to show or hide the data.
         */
        this.showData = true;
        /**
         * Path where the application is deployed
         */
        this.contextRoot = 'alfresco';
        /**
         * Path that the webscript service is mapped to.
         */
        this.servicePath = 'service';
        /**
         * Content type to interpret the data received from the webscript.
         * Can be "JSON" , "HTML" , "DATATABLE" or "TEXT"
         */
        this.contentType = 'TEXT';
        /**
         * Emitted when the operation succeeds. You can get the plain data from
         * the webscript through the **success** event parameter and use it as you
         * need in your application.
         */
        this.success = new EventEmitter();
        this.data = undefined;
        this.showError = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.showData) {
            this.clean();
        }
        return new Promise((resolve, reject) => {
            this.apiService.getInstance().webScript.executeWebScript('GET', this.scriptPath, this.scriptArgs, this.contextRoot, this.servicePath).then((webScriptdata) => {
                this.data = webScriptdata;
                if (this.showData) {
                    if (this.contentType === 'DATATABLE') {
                        this.data = this.showDataAsDataTable(webScriptdata);
                    }
                }
                this.success.emit(this.data);
                resolve();
            }, (error) => {
                this.logService.log('Error' + error);
                reject();
            });
        });
    }
    /**
     * show the data in a ng2-alfresco-datatable
     *
     * \@retutns the data as datatable
     * @param {?} data
     *
     * @return {?}
     */
    showDataAsDataTable(data) {
        /** @type {?} */
        let datatableData = null;
        try {
            if (!data.schema) {
                data.schema = ObjectDataTableAdapter.generateSchema(data.data);
            }
            if (data.schema && data.schema.length > 0) {
                this.data = new ObjectDataTableAdapter(data.data, data.schema);
            }
        }
        catch (e) {
            this.logService.error('error during the cast as datatable');
        }
        return datatableData;
    }
    /**
     * @return {?}
     */
    clean() {
        this.data = undefined;
    }
    /**
     * @return {?}
     */
    isDataTableContent() {
        return this.contentType === 'DATATABLE';
    }
}
WebscriptComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-webscript-get',
                template: "<div *ngIf=\"showData\">\n    <div *ngIf=\"contentType === 'JSON'\" id=\"webscript-data-JSON\">{{data | json}}</div>\n    <div *ngIf=\"contentType === 'HTML'\" id=\"webscript-data-HTML\" [innerHTML]=\"data\"></div>\n    <div *ngIf=\"contentType === 'TEXT'\" id=\"webscript-data-TEXT\">{{data}}</div>\n    <div *ngIf=\"isDataTableContent()\">\n        <adf-datatable id=\"webscript-datatable-wrapper\" [data]=\"data\"></adf-datatable>\n        <div>\n            <div *ngIf=\"showError\" id=\"error\">{{'WEBSCRIPT.ERROR' | translate: {\n                data: data,\n                contentType: contentType\n                }\n                }}\n            </div>\n        </div>\n    </div>\n</div>\n"
            }] }
];
/** @nocollapse */
WebscriptComponent.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
WebscriptComponent.propDecorators = {
    scriptPath: [{ type: Input }],
    scriptArgs: [{ type: Input }],
    showData: [{ type: Input }],
    contextRoot: [{ type: Input }],
    servicePath: [{ type: Input }],
    contentType: [{ type: Input }],
    success: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class WebScriptModule {
}
WebScriptModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    CoreModule.forChild()
                ],
                exports: [
                    WebscriptComponent
                ],
                declarations: [
                    WebscriptComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ShareDataRow {
    /**
     * @param {?} obj
     * @param {?} documentListService
     * @param {?} permissionsStyle
     * @param {?=} thumbnailService
     */
    constructor(obj, documentListService, permissionsStyle, thumbnailService) {
        this.obj = obj;
        this.documentListService = documentListService;
        this.permissionsStyle = permissionsStyle;
        this.thumbnailService = thumbnailService;
        this.cache = {};
        this.isSelected = false;
        this.cssClass = '';
        if (!obj) {
            throw new Error(ShareDataRow.ERR_OBJECT_NOT_FOUND);
        }
        this.isDropTarget = this.isFolderAndHasPermissionToUpload(obj);
        if (permissionsStyle) {
            this.cssClass = this.getPermissionClass(obj);
        }
    }
    /**
     * @return {?}
     */
    get node() {
        return this.obj;
    }
    /**
     * @param {?} nodeEntity
     * @return {?}
     */
    getPermissionClass(nodeEntity) {
        /** @type {?} */
        let permissionsClasses = '';
        this.permissionsStyle.forEach((currentPermissionsStyle) => {
            if (this.applyPermissionStyleToFolder(nodeEntity.entry, currentPermissionsStyle) || this.applyPermissionStyleToFile(nodeEntity.entry, currentPermissionsStyle)) {
                if (this.documentListService.hasPermission(nodeEntity.entry, currentPermissionsStyle.permission)) {
                    permissionsClasses += ` ${currentPermissionsStyle.css}`;
                }
            }
        });
        return permissionsClasses;
    }
    /**
     * @param {?} node
     * @param {?} currentPermissionsStyle
     * @return {?}
     */
    applyPermissionStyleToFile(node, currentPermissionsStyle) {
        return (currentPermissionsStyle.isFile && node.isFile);
    }
    /**
     * @param {?} node
     * @param {?} currentPermissionsStyle
     * @return {?}
     */
    applyPermissionStyleToFolder(node, currentPermissionsStyle) {
        return (currentPermissionsStyle.isFolder && node.isFolder);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    isFolderAndHasPermissionToUpload(obj) {
        return this.isFolder(obj) && this.documentListService.hasPermission(obj.entry, 'create');
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    isFolder(obj) {
        return obj.entry && obj.entry.isFolder;
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    cacheValue(key, value) {
        this.cache[key] = value;
        return value;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getValue(key) {
        if (this.cache[key] !== undefined) {
            return this.cache[key];
        }
        return ObjectUtils.getValue(this.obj.entry, key);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    imageErrorResolver(event) {
        return this.thumbnailService.getMimeTypeIcon(this.obj.entry.content.mimeType);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    hasValue(key) {
        return this.getValue(key) !== undefined;
    }
}
ShareDataRow.ERR_OBJECT_NOT_FOUND = 'Object source not found';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ShareDataTableAdapter {
    /**
     * @param {?} documentListService
     * @param {?} thumbnailService
     * @param {?=} schema
     * @param {?=} sorting
     * @param {?=} sortingMode
     */
    constructor(documentListService, thumbnailService, schema = [], sorting, sortingMode = 'client') {
        this.documentListService = documentListService;
        this.thumbnailService = thumbnailService;
        this.ERR_ROW_NOT_FOUND = 'Row not found';
        this.ERR_COL_NOT_FOUND = 'Column not found';
        this.thumbnails = false;
        this.rows = [];
        this.columns = schema || [];
        this.sorting = sorting;
        this.sortingMode = sortingMode;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set sortingMode(value) {
        /** @type {?} */
        let newValue = (value || 'client').toLowerCase();
        if (newValue !== 'client' && newValue !== 'server') {
            newValue = 'client';
        }
        this._sortingMode = newValue;
    }
    /**
     * @return {?}
     */
    get sortingMode() {
        return this._sortingMode;
    }
    /**
     * @return {?}
     */
    getRows() {
        return this.rows;
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    setRows(rows) {
        this.rows = rows || [];
        this.sort();
    }
    /**
     * @return {?}
     */
    getColumns() {
        return this.columns;
    }
    /**
     * @param {?} columns
     * @return {?}
     */
    setColumns(columns) {
        this.columns = columns || [];
    }
    /**
     * @param {?} row
     * @param {?} col
     * @return {?}
     */
    getValue(row, col) {
        if (!row) {
            throw new Error(this.ERR_ROW_NOT_FOUND);
        }
        if (!col) {
            throw new Error(this.ERR_COL_NOT_FOUND);
        }
        /** @type {?} */
        let dataRow = /** @type {?} */ (row);
        /** @type {?} */
        let value = row.getValue(col.key);
        if (dataRow.cache[col.key] !== undefined) {
            return dataRow.cache[col.key];
        }
        if (col.key === '$thumbnail') {
            if (this.imageResolver) {
                /** @type {?} */
                let resolved = this.imageResolver(row, col);
                if (resolved) {
                    return resolved;
                }
            }
            /** @type {?} */
            const node = (/** @type {?} */ (row)).node;
            if (node.entry.isFolder) {
                if (this.isSmartFolder(node)) {
                    return this.documentListService.getMimeTypeIcon('smartFolder');
                }
                else {
                    return this.documentListService.getMimeTypeIcon('folder');
                }
            }
            if (node.entry.isFile) {
                if (this.thumbnails) {
                    return this.documentListService.getDocumentThumbnailUrl(node);
                }
            }
            if (node.entry.content) {
                /** @type {?} */
                const mimeType = node.entry.content.mimeType;
                if (mimeType) {
                    return this.documentListService.getMimeTypeIcon(mimeType);
                }
            }
            return this.documentListService.getDefaultMimeTypeIcon();
        }
        if (col.type === 'image') {
            if (this.imageResolver) {
                /** @type {?} */
                let resolved = this.imageResolver(row, col);
                if (resolved) {
                    return resolved;
                }
            }
        }
        return dataRow.cacheValue(col.key, value);
    }
    /**
     * @return {?}
     */
    getSorting() {
        return this.sorting;
    }
    /**
     * @param {?} sorting
     * @return {?}
     */
    setSorting(sorting) {
        this.sorting = sorting;
        this.sortRows(this.rows, this.sorting);
    }
    /**
     * @param {?=} key
     * @param {?=} direction
     * @return {?}
     */
    sort(key, direction) {
        /** @type {?} */
        let sorting = this.sorting || new DataSorting();
        if (key) {
            sorting.key = key;
            sorting.direction = direction || 'asc';
        }
        this.setSorting(sorting);
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    setFilter(filter$$1) {
        this.filter = filter$$1;
    }
    /**
     * @param {?} resolver
     * @return {?}
     */
    setImageResolver(resolver) {
        this.imageResolver = resolver;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isSmartFolder(node) {
        /** @type {?} */
        let nodeAspects = this.getNodeAspectNames(node);
        return nodeAspects.indexOf('smf:customConfigSmartFolder') > -1 ||
            (nodeAspects.indexOf('smf:systemConfigSmartFolder') > -1);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getNodeAspectNames(node) {
        return node.entry && node.entry.aspectNames ? node.entry.aspectNames : node.aspectNames ? node.aspectNames : [];
    }
    /**
     * @param {?} rows
     * @param {?} sorting
     * @return {?}
     */
    sortRows(rows, sorting) {
        if (this.sortingMode === 'server') {
            return;
        }
        /** @type {?} */
        const options = {};
        if (sorting && sorting.key && rows && rows.length > 0) {
            if (sorting.key.includes('sizeInBytes') || sorting.key === 'name') {
                options.numeric = true;
            }
            rows.sort((a, b) => {
                if (a.node.entry.isFolder !== b.node.entry.isFolder) {
                    return a.node.entry.isFolder ? -1 : 1;
                }
                /** @type {?} */
                let left = a.getValue(sorting.key);
                if (left) {
                    left = (left instanceof Date) ? left.valueOf().toString() : left.toString();
                }
                else {
                    left = '';
                }
                /** @type {?} */
                let right = b.getValue(sorting.key);
                if (right) {
                    right = (right instanceof Date) ? right.valueOf().toString() : right.toString();
                }
                else {
                    right = '';
                }
                return sorting.direction === 'asc'
                    ? left.localeCompare(right, undefined, options)
                    : right.localeCompare(left, undefined, options);
            });
        }
    }
    /**
     * @param {?} page
     * @param {?=} merge
     * @return {?}
     */
    loadPage(page, merge$$1 = false) {
        /** @type {?} */
        let rows = [];
        if (page && page.list) {
            /** @type {?} */
            let data = page.list.entries;
            if (data && data.length > 0) {
                rows = data.map(item => new ShareDataRow(item, this.documentListService, this.permissionsStyle, this.thumbnailService));
                if (this.filter) {
                    rows = rows.filter(this.filter);
                }
                if (this.sortingMode !== 'server') {
                    // Sort by first sortable or just first column
                    if (this.columns && this.columns.length > 0) {
                        /** @type {?} */
                        let sorting = this.getSorting();
                        if (sorting) {
                            this.sortRows(rows, sorting);
                        }
                        else {
                            /** @type {?} */
                            let sortable = this.columns.filter(c => c.sortable);
                            if (sortable.length > 0) {
                                this.sort(sortable[0].key, 'asc');
                            }
                            else {
                                this.sort(this.columns[0].key, 'asc');
                            }
                        }
                    }
                }
            }
        }
        if (merge$$1) {
            /** @type {?} */
            let listPrunedDuplicate = rows.filter((elemntToFilter) => {
                /** @type {?} */
                let isPresent = this.rows.find((currenRow) => {
                    return currenRow.obj.entry.id === elemntToFilter.obj.entry.id;
                });
                return !isPresent;
            });
            this.rows = this.rows.concat(listPrunedDuplicate);
        }
        else {
            this.rows = rows;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
let presetsDefaultModel = {
    '-trashcan-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'archivedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.DELETED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'archivedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.DELETED_BY',
            sortable: true
        }
    ],
    '-sites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'title',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'visibility',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.STATUS',
            sortable: true
        }
    ],
    '-mysites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'title',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'visibility',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.STATUS',
            sortable: true
        }
    ],
    '-favorites-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        }
    ],
    '-recent-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            cssClass: 'ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        }
    ],
    '-sharedlinks-': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'path',
            type: 'location',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.LOCATION',
            cssClass: 'ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        },
        {
            key: 'sharedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SHARED_BY',
            sortable: true
        }
    ],
    'default': [
        {
            key: '$thumbnail',
            type: 'image',
            srTitle: 'ADF-DOCUMENT-LIST.LAYOUT.THUMBNAIL',
            sortable: false
        },
        {
            key: 'name',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.NAME',
            cssClass: 'full-width ellipsis-cell',
            sortable: true
        },
        {
            key: 'content.sizeInBytes',
            type: 'fileSize',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.SIZE',
            sortable: true
        },
        {
            key: 'modifiedAt',
            type: 'date',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_ON',
            format: 'timeAgo',
            sortable: true
        },
        {
            key: 'modifiedByUser.displayName',
            type: 'text',
            title: 'ADF-DOCUMENT-LIST.LAYOUT.MODIFIED_BY',
            sortable: true
        }
    ]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentActionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.disableWithNoPermission = false;
        this.disabled = false;
        this.visible = true;
        if (obj) {
            this.icon = obj.icon;
            this.title = obj.title;
            this.handler = obj.handler;
            this.execute = obj.execute;
            this.target = obj.target;
            this.permission = obj.permission;
            this.disableWithNoPermission = obj.disableWithNoPermission;
            if (obj.hasOwnProperty('disabled')) {
                this.disabled = obj.disabled;
            }
            if (obj.hasOwnProperty('visible')) {
                this.visible = obj.visible;
            }
        }
    }
}
/** @enum {string} */
const ContentActionTarget = {
    Document: 'document',
    Folder: 'folder',
    All: 'all',
};
class DocumentActionModel extends ContentActionModel {
    /**
     * @param {?=} json
     */
    constructor(json) {
        super(json);
        this.target = 'document';
    }
}
class FolderActionModel extends ContentActionModel {
    /**
     * @param {?=} json
     */
    constructor(json) {
        super(json);
        this.target = 'folder';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NodeEntityEvent extends BaseEvent {
    /**
     * @param {?} entity
     */
    constructor(entity) {
        super();
        this.value = entity;
    }
}
class NodeEntryEvent extends BaseEvent {
    /**
     * @param {?} entity
     */
    constructor(entity) {
        super();
        this.value = entity;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class CustomResourcesService {
    /**
     * @param {?} apiService
     * @param {?} logService
     */
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.CREATE_PERMISSION = 'create';
    }
    /**
     * Gets files recently accessed by a user.
     * @param {?} personId ID of the user
     * @param {?} pagination Specifies how to paginate the results
     * @return {?} List of nodes for the recently used files
     */
    getRecentFiles(personId, pagination) {
        return new Observable(observer => {
            this.apiService.peopleApi.getPerson(personId)
                .then((person) => {
                /** @type {?} */
                const username = person.entry.id;
                /** @type {?} */
                const query = {
                    query: {
                        query: '*',
                        language: 'afts'
                    },
                    filterQueries: [
                        { query: `cm:modified:[NOW/DAY-30DAYS TO NOW/DAY+1DAY]` },
                        { query: `cm:modifier:${username} OR cm:creator:${username}` },
                        { query: `TYPE:"content" AND -TYPE:"app:filelink" AND -TYPE:"fm:post"` }
                    ],
                    include: ['path', 'properties', 'allowableOperations'],
                    sort: [{
                            type: 'FIELD',
                            field: 'cm:modified',
                            ascending: false
                        }],
                    paging: {
                        maxItems: pagination.maxItems,
                        skipCount: pagination.skipCount
                    }
                };
                return this.apiService.searchApi.search(query)
                    .then((searchResult) => {
                    observer.next(searchResult);
                    observer.complete();
                }, (err) => {
                    observer.error(err);
                    observer.complete();
                });
            }, (err) => {
                observer.error(err);
                observer.complete();
            });
        }).pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Gets favorite files for the current user.
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of favorite files
     */
    loadFavorites(pagination, includeFields = []) {
        /** @type {?} */
        let includeFieldsRequest = this.getIncludesFields(includeFields);
        /** @type {?} */
        const options = {
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount,
            where: '(EXISTS(target/file) OR EXISTS(target/folder))',
            include: includeFieldsRequest
        };
        return new Observable(observer => {
            this.apiService.favoritesApi.getFavorites('-me-', options)
                .then((result) => {
                /** @type {?} */
                let page = {
                    list: {
                        entries: result.list.entries
                            .map(({ entry: { target } }) => ({
                            entry: target.file || target.folder
                        }))
                            .map(({ entry }) => {
                            entry.properties = {
                                'cm:title': entry.title,
                                'cm:description': entry.description
                            };
                            return { entry };
                        }),
                        pagination: result.list.pagination
                    }
                };
                observer.next(page);
                observer.complete();
            }, (err) => {
                observer.error(err);
                observer.complete();
            });
        }).pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Gets sites that the current user is a member of.
     * @param {?} pagination Specifies how to paginate the results
     * @return {?} List of sites
     */
    loadMemberSites(pagination) {
        /** @type {?} */
        const options = {
            include: ['properties'],
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return new Observable(observer => {
            this.apiService.peopleApi.getSiteMembership('-me-', options)
                .then((result) => {
                /** @type {?} */
                let page = {
                    list: {
                        entries: result.list.entries
                            .map(({ entry: { site } }) => {
                            site.allowableOperations = site.allowableOperations ? site.allowableOperations : [this.CREATE_PERMISSION];
                            site.name = site.name || site.title;
                            return {
                                entry: site
                            };
                        }),
                        pagination: result.list.pagination
                    }
                };
                observer.next(page);
                observer.complete();
            }, (err) => {
                observer.error(err);
                observer.complete();
            });
        }).pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Gets all sites in the respository.
     * @param {?} pagination Specifies how to paginate the results
     * @return {?} List of sites
     */
    loadSites(pagination) {
        /** @type {?} */
        const options = {
            include: ['properties', 'aspectNames'],
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return new Observable(observer => {
            this.apiService.sitesApi.getSites(options)
                .then((page) => {
                page.list.entries.map(({ entry }) => {
                    entry.name = entry.name || entry.title;
                    return { entry };
                });
                observer.next(page);
                observer.complete();
            }, (err) => {
                observer.error(err);
                observer.complete();
            });
        }).pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Gets all items currently in the trash.
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of deleted items
     */
    loadTrashcan(pagination, includeFields = []) {
        /** @type {?} */
        let includeFieldsRequest = this.getIncludesFields(includeFields);
        /** @type {?} */
        const options = {
            include: includeFieldsRequest,
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return from(this.apiService.nodesApi.getDeletedNodes(options))
            .pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Gets shared links for the current user.
     * @param {?} pagination Specifies how to paginate the results
     * @param {?=} includeFields List of data field names to include in the results
     * @return {?} List of shared links
     */
    loadSharedLinks(pagination, includeFields = []) {
        /** @type {?} */
        let includeFieldsRequest = this.getIncludesFields(includeFields);
        /** @type {?} */
        const options = {
            include: includeFieldsRequest,
            maxItems: pagination.maxItems,
            skipCount: pagination.skipCount
        };
        return from(this.apiService.sharedLinksApi.findSharedLinks(options))
            .pipe(catchError(err => this.handleError(err)));
    }
    /**
     * Is the folder ID one of the well-known aliases?
     * @param {?} folderId Folder ID name to check
     * @return {?} True if the ID is a well-known name, false otherwise
     */
    isCustomSource(folderId) {
        /** @type {?} */
        let isCustomSources = false;
        /** @type {?} */
        const sources = ['-trashcan-', '-sharedlinks-', '-sites-', '-mysites-', '-favorites-', '-recent-'];
        if (sources.indexOf(folderId) > -1) {
            isCustomSources = true;
        }
        return isCustomSources;
    }
    /**
     * Is the folder ID a "-my", "-root-", or "-shared-" alias?
     * @param {?} folderId Folder ID name to check
     * @return {?} True if the ID is one of the suppored sources, false otherwise
     */
    isSupportedSource(folderId) {
        /** @type {?} */
        let isSupportedSources = false;
        /** @type {?} */
        const sources = ['-my-', '-root-', '-shared-'];
        if (sources.indexOf(folderId) > -1) {
            isSupportedSources = true;
        }
        return isSupportedSources;
    }
    /**
     * Gets a folder's contents.
     * @param {?} nodeId ID of the target folder node
     * @param {?} pagination Specifies how to paginate the results
     * @param {?} includeFields List of data field names to include in the results
     * @return {?} List of items contained in the folder
     */
    loadFolderByNodeId(nodeId, pagination, includeFields) {
        if (nodeId === '-trashcan-') {
            return this.loadTrashcan(pagination, includeFields);
        }
        else if (nodeId === '-sharedlinks-') {
            return this.loadSharedLinks(pagination, includeFields);
        }
        else if (nodeId === '-sites-') {
            return this.loadSites(pagination);
        }
        else if (nodeId === '-mysites-') {
            return this.loadMemberSites(pagination);
        }
        else if (nodeId === '-favorites-') {
            return this.loadFavorites(pagination, includeFields);
        }
        else if (nodeId === '-recent-') {
            return this.getRecentFiles('-me-', pagination);
        }
    }
    /**
     * Gets the contents of one of the well-known aliases in the form of node ID strings.
     * @param {?} nodeId ID of the target folder node
     * @param {?=} pagination Specifies how to paginate the results
     * @return {?} List of node IDs
     */
    getCorrespondingNodeIds(nodeId, pagination = {}) {
        if (this.isCustomSource(nodeId)) {
            return this.loadFolderByNodeId(nodeId, pagination, [])
                .pipe(map(result => result.list.entries.map((node) => {
                if (nodeId === '-sharedlinks-') {
                    return node.entry.nodeId;
                }
                else if (nodeId === '-sites-' || nodeId === '-mysites-') {
                    return node.entry.guid;
                }
                else if (nodeId === '-favorites-') {
                    return node.entry.targetGuid;
                }
                return node.entry.id;
            })));
        }
        else if (nodeId) {
            // cases when nodeId is '-my-', '-root-' or '-shared-'
            return from(this.apiService.nodesApi.getNode(nodeId)
                .then(node => [node.entry.id]));
        }
        return of([]);
    }
    /**
     * Does the well-known alias have a corresponding node ID?
     * @param {?} nodeId Node to check
     * @return {?} True if the alias has a corresponding node ID, false otherwise
     */
    hasCorrespondingNodeIds(nodeId) {
        return this.isCustomSource(nodeId) || this.isSupportedSource(nodeId);
    }
    /**
     * @param {?} includeFields
     * @return {?}
     */
    getIncludesFields(includeFields) {
        return ['path', 'properties', 'allowableOperations', 'permissions', 'aspectNames', ...includeFields]
            .filter((element, index, array) => index === array.indexOf(element));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
CustomResourcesService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CustomResourcesService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
const PaginationStrategy = {
    Finite: 0,
    Infinite: 1,
};
PaginationStrategy[PaginationStrategy.Finite] = 'Finite';
PaginationStrategy[PaginationStrategy.Infinite] = 'Infinite';
class DocumentListComponent {
    /**
     * @param {?} documentListService
     * @param {?} ngZone
     * @param {?} elementRef
     * @param {?} appConfig
     * @param {?} preferences
     * @param {?} customResourcesService
     * @param {?} contentService
     * @param {?} thumbnailService
     */
    constructor(documentListService, ngZone, elementRef, appConfig, preferences, customResourcesService, contentService, thumbnailService) {
        this.documentListService = documentListService;
        this.ngZone = ngZone;
        this.elementRef = elementRef;
        this.appConfig = appConfig;
        this.preferences = preferences;
        this.customResourcesService = customResourcesService;
        this.contentService = contentService;
        this.thumbnailService = thumbnailService;
        /**
         * Change the display mode of the table. Can be "list" or "gallery".
         */
        this.display = DisplayMode.List;
        /**
         * Define a set of CSS styles styles to apply depending on the permission
         * of the user on that node. See the Permission Style model
         * page for further details and examples.
         */
        this.permissionsStyle = [];
        /**
         * The default route for all the location-based columns (if declared).
         */
        this.locationFormat = '/';
        /**
         * Toggles navigation to folder content or file preview
         */
        this.navigate = true;
        /**
         * Toggles the header
         */
        this.showHeader = true;
        /**
         * User interaction for folder navigation or file preview.
         * Valid values are "click" and "dblclick". Default value: "dblclick"
         */
        this.navigationMode = DocumentListComponent.DOUBLE_CLICK_NAVIGATION;
        /**
         * Show document thumbnails rather than icons
         */
        this.thumbnails = false;
        /**
         * Row selection mode. Can be null, `single` or `multiple`. For `multiple` mode,
         * you can use Cmd (macOS) or Ctrl (Win) modifier key to toggle selection for multiple rows.
         */
        this.selectionMode = 'single';
        /**
         * Toggles multiselect mode
         */
        this.multiselect = false;
        /**
         * Toggles content actions for each row
         */
        this.contentActions = false;
        /**
         * Position of the content actions dropdown menu. Can be set to "left" or "right".
         */
        this.contentActionsPosition = 'right';
        /**
         * Toggles context menus for each row
         */
        this.contextMenuActions = false;
        /**
         * Custom image for empty folder. Default value: './assets/images/empty_doc_lib.svg'
         */
        this.emptyFolderImageUrl = './assets/images/empty_doc_lib.svg';
        /**
         * Toggle file drop support for rows (see Upload Directive for further details
         */
        this.allowDropFiles = false;
        /**
         * Defines default sorting. The format is an array of 2 strings `[key, direction]`
         * i.e. `['name', 'desc']` or `['name', 'asc']`. Set this value only if you want to
         * override the default sorting detected by the component based on columns.
         */
        this.sorting = ['name', 'asc'];
        /**
         * Defines sorting mode. Can be either `client` or `server`.
         */
        this.sortingMode = 'client';
        /**
         * Toggles the loading state and animated spinners for the component. Used in
         * combination with `navigate=false` to perform custom navigation and loading
         * state indication.
         */
        this.loading = false;
        /**
         * Custom row filter
         */
        this.rowFilter = null;
        /**
         * Custom image resolver
         */
        this.imageResolver = null;
        /**
         * The ID of the folder node to display or a reserved string alias for special sources
         */
        this.currentFolderId = null;
        /**
         * Currently displayed folder node
         * @deprecated 2.3.0 - use currentFolderId or node
         */
        this.folderNode = null;
        /**
         * The Document list will show all the nodes contained in the NodePaging entity
         */
        this.node = null;
        /**
         * Number of elements to skip over for pagination purposes
         * @deprecated 2.3.0 - define it in pagination
         */
        this.skipCount = 0;
        /**
         * Set document list to work in infinite scrolling mode
         * @deprecated 2.3.0
         */
        this.enableInfiniteScrolling = false;
        /**
         * Emitted when the user clicks a list node
         */
        this.nodeClick = new EventEmitter();
        /**
         * Emitted when the user double-clicks a list node
         */
        this.nodeDblClick = new EventEmitter();
        /**
         * Emitted when the current display folder changes
         */
        this.folderChange = new EventEmitter();
        /**
         * Emitted when the user acts upon files with either single or double click
         * (depends on `navigation-mode`). Useful for integration with the
         * Viewer component.
         */
        this.preview = new EventEmitter();
        /**
         * Emitted when the Document List has loaded all items and is ready for use
         */
        this.ready = new EventEmitter();
        /**
         * Emitted when the API fails to get the Document List data
         */
        this.error = new EventEmitter();
        this.actions = [];
        this.contextActionHandler = new Subject();
        this.noPermission = false;
        this.selection = new Array();
        this.layoutPresets = {};
        this.subscriptions = [];
        this.rowMenuCache = {};
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getContextActions(node) {
        if (node && node.entry) {
            /** @type {?} */
            let actions = this.getNodeActions(node);
            if (actions && actions.length > 0) {
                return actions.map((currentAction) => {
                    return {
                        model: currentAction,
                        node: node,
                        subject: this.contextActionHandler
                    };
                });
            }
        }
        return null;
    }
    /**
     * @deprecated 2.3.0 define it in pagination
     * @return {?}
     */
    get supportedPageSizes() {
        return this.preferences.getDefaultPageSizes();
    }
    /**
     * @return {?}
     */
    get hasCustomLayout() {
        return this.columnList && this.columnList.columns && this.columnList.columns.length > 0;
    }
    /**
     * @return {?}
     */
    getDefaultSorting() {
        /** @type {?} */
        let defaultSorting;
        if (this.sorting) {
            const [key, direction] = this.sorting;
            defaultSorting = new DataSorting(key, direction);
        }
        return defaultSorting;
    }
    /**
     * @param {?=} name
     * @return {?}
     */
    getLayoutPreset(name = 'default') {
        return (this.layoutPresets[name] || this.layoutPresets['default']).map(col => new ObjectDataColumn(col));
    }
    /**
     * @return {?}
     */
    get pagination() {
        /** @type {?} */
        let maxItems = this.preferences.paginationSize;
        if (!this._pagination) {
            if (this.maxItems) {
                maxItems = this.maxItems;
            }
            /** @type {?} */
            let defaultPagination = /** @type {?} */ ({
                maxItems: maxItems,
                skipCount: 0,
                totalItems: 0,
                hasMoreItems: false
            });
            this._pagination = new BehaviorSubject(defaultPagination);
        }
        return this._pagination;
    }
    /**
     * @return {?}
     */
    isEmptyTemplateDefined() {
        if (this.dataTable) {
            if (this.emptyFolderTemplate) {
                return true;
            }
        }
        return false;
    }
    /**
     * @return {?}
     */
    isNoPermissionTemplateDefined() {
        if (this.dataTable) {
            if (this.noPermissionTemplate) {
                return true;
            }
        }
        return false;
    }
    /**
     * @return {?}
     */
    isMobile() {
        return !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return !this.data || this.data.getRows().length === 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.rowMenuCache = {};
        this.loadLayoutPresets();
        this.data = new ShareDataTableAdapter(this.documentListService, this.thumbnailService, null, this.getDefaultSorting(), this.sortingMode);
        this.data.thumbnails = this.thumbnails;
        this.data.permissionsStyle = this.permissionsStyle;
        if (this.rowFilter) {
            this.data.setFilter(this.rowFilter);
        }
        if (this.imageResolver) {
            this.data.setImageResolver(this.imageResolver);
        }
        this.subscriptions.push(this.contextActionHandler.subscribe(val => this.contextActionCallback(val)));
        this.enforceSingleClickNavigationForMobile();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.columnList) {
            this.subscriptions.push(this.columnList.columns.changes.subscribe(() => {
                this.setTableSchema();
            }));
        }
        this.setTableSchema();
    }
    /**
     * @return {?}
     */
    setTableSchema() {
        /** @type {?} */
        let schema = [];
        if (this.hasCustomLayout) {
            schema = this.columnList.columns.map(c => /** @type {?} */ (c));
        }
        if (!this.data) {
            this.data = new ShareDataTableAdapter(this.documentListService, this.thumbnailService, schema, this.getDefaultSorting(), this.sortingMode);
        }
        else if (schema && schema.length > 0) {
            this.data.setColumns(schema);
        }
        /** @type {?} */
        let columns = this.data.getColumns();
        if (!columns || columns.length === 0) {
            this.setupDefaultColumns(this.currentFolderId);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.resetSelection();
        if (this.data) {
            this.data.thumbnails = this.thumbnails;
        }
        if (changes["sortingMode"] && !changes["sortingMode"].firstChange && this.data) {
            this.data.sortingMode = changes["sortingMode"].currentValue;
        }
        if (changes["sorting"] && !changes["sorting"].firstChange && this.data) {
            /** @type {?} */
            const newValue = changes["sorting"].currentValue;
            if (newValue && newValue.length > 0) {
                const [key, direction] = newValue;
                this.data.setSorting(new DataSorting(key, direction));
            }
        }
        if (changes["folderNode"] && changes["folderNode"].currentValue) {
            this.currentFolderId = changes["folderNode"].currentValue.id;
            this.resetNewFolderPagination();
            this.loadFolder();
        }
        else if (changes["currentFolderId"] &&
            changes["currentFolderId"].currentValue &&
            changes["currentFolderId"].currentValue !== changes["currentFolderId"].previousValue) {
            this.resetNewFolderPagination();
            this.loadFolder();
        }
        else if (this.data) {
            if (changes["node"] && changes["node"].currentValue) {
                this.data.loadPage(changes["node"].currentValue);
                this.onDataReady(changes["node"].currentValue);
            }
            else if (changes["rowFilter"] && changes["rowFilter"].currentValue !== changes["rowFilter"].previousValue) {
                this.data.setFilter(changes["rowFilter"].currentValue);
                if (this.currentFolderId) {
                    this.loadFolderNodesByFolderNodeId(this.currentFolderId, this.pagination.getValue()).catch(err => this.error.emit(err));
                }
            }
            else if (changes["imageResolver"]) {
                this.data.setImageResolver(changes["imageResolver"].currentValue);
            }
        }
    }
    /**
     * @return {?}
     */
    reload() {
        this.ngZone.run(() => {
            this.resetSelection();
            if (this.node) {
                this.data.loadPage(this.node);
                this.onDataReady(this.node);
            }
            else {
                this.loadFolder();
            }
        });
    }
    /**
     * @param {?} action
     * @return {?}
     */
    contextActionCallback(action) {
        if (action) {
            this.executeContentAction(action.node, action.model);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getNodeActions(node) {
        if (node && node.entry) {
            /** @type {?} */
            let target = null;
            if (node.entry.isFile) {
                target = 'document';
            }
            else if (node.entry.isFolder) {
                target = 'folder';
            }
            if (target) {
                /** @type {?} */
                const actions = this.rowMenuCache[node.entry.id];
                if (actions) {
                    actions.forEach(action => {
                        this.refreshAction(action, node);
                    });
                    return actions;
                }
                /** @type {?} */
                let actionsByTarget = this.actions
                    .filter(entry => {
                    /** @type {?} */
                    const isVisible = (typeof entry.visible === 'function')
                        ? entry.visible(node)
                        : entry.visible;
                    return isVisible && entry.target.toLowerCase() === target;
                })
                    .map(action => new ContentActionModel(action));
                actionsByTarget.forEach((action) => {
                    this.refreshAction(action, node);
                });
                this.rowMenuCache[node.entry.id] = actionsByTarget;
                return actionsByTarget;
            }
        }
        return [];
    }
    /**
     * @param {?} action
     * @param {?} node
     * @return {?}
     */
    refreshAction(action, node) {
        action.disabled = this.isActionDisabled(action, node);
        action.visible = this.isActionVisible(action, node);
    }
    /**
     * @param {?} action
     * @param {?} node
     * @return {?}
     */
    isActionVisible(action, node) {
        if (typeof action.visible === 'function') {
            return action.visible(node);
        }
        return action.visible;
    }
    /**
     * @param {?} action
     * @param {?} node
     * @return {?}
     */
    isActionDisabled(action, node) {
        if (typeof action.disabled === 'function') {
            return action.disabled(node);
        }
        if (action.permission && action.disableWithNoPermission && !this.contentService.hasPermission(node.entry, action.permission)) {
            return true;
        }
        return action.disabled;
    }
    /**
     * @param {?=} e
     * @return {?}
     */
    onShowContextMenu(e) {
        if (e && this.contextMenuActions) {
            e.preventDefault();
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    performNavigation(node) {
        if (this.canNavigateFolder(node)) {
            this.updateFolderData(node);
            return true;
        }
        return false;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    performCustomSourceNavigation(node) {
        if (this.customResourcesService.isCustomSource(this.currentFolderId)) {
            this.updateFolderData(node);
            return true;
        }
        return false;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    updateFolderData(node) {
        this.resetNewFolderPagination();
        this.currentFolderId = node.entry.id;
        this.reload();
        this.folderChange.emit(new NodeEntryEvent(node.entry));
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    updateCustomSourceData(nodeId) {
        this.folderNode = null;
        this.currentFolderId = nodeId;
    }
    /**
     * Invoked when executing content action for a document or folder.
     * @param {?} node Node to be the context of the execution.
     * @param {?} action Action to be executed against the context.
     * @return {?}
     */
    executeContentAction(node, action) {
        if (node && node.entry && action) {
            /** @type {?} */
            let handlerSub;
            if (typeof action.handler === 'function') {
                handlerSub = action.handler(node, this, action.permission);
            }
            else {
                handlerSub = of(true);
            }
            if (typeof action.execute === 'function' && handlerSub) {
                handlerSub.subscribe(() => {
                    action.execute(node);
                });
            }
        }
    }
    /**
     * @return {?}
     */
    loadFolder() {
        if (!this.pagination.getValue().merge) {
            this.loading = true;
        }
        if (!this.hasCustomLayout) {
            this.setupDefaultColumns(this.currentFolderId);
        }
        if (this.folderNode) {
            return this.loadFolderNodesByFolderNodeId(this.folderNode.id, this.pagination.getValue())
                .catch(err => this.handleError(err));
        }
        else {
            this.loadFolderByNodeId(this.currentFolderId);
        }
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    loadFolderByNodeId(nodeId) {
        if (this.customResourcesService.isCustomSource(nodeId)) {
            this.updateCustomSourceData(nodeId);
            this.customResourcesService.loadFolderByNodeId(nodeId, this.pagination.getValue(), this.includeFields)
                .subscribe((page) => {
                this.onPageLoaded(page);
            }, err => {
                this.error.emit(err);
            });
        }
        else {
            this.documentListService
                .getFolderNode(nodeId, this.includeFields)
                .subscribe((node) => {
                this.folderNode = node;
                return this.loadFolderNodesByFolderNodeId(node.id, this.pagination.getValue())
                    .catch(err => this.handleError(err));
            }, err => {
                this.handleError(err);
            });
        }
    }
    /**
     * @param {?} id
     * @param {?} pagination
     * @return {?}
     */
    loadFolderNodesByFolderNodeId(id, pagination) {
        return new Promise((resolve, reject) => {
            this.documentListService
                .getFolder(null, {
                maxItems: pagination.maxItems,
                skipCount: pagination.skipCount,
                rootFolderId: id
            }, this.includeFields)
                .subscribe(nodePaging => {
                this.data.loadPage(/** @type {?} */ (nodePaging), this.pagination.getValue().merge);
                this.loading = false;
                this.onDataReady(nodePaging);
                resolve(true);
            }, err => {
                this.handleError(err);
            });
        });
    }
    /**
     * @return {?}
     */
    resetSelection() {
        this.dataTable.resetSelection();
        this.selection = [];
        this.noPermission = false;
    }
    /**
     * @param {?} nodePaging
     * @return {?}
     */
    onPageLoaded(nodePaging) {
        if (nodePaging) {
            this.data.loadPage(nodePaging, this.pagination.getValue().merge);
            this.loading = false;
            this.onDataReady(nodePaging);
        }
    }
    /**
     * Creates a set of predefined columns.
     * @param {?=} preset
     * @return {?}
     */
    setupDefaultColumns(preset = 'default') {
        if (this.data) {
            /** @type {?} */
            const columns = this.getLayoutPreset(preset);
            this.data.setColumns(columns);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onPreviewFile(node) {
        if (node) {
            this.preview.emit(new NodeEntityEvent(node));
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onNodeClick(node) {
        /** @type {?} */
        const domEvent = new CustomEvent('node-click', {
            detail: {
                sender: this,
                node: node
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
        /** @type {?} */
        const event = new NodeEntityEvent(node);
        this.nodeClick.emit(event);
        if (!event.defaultPrevented) {
            if (this.navigate && this.navigationMode === DocumentListComponent.SINGLE_CLICK_NAVIGATION) {
                if (node && node.entry) {
                    if (node.entry.isFile) {
                        this.onPreviewFile(node);
                    }
                    if (node.entry.isFolder) {
                        this.performNavigation(node);
                    }
                }
            }
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onNodeDblClick(node) {
        /** @type {?} */
        const domEvent = new CustomEvent('node-dblclick', {
            detail: {
                sender: this,
                node: node
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
        /** @type {?} */
        const event = new NodeEntityEvent(node);
        this.nodeDblClick.emit(event);
        if (!event.defaultPrevented) {
            if (this.navigate && this.navigationMode === DocumentListComponent.DOUBLE_CLICK_NAVIGATION) {
                if (node && node.entry) {
                    if (node.entry.isFile) {
                        this.onPreviewFile(node);
                    }
                    if (node.entry.isFolder) {
                        this.performNavigation(node);
                    }
                }
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onNodeSelect(event) {
        this.selection = event.selection.map(entry => entry.node);
        /** @type {?} */
        const domEvent = new CustomEvent('node-select', {
            detail: {
                node: event.row.node,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onNodeUnselect(event) {
        this.selection = event.selection.map(entry => entry.node);
        /** @type {?} */
        const domEvent = new CustomEvent('node-unselect', {
            detail: {
                node: event.row.node,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onShowRowContextMenu(event) {
        if (this.contextMenuActions) {
            /** @type {?} */
            let args = event.value;
            /** @type {?} */
            let node = (/** @type {?} */ (args.row)).node;
            if (node) {
                args.actions = this.getContextActions(node) || [];
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onShowRowActionsMenu(event) {
        if (this.contentActions) {
            /** @type {?} */
            let args = event.value;
            /** @type {?} */
            let node = (/** @type {?} */ (args.row)).node;
            if (node) {
                args.actions = this.getNodeActions(node) || [];
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExecuteRowAction(event) {
        if (this.contentActions) {
            /** @type {?} */
            let args = event.value;
            /** @type {?} */
            let node = (/** @type {?} */ (args.row)).node;
            /** @type {?} */
            let action = (/** @type {?} */ (args.action));
            this.executeContentAction(node, action);
        }
    }
    /**
     * @return {?}
     */
    enforceSingleClickNavigationForMobile() {
        if (this.isMobile()) {
            this.navigationMode = DocumentListComponent.SINGLE_CLICK_NAVIGATION;
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    canNavigateFolder(node) {
        /** @type {?} */
        let canNavigateFolder = false;
        if (this.customResourcesService.isCustomSource(this.currentFolderId)) {
            canNavigateFolder = false;
        }
        else if (node && node.entry && node.entry.isFolder) {
            canNavigateFolder = true;
        }
        return canNavigateFolder;
    }
    /**
     * @return {?}
     */
    loadLayoutPresets() {
        /** @type {?} */
        const externalSettings = this.appConfig.get('document-list.presets', null);
        if (externalSettings) {
            this.layoutPresets = Object.assign({}, presetsDefaultModel, externalSettings);
        }
        else {
            this.layoutPresets = presetsDefaultModel;
        }
    }
    /**
     * @param {?} nodePaging
     * @return {?}
     */
    onDataReady(nodePaging) {
        this.ready.emit(nodePaging);
        this.pagination.next(nodePaging.list.pagination);
    }
    /**
     * @param {?} pagination
     * @return {?}
     */
    updatePagination(pagination) {
        this.pagination.next(pagination);
        this.reload();
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    navigateTo(nodeId) {
        this.currentFolderId = nodeId;
        this.resetNewFolderPagination();
        this.loadFolder();
        this.folderChange.emit(new NodeEntryEvent({ id: nodeId }));
    }
    /**
     * @return {?}
     */
    resetNewFolderPagination() {
        this.folderNode = null;
        this.pagination.value.skipCount = 0;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(s => s.unsubscribe());
        this.subscriptions = [];
    }
    /**
     * @param {?} err
     * @return {?}
     */
    handleError(err) {
        if (err.message) {
            if (JSON.parse(err.message).error.statusCode === 403) {
                this.loading = false;
                this.noPermission = true;
            }
        }
        this.error.emit(err);
    }
}
DocumentListComponent.SINGLE_CLICK_NAVIGATION = 'click';
DocumentListComponent.DOUBLE_CLICK_NAVIGATION = 'dblclick';
DocumentListComponent.DEFAULT_PAGE_SIZE = 20;
DocumentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-document-list',
                template: "<adf-datatable\n    #dataTable\n    [selectionMode]=\"selectionMode\"\n    [data]=\"data\"\n    [actions]=\"contentActions\"\n    [actionsPosition]=\"contentActionsPosition\"\n    [multiselect]=\"multiselect\"\n    [allowDropFiles]=\"allowDropFiles\"\n    [contextMenu]=\"contextMenuActions\"\n    [rowStyle]=\"rowStyle\"\n    [rowStyleClass]=\"rowStyleClass\"\n    [loading]=\"loading\"\n    [display]=\"display\"\n    [noPermission]=\"noPermission\"\n    [showHeader]=\"!isEmpty() && showHeader\"\n    [rowMenuCacheEnabled]=\"false\"\n    (showRowContextMenu)=\"onShowRowContextMenu($event)\"\n    (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n    (executeRowAction)=\"onExecuteRowAction($event)\"\n    (rowClick)=\"onNodeClick($event.value?.node)\"\n    (rowDblClick)=\"onNodeDblClick($event.value?.node)\"\n    (row-select)=\"onNodeSelect($event.detail)\"\n    (row-unselect)=\"onNodeUnselect($event.detail)\"\n    [class.adf-datatable-gallery-thumbnails]=\"data.thumbnails\">\n\n    <div *ngIf=\"!isEmptyTemplateDefined()\">\n        <no-content-template>\n            <ng-template>\n                <adf-empty-list>\n                    <div class=\"adf-empty-list_template adf-empty-folder\">\n                        <div class=\"adf-empty-folder-this-space-is-empty\">{{'ADF-DOCUMENT-LIST.EMPTY.HEADER' | translate}}</div>\n                        <div fxHide.lt-md=\"true\" class=\"adf-empty-folder-drag-drop\">{{ 'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.TITLE' | translate }}</div>\n                        <div fxHide.lt-md=\"true\" class=\"adf-empty-folder-any-files-here-to-add\">{{ 'ADF-DATATABLE.EMPTY.DRAG-AND-DROP.SUBTITLE' | translate }}</div>\n                        <img class=\"adf-empty-folder-image\" [src]=\"emptyFolderImageUrl\">\n                    </div>\n                    <!-- <div adf-empty-list-header class=\"adf-empty-list-header\"> {{'ADF-DOCUMENT-LIST.EMPTY.HEADER' | translate}} </div> -->\n                </adf-empty-list>\n            </ng-template>\n        </no-content-template>\n    </div>\n\n    <div *ngIf=\"!isNoPermissionTemplateDefined()\">\n        <no-permission-template>\n            <ng-template>\n                <div class=\"adf-no-permission__template\">\n                    <mat-icon>ic_error</mat-icon>\n                    <p class=\"adf-no-permission__template--text\">{{ 'ADF-DOCUMENT-LIST.NO_PERMISSION' | translate }}</p>\n                </div>\n            </ng-template>\n        </no-permission-template>\n    </div>\n\n    <div>\n        <loading-content-template>\n            <ng-template>\n                <div class=\"adf-document-list-loading-container\">\n                    <mat-progress-spinner\n                        id=\"adf-document-list-loading\"\n                        class=\"adf-document-list-loading-margin\"\n                        [color]=\"'primary'\"\n                        [mode]=\"'indeterminate'\">\n                    </mat-progress-spinner>\n                </div>\n            </ng-template>\n        </loading-content-template>\n    </div>\n</adf-datatable>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
DocumentListComponent.ctorParameters = () => [
    { type: DocumentListService },
    { type: NgZone },
    { type: ElementRef },
    { type: AppConfigService },
    { type: UserPreferencesService },
    { type: CustomResourcesService },
    { type: ContentService },
    { type: ThumbnailService }
];
DocumentListComponent.propDecorators = {
    columnList: [{ type: ContentChild, args: [DataColumnListComponent,] }],
    includeFields: [{ type: Input }],
    display: [{ type: Input }],
    permissionsStyle: [{ type: Input }],
    locationFormat: [{ type: Input }],
    navigate: [{ type: Input }],
    showHeader: [{ type: Input }],
    navigationMode: [{ type: Input }],
    thumbnails: [{ type: Input }],
    selectionMode: [{ type: Input }],
    multiselect: [{ type: Input }],
    contentActions: [{ type: Input }],
    contentActionsPosition: [{ type: Input }],
    contextMenuActions: [{ type: Input }],
    emptyFolderImageUrl: [{ type: Input }],
    allowDropFiles: [{ type: Input }],
    sorting: [{ type: Input }],
    sortingMode: [{ type: Input }],
    rowStyle: [{ type: Input }],
    rowStyleClass: [{ type: Input }],
    loading: [{ type: Input }],
    rowFilter: [{ type: Input }],
    imageResolver: [{ type: Input }],
    currentFolderId: [{ type: Input }],
    folderNode: [{ type: Input }],
    node: [{ type: Input }],
    maxItems: [{ type: Input }],
    skipCount: [{ type: Input }],
    enableInfiniteScrolling: [{ type: Input }],
    nodeClick: [{ type: Output }],
    nodeDblClick: [{ type: Output }],
    folderChange: [{ type: Output }],
    preview: [{ type: Output }],
    ready: [{ type: Output }],
    error: [{ type: Output }],
    dataTable: [{ type: ViewChild, args: ['dataTable',] }],
    onShowContextMenu: [{ type: HostListener, args: ['contextmenu', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentColumnListComponent {
    /**
     * @param {?} documentList
     * @param {?} logService
     */
    constructor(documentList, logService) {
        this.documentList = documentList;
        this.logService = logService;
        this.logService.log('ContentColumnListComponent is deprecated starting with 1.7.0 and may be removed in future versions. Use DataColumnListComponent instead.');
    }
    /**
     * Registers column model within the parent document list component.
     * @param {?} column Column definition model to register.
     * @return {?}
     */
    registerColumn(column) {
        if (this.documentList && column) {
            /** @type {?} */
            let columns = this.documentList.data.getColumns();
            columns.push(column);
            return true;
        }
        return false;
    }
}
ContentColumnListComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-columns',
                template: ''
            }] }
];
/** @nocollapse */
ContentColumnListComponent.ctorParameters = () => [
    { type: DocumentListComponent },
    { type: LogService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentColumnComponent {
    /**
     * @param {?} list
     * @param {?} logService
     */
    constructor(list, logService) {
        this.list = list;
        this.logService = logService;
        this.type = 'text';
        this.sortable = false;
        this.title = '';
        this.logService.log('ContentColumnComponent is deprecated starting with 1.7.0 and may be removed in future versions. Use DataColumnComponent instead.');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.srTitle && this.key === '$thumbnail') {
            this.srTitle = 'Thumbnail';
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.register();
    }
    /**
     * @return {?}
     */
    register() {
        if (this.list) {
            return this.list.registerColumn(this);
        }
        return false;
    }
}
ContentColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-column',
                template: ''
            }] }
];
/** @nocollapse */
ContentColumnComponent.ctorParameters = () => [
    { type: ContentColumnListComponent },
    { type: LogService }
];
ContentColumnComponent.propDecorators = {
    key: [{ type: Input }],
    type: [{ type: Input }],
    format: [{ type: Input }],
    sortable: [{ type: Input }],
    title: [{ type: Input }],
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    srTitle: [{ type: Input, args: ['sr-title',] }],
    cssClass: [{ type: Input, args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PermissionModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        if (obj) {
            this.type = obj.type || null;
            this.action = obj.action || null;
            this.permission = obj.permission || null;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NodeActionsService {
    /**
     * @param {?} contentDialogService
     * @param {?} dialogRef
     * @param {?} content
     * @param {?=} documentListService
     * @param {?=} apiService
     * @param {?=} dialog
     */
    constructor(contentDialogService, dialogRef, content, documentListService, apiService, dialog) {
        this.contentDialogService = contentDialogService;
        this.dialogRef = dialogRef;
        this.content = content;
        this.documentListService = documentListService;
        this.apiService = apiService;
        this.dialog = dialog;
        this.error = new EventEmitter();
    }
    /**
     * @param {?} node
     * @return {?}
     */
    downloadNode(node) {
        new NodeDownloadDirective(this.apiService, this.dialog)
            .downloadNode(node);
    }
    /**
     * Copy content node
     *
     * @param {?} contentEntry node to copy
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    copyContent(contentEntry, permission) {
        return this.doFileOperation('copy', 'content', contentEntry, permission);
    }
    /**
     * Copy folder node
     *
     * @param {?} contentEntry node to copy
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    copyFolder(contentEntry, permission) {
        return this.doFileOperation('copy', 'folder', contentEntry, permission);
    }
    /**
     * Move content node
     *
     * @param {?} contentEntry node to move
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    moveContent(contentEntry, permission) {
        return this.doFileOperation('move', 'content', contentEntry, permission);
    }
    /**
     * Move folder node
     *
     * @param {?} contentEntry node to move
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    moveFolder(contentEntry, permission) {
        return this.doFileOperation('move', 'folder', contentEntry, permission);
    }
    /**
     * General method for performing the given operation (copy|move)
     *
     * @param {?} action the action to perform (copy|move)
     * @param {?} type type of the content (content|folder)
     * @param {?} contentEntry the contentEntry which has to have the action performed on
     * @param {?=} permission permission which is needed to apply the action
     * @return {?}
     */
    doFileOperation(action, type, contentEntry, permission) {
        /** @type {?} */
        const observable = new Subject();
        this.contentDialogService
            .openCopyMoveDialog(action, contentEntry, permission)
            .subscribe((selections) => {
            /** @type {?} */
            const selection = selections[0];
            this.documentListService[`${action}Node`].call(this.documentListService, contentEntry.id, selection.id)
                .subscribe(observable.next.bind(observable, `OPERATION.SUCCESS.${type.toUpperCase()}.${action.toUpperCase()}`), observable.error.bind(observable));
        }, (error) => {
            observable.error(error);
            return observable;
        });
        return observable;
    }
}
NodeActionsService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NodeActionsService.ctorParameters = () => [
    { type: ContentNodeDialogService },
    { type: MatDialog },
    { type: ContentService },
    { type: DocumentListService },
    { type: AlfrescoApiService },
    { type: MatDialog }
];
NodeActionsService.propDecorators = {
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DocumentActionsService {
    /**
     * @param {?} nodeActionsService
     * @param {?} contentNodeDialogService
     * @param {?} translation
     * @param {?=} documentListService
     * @param {?=} contentService
     */
    constructor(nodeActionsService, contentNodeDialogService, translation, documentListService, contentService) {
        this.nodeActionsService = nodeActionsService;
        this.contentNodeDialogService = contentNodeDialogService;
        this.translation = translation;
        this.documentListService = documentListService;
        this.contentService = contentService;
        this.permissionEvent = new Subject();
        this.error = new Subject();
        this.success = new Subject();
        this.handlers = {};
        this.setupActionHandlers();
    }
    /**
     * Gets the handler for an action.
     * @param {?} key Identifier of the action
     * @return {?} The handler for the action
     */
    getHandler(key) {
        if (key) {
            /** @type {?} */
            let lkey = key.toLowerCase();
            return this.handlers[lkey] || null;
        }
        return null;
    }
    /**
     * Sets a new handler for an action.
     * @param {?} key Identifier of the action
     * @param {?} handler Handler for the action
     * @return {?} False if the key was an empty/null string, true otherwise
     */
    setHandler(key, handler) {
        if (key) {
            /** @type {?} */
            let lkey = key.toLowerCase();
            this.handlers[lkey] = handler;
            return true;
        }
        return false;
    }
    /**
     * Checks if actions can be executed for an item.
     * @param {?} obj Item to receive an action
     * @return {?} True if the action can be executed on this item, false otherwise
     */
    canExecuteAction(obj) {
        return this.documentListService && obj && obj.entry.isFile === true;
    }
    /**
     * @return {?}
     */
    setupActionHandlers() {
        this.handlers['copy'] = this.copyNode.bind(this);
        this.handlers['move'] = this.moveNode.bind(this);
        this.handlers['delete'] = this.deleteNode.bind(this);
        this.handlers['download'] = this.downloadNode.bind(this);
        this.handlers['lock'] = this.lockNode.bind(this);
    }
    /**
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    lockNode(node, target, permission) {
        return this.contentNodeDialogService.openLockNodeDialog(node.entry);
    }
    /**
     * @param {?} obj
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    downloadNode(obj, target, permission) {
        this.nodeActionsService.downloadNode(obj);
    }
    /**
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    copyNode(node, target, permission) {
        /** @type {?} */
        const actionObservable = this.nodeActionsService.copyContent(node.entry, permission);
        this.prepareHandlers(actionObservable, 'content', 'copy', target, permission);
        return actionObservable;
    }
    /**
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    moveNode(node, target, permission) {
        /** @type {?} */
        const actionObservable = this.nodeActionsService.moveContent(node.entry, permission);
        this.prepareHandlers(actionObservable, 'content', 'move', target, permission);
        return actionObservable;
    }
    /**
     * @param {?} actionObservable
     * @param {?} type
     * @param {?} action
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    prepareHandlers(actionObservable, type, action, target, permission) {
        actionObservable.subscribe((fileOperationMessage) => {
            this.success.next(fileOperationMessage);
        }, this.error.next.bind(this.error));
    }
    /**
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    deleteNode(node, target, permission) {
        /** @type {?} */
        let handlerObservable;
        if (this.canExecuteAction(node)) {
            if (this.contentService.hasPermission(node.entry, permission)) {
                handlerObservable = this.documentListService.deleteNode(node.entry.id);
                handlerObservable.subscribe(() => {
                    /** @type {?} */
                    let message = this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: node.entry.name });
                    this.success.next(message);
                }, () => {
                    /** @type {?} */
                    let message = this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: node.entry.name });
                    this.error.next(message);
                });
                return handlerObservable;
            }
            else {
                this.permissionEvent.next(new PermissionModel({
                    type: 'content',
                    action: 'delete',
                    permission: permission
                }));
                return throwError(new Error('No permission to delete'));
            }
        }
    }
}
DocumentActionsService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DocumentActionsService.ctorParameters = () => [
    { type: NodeActionsService },
    { type: ContentNodeDialogService },
    { type: TranslationService },
    { type: DocumentListService },
    { type: ContentService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FolderActionsService {
    /**
     * @param {?} nodeActionsService
     * @param {?} documentListService
     * @param {?} contentService
     * @param {?} translation
     */
    constructor(nodeActionsService, documentListService, contentService, translation) {
        this.nodeActionsService = nodeActionsService;
        this.documentListService = documentListService;
        this.contentService = contentService;
        this.translation = translation;
        this.permissionEvent = new Subject();
        this.error = new Subject();
        this.success = new Subject();
        this.handlers = {};
        this.setupActionHandlers();
    }
    /**
     * Gets the handler function for an action.
     * @param {?} key Identifier for the action
     * @return {?} The handler function
     */
    getHandler(key) {
        if (key) {
            /** @type {?} */
            let lkey = key.toLowerCase();
            return this.handlers[lkey] || null;
        }
        return null;
    }
    /**
     * Sets a new handler function for an action.
     * @param {?} key Identifier for the action
     * @param {?} handler The new handler function
     * @return {?} True if the key was a valid action identifier, false otherwise
     */
    setHandler(key, handler) {
        if (key) {
            /** @type {?} */
            let lkey = key.toLowerCase();
            this.handlers[lkey] = handler;
            return true;
        }
        return false;
    }
    /**
     * Checks if an action is available for a particular item.
     * @param {?} obj Item to check
     * @return {?} True if the action is available, false otherwise
     */
    canExecuteAction(obj) {
        return this.documentListService && obj && obj.entry.isFolder === true;
    }
    /**
     * @return {?}
     */
    setupActionHandlers() {
        this.handlers['copy'] = this.copyNode.bind(this);
        this.handlers['move'] = this.moveNode.bind(this);
        this.handlers['delete'] = this.deleteNode.bind(this);
        this.handlers['download'] = this.downloadNode.bind(this);
    }
    /**
     * @param {?} obj
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    downloadNode(obj, target, permission) {
        this.nodeActionsService.downloadNode(obj);
    }
    /**
     * @param {?} obj
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    copyNode(obj, target, permission) {
        /** @type {?} */
        const actionObservable = this.nodeActionsService.copyFolder(obj.entry, permission);
        this.prepareHandlers(actionObservable, 'folder', 'copy', target, permission);
        return actionObservable;
    }
    /**
     * @param {?} obj
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    moveNode(obj, target, permission) {
        /** @type {?} */
        const actionObservable = this.nodeActionsService.moveFolder(obj.entry, permission);
        this.prepareHandlers(actionObservable, 'folder', 'move', target, permission);
        return actionObservable;
    }
    /**
     * @param {?} actionObservable
     * @param {?} type
     * @param {?} action
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    prepareHandlers(actionObservable, type, action, target, permission) {
        actionObservable.subscribe((fileOperationMessage) => {
            if (target && typeof target.reload === 'function') {
                target.reload();
            }
            this.success.next(fileOperationMessage);
        }, this.error.next.bind(this.error));
    }
    /**
     * @param {?} node
     * @param {?=} target
     * @param {?=} permission
     * @return {?}
     */
    deleteNode(node, target, permission) {
        /** @type {?} */
        let handlerObservable;
        if (this.canExecuteAction(node)) {
            if (this.contentService.hasPermission(node.entry, permission)) {
                handlerObservable = this.documentListService.deleteNode(node.entry.id);
                handlerObservable.subscribe(() => {
                    if (target && typeof target.reload === 'function') {
                        target.reload();
                    }
                    /** @type {?} */
                    let message = this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: node.entry.name });
                    this.success.next(message);
                }, () => {
                    /** @type {?} */
                    let message = this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: node.entry.name });
                    this.error.next(message);
                });
                return handlerObservable;
            }
            else {
                this.permissionEvent.next(new PermissionModel({ type: 'folder', action: 'delete', permission: permission }));
                return throwError(new Error('No permission to delete'));
            }
        }
    }
}
FolderActionsService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FolderActionsService.ctorParameters = () => [
    { type: NodeActionsService },
    { type: DocumentListService },
    { type: ContentService },
    { type: TranslationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentActionListComponent {
    /**
     * @param {?} documentList
     */
    constructor(documentList) {
        this.documentList = documentList;
    }
    /**
     * Registers action handler within the parent document list component.
     * @param {?} action Action model to register.
     * @return {?}
     */
    registerAction(action) {
        if (this.documentList && action) {
            this.documentList.actions.push(action);
            return true;
        }
        return false;
    }
    /**
     * @param {?} action
     * @return {?}
     */
    unregisterAction(action) {
        if (this.documentList && action) {
            /** @type {?} */
            const idx = this.documentList.actions.indexOf(action);
            if (idx >= 0) {
                this.documentList.actions.splice(idx, 1);
                return true;
            }
        }
        return false;
    }
}
ContentActionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-actions',
                template: ''
            }] }
];
/** @nocollapse */
ContentActionListComponent.ctorParameters = () => [
    { type: DocumentListComponent }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentActionComponent {
    /**
     * @param {?} list
     * @param {?} documentActions
     * @param {?} folderActions
     */
    constructor(list, documentActions, folderActions) {
        this.list = list;
        this.documentActions = documentActions;
        this.folderActions = folderActions;
        /**
         * The title of the action as shown in the menu.
         */
        this.title = 'Action';
        /**
         * Visibility state (see examples).
         */
        this.visible = true;
        /**
         * Type of item that the action applies to. Can be "document" or "folder"
         */
        this.target = ContentActionTarget.All;
        /**
         * Is the menu item disabled?
         */
        this.disabled = false;
        /**
         * Emitted when the user selects the action from the menu.
         */
        this.execute = new EventEmitter();
        /**
         * Emitted when a permission error occurs
         */
        this.permissionEvent = new EventEmitter();
        /**
         * Emitted when an error occurs during the action.
         * Applies to copy and move actions.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the action succeeds with the success string message.
         * Applies to copy, move and delete actions.
         */
        this.success = new EventEmitter();
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.target === ContentActionTarget.All) {
            this.folderActionModel = this.generateAction(ContentActionTarget.Folder);
            this.documentActionModel = this.generateAction(ContentActionTarget.Document);
        }
        else {
            this.documentActionModel = this.generateAction(this.target);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["visible"] && !changes["visible"].firstChange) {
            if (this.documentActionModel) {
                this.documentActionModel.visible = changes["visible"].currentValue;
            }
            if (this.folderActionModel) {
                this.folderActionModel.visible = changes["visible"].currentValue;
            }
        }
        if (changes["disabled"] && !changes["disabled"].firstChange) {
            if (this.documentActionModel) {
                this.documentActionModel.disabled = changes["disabled"].currentValue;
            }
            if (this.folderActionModel) {
                this.folderActionModel.disabled = changes["disabled"].currentValue;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(subscription => subscription.unsubscribe());
        this.subscriptions = [];
        if (this.documentActionModel) {
            this.unregister(this.documentActionModel);
            this.documentActionModel = null;
        }
        if (this.folderActionModel) {
            this.unregister(this.folderActionModel);
            this.folderActionModel = null;
        }
    }
    /**
     * @param {?} model
     * @return {?}
     */
    register(model) {
        if (this.list) {
            return this.list.registerAction(model);
        }
        return false;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    unregister(model) {
        if (this.list) {
            return this.list.unregisterAction(model);
        }
        return false;
    }
    /**
     * @param {?} target
     * @return {?}
     */
    generateAction(target) {
        /** @type {?} */
        const model = new ContentActionModel({
            title: this.title,
            icon: this.icon,
            permission: this.permission,
            disableWithNoPermission: this.disableWithNoPermission,
            target: target,
            disabled: this.disabled,
            visible: this.visible
        });
        if (this.handler) {
            model.handler = this.getSystemHandler(target, this.handler);
        }
        if (this.execute) {
            model.execute = (value) => {
                this.execute.emit({ value });
            };
        }
        this.register(model);
        return model;
    }
    /**
     * @param {?} target
     * @param {?} name
     * @return {?}
     */
    getSystemHandler(target, name) {
        if (target) {
            target = target.toLowerCase();
            if (target === ContentActionTarget.Document) {
                if (this.documentActions) {
                    this.subscriptions.push(this.documentActions.permissionEvent.subscribe(permission => {
                        this.permissionEvent.emit(permission);
                    }), this.documentActions.error.subscribe(errors => {
                        this.error.emit(errors);
                    }), this.documentActions.success.subscribe(message => {
                        this.success.emit(message);
                    }));
                    return this.documentActions.getHandler(name);
                }
                return null;
            }
            if (target === ContentActionTarget.Folder) {
                if (this.folderActions) {
                    this.subscriptions.push(this.folderActions.permissionEvent.subscribe(permission => {
                        this.permissionEvent.emit(permission);
                    }), this.folderActions.error.subscribe(errors => {
                        this.error.emit(errors);
                    }), this.folderActions.success.subscribe(message => {
                        this.success.emit(message);
                    }));
                    return this.folderActions.getHandler(name);
                }
                return null;
            }
        }
        return null;
    }
}
ContentActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'content-action',
                template: '',
                providers: [
                    DocumentActionsService,
                    FolderActionsService
                ]
            }] }
];
/** @nocollapse */
ContentActionComponent.ctorParameters = () => [
    { type: ContentActionListComponent },
    { type: DocumentActionsService },
    { type: FolderActionsService }
];
ContentActionComponent.propDecorators = {
    title: [{ type: Input }],
    icon: [{ type: Input }],
    visible: [{ type: Input }],
    handler: [{ type: Input }],
    target: [{ type: Input }],
    permission: [{ type: Input }],
    disableWithNoPermission: [{ type: Input }],
    disabled: [{ type: Input }],
    execute: [{ type: Output }],
    permissionEvent: [{ type: Output }],
    error: [{ type: Output }],
    success: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class EmptyFolderContentDirective {
    /**
     * @param {?} documentList
     */
    constructor(documentList) {
        this.documentList = documentList;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.documentList.emptyFolderTemplate = this.template;
        this.documentList.dataTable.noContentTemplate = this.template;
    }
}
EmptyFolderContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'empty-folder-content'
            },] }
];
/** @nocollapse */
EmptyFolderContentDirective.ctorParameters = () => [
    { type: DocumentListComponent }
];
EmptyFolderContentDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NoPermissionContentDirective {
    /**
     * @param {?} documentList
     */
    constructor(documentList) {
        this.documentList = documentList;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.documentList.noPermissionTemplate = this.template;
        this.documentList.dataTable.noPermissionTemplate = this.template;
    }
}
NoPermissionContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'no-permission-content'
            },] }
];
/** @nocollapse */
NoPermissionContentDirective.ctorParameters = () => [
    { type: DocumentListComponent }
];
NoPermissionContentDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodePaging {
}
class NodePagingList {
}
class NodeMinimalEntry {
}
class Pagination {
}
class NodeMinimal {
    constructor() {
        this.properties = {};
    }
}
class UserInfo {
}
class ContentInfo {
}
class PathInfoEntity {
}
class PathElementEntity {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PermissionStyleModel {
    /**
     * @param {?} css
     * @param {?} permission
     * @param {?=} isFile
     * @param {?=} isFolder
     */
    constructor(css, permission, isFile = true, isFolder = true) {
        this.isFolder = true;
        this.isFile = true;
        this.css = css;
        this.permission = permission;
        this.isFile = isFile;
        this.isFolder = isFolder;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FileUploadingListComponent {
    /**
     * @param {?} uploadService
     * @param {?} nodesApi
     * @param {?} translateService
     */
    constructor(uploadService, nodesApi, translateService) {
        this.uploadService = uploadService;
        this.nodesApi = nodesApi;
        this.translateService = translateService;
        this.FileUploadStatus = FileUploadStatus;
        this.files = [];
        /**
         * Emitted when a file in the list has an error.
         */
        this.error = new EventEmitter();
    }
    /**
     * Cancel file upload
     *
     * \@memberOf FileUploadingListComponent
     * @param {?} file File model to cancel upload for.
     *
     * @return {?}
     */
    cancelFile(file) {
        this.uploadService.cancelUpload(file);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    removeFile(file) {
        this.deleteNode(file)
            .subscribe(() => {
            if (file.status === FileUploadStatus.Error) {
                this.notifyError(file);
            }
            this.uploadService.cancelUpload(file);
        });
    }
    /**
     * Call the appropriate method for each file, depending on state
     * @return {?}
     */
    cancelAllFiles() {
        this.getUploadingFiles()
            .forEach((file) => this.uploadService.cancelUpload(file));
        /** @type {?} */
        const deletedFiles = this.files
            .filter((file) => file.status === FileUploadStatus.Complete)
            .map((file) => this.deleteNode(file));
        forkJoin(...deletedFiles)
            .subscribe((files) => {
            /** @type {?} */
            const errors = files
                .filter((file) => file.status === FileUploadStatus.Error);
            if (errors.length) {
                this.notifyError(...errors);
            }
            this.uploadService.cancelUpload(...files);
        });
    }
    /**
     * Checks if all the files are uploaded false if there is at least one file in Progress | Starting | Pending
     * @return {?}
     */
    isUploadCompleted() {
        return !this.isUploadCancelled() &&
            Boolean(this.files.length) &&
            !this.files
                .some(({ status }) => status === FileUploadStatus.Starting ||
                status === FileUploadStatus.Progress ||
                status === FileUploadStatus.Pending);
    }
    /**
     * Check if all the files are Cancelled | Aborted | Error. false if there is at least one file in uploading states
     * @return {?}
     */
    isUploadCancelled() {
        return !!this.files.length &&
            this.files
                .every(({ status }) => status === FileUploadStatus.Aborted ||
                status === FileUploadStatus.Cancelled ||
                status === FileUploadStatus.Deleted);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    deleteNode(file) {
        const { id } = file.data.entry;
        return this.nodesApi
            .deleteNode(id, { permanent: true })
            .pipe(map(() => {
            file.status = FileUploadStatus.Deleted;
            return file;
        }), catchError(() => {
            file.status = FileUploadStatus.Error;
            return of(file);
        }));
    }
    /**
     * @param {...?} files
     * @return {?}
     */
    notifyError(...files) {
        /** @type {?} */
        let messageError = null;
        if (files.length === 1) {
            messageError = this.translateService
                .instant('FILE_UPLOAD.MESSAGES.REMOVE_FILE_ERROR', { fileName: files[0].name });
        }
        else {
            messageError = this.translateService
                .instant('FILE_UPLOAD.MESSAGES.REMOVE_FILES_ERROR', { total: files.length });
        }
        this.error.emit(messageError);
    }
    /**
     * @return {?}
     */
    getUploadingFiles() {
        return this.files.filter((item) => {
            if (item.status === FileUploadStatus.Pending ||
                item.status === FileUploadStatus.Progress ||
                item.status === FileUploadStatus.Starting) {
                return item;
            }
        });
    }
}
FileUploadingListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-list',
                template: "<div class=\"upload-list\">\n    <ng-template\n        ngFor\n        [ngForOf]=\"files\"\n        [ngForTemplate]=\"template\">\n    </ng-template>\n</div>\n",
                styles: [":host{display:flex;flex-direction:column}"]
            }] }
];
/** @nocollapse */
FileUploadingListComponent.ctorParameters = () => [
    { type: UploadService },
    { type: NodesApiService },
    { type: TranslationService }
];
FileUploadingListComponent.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    files: [{ type: Input }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FileUploadingDialogComponent {
    /**
     * @param {?} uploadService
     * @param {?} changeDetecor
     */
    constructor(uploadService, changeDetecor) {
        this.uploadService = uploadService;
        this.changeDetecor = changeDetecor;
        /**
         * Dialog position. Can be 'left' or 'right'.
         */
        this.position = 'right';
        /**
         * Emitted when a file in the list has an error.
         */
        this.error = new EventEmitter();
        this.filesUploadingList = [];
        this.isDialogActive = false;
        this.totalCompleted = 0;
        this.totalErrors = 0;
        this.isDialogMinimized = false;
        this.isConfirmation = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.listSubscription = this.uploadService
            .queueChanged.subscribe((fileList) => {
            this.filesUploadingList = fileList;
            if (this.filesUploadingList.length) {
                this.isDialogActive = true;
            }
        });
        this.counterSubscription = merge(this.uploadService.fileUploadComplete, this.uploadService.fileUploadDeleted)
            .subscribe((event) => {
            this.totalCompleted = event.totalComplete;
            this.changeDetecor.detectChanges();
        });
        this.errorSubscription = this.uploadService.fileUploadError
            .subscribe((event) => {
            this.totalErrors = event.totalError;
            this.changeDetecor.detectChanges();
        });
        this.fileUploadSubscription = this.uploadService
            .fileUpload.subscribe(() => {
            this.changeDetecor.detectChanges();
        });
        this.uploadService.fileDeleted.subscribe((objId) => {
            if (this.filesUploadingList) {
                /** @type {?} */
                let file = this.filesUploadingList.find((item) => {
                    return item.data.entry.id === objId;
                });
                if (file) {
                    file.status = FileUploadStatus.Cancelled;
                    this.changeDetecor.detectChanges();
                }
            }
        });
    }
    /**
     * Toggle confirmation message.
     * @return {?}
     */
    toggleConfirmation() {
        this.isConfirmation = !this.isConfirmation;
        if (this.isDialogMinimized) {
            this.isDialogMinimized = false;
        }
    }
    /**
     * Cancel uploads and hide confiramtion
     * @return {?}
     */
    cancelAllUploads() {
        this.toggleConfirmation();
        this.uploadList.cancelAllFiles();
    }
    /**
     * Toggle dialog minimized state.
     * @return {?}
     */
    toggleMinimized() {
        this.isDialogMinimized = !this.isDialogMinimized;
        this.changeDetecor.detectChanges();
    }
    /**
     * Dismiss dialog
     * @return {?}
     */
    close() {
        this.isConfirmation = false;
        this.totalCompleted = 0;
        this.totalErrors = 0;
        this.filesUploadingList = [];
        this.isDialogActive = false;
        this.isDialogMinimized = false;
        this.uploadService.clearQueue();
        this.changeDetecor.detectChanges();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.uploadService.clearQueue();
        this.listSubscription.unsubscribe();
        this.counterSubscription.unsubscribe();
        this.fileUploadSubscription.unsubscribe();
        this.errorSubscription.unsubscribe();
    }
}
FileUploadingDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-dialog, file-uploading-dialog',
                template: "<div *ngIf=\"isDialogActive\"\n     class=\"upload-dialog\"\n     id=\"upload-dialog\"\n     [class.upload-dialog--minimized]=\"isDialogMinimized\"\n     [class.upload-dialog--position-left]=\"position === 'left'\"\n     [class.upload-dialog--position-right]=\"position === 'right'\">\n    <header class=\"upload-dialog__header\">\n        <button\n            mat-button\n            color=\"secondary\"\n            [disabled]=\"isConfirmation\"\n            (click)=\"toggleMinimized()\">\n            <mat-icon\n                mat-list-icon\n                title=\"{{ (isDialogMinimized ? 'ADF_FILE_UPLOAD.BUTTON.MAXIMIZE': 'ADF_FILE_UPLOAD.BUTTON.MINIMIZE') | translate }}\">\n                    {{ isDialogMinimized ? 'keyboard_arrow_up' : 'keyboard_arrow_down' }}\n            </mat-icon>\n        </button>\n\n        <span\n            class=\"upload-dialog__title\"\n            *ngIf=\"!uploadList.isUploadCompleted() && !uploadList.isUploadCancelled()\">\n            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_PROGRESS'\n                | translate: {\n                    completed: totalCompleted,\n                    total: filesUploadingList.length\n                }\n            }}\n        </span>\n\n        <span\n            class=\"upload-dialog__title\"\n            *ngIf=\"uploadList.isUploadCompleted()\">\n            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_COMPLETED'\n                | translate: {\n                    completed: totalCompleted,\n                    total: filesUploadingList.length\n                }\n            }}\n        </span>\n\n        <span\n            class=\"upload-dialog__title\"\n            *ngIf=\"uploadList.isUploadCancelled()\">\n            {{ 'FILE_UPLOAD.MESSAGES.UPLOAD_CANCELED' | translate }}\n        </span>\n    </header>\n\n    <section class=\"upload-dialog__info\"\n        *ngIf=\"totalErrors\">\n        {{\n            (totalErrors > 1\n                 ? 'FILE_UPLOAD.MESSAGES.UPLOAD_ERRORS'\n                 : 'FILE_UPLOAD.MESSAGES.UPLOAD_ERROR')\n                 | translate: { total: totalErrors }\n        }}\n    </section>\n\n    <section class=\"upload-dialog__content\"\n        [class.upload-dialog--padding]=\"isConfirmation\">\n        <adf-file-uploading-list\n            [class.upload-dialog--hide]=\"isConfirmation\"\n            #uploadList\n            [files]=\"filesUploadingList\">\n                <ng-template let-file=\"$implicit\">\n                     <adf-file-uploading-list-row\n                        [file]=\"file\"\n                        (remove)=\"uploadList.removeFile(file)\"\n                        (cancel)=\"uploadList.cancelFile(file)\">\n                    </adf-file-uploading-list-row>\n                </ng-template>\n        </adf-file-uploading-list>\n\n        <div\n            class=\"upload-dialog__confirmation\"\n            [class.upload-dialog--hide]=\"!isConfirmation\">\n                <p class=\"upload-dialog__confirmation--title\">\n                    {{ 'ADF_FILE_UPLOAD.CONFIRMATION.MESSAGE.TITLE' | translate }}\n                </p>\n\n                <p class=\"upload-dialog__confirmation--text\">\n                    {{ 'ADF_FILE_UPLOAD.CONFIRMATION.MESSAGE.TEXT' | translate }}\n                </p>\n        </div>\n    </section>\n\n    <footer class=\"upload-dialog__actions\"\n            *ngIf=\"!isConfirmation\">\n        <button\n            id=\"adf-upload-dialog-cancel-all\"\n            color=\"primary\"\n            mat-button\n            *ngIf=\"!uploadList.isUploadCompleted() && !uploadList.isUploadCancelled()\"\n            (click)=\"toggleConfirmation()\">\n            {{ 'ADF_FILE_UPLOAD.BUTTON.CANCEL_ALL' | translate }}\n        </button>\n\n        <button\n            id=\"adf-upload-dialog-close\"\n            *ngIf=\"uploadList.isUploadCompleted() || uploadList.isUploadCancelled()\"\n            mat-button\n            color=\"primary\"\n            (click)=\"close()\">\n            {{ 'ADF_FILE_UPLOAD.BUTTON.CLOSE' | translate }}\n        </button>\n    </footer>\n\n    <footer class=\"upload-dialog__actions\"\n            *ngIf=\"isConfirmation\">\n        <button\n            id=\"adf-upload-dialog-cancel\"\n            color=\"secondary\"\n            mat-button\n            (click)=\"cancelAllUploads()\">\n            {{ 'ADF_FILE_UPLOAD.CONFIRMATION.BUTTON.CANCEL' | translate }}\n        </button>\n\n        <button\n            id=\"adf-upload-dialog-confirm\"\n            mat-button\n            color=\"primary\"\n            (click)=\"toggleConfirmation()\">\n            {{ 'ADF_FILE_UPLOAD.CONFIRMATION.BUTTON.CONTINUE' | translate }}\n        </button>\n    </footer>\n</div>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
FileUploadingDialogComponent.ctorParameters = () => [
    { type: UploadService },
    { type: ChangeDetectorRef }
];
FileUploadingDialogComponent.propDecorators = {
    uploadList: [{ type: ViewChild, args: ['uploadList',] }],
    position: [{ type: Input }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FileUploadingListRowComponent {
    constructor() {
        this.cancel = new EventEmitter();
        this.remove = new EventEmitter();
        this.FileUploadStatus = FileUploadStatus;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    onCancel(file) {
        this.cancel.emit(file);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    onRemove(file) {
        this.remove.emit(file);
    }
}
FileUploadingListRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-file-uploading-list-row',
                template: "<div class=\"adf-file-uploading-row\">\n    <mat-icon\n        mat-list-icon\n        class=\"adf-file-uploading-row__type\">\n        insert_drive_file\n    </mat-icon>\n\n    <span\n        class=\"adf-file-uploading-row__name\"\n        title=\"{{ file.name }}\">\n        {{ file.name }}\n    </span>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Progress || file.status === FileUploadStatus.Starting\"\n        (click)=\"onCancel(file)\"\n        class=\"adf-file-uploading-row__group adf-file-uploading-row__group--toggle\"\n        title=\"{{ 'ADF_FILE_UPLOAD.BUTTON.CANCEL_FILE' | translate }}\">\n        <span class=\"adf-file-uploading-row__status\">\n            {{ file.progress.loaded | adfFileSize }} / {{ file.progress.total | adfFileSize }}\n        </span>\n\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__action adf-file-uploading-row__action--cancel\">\n            clear\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Complete\"\n        (click)=\"onRemove(file)\"\n        class=\"adf-file-uploading-row__group adf-file-uploading-row__group--toggle\"\n        title=\"{{ 'ADF_FILE_UPLOAD.BUTTON.REMOVE_FILE' | translate }}\">\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__status adf-file-uploading-row__status--done\">\n            check_circle\n        </mat-icon>\n\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__action adf-file-uploading-row__action--remove\">\n            remove_circle\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Pending\"\n        (click)=\"onCancel(file)\"\n        class=\"adf-file-uploading-row__group adf-file-uploading-row__group--toggle\">\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__status adf-file-uploading-row__status--pending\">\n            schedule\n        </mat-icon>\n\n        <mat-icon\n            mat-list-icon\n            class=\"adf-file-uploading-row__action adf-file-uploading-row__action--remove\">\n            remove_circle\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Error\"\n        class=\"adf-file-uploading-row__block adf-file-uploading-row__status--error\">\n        <mat-icon mat-list-icon>\n            report_problem\n        </mat-icon>\n    </div>\n\n    <div\n        *ngIf=\"file.status === FileUploadStatus.Cancelled  ||\n            file.status === FileUploadStatus.Aborted ||\n            file.status === FileUploadStatus.Deleted\"\n        class=\"adf-file-uploading-row__block adf-file-uploading-row__status--cancelled\">\n        {{ 'ADF_FILE_UPLOAD.STATUS.FILE_CANCELED_STATUS' | translate }}\n    </div>\n<div>\n",
                styles: [""]
            }] }
];
FileUploadingListRowComponent.propDecorators = {
    file: [{ type: Input }],
    cancel: [{ type: Output }],
    remove: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UploadFilesEvent {
    /**
     * @param {?} files
     * @param {?} uploadService
     * @param {?} callback
     */
    constructor(files, uploadService, callback) {
        this.files = files;
        this.uploadService = uploadService;
        this.callback = callback;
        this.isDefaultPrevented = false;
    }
    /**
     * @return {?}
     */
    get defaultPrevented() {
        return this.isDefaultPrevented;
    }
    /**
     * @return {?}
     */
    preventDefault() {
        this.isDefaultPrevented = true;
    }
    /**
     * @return {?}
     */
    pauseUpload() {
        this.preventDefault();
    }
    /**
     * @return {?}
     */
    resumeUpload() {
        if (this.files && this.files.length > 0) {
            this.uploadService.addToQueue(...this.files);
            this.uploadService.uploadFilesInTheQueue(this.callback);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class UploadBase {
    /**
     * @param {?} uploadService
     * @param {?} translationService
     * @param {?} ngZone
     */
    constructor(uploadService, translationService, ngZone) {
        this.uploadService = uploadService;
        this.translationService = translationService;
        this.ngZone = ngZone;
        /**
         * The ID of the root. Use the nodeId for
         * Content Services or the taskId/processId for Process Services.
         */
        this.rootFolderId = '-root-';
        /**
         * Toggles component disabled state (if there is no node permission checking).
         */
        this.disabled = false;
        /**
         * Filter for accepted file types.
         */
        this.acceptedFilesType = '*';
        /**
         * Toggles versioning.
         */
        this.versioning = false;
        /**
         * majorVersion boolean field to true to indicate a major version should be created.
         */
        this.majorVersion = false;
        /**
         * Custom node type for uploaded file
         */
        this.nodeType = 'cm:content';
        /**
         * Emitted when the file is uploaded successfully.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when a folder is created.
         * @deprecated 2.4.0 No longer used by the framework
         */
        this.createFolder = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the upload begins.
         */
        this.beginUpload = new EventEmitter();
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.uploadService.fileUploadError.subscribe((error) => {
            this.error.emit(error);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(subscription => subscription.unsubscribe());
        this.subscriptions = [];
    }
    /**
     * Upload a list of file in the specified path
     * @param {?} files
     * @return {?}
     */
    uploadFiles(files) {
        /** @type {?} */
        const filteredFiles = files
            .map((file) => {
            return this.createFileModel(file, this.rootFolderId, (file.webkitRelativePath || '').replace(/\/[^\/]*$/, ''));
        });
        this.uploadQueue(filteredFiles);
    }
    /**
     * @param {?} files
     * @return {?}
     */
    uploadFilesInfo(files) {
        /** @type {?} */
        const filteredFiles = files
            .map((fileInfo) => {
            return this.createFileModel(fileInfo.file, this.rootFolderId, fileInfo.relativeFolder);
        });
        this.uploadQueue(filteredFiles);
    }
    /**
     * @param {?} files
     * @return {?}
     */
    uploadQueue(files) {
        /** @type {?} */
        let filteredFiles = files
            .filter(this.isFileAcceptable.bind(this))
            .filter(this.isFileSizeAcceptable.bind(this));
        this.ngZone.run(() => {
            /** @type {?} */
            const event = new UploadFilesEvent([...filteredFiles], this.uploadService, this.success);
            this.beginUpload.emit(event);
            if (!event.defaultPrevented) {
                if (filteredFiles.length > 0) {
                    this.uploadService.addToQueue(...filteredFiles);
                    this.uploadService.uploadFilesInTheQueue(this.success);
                }
            }
        });
    }
    /**
     * Checks if the given file is allowed by the extension filters
     *
     * @param {?} file FileModel
     * @return {?}
     */
    isFileAcceptable(file) {
        if (this.acceptedFilesType === '*') {
            return true;
        }
        /** @type {?} */
        const allowedExtensions = this.acceptedFilesType
            .split(',')
            .map(ext => ext.replace(/^\./, ''));
        if (allowedExtensions.indexOf(file.extension) !== -1) {
            return true;
        }
        return false;
    }
    /**
     * Creates FileModel from File
     *
     * @param {?} file
     * @param {?} parentId
     * @param {?} path
     * @param {?=} id
     * @return {?}
     */
    createFileModel(file, parentId, path, id) {
        return new FileModel(file, {
            comment: this.comment,
            majorVersion: this.majorVersion,
            newVersion: this.versioning,
            parentId: parentId,
            path: path,
            nodeType: this.nodeType
        }, id);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    isFileSizeAllowed(file) {
        /** @type {?} */
        let isFileSizeAllowed = true;
        if (this.isMaxFileSizeDefined()) {
            isFileSizeAllowed = this.isFileSizeCorrect(file);
        }
        return isFileSizeAllowed;
    }
    /**
     * @return {?}
     */
    isMaxFileSizeDefined() {
        return this.maxFilesSize !== undefined && this.maxFilesSize !== null;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    isFileSizeCorrect(file) {
        return this.maxFilesSize >= 0 && file.size <= this.maxFilesSize;
    }
    /**
     * Checks if the given file is an acceptable size
     *
     * @param {?} file FileModel
     * @return {?}
     */
    isFileSizeAcceptable(file) {
        /** @type {?} */
        let acceptableSize = true;
        if (!this.isFileSizeAllowed(file)) {
            acceptableSize = false;
            /** @type {?} */
            const message = this.translationService.instant('FILE_UPLOAD.MESSAGES.EXCEED_MAX_FILE_SIZE', { fileName: file.name });
            this.error.emit(message);
        }
        return acceptableSize;
    }
}
UploadBase.propDecorators = {
    maxFilesSize: [{ type: Input }],
    rootFolderId: [{ type: Input }],
    disabled: [{ type: Input }],
    acceptedFilesType: [{ type: Input }],
    versioning: [{ type: Input }],
    majorVersion: [{ type: Input }],
    comment: [{ type: Input }],
    nodeType: [{ type: Input }],
    success: [{ type: Output }],
    createFolder: [{ type: Output }],
    error: [{ type: Output }],
    beginUpload: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class UploadButtonComponent extends UploadBase {
    /**
     * @param {?} uploadService
     * @param {?} contentService
     * @param {?} translationService
     * @param {?} logService
     * @param {?} ngZone
     */
    constructor(uploadService, contentService, translationService, logService, ngZone) {
        super(uploadService, translationService, ngZone);
        this.uploadService = uploadService;
        this.contentService = contentService;
        this.translationService = translationService;
        this.logService = logService;
        this.ngZone = ngZone;
        /**
         * Allows/disallows upload folders (only for Chrome).
         */
        this.uploadFolders = false;
        /**
         * Allows/disallows multiple files
         */
        this.multipleFiles = false;
        /**
         * Custom tooltip text.
         */
        this.tooltip = null;
        /**
         * Emitted when create permission is missing.
         */
        this.permissionEvent = new EventEmitter();
        this.hasPermission = false;
        this.permissionValue = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.permissionValue.subscribe((permission) => {
            this.hasPermission = permission;
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        let rootFolderId = changes['rootFolderId'];
        if (rootFolderId && rootFolderId.currentValue) {
            this.checkPermission();
        }
    }
    /**
     * @return {?}
     */
    isButtonDisabled() {
        return this.disabled ? true : undefined;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onFilesAdded($event) {
        /** @type {?} */
        let files = FileUtils.toFileArray($event.currentTarget.files);
        if (this.hasPermission) {
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        // reset the value of the input file
        $event.target.value = '';
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDirectoryAdded($event) {
        if (this.hasPermission) {
            /** @type {?} */
            let files = FileUtils.toFileArray($event.currentTarget.files);
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        // reset the value of the input file
        $event.target.value = '';
    }
    /**
     * @return {?}
     */
    checkPermission() {
        if (this.rootFolderId) {
            /** @type {?} */
            let opts = {
                includeSource: true,
                include: ['allowableOperations']
            };
            this.contentService.getNode(this.rootFolderId, opts).subscribe(res => this.permissionValue.next(this.nodeHasPermission(res.entry, PermissionsEnum.CREATE)), error => this.error.emit(error));
        }
    }
    /**
     * @param {?} node
     * @param {?} permission
     * @return {?}
     */
    nodeHasPermission(node, permission) {
        return this.contentService.hasPermission(node, permission);
    }
}
UploadButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-upload-button',
                template: "<form class=\"adf-upload-button-file-container\">\n    <!--Files Upload-->\n    <a *ngIf=\"!uploadFolders\"\n        [disabled]=\"isButtonDisabled()\"\n        mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n\n        <!--Multiple Files Upload-->\n        <span *ngIf=\"multipleFiles\">\n            <label\n                id=\"upload-multiple-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-multiple-files\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-multiple-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-multiple-files\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-multiple-files\"\n                data-automation-id=\"upload-multiple-files\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                multiple=\"multiple\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n\n        <!--Single Files Upload-->\n        <span *ngIf=\"!multipleFiles\">\n            <label\n                id=\"upload-single-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-single-file\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-single-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-single-file\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-single-file\"\n                data-automation-id=\"upload-single-file\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n    </a>\n\n    <!--Folders Upload-->\n    <a *ngIf=\"uploadFolders\"\n        [disabled]=\"isButtonDisabled()\" mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n        <label\n            id=\"uploadFolder-label\"\n            *ngIf=\"!staticTitle\"\n            for=\"uploadFolder\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FOLDER' | translate }}</label>\n        <label\n            id=\"uploadFolder-label-static\"\n            *ngIf=\"staticTitle\"\n            for=\"uploadFolder\">{{ staticTitle }}</label>\n        <input #uploadFolders\n            id=\"uploadFolder\"\n            data-automation-id=\"uploadFolder\"\n            type=\"file\"\n            name=\"uploadFiles\"\n            multiple=\"multiple\"\n            accept=\"{{acceptedFilesType}}\"\n            webkitdirectory directory\n            [attr.disabled]=\"isButtonDisabled()\"\n            [title]=\"tooltip\"\n            (change)=\"onDirectoryAdded($event)\">\n    </a>\n</form>\n",
                viewProviders: [
                    { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef(() => UploadButtonComponent) }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-upload-button-file-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}"]
            }] }
];
/** @nocollapse */
UploadButtonComponent.ctorParameters = () => [
    { type: UploadService },
    { type: ContentService },
    { type: TranslationService },
    { type: LogService },
    { type: NgZone }
];
UploadButtonComponent.propDecorators = {
    uploadFolders: [{ type: Input }],
    multipleFiles: [{ type: Input }],
    staticTitle: [{ type: Input }],
    tooltip: [{ type: Input }],
    permissionEvent: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class UploadVersionButtonComponent extends UploadButtonComponent {
    /**
     * @param {?} file
     * @return {?}
     */
    createFileModel(file) {
        /** @type {?} */
        const fileModel = super.createFileModel(file, this.rootFolderId, (file.webkitRelativePath || '').replace(/\/[^\/]*$/, ''), this.node.id);
        if (!this.isFileAcceptable(fileModel)) {
            /** @type {?} */
            const message = this.translationService.instant('FILE_UPLOAD.VERSION.MESSAGES.INCOMPATIBLE_VERSION');
            this.error.emit(message);
        }
        return fileModel;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.checkPermission();
    }
    /**
     * @return {?}
     */
    checkPermission() {
        this.permissionValue.next(this.nodeHasPermission(this.node, PermissionsEnum.UPDATE));
    }
}
UploadVersionButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-upload-version-button',
                template: "<form class=\"adf-upload-button-file-container\">\n    <!--Files Upload-->\n    <a *ngIf=\"!uploadFolders\"\n        [disabled]=\"isButtonDisabled()\"\n        mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n\n        <!--Multiple Files Upload-->\n        <span *ngIf=\"multipleFiles\">\n            <label\n                id=\"upload-multiple-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-multiple-files\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-multiple-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-multiple-files\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-multiple-files\"\n                data-automation-id=\"upload-multiple-files\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                multiple=\"multiple\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n\n        <!--Single Files Upload-->\n        <span *ngIf=\"!multipleFiles\">\n            <label\n                id=\"upload-single-file-label\"\n                *ngIf=\"!staticTitle\"\n                for=\"upload-single-file\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</label>\n            <label\n                id=\"upload-single-file-label-static\"\n                *ngIf=\"staticTitle\"\n                for=\"upload-single-file\">{{ staticTitle }}</label>\n            <input #uploadFiles\n                id=\"upload-single-file\"\n                data-automation-id=\"upload-single-file\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </span>\n    </a>\n\n    <!--Folders Upload-->\n    <a *ngIf=\"uploadFolders\"\n        [disabled]=\"isButtonDisabled()\" mat-raised-button color=\"primary\">\n        <mat-icon>file_upload</mat-icon>\n        <label\n            id=\"uploadFolder-label\"\n            *ngIf=\"!staticTitle\"\n            for=\"uploadFolder\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FOLDER' | translate }}</label>\n        <label\n            id=\"uploadFolder-label-static\"\n            *ngIf=\"staticTitle\"\n            for=\"uploadFolder\">{{ staticTitle }}</label>\n        <input #uploadFolders\n            id=\"uploadFolder\"\n            data-automation-id=\"uploadFolder\"\n            type=\"file\"\n            name=\"uploadFiles\"\n            multiple=\"multiple\"\n            accept=\"{{acceptedFilesType}}\"\n            webkitdirectory directory\n            [attr.disabled]=\"isButtonDisabled()\"\n            [title]=\"tooltip\"\n            (change)=\"onDirectoryAdded($event)\">\n    </a>\n</form>\n",
                viewProviders: [
                    { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef(() => UploadVersionButtonComponent) }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-upload-button-file-container input{cursor:pointer;height:100%;right:0;opacity:0;position:absolute;top:0;width:300px;z-index:4}"]
            }] }
];
UploadVersionButtonComponent.propDecorators = {
    node: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class UploadDragAreaComponent extends UploadBase {
    /**
     * @param {?} uploadService
     * @param {?} translationService
     * @param {?} notificationService
     * @param {?} contentService
     * @param {?} ngZone
     */
    constructor(uploadService, translationService, notificationService, contentService, ngZone) {
        super(uploadService, translationService, ngZone);
        this.uploadService = uploadService;
        this.translationService = translationService;
        this.notificationService = notificationService;
        this.contentService = contentService;
        this.ngZone = ngZone;
    }
    /**
     * ID of parent folder node
     * @deprecated 2.4.0 - use rootFolderId ID of parent folder node
     * @param {?} nodeId
     * @return {?}
     */
    set parentId(nodeId) {
        this.rootFolderId = nodeId;
    }
    /**
     * Method called when files are dropped in the drag area.
     *
     * @param {?} files - files dropped in the drag area.
     * @return {?}
     */
    onFilesDropped(files) {
        if (!this.disabled && files.length) {
            this.uploadFiles(files);
        }
    }
    /**
     * Called when the file are dropped in the drag area.
     * @deprecated in 2.4.0: use `onFilesDropped` instead
     * @param {?} item - FileEntity
     * @return {?}
     */
    onFilesEntityDropped(item) {
        if (!this.disabled) {
            item.file((file) => {
                // const fileModel = this.createFileModel(file, this.rootFolderId, item.fullPath.replace(item.name, ''));
                this.uploadFiles([file]);
            });
        }
    }
    /**
     * Called when a folder are dropped in the drag area
     *
     * @param {?} folder - name of the dropped folder
     * @return {?}
     */
    onFolderEntityDropped(folder) {
        if (!this.disabled && folder.isDirectory) {
            FileUtils.flattern(folder).then(filesInfo => {
                this.uploadFilesInfo(filesInfo);
            });
        }
    }
    /**
     * Show undo notification bar.
     *
     * @param {?} latestFilesAdded - files in the upload queue enriched with status flag and xhr object.
     * @return {?}
     */
    showUndoNotificationBar(latestFilesAdded) {
        /** @type {?} */
        let messageTranslate;
        /** @type {?} */
        let actionTranslate;
        messageTranslate = this.translationService.get('FILE_UPLOAD.MESSAGES.PROGRESS');
        actionTranslate = this.translationService.get('FILE_UPLOAD.ACTION.UNDO');
        this.notificationService.openSnackMessageAction(messageTranslate.value, actionTranslate.value, 3000).onAction().subscribe(() => {
            this.uploadService.cancelUpload(...latestFilesAdded);
        });
    }
    /**
     * Returns true or false considering the component options and node permissions
     * @return {?}
     */
    isDroppable() {
        return !this.disabled;
    }
    /**
     * Handles 'upload-files' events raised by child components.
     *
     * @param {?} event DOM event
     * @return {?}
     */
    onUploadFiles(event) {
        event.stopPropagation();
        event.preventDefault();
        /** @type {?} */
        let isAllowed = this.contentService.hasPermission(event.detail.data.obj.entry, PermissionsEnum.CREATE);
        if (isAllowed) {
            /** @type {?} */
            let fileInfo = event.detail.files;
            if (this.isTargetNodeFolder(event)) {
                /** @type {?} */
                const destinationFolderName = event.detail.data.obj.entry.name;
                fileInfo.map((file) => file.relativeFolder = destinationFolderName ? destinationFolderName.concat(file.relativeFolder) : file.relativeFolder);
            }
            if (fileInfo && fileInfo.length > 0) {
                this.uploadFilesInfo(fileInfo);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    isTargetNodeFolder(event) {
        return event.detail.data.obj && event.detail.data.obj.entry.isFolder;
    }
}
UploadDragAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-upload-drag-area',
                template: "<div [file-draggable]=\"isDroppable()\" class=\"upload-border\"\n     (filesDropped)=\"onFilesDropped($event)\"\n     (folderEntityDropped)=\"onFolderEntityDropped($event)\"\n     (upload-files)=\"onUploadFiles($event)\"\n     dropzone=\"\" webkitdropzone=\"*\" #droparea>\n    <ng-content></ng-content>\n</div>\n",
                host: { 'class': 'adf-upload-drag-area' },
                viewProviders: [
                    { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef(() => UploadDragAreaComponent) }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: ["adf-upload-drag-area{overflow:hidden}.upload-border{vertical-align:middle;text-align:center;width:100%;box-sizing:border-box}.file-draggable__input-focus{color:#2196f3;border:1px dashed #2196f3}"]
            }] }
];
/** @nocollapse */
UploadDragAreaComponent.ctorParameters = () => [
    { type: UploadService },
    { type: TranslationService },
    { type: NotificationService },
    { type: ContentService },
    { type: NgZone }
];
UploadDragAreaComponent.propDecorators = {
    parentId: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FileDraggableDirective {
    /**
     * @param {?} el
     * @param {?} ngZone
     */
    constructor(el, ngZone) {
        this.ngZone = ngZone;
        /**
         * Enables/disables drag-and-drop functionality.
         */
        this.enabled = true;
        /**
         * Emitted when one or more files are dragged and dropped onto the draggable element.
         */
        this.filesDropped = new EventEmitter();
        /**
         * Emitted when one or more files are dragged and dropped onto the draggable element.
         * @deprecated in 2.4.0: use `filesDropped` instead
         */
        this.filesEntityDropped = new EventEmitter();
        /**
         * Emitted when a directory is dragged and dropped onto the draggable element.
         */
        this.folderEntityDropped = new EventEmitter();
        this.cssClassName = 'file-draggable__input-focus';
        this.element = el.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            this.element.addEventListener('dragenter', this.onDragEnter.bind(this));
            this.element.addEventListener('dragover', this.onDragOver.bind(this));
            this.element.addEventListener('dragleave', this.onDragLeave.bind(this));
            this.element.addEventListener('drop', this.onDropFiles.bind(this));
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.element.removeEventListener('dragenter', this.onDragEnter);
        this.element.removeEventListener('dragover', this.onDragOver);
        this.element.removeEventListener('dragleave', this.onDragLeave);
        this.element.removeEventListener('drop', this.onDropFiles);
    }
    /**
     * Method called when files is dropped in the drag and drop area.
     * @param {?} event DOM event.
     * @return {?}
     */
    onDropFiles(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            /** @type {?} */
            const items = event.dataTransfer.items;
            if (items) {
                /** @type {?} */
                const files = [];
                for (let i = 0; i < items.length; i++) {
                    if (items[i].webkitGetAsEntry) {
                        /** @type {?} */
                        const item = items[i].webkitGetAsEntry();
                        if (item) {
                            if (item.isFile) {
                                /** @type {?} */
                                const file = items[i].getAsFile();
                                if (file) {
                                    files.push(file);
                                }
                            }
                            else if (item.isDirectory) {
                                this.folderEntityDropped.emit(item);
                            }
                        }
                    }
                }
                if (files.length > 0) {
                    this.filesDropped.emit(files);
                }
            }
            else {
                /** @type {?} */
                const files = FileUtils.toFileArray(event.dataTransfer.files);
                this.filesDropped.emit(files);
            }
            this.element.classList.remove(this.cssClassName);
        }
    }
    /**
     * Change the style of the drag area when a file drag in.
     *
     * @param {?} event - DOM event.
     * @return {?}
     */
    onDragEnter(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.add(this.cssClassName);
        }
    }
    /**
     * Change the style of the drag area when a file drag out.
     *
     * @param {?} event - DOM event.
     * @return {?}
     */
    onDragLeave(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.remove(this.cssClassName);
        }
    }
    /**
     * Change the style of the drag area when a file is over the drag area.
     *
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) {
        if (this.enabled && !event.defaultPrevented) {
            this.preventDefault(event);
            this.element.classList.add(this.cssClassName);
        }
    }
    /**
     * Prevent default and stop propagation of the DOM event.
     *
     * @param {?} event
     * @return {?}
     */
    preventDefault(event) {
        event.stopPropagation();
        event.preventDefault();
    }
}
FileDraggableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[file-draggable]'
            },] }
];
/** @nocollapse */
FileDraggableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
FileDraggableDirective.propDecorators = {
    enabled: [{ type: Input, args: ['file-draggable',] }],
    filesDropped: [{ type: Output }],
    filesEntityDropped: [{ type: Output }],
    folderEntityDropped: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class UploadModule {
}
UploadModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    FileDraggableDirective,
                    UploadDragAreaComponent,
                    UploadButtonComponent,
                    UploadVersionButtonComponent,
                    FileUploadingDialogComponent,
                    FileUploadingListComponent,
                    FileUploadingListRowComponent
                ],
                exports: [
                    FileDraggableDirective,
                    UploadDragAreaComponent,
                    UploadButtonComponent,
                    UploadVersionButtonComponent,
                    FileUploadingDialogComponent,
                    FileUploadingListComponent,
                    FileUploadingListRowComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DocumentListModule {
}
DocumentListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    CommonModule,
                    FlexLayoutModule,
                    MaterialModule,
                    UploadModule
                ],
                declarations: [
                    DocumentListComponent,
                    ContentColumnComponent,
                    ContentColumnListComponent,
                    ContentActionComponent,
                    ContentActionListComponent,
                    EmptyFolderContentDirective,
                    NoPermissionContentDirective
                ],
                exports: [
                    DocumentListComponent,
                    ContentColumnComponent,
                    ContentColumnListComponent,
                    ContentActionComponent,
                    ContentActionListComponent,
                    EmptyFolderContentDirective,
                    NoPermissionContentDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchQueryBuilderService {
    /**
     * @param {?} appConfig
     * @param {?} alfrescoApiService
     */
    constructor(appConfig, alfrescoApiService) {
        this.appConfig = appConfig;
        this.alfrescoApiService = alfrescoApiService;
        this._userQuery = '';
        this.updated = new Subject();
        this.executed = new Subject();
        this.categories = [];
        this.queryFragments = {};
        this.filterQueries = [];
        this.paging = null;
        this.sorting = [];
        this.userFacetQueries = [];
        this.userFacetBuckets = {};
        // TODO: to be supported in future iterations
        this.ranges = {};
        this.resetToDefaults();
    }
    /**
     * @return {?}
     */
    get userQuery() {
        return this._userQuery;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set userQuery(value) {
        value = (value || '').trim();
        this._userQuery = value ? `(${value})` : '';
    }
    /**
     * @return {?}
     */
    resetToDefaults() {
        /** @type {?} */
        const template = this.appConfig.get('search');
        if (template) {
            this.config = JSON.parse(JSON.stringify(template));
            this.categories = (this.config.categories || []).filter(category => category.enabled);
            this.filterQueries = this.config.filterQueries || [];
            this.userFacetBuckets = {};
            this.userFacetQueries = [];
            if (this.config.sorting) {
                this.sorting = this.config.sorting.defaults || [];
            }
        }
    }
    /**
     * @param {?} query
     * @return {?}
     */
    addUserFacetQuery(query) {
        if (query) {
            /** @type {?} */
            const existing = this.userFacetQueries.find(facetQuery => facetQuery.label === query.label);
            if (existing) {
                existing.query = query.query;
            }
            else {
                this.userFacetQueries.push(Object.assign({}, query));
            }
        }
    }
    /**
     * @param {?} query
     * @return {?}
     */
    removeUserFacetQuery(query) {
        if (query) {
            this.userFacetQueries = this.userFacetQueries
                .filter(facetQuery => facetQuery.label !== query.label);
        }
    }
    /**
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    addUserFacetBucket(field, bucket) {
        if (field && field.field && bucket) {
            /** @type {?} */
            const buckets = this.userFacetBuckets[field.field] || [];
            /** @type {?} */
            const existing = buckets.find(facetBucket => facetBucket.label === bucket.label);
            if (!existing) {
                buckets.push(bucket);
            }
            this.userFacetBuckets[field.field] = buckets;
        }
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getUserFacetBuckets(field) {
        return this.userFacetBuckets[field] || [];
    }
    /**
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    removeUserFacetBucket(field, bucket) {
        if (field && field.field && bucket) {
            /** @type {?} */
            const buckets = this.userFacetBuckets[field.field] || [];
            this.userFacetBuckets[field.field] = buckets
                .filter(facetBucket => facetBucket.label !== bucket.label);
        }
    }
    /**
     * @param {?} query
     * @return {?}
     */
    addFilterQuery(query) {
        if (query) {
            /** @type {?} */
            const existing = this.filterQueries.find(filterQuery => filterQuery.query === query);
            if (!existing) {
                this.filterQueries.push({ query: query });
            }
        }
    }
    /**
     * @param {?} query
     * @return {?}
     */
    removeFilterQuery(query) {
        if (query) {
            this.filterQueries = this.filterQueries
                .filter(filterQuery => filterQuery.query !== query);
        }
    }
    /**
     * @param {?} label
     * @return {?}
     */
    getFacetQuery(label) {
        if (label && this.hasFacetQueries) {
            /** @type {?} */
            const result = this.config.facetQueries.queries.find(query => query.label === label);
            if (result) {
                return Object.assign({}, result);
            }
        }
        return null;
    }
    /**
     * @param {?} label
     * @return {?}
     */
    getFacetField(label) {
        if (label) {
            /** @type {?} */
            const fields = this.config.facetFields.fields || [];
            /** @type {?} */
            const result = fields.find(field => field.label === label);
            if (result) {
                return Object.assign({}, result);
            }
        }
        return null;
    }
    /**
     * @return {?}
     */
    update() {
        /** @type {?} */
        const query = this.buildQuery();
        this.updated.next(query);
    }
    /**
     * @return {?}
     */
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const query = this.buildQuery();
            if (query) {
                /** @type {?} */
                const data = yield this.alfrescoApiService.searchApi.search(query);
                this.executed.next(data);
            }
        });
    }
    /**
     * @return {?}
     */
    buildQuery() {
        /** @type {?} */
        let query = this.getFinalQuery();
        /** @type {?} */
        const include = this.config.include || [];
        if (include.length === 0) {
            include.push('path', 'allowableOperations');
        }
        if (query) {
            /** @type {?} */
            const result = {
                query: {
                    query: query,
                    language: 'afts'
                },
                include: include,
                paging: this.paging,
                fields: this.config.fields,
                filterQueries: this.filterQueries,
                facetQueries: this.facetQueries,
                facetFields: this.facetFields,
                sort: this.sort
            };
            return result;
        }
        return null;
    }
    /**
     * Returns primary sorting definition.
     * @return {?}
     */
    getPrimarySorting() {
        if (this.sorting && this.sorting.length > 0) {
            return this.sorting[0];
        }
        return null;
    }
    /**
     * Returns all pre-configured sorting options that users can choose from.
     * @return {?}
     */
    getSortingOptions() {
        if (this.config && this.config.sorting) {
            return this.config.sorting.options || [];
        }
        return [];
    }
    /**
     * Check if FacetQueries has been defined
     * @return {?}
     */
    get hasFacetQueries() {
        if (this.config
            && this.config.facetQueries
            && this.config.facetQueries.queries
            && this.config.facetQueries.queries.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    get sort() {
        return this.sorting.map(def => {
            return {
                type: def.type,
                field: def.field,
                ascending: def.ascending
            };
        });
    }
    /**
     * @return {?}
     */
    get facetQueries() {
        if (this.hasFacetQueries) {
            return this.config.facetQueries.queries.map(query => {
                return /** @type {?} */ (Object.assign({}, query));
            });
        }
        return null;
    }
    /**
     * @return {?}
     */
    getFinalQuery() {
        /** @type {?} */
        let query = '';
        this.categories.forEach(facet => {
            /** @type {?} */
            const customQuery = this.queryFragments[facet.id];
            if (customQuery) {
                if (query.length > 0) {
                    query += ' AND ';
                }
                query += `(${customQuery})`;
            }
        });
        /** @type {?} */
        let result = [this.userQuery, query]
            .filter(entry => entry)
            .join(' AND ');
        if (this.userFacetQueries && this.userFacetQueries.length > 0) {
            /** @type {?} */
            const combined = this.userFacetQueries
                .map(userQuery => userQuery.query)
                .join(' OR ');
            result += ` AND (${combined})`;
        }
        if (this.userFacetBuckets) {
            Object.keys(this.userFacetBuckets).forEach(key => {
                /** @type {?} */
                const subQuery = (this.userFacetBuckets[key] || [])
                    .map(bucket => bucket.filterQuery)
                    .join(' OR ');
                if (subQuery) {
                    if (result.length > 0) {
                        result += ' AND ';
                    }
                    result += `(${subQuery})`;
                }
            });
        }
        return result;
    }
    /**
     * @return {?}
     */
    get facetFields() {
        /** @type {?} */
        const facetFields = this.config.facetFields && this.config.facetFields.fields;
        if (facetFields && facetFields.length > 0) {
            return {
                facets: facetFields.map(facet => /** @type {?} */ ({
                    field: facet.field,
                    mincount: facet.mincount,
                    label: facet.label,
                    limit: facet.limit,
                    offset: facet.offset,
                    prefix: facet.prefix
                }))
            };
        }
        return null;
    }
}
SearchQueryBuilderService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SearchQueryBuilderService.ctorParameters = () => [
    { type: AppConfigService },
    { type: AlfrescoApiService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchComponent {
    /**
     * @param {?} searchService
     * @param {?} _elementRef
     */
    constructor(searchService, _elementRef) {
        this.searchService = searchService;
        this._elementRef = _elementRef;
        /**
         * Function that maps an option's value to its display value in the trigger.
         */
        this.displayWith = null;
        /**
         * Maximum number of results to show in the search.
         */
        this.maxResults = 20;
        /**
         * Number of results to skip from the results pagination.
         */
        this.skipResults = 0;
        /**
         * Search term to use when executing the search. Updating this value will
         * run a new search and update the results.
         */
        this.searchTerm = '';
        /**
         * Emitted when search results have fully loaded.
         */
        this.resultLoaded = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        this.showPanel = false;
        this._isOpen = false;
        this.keyPressedStream = new Subject();
        this._classList = {};
        this.keyPressedStream.asObservable()
            .pipe(debounceTime(200))
            .subscribe((searchedWord) => {
            this.loadSearchResults(searchedWord);
        });
        searchService.dataLoaded.subscribe(data => this.onSearchDataLoaded(data), error => this.onSearchDataError(error));
    }
    /**
     * CSS class for display.
     * @param {?} classList
     * @return {?}
     */
    set classList(classList) {
        if (classList && classList.length) {
            classList.split(' ').forEach(className => this._classList[className.trim()] = true);
            this._elementRef.nativeElement.className = '';
        }
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this._isOpen && this.showPanel;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        this._isOpen = value;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setVisibility();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.queryBody &&
            this.hasDifferentQueryBody(changes.queryBody.previousValue, changes.queryBody.currentValue)) {
            this.loadSearchResults();
        }
        if (changes.searchTerm && changes.searchTerm.currentValue) {
            this.loadSearchResults(changes.searchTerm.currentValue);
        }
    }
    /**
     * @return {?}
     */
    resetResults() {
        this.cleanResults();
        this.setVisibility();
    }
    /**
     * @return {?}
     */
    reload() {
        this.loadSearchResults(this.searchTerm);
    }
    /**
     * @param {?} previousQueryBody
     * @param {?} currentQueryBody
     * @return {?}
     */
    hasDifferentQueryBody(previousQueryBody, currentQueryBody) {
        return JSON.stringify(previousQueryBody) !== JSON.stringify(currentQueryBody);
    }
    /**
     * @return {?}
     */
    cleanResults() {
        if (this.results) {
            this.results = {};
        }
    }
    /**
     * @param {?=} searchTerm
     * @return {?}
     */
    loadSearchResults(searchTerm) {
        this.resetResults();
        if (searchTerm) {
            if (this.queryBody) {
                this.searchService.searchByQueryBody(this.queryBody).subscribe(result => this.onSearchDataLoaded(result), err => this.onSearchDataError(err));
            }
            else {
                this.searchService.search(searchTerm, this.maxResults, this.skipResults).subscribe(result => this.onSearchDataLoaded(result), err => this.onSearchDataError(err));
            }
        }
        else {
            this.cleanResults();
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onSearchDataLoaded(data) {
        if (data) {
            this.results = data;
            this.resultLoaded.emit(this.results);
            this.isOpen = true;
            this.setVisibility();
        }
    }
    /**
     * @param {?} error
     * @return {?}
     */
    onSearchDataError(error) {
        if (error && error.status !== 400) {
            this.results = null;
            this.error.emit(error);
        }
    }
    /**
     * @return {?}
     */
    hidePanel() {
        if (this.isOpen) {
            this._classList['adf-search-show'] = false;
            this._classList['adf-search-hide'] = true;
            this.isOpen = false;
        }
    }
    /**
     * @return {?}
     */
    setVisibility() {
        this.showPanel = !!this.results && !!this.results.list;
        this._classList['adf-search-show'] = this.showPanel;
        this._classList['adf-search-hide'] = !this.showPanel;
    }
}
SearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search',
                template: "<div role=\"listbox\" id=\"adf-search-results-content\" [ngClass]=\"_classList\" #panel>\n    <ng-template\n        [ngTemplateOutlet]=\"template\"\n        [ngTemplateOutletContext]=\"{ $implicit: results }\">\n    </ng-template>\n</div>\n\n\n",
                encapsulation: ViewEncapsulation.None,
                preserveWhitespaces: false,
                exportAs: 'searchAutocomplete',
                host: {
                    'class': 'adf-search'
                },
                styles: [""]
            }] }
];
/** @nocollapse */
SearchComponent.ctorParameters = () => [
    { type: SearchService },
    { type: ElementRef }
];
SearchComponent.propDecorators = {
    panel: [{ type: ViewChild, args: ['panel',] }],
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    displayWith: [{ type: Input }],
    maxResults: [{ type: Input }],
    skipResults: [{ type: Input }],
    queryBody: [{ type: Input }],
    searchTerm: [{ type: Input }],
    classList: [{ type: Input, args: ['class',] }],
    resultLoaded: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class EmptySearchResultComponent {
}
EmptySearchResultComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-empty-search-result',
                template: "<div class=\"adf-empty-search-result\">\n    <ng-content></ng-content>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchControlComponent {
    /**
     * @param {?} authService
     * @param {?} thumbnailService
     */
    constructor(authService, thumbnailService) {
        this.authService = authService;
        this.thumbnailService = thumbnailService;
        /**
         * Toggles whether to use an expanding search control. If false
         * then a regular input is used.
         */
        this.expandable = true;
        /**
         * Toggles highlighting of the search term in the results.
         */
        this.highlight = false;
        /**
         * Type of the input field to render, e.g. "search" or "text" (default).
         */
        this.inputType = 'text';
        /**
         * Toggles auto-completion of the search input field.
         */
        this.autocomplete = false;
        /**
         * Toggles "find-as-you-type" suggestions for possible matches.
         */
        this.liveSearchEnabled = true;
        /**
         * Maximum number of results to show in the live search.
         */
        this.liveSearchMaxResults = 5;
        /**
         * Emitted when the search is submitted pressing ENTER button.
         * The search term is provided as value of the event.
         */
        this.submit = new EventEmitter();
        /**
         * Emitted when the search term is changed. The search term is provided
         * in the 'value' property of the returned object.  If the term is less
         * than three characters in length then the term is truncated to an empty
         * string.
         */
        this.searchChange = new EventEmitter();
        /**
         * Emitted when a file item from the list of "find-as-you-type" results is selected.
         */
        this.optionClicked = new EventEmitter();
        this.searchTerm = '';
        this.noSearchResultTemplate = null;
        this.toggleSearch = new Subject();
        this.focusSubject = new Subject();
        this.toggleSearch.asObservable().pipe(debounceTime(200)).subscribe(() => {
            if (this.expandable) {
                this.subscriptAnimationState = this.subscriptAnimationState === 'inactive' ? 'active' : 'inactive';
                if (this.subscriptAnimationState === 'inactive') {
                    this.searchTerm = '';
                    this.searchAutocomplete.resetResults();
                    if (document.activeElement.id === this.searchInput.nativeElement.id) {
                        this.searchInput.nativeElement.blur();
                    }
                }
            }
        });
    }
    /**
     * @param {?} animationDoneEvent
     * @return {?}
     */
    applySearchFocus(animationDoneEvent) {
        if (animationDoneEvent.toState === 'active') {
            this.searchInput.nativeElement.focus();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptAnimationState = this.expandable ? 'inactive' : 'no-animation';
        this.setupFocusEventHandlers();
    }
    /**
     * @return {?}
     */
    isNoSearchTemplatePresent() {
        return this.emptySearchTemplate ? true : false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.focusSubject) {
            this.focusSubject.unsubscribe();
            this.focusSubject = null;
        }
        if (this.toggleSearch) {
            this.toggleSearch.unsubscribe();
            this.toggleSearch = null;
        }
    }
    /**
     * @return {?}
     */
    isLoggedIn() {
        return this.authService.isEcmLoggedIn();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    searchSubmit(event) {
        this.submit.emit(event);
        this.toggleSearchBar();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    inputChange(event) {
        this.searchChange.emit(event);
    }
    /**
     * @return {?}
     */
    getAutoComplete() {
        return this.autocomplete ? 'on' : 'off';
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getMimeTypeIcon(node) {
        /** @type {?} */
        let mimeType;
        if (node.entry.content && node.entry.content.mimeType) {
            mimeType = node.entry.content.mimeType;
        }
        if (node.entry.isFolder) {
            mimeType = 'folder';
        }
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    /**
     * @return {?}
     */
    isSearchBarActive() {
        return this.subscriptAnimationState === 'active' && this.liveSearchEnabled;
    }
    /**
     * @return {?}
     */
    toggleSearchBar() {
        if (this.toggleSearch) {
            this.toggleSearch.next();
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    elementClicked(item) {
        if (item.entry) {
            this.optionClicked.next(item);
            this.toggleSearchBar();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onFocus($event) {
        this.focusSubject.next($event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onBlur($event) {
        this.focusSubject.next($event);
    }
    /**
     * @return {?}
     */
    activateToolbar() {
        if (!this.isSearchBarActive()) {
            this.toggleSearchBar();
        }
    }
    /**
     * @return {?}
     */
    selectFirstResult() {
        if (this.listResultElement && this.listResultElement.length > 0) {
            /** @type {?} */
            let firstElement = /** @type {?} */ (this.listResultElement.first);
            firstElement._getHostElement().focus();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onRowArrowDown($event) {
        /** @type {?} */
        let nextElement = this.getNextElementSibling(/** @type {?} */ ($event.target));
        if (nextElement) {
            nextElement.focus();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onRowArrowUp($event) {
        /** @type {?} */
        let previousElement = this.getPreviousElementSibling(/** @type {?} */ ($event.target));
        if (previousElement) {
            previousElement.focus();
        }
        else {
            this.searchInput.nativeElement.focus();
            this.focusSubject.next(new FocusEvent('focus'));
        }
    }
    /**
     * @return {?}
     */
    setupFocusEventHandlers() {
        /** @type {?} */
        const focusEvents = this.focusSubject
            .asObservable()
            .pipe(debounceTime(50), filter(($event) => {
            return this.isSearchBarActive() && ($event.type === 'blur' || $event.type === 'focusout');
        }));
        focusEvents.subscribe(() => {
            this.toggleSearchBar();
        });
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getNextElementSibling(node) {
        return node.nextElementSibling;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getPreviousElementSibling(node) {
        return node.previousElementSibling;
    }
}
SearchControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-control',
                template: "<div class=\"adf-search-container\">\n    <div *ngIf=\"isLoggedIn()\" [@transitionMessages]=\"subscriptAnimationState\"\n         (@transitionMessages.done)=\"applySearchFocus($event)\">\n        <button mat-icon-button\n                *ngIf=\"expandable\"\n                id=\"adf-search-button\"\n                class=\"adf-search-button\"\n                [title]=\"'SEARCH.BUTTON.TOOLTIP' | translate\"\n                (click)=\"toggleSearchBar()\"\n                (keyup.enter)=\"toggleSearchBar()\">\n            <mat-icon [attr.aria-label]=\"'SEARCH.BUTTON.ARIA-LABEL' | translate\">search</mat-icon>\n        </button>\n        <mat-form-field class=\"adf-input-form-field-divider\">\n            <input matInput\n                   #searchInput\n                   [attr.aria-label]=\"'SEARCH.INPUT.ARIA-LABEL' | translate\"\n                   [attr.type]=\"inputType\"\n                   [autocomplete]=\"getAutoComplete()\"\n                   id=\"adf-control-input\"\n                   [(ngModel)]=\"searchTerm\"\n                   (focus)=\"activateToolbar()\"\n                   (blur)=\"onBlur($event)\"\n                   (keyup.escape)=\"toggleSearchBar()\"\n                   (keyup.arrowdown)=\"selectFirstResult()\"\n                   (ngModelChange)=\"inputChange($event)\"\n                   [searchAutocomplete]=\"auto\"\n                   (keyup.enter)=\"searchSubmit($event)\">\n        </mat-form-field>\n    </div>\n</div>\n\n<adf-search #search\n            #auto=\"searchAutocomplete\"\n            class=\"adf-search-result-autocomplete\"\n            [maxResults]=\"liveSearchMaxResults\"\n            [queryBody]=\"customQueryBody\">\n    <ng-template let-data>\n        <mat-list *ngIf=\"isSearchBarActive()\" id=\"autocomplete-search-result-list\">\n            <mat-list-item\n                *ngFor=\"let item of data?.list?.entries; let idx = index\"\n                id=\"result_option_{{idx}}\"\n                [attr.data-automation-id]=\"'autocomplete_for_' + item.entry.name\"\n                [tabindex]=\"0\"\n                (focus)=\"onFocus($event)\"\n                (blur)=\"onBlur($event)\"\n                (keyup.arrowdown)=\"onRowArrowDown($event)\"\n                (keyup.arrowup)=\"onRowArrowUp($event)\"\n                class=\"adf-search-autocomplete-item\"\n                (click)=\"elementClicked(item)\"\n                (keyup.enter)=\"elementClicked(item)\"\n                (touchend)=\"elementClicked(item)\">\n                <!-- This is a comment -->\n                <mat-icon mat-list-icon>\n                    <img [src]=\"getMimeTypeIcon(item)\"/>\n                </mat-icon>\n                <h4 mat-line id=\"result_name_{{idx}}\"\n                    *ngIf=\"highlight; else elseBlock\"\n                    class=\"adf-search-fixed-text\"\n                    [innerHtml]=\"item.entry.name | highlight: searchTerm\">\n                    {{ item?.entry.name }}\n                </h4>\n                <ng-template #elseBlock>\n                    <h4 class=\"adf-search-fixed-text\" mat-line id=\"result_name_{{idx}}\"\n                        [innerHtml]=\"item.entry.name\"></h4>\n                </ng-template>\n                <p mat-line class=\"adf-search-fixed-text\"> {{item?.entry.createdByUser.displayName}} </p>\n            </mat-list-item>\n            <mat-list-item id=\"search_no_result\"\n                           data-automation-id=\"search_no_result_found\"\n                           *ngIf=\"data?.list?.entries.length === 0\">\n                <ng-content\n                    selector=\"adf-empty-search-result\"\n                    *ngIf=\"isNoSearchTemplatePresent() else defaultNoResult\">\n                </ng-content>\n                <ng-template #defaultNoResult>\n                    <p mat-line class=\"adf-search-fixed-text\">{{ 'SEARCH.RESULTS.NONE' | translate:{searchTerm:\n                        searchTerm} }}</p>\n                </ng-template>\n            </mat-list-item>\n        </mat-list>\n    </ng-template>\n</adf-search>\n",
                animations: [
                    trigger('transitionMessages', [
                        state('active', style({ transform: 'translateX(0%)', 'margin-left': '13px' })),
                        state('inactive', style({ transform: 'translateX(81%)' })),
                        state('no-animation', style({ transform: 'translateX(0%)', width: '100%' })),
                        transition('inactive => active', animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')),
                        transition('active => inactive', animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'))
                    ])
                ],
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-control' },
                styles: [""]
            }] }
];
/** @nocollapse */
SearchControlComponent.ctorParameters = () => [
    { type: AuthenticationService },
    { type: ThumbnailService }
];
SearchControlComponent.propDecorators = {
    expandable: [{ type: Input }],
    highlight: [{ type: Input }],
    inputType: [{ type: Input }],
    autocomplete: [{ type: Input }],
    liveSearchEnabled: [{ type: Input }],
    liveSearchMaxResults: [{ type: Input }],
    customQueryBody: [{ type: Input }],
    submit: [{ type: Output }],
    searchChange: [{ type: Output }],
    optionClicked: [{ type: Output }],
    searchAutocomplete: [{ type: ViewChild, args: ['search',] }],
    searchInput: [{ type: ViewChild, args: ['searchInput',] }],
    listResultElement: [{ type: ViewChildren, args: [MatListItem,] }],
    emptySearchTemplate: [{ type: ContentChild, args: [EmptySearchResultComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => SearchTriggerDirective),
    multi: true
};
class SearchTriggerDirective {
    /**
     * @param {?} element
     * @param {?} ngZone
     * @param {?} changeDetectorRef
     * @param {?} document
     */
    constructor(element, ngZone, changeDetectorRef, document) {
        this.element = element;
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        this.document = document;
        this.onDestroy$ = new Subject();
        this.autocomplete = 'off';
        this._panelOpen = false;
        this.escapeEventStream = new Subject();
        this.onChange = () => { };
        this.onTouched = () => { };
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
        if (this.escapeEventStream) {
            this.escapeEventStream.unsubscribe();
            this.escapeEventStream = null;
        }
        if (this.closingActionsSubscription) {
            this.closingActionsSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    get panelOpen() {
        return this._panelOpen && this.searchPanel.showPanel;
    }
    /**
     * @return {?}
     */
    openPanel() {
        this.searchPanel.isOpen = this._panelOpen = true;
        this.closingActionsSubscription = this.subscribeToClosingActions();
    }
    /**
     * @return {?}
     */
    closePanel() {
        if (this._panelOpen) {
            this.closingActionsSubscription.unsubscribe();
            this._panelOpen = false;
            this.searchPanel.resetResults();
            this.searchPanel.hidePanel();
            this.changeDetectorRef.detectChanges();
        }
    }
    /**
     * @return {?}
     */
    get panelClosingActions() {
        return merge(this.escapeEventStream, this.outsideClickStream);
    }
    /**
     * @return {?}
     */
    get outsideClickStream() {
        if (!this.document) {
            return of(null);
        }
        return merge(fromEvent(this.document, 'click'), fromEvent(this.document, 'touchend')).pipe(filter((event) => {
            /** @type {?} */
            const clickTarget = /** @type {?} */ (event.target);
            return this._panelOpen && clickTarget !== this.element.nativeElement;
        }));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        Promise.resolve(null).then(() => this.setTriggerValue(value));
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleKeydown(event) {
        /** @type {?} */
        const keyCode = event.keyCode;
        if (keyCode === ESCAPE && this.panelOpen) {
            this.escapeEventStream.next();
            event.stopPropagation();
        }
        else if (keyCode === ENTER) {
            this.escapeEventStream.next();
            event.preventDefault();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleInput(event) {
        if (document.activeElement === event.target) {
            /** @type {?} */
            let inputValue = (/** @type {?} */ (event.target)).value;
            this.onChange(inputValue);
            if (inputValue) {
                this.searchPanel.keyPressedStream.next(inputValue);
                this.openPanel();
            }
            else {
                this.searchPanel.resetResults();
                this.closePanel();
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    isPanelOptionClicked(event) {
        /** @type {?} */
        let isPanelOption = false;
        if (event) {
            /** @type {?} */
            let clickTarget = /** @type {?} */ (event.target);
            isPanelOption = !this.isNoResultOption(event) &&
                !!this.searchPanel.panel &&
                !!this.searchPanel.panel.nativeElement.contains(clickTarget);
        }
        return isPanelOption;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    isNoResultOption(event) {
        return this.searchPanel.results.list ? this.searchPanel.results.list.entries.length === 0 : true;
    }
    /**
     * @return {?}
     */
    subscribeToClosingActions() {
        /** @type {?} */
        const firstStable = this.ngZone.onStable.asObservable();
        /** @type {?} */
        const optionChanges = this.searchPanel.keyPressedStream.asObservable();
        return merge(firstStable, optionChanges)
            .pipe(takeUntil(this.onDestroy$), switchMap(() => {
            this.searchPanel.setVisibility();
            return this.panelClosingActions;
        }))
            .subscribe(event => this.setValueAndClose(event));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setTriggerValue(value) {
        /** @type {?} */
        const toDisplay = this.searchPanel && this.searchPanel.displayWith ?
            this.searchPanel.displayWith(value) : value;
        /** @type {?} */
        const inputValue = toDisplay != null ? toDisplay : '';
        this.element.nativeElement.value = inputValue;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    setValueAndClose(event) {
        if (this.isPanelOptionClicked(event) && !event.defaultPrevented) {
            this.setTriggerValue(event.target.textContent.trim());
            this.onChange(event.target.textContent.trim());
            this.element.nativeElement.focus();
        }
        this.closePanel();
    }
}
SearchTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: `input[searchAutocomplete], textarea[searchAutocomplete]`,
                host: {
                    'role': 'combobox',
                    '[attr.autocomplete]': 'autocomplete',
                    'aria-autocomplete': 'list',
                    '[attr.aria-expanded]': 'panelOpen.toString()',
                    '(blur)': 'onTouched()',
                    '(input)': 'handleInput($event)',
                    '(keydown)': 'handleKeydown($event)'
                },
                providers: [SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR]
            },] }
];
/** @nocollapse */
SearchTriggerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
SearchTriggerDirective.propDecorators = {
    searchPanel: [{ type: Input, args: ['searchAutocomplete',] }],
    autocomplete: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
const DEFAULT_PAGE_SIZE = 5;
/**
 * @template T
 */
class SearchFilterList {
    /**
     * @param {?=} items
     * @param {?=} pageSize
     */
    constructor(items = [], pageSize) {
        this.filteredItems = [];
        this._filterText = '';
        this.items = [];
        this.pageSize = DEFAULT_PAGE_SIZE;
        this.currentPageSize = DEFAULT_PAGE_SIZE;
        this._filter = () => true;
        this.items = items;
        this.filteredItems = items;
        this.pageSize = pageSize || DEFAULT_PAGE_SIZE;
        this.currentPageSize = pageSize || DEFAULT_PAGE_SIZE;
    }
    /**
     * @return {?}
     */
    get filterText() {
        return this._filterText;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set filterText(value) {
        this._filterText = value;
        this.applyFilter();
    }
    /**
     * @return {?}
     */
    get filter() {
        return this._filter;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set filter(value) {
        this._filter = value;
        this.applyFilter();
    }
    /**
     * @return {?}
     */
    applyFilter() {
        if (this.filter) {
            this.filteredItems = this.items.filter(this.filter);
        }
        else {
            this.filteredItems = this.items;
        }
        this.currentPageSize = this.pageSize;
    }
    /**
     * Returns visible portion of the items.
     * @return {?}
     */
    get visibleItems() {
        return this.filteredItems.slice(0, this.currentPageSize);
    }
    /**
     * Returns entire collection length including items not displayed on the page.
     * @return {?}
     */
    get length() {
        return this.items.length;
    }
    /**
     * Detects whether more items can be displayed.
     * @return {?}
     */
    get canShowMoreItems() {
        return this.filteredItems.length > this.currentPageSize;
    }
    /**
     * Detects whether less items can be displayed.
     * @return {?}
     */
    get canShowLessItems() {
        return this.currentPageSize > this.pageSize;
    }
    /**
     * Detects whether content fits single page.
     * @return {?}
     */
    get fitsPage() {
        return this.pageSize >= this.filteredItems.length;
    }
    /**
     * Display more items.
     * @return {?}
     */
    showMoreItems() {
        if (this.canShowMoreItems) {
            this.currentPageSize += this.pageSize;
        }
    }
    /**
     * Display less items.
     * @return {?}
     */
    showLessItems() {
        if (this.canShowLessItems) {
            this.currentPageSize -= this.pageSize;
        }
    }
    /**
     * Reset entire collection and page settings.
     * @return {?}
     */
    clear() {
        this.currentPageSize = this.pageSize;
        this.items = [];
        this.filteredItems = [];
        this.filterText = '';
    }
    /**
     * @return {?}
     */
    [Symbol.iterator]() {
        /** @type {?} */
        let pointer = 0;
        /** @type {?} */
        let items = this.visibleItems;
        return {
            /**
             * @return {?}
             */
            next() {
                if (pointer < items.length) {
                    return {
                        done: false,
                        value: items[pointer++]
                    };
                }
                else {
                    return {
                        done: true,
                        value: null
                    };
                }
            }
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ResponseFacetQueryList extends SearchFilterList {
    /**
     * @param {?=} items
     * @param {?=} pageSize
     */
    constructor(items = [], pageSize = 5) {
        super(items
            .filter(item => {
            return item.count > 0;
        }), pageSize);
        this.filter = (query) => {
            if (this.filterText && query.label) {
                /** @type {?} */
                const pattern = (this.filterText || '').toLowerCase();
                /** @type {?} */
                const label = query.label.toLowerCase();
                return label.startsWith(pattern);
            }
            return true;
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchFilterComponent {
    /**
     * @param {?} queryBuilder
     * @param {?} searchService
     * @param {?} translationService
     */
    constructor(queryBuilder, searchService, translationService) {
        this.queryBuilder = queryBuilder;
        this.searchService = searchService;
        this.translationService = translationService;
        this.DEFAULT_PAGE_SIZE = 5;
        this.isAlive = true;
        this.responseFacetQueries = null;
        this.responseFacetFields = null;
        this.facetQueriesPageSize = this.DEFAULT_PAGE_SIZE;
        this.facetQueriesLabel = 'Facet Queries';
        this.facetQueriesExpanded = false;
        this.facetFieldsExpanded = false;
        this.canResetSelectedQueries = false;
        this.selectedFacetQueries = [];
        this.selectedBuckets = [];
        if (queryBuilder.config && queryBuilder.config.facetQueries) {
            this.facetQueriesLabel = queryBuilder.config.facetQueries.label || 'Facet Queries';
            this.facetQueriesPageSize = queryBuilder.config.facetQueries.pageSize || this.DEFAULT_PAGE_SIZE;
            this.facetQueriesExpanded = queryBuilder.config.facetQueries.expanded;
        }
        if (queryBuilder.config && queryBuilder.config.facetFields) {
            this.facetFieldsExpanded = queryBuilder.config.facetFields.expanded;
        }
        this.queryBuilder.updated.pipe(takeWhile(() => this.isAlive)).subscribe(() => {
            this.queryBuilder.execute();
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.queryBuilder) {
            this.queryBuilder.executed.pipe(takeWhile(() => this.isAlive)).subscribe((data) => {
                this.onDataLoaded(data);
                this.searchService.dataLoaded.next(data);
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.isAlive = false;
    }
    /**
     * @param {?} event
     * @param {?} facetQuery
     * @return {?}
     */
    onToggleFacetQuery(event, facetQuery) {
        if (event && facetQuery) {
            if (event.checked) {
                this.selectFacetQuery(facetQuery);
            }
            else {
                this.unselectFacetQuery(facetQuery);
            }
        }
    }
    /**
     * @param {?} query
     * @return {?}
     */
    selectFacetQuery(query) {
        if (query) {
            query.checked = true;
            this.queryBuilder.addUserFacetQuery(query);
            this.updateSelectedFields();
            this.queryBuilder.update();
        }
    }
    /**
     * @param {?} query
     * @return {?}
     */
    unselectFacetQuery(query) {
        if (query) {
            query.checked = false;
            this.queryBuilder.removeUserFacetQuery(query);
            this.updateSelectedFields();
            this.queryBuilder.update();
        }
    }
    /**
     * @return {?}
     */
    updateSelectedBuckets() {
        if (this.responseFacetFields) {
            this.selectedBuckets = [];
            for (let field of this.responseFacetFields) {
                if (field.buckets) {
                    this.selectedBuckets.push(...this.queryBuilder.getUserFacetBuckets(field.field)
                        .filter(bucket => bucket.checked)
                        .map(bucket => {
                        return { field, bucket };
                    }));
                }
            }
        }
        else {
            this.selectedBuckets = [];
        }
    }
    /**
     * @return {?}
     */
    updateSelectedFields() {
        if (this.responseFacetQueries) {
            this.selectedFacetQueries = this.responseFacetQueries.items.filter(item => item.checked);
            this.canResetSelectedQueries = this.selectedFacetQueries.length > 0;
        }
        else {
            this.selectedFacetQueries = [];
            this.canResetSelectedQueries = false;
        }
    }
    /**
     * @param {?} event
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    onToggleBucket(event, field, bucket) {
        if (event && bucket) {
            if (event.checked) {
                this.selectFacetBucket(field, bucket);
            }
            else {
                this.unselectFacetBucket(field, bucket);
            }
        }
    }
    /**
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    selectFacetBucket(field, bucket) {
        if (bucket) {
            bucket.checked = true;
            this.queryBuilder.addUserFacetBucket(field, bucket);
            this.updateSelectedBuckets();
            this.queryBuilder.update();
        }
    }
    /**
     * @param {?} field
     * @param {?} bucket
     * @return {?}
     */
    unselectFacetBucket(field, bucket) {
        if (bucket) {
            bucket.checked = false;
            this.queryBuilder.removeUserFacetBucket(field, bucket);
            this.updateSelectedBuckets();
            this.queryBuilder.update();
        }
    }
    /**
     * @return {?}
     */
    resetSelectedQueries() {
        if (this.canResetSelectedQueries) {
            for (let query of this.responseFacetQueries.items) {
                query.checked = false;
                this.queryBuilder.removeUserFacetQuery(query);
            }
            this.selectedFacetQueries = [];
            this.canResetSelectedQueries = false;
            this.queryBuilder.update();
        }
    }
    /**
     * @param {?} field
     * @return {?}
     */
    canResetSelectedBuckets(field) {
        if (field && field.buckets) {
            return field.buckets.items.some(bucket => bucket.checked);
        }
        return false;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    resetSelectedBuckets(field) {
        if (field && field.buckets) {
            for (let bucket of field.buckets.items) {
                bucket.checked = false;
                this.queryBuilder.removeUserFacetBucket(field, bucket);
            }
            this.updateSelectedBuckets();
            this.queryBuilder.update();
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onDataLoaded(data) {
        /** @type {?} */
        const context = data.list.context;
        if (context) {
            this.parseFacetFields(context);
            this.parseFacetQueries(context);
        }
        else {
            this.responseFacetQueries = null;
            this.responseFacetFields = null;
        }
    }
    /**
     * @param {?} context
     * @return {?}
     */
    parseFacetFields(context) {
        if (!this.responseFacetFields) {
            /** @type {?} */
            const configFacetFields = this.queryBuilder.config.facetFields && this.queryBuilder.config.facetFields.fields || [];
            this.responseFacetFields = configFacetFields.map(field => {
                /** @type {?} */
                const responseField = (context.facetsFields || []).find(response => response.label === field.label);
                /** @type {?} */
                const buckets = ((responseField && responseField.buckets) || []).map(bucket => {
                    /** @type {?} */
                    const selectedBucket = this.selectedBuckets.find(facetBucket => facetBucket.bucket.label === bucket.label && facetBucket.field.field === field.field);
                    return /** @type {?} */ (Object.assign({}, bucket, { checked: !!selectedBucket, display: this.translationService.instant(bucket.display), label: this.translationService.instant(bucket.label) }));
                });
                /** @type {?} */
                const bucketList = new SearchFilterList(buckets, field.pageSize);
                bucketList.filter = (bucket) => {
                    if (bucket && bucketList.filterText) {
                        /** @type {?} */
                        const pattern = (bucketList.filterText || '').toLowerCase();
                        /** @type {?} */
                        const label = (bucket.display || bucket.label || '').toLowerCase();
                        return label.startsWith(pattern);
                    }
                    return true;
                };
                return Object.assign({}, field, { label: this.translationService.instant(field.label), pageSize: field.pageSize | this.DEFAULT_PAGE_SIZE, currentPageSize: field.pageSize | this.DEFAULT_PAGE_SIZE, buckets: bucketList });
            });
        }
        else {
            this.responseFacetFields = this.responseFacetFields
                .map(field => {
                /** @type {?} */
                let responseField = (context.facetsFields || []).find(response => response.label === field.label);
                (field && field.buckets && field.buckets.items || [])
                    .map(bucket => {
                    /** @type {?} */
                    const responseBucket = ((responseField && responseField.buckets) || []).find(respBucket => respBucket.label === bucket.label);
                    bucket.count = responseBucket ? responseBucket.count : 0;
                    return bucket;
                });
                return field;
            });
        }
    }
    /**
     * @param {?} context
     * @return {?}
     */
    parseFacetQueries(context) {
        /** @type {?} */
        const responseQueries = this.getFacetQueryMap(context);
        if (this.queryBuilder.config.facetQueries) {
            /** @type {?} */
            const bkpResponseFacetQueries = Object.assign({}, this.responseFacetQueries);
            /** @type {?} */
            const facetQueries = (this.queryBuilder.config.facetQueries.queries || [])
                .map(query => {
                /** @type {?} */
                const queryResult = responseQueries[query.label];
                /** @type {?} */
                const bkpQuery = (bkpResponseFacetQueries.items || []).find(item => item.label === query.label);
                if (bkpQuery) {
                    bkpQuery.count = queryResult.count;
                    return bkpQuery;
                }
                return /** @type {?} */ (Object.assign({}, query, { label: this.translationService.instant(query.label), count: queryResult.count }));
            });
            if (facetQueries.length > 0) {
                if (this.responseFacetQueries) {
                    this.responseFacetQueries.items = facetQueries;
                }
                else {
                    this.responseFacetQueries = new ResponseFacetQueryList(facetQueries, this.facetQueriesPageSize);
                }
            }
            else {
                this.responseFacetQueries = null;
            }
        }
    }
    /**
     * @param {?} context
     * @return {?}
     */
    getFacetQueryMap(context) {
        /** @type {?} */
        const result = {};
        (context.facetQueries || []).forEach(query => {
            result[query.label] = query;
        });
        return result;
    }
}
SearchFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-filter',
                template: "<mat-accordion multi=\"true\" displayMode=\"flat\">\n\n    <mat-expansion-panel\n        *ngFor=\"let category of queryBuilder.categories\"\n        [attr.data-automation-id]=\"'expansion-panel-'+category.name\"\n        [(expanded)]=\"category.expanded\">\n        <mat-expansion-panel-header>\n            <mat-panel-title>\n                {{ category.name | translate }}\n            </mat-panel-title>\n        </mat-expansion-panel-header>\n        <adf-search-widget-container\n            [id]=\"category.id\"\n            [selector]=\"category.component.selector\"\n            [settings]=\"category.component.settings\">\n        </adf-search-widget-container>\n    </mat-expansion-panel>\n\n    <ng-container *ngIf=\"responseFacetQueries\">\n        <mat-expansion-panel [expanded]=\"facetQueriesExpanded\" [attr.data-automation-id]=\"'expansion-panel-'+facetQueriesLabel\">\n            <mat-expansion-panel-header>\n                <mat-panel-title>{{ facetQueriesLabel | translate }}</mat-panel-title>\n            </mat-expansion-panel-header>\n            <div class=\"facet-result-filter\">\n                <mat-form-field>\n                    <input\n                        matInput\n                        placeholder=\"{{ 'SEARCH.FILTER.ACTIONS.FILTER-CATEGORY' | translate }}\"\n                        [attr.data-automation-id]=\"'facet-result-filter-'+facetQueriesLabel\"\n                        [(ngModel)]=\"responseFacetQueries.filterText\">\n                    <button *ngIf=\"responseFacetQueries.filterText\"\n                        mat-button matSuffix mat-icon-button\n                        (click)=\"responseFacetQueries.filterText = ''\">\n                        <mat-icon>close</mat-icon>\n                    </button>\n                </mat-form-field>\n            </div>\n            <div class=\"checklist\">\n                <ng-container *ngFor=\"let query of responseFacetQueries\">\n                    <mat-checkbox\n                        [checked]=\"query.checked\"\n                        [attr.data-automation-id]=\"'checkbox-'+facetQueriesLabel+'-'+query.label\"\n                        (change)=\"onToggleFacetQuery($event, query)\">\n                        {{ query.label }} ({{ query.count }})\n                    </mat-checkbox>\n                </ng-container>\n            </div>\n            <div class=\"facet-buttons\">\n                <button mat-icon-button\n                    *ngIf=\"canResetSelectedQueries\"\n                    title=\"{{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\"\n                    (click)=\"resetSelectedQueries()\">\n                    <mat-icon>clear</mat-icon>\n                </button>\n                <button mat-icon-button\n                    *ngIf=\"responseFacetQueries.canShowLessItems\"\n                    title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-LESS' | translate }}\"\n                    (click)=\"responseFacetQueries.showLessItems()\">\n                    <mat-icon>keyboard_arrow_up</mat-icon>\n                </button>\n                <button mat-icon-button\n                    *ngIf=\"responseFacetQueries.canShowMoreItems\"\n                    title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-MORE' | translate }}\"\n                    (click)=\"responseFacetQueries.showMoreItems()\">\n                    <mat-icon>keyboard_arrow_down</mat-icon>\n                </button>\n            </div>\n        </mat-expansion-panel>\n    </ng-container>\n\n    <ng-container *ngIf=\"responseFacetFields\">\n        <mat-expansion-panel [attr.data-automation-id]=\"'expansion-panel-'+field.label\" *ngFor=\"let field of responseFacetFields\"\n                             [expanded]=\"facetFieldsExpanded\">\n            <mat-expansion-panel-header>\n                <mat-panel-title>{{ field.label }}</mat-panel-title>\n            </mat-expansion-panel-header>\n\n            <div class=\"facet-result-filter\">\n                <mat-form-field>\n                    <input\n                        matInput\n                        placeholder=\"{{ 'SEARCH.FILTER.ACTIONS.FILTER-CATEGORY' | translate }}\"\n                        [attr.data-automation-id]=\"'facet-result-filter-'+field.label\"\n                        [(ngModel)]=\"field.buckets.filterText\">\n                    <button *ngIf=\"field.buckets.filterText\"\n                        mat-button matSuffix mat-icon-button\n                        (click)=\"field.buckets.filterText = ''\">\n                        <mat-icon>close</mat-icon>\n                    </button>\n                </mat-form-field>\n            </div>\n\n            <div class=\"checklist\">\n                <mat-checkbox\n                    *ngFor=\"let bucket of field.buckets\"\n                    [checked]=\"bucket.checked\"\n                    [attr.data-automation-id]=\"'checkbox-'+field.label+'-'+(bucket.display || bucket.label)\"\n                    (change)=\"onToggleBucket($event, field, bucket)\">\n                    {{ bucket.display || bucket.label }} <span *ngIf=\"bucket.count!==null\">(</span>{{ bucket.count }}<span *ngIf=\"bucket.count!==null\">)</span>\n                </mat-checkbox>\n            </div>\n\n            <div class=\"facet-buttons\" *ngIf=\"field.buckets.fitsPage\">\n                <button *ngIf=\"canResetSelectedBuckets(field)\"\n                    mat-button\n                    color=\"primary\"\n                    (click)=\"resetSelectedBuckets(field)\">\n                    {{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\n                </button>\n            </div>\n\n            <div class=\"facet-buttons\" *ngIf=\"!field.buckets.fitsPage\">\n                <button mat-icon-button\n                    *ngIf=\"canResetSelectedBuckets(field)\"\n                    title=\"{{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\"\n                    (click)=\"resetSelectedBuckets(field)\">\n                    <mat-icon>clear</mat-icon>\n                </button>\n                <button mat-icon-button\n                    *ngIf=\"field.buckets.canShowLessItems\"\n                    (click)=\"field.buckets.showLessItems()\"\n                    title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-LESS' | translate }}\">\n                    <mat-icon>keyboard_arrow_up</mat-icon>\n                </button>\n                <button mat-icon-button\n                    *ngIf=\"field.buckets.canShowMoreItems\"\n                    (click)=\"field.buckets.showMoreItems()\"\n                    title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-MORE' | translate }}\">\n                    <mat-icon>keyboard_arrow_down</mat-icon>\n                </button>\n            </div>\n        </mat-expansion-panel>\n    </ng-container>\n</mat-accordion>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-filter' },
                styles: [".adf-search-filter .checklist{display:flex;flex-direction:column}.adf-search-filter .checklist .mat-checkbox{margin:5px}.adf-search-filter .checklist .mat-checkbox.mat-checkbox-checked .mat-checkbox-label{font-weight:700}.adf-search-filter .facet-result-filter{display:flex;flex-direction:column}.adf-search-filter .facet-result-filter>*{width:100%}.adf-search-filter .facet-buttons{text-align:right}.adf-search-filter .facet-buttons .mat-button{text-transform:uppercase}.adf-search-filter .facet-buttons--topSpace{padding-top:15px}"]
            }] }
];
/** @nocollapse */
SearchFilterComponent.ctorParameters = () => [
    { type: SearchQueryBuilderService },
    { type: SearchService },
    { type: TranslationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchTextComponent {
    constructor() {
        /**
         * The content of the text box.
         */
        this.value = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.context && this.settings && this.settings["pattern"]) {
            /** @type {?} */
            const pattern = new RegExp(this.settings["pattern"], 'g');
            /** @type {?} */
            const match = pattern.exec(this.context.queryFragments[this.id] || '');
            if (match && match.length > 1) {
                this.value = match[1];
            }
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.value = '';
        this.updateQuery(null);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangedHandler(event) {
        this.value = event.target.value;
        this.updateQuery(this.value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateQuery(value) {
        if (this.context && this.settings && this.settings.field) {
            this.context.queryFragments[this.id] = value ? `${this.settings.field}:'${value}'` : '';
            this.context.update();
        }
    }
}
SearchTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-text',
                template: "<mat-form-field>\n    <input\n        matInput\n        [placeholder]=\"settings?.placeholder\"\n        [(ngModel)]=\"value\"\n        (change)=\"onChangedHandler($event)\">\n    <button mat-button *ngIf=\"value\" matSuffix mat-icon-button (click)=\"reset()\">\n        <mat-icon>close</mat-icon>\n    </button>\n</mat-form-field>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-text' },
                styles: [".adf-search-text .mat-form-field{width:100%}"]
            }] }
];
SearchTextComponent.propDecorators = {
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchRadioComponent {
    constructor() {
        this.pageSize = 5;
        this.options = new SearchFilterList();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            this.pageSize = this.settings["pageSize"] || 5;
            if (this.settings["options"] && this.settings["options"].length > 0) {
                this.options = new SearchFilterList(this.settings["options"], this.pageSize);
            }
        }
        this.setValue(this.getSelectedValue());
    }
    /**
     * @return {?}
     */
    getSelectedValue() {
        /** @type {?} */
        const options = this.settings['options'] || [];
        if (options && options.length > 0) {
            /** @type {?} */
            let selected = options.find(opt => opt.default);
            if (!selected) {
                selected = options[0];
            }
            return selected.value;
        }
        return null;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    setValue(newValue) {
        this.value = newValue;
        this.context.queryFragments[this.id] = newValue;
        this.context.update();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    changeHandler(event) {
        this.setValue(event.value);
    }
}
SearchRadioComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-radio',
                template: "<mat-radio-group\n    [(ngModel)]=\"value\"\n    (change)=\"changeHandler($event)\">\n    <mat-radio-button\n        *ngFor=\"let option of options\"\n        [value]=\"option.value\">\n        {{ option.name | translate }}\n    </mat-radio-button>\n</mat-radio-group>\n\n<div class=\"facet-buttons\" *ngIf=\"!options.fitsPage\">\n    <button mat-icon-button\n        *ngIf=\"options.canShowLessItems\"\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-LESS' | translate }}\"\n        (click)=\"options.showLessItems()\">\n        <mat-icon>keyboard_arrow_up</mat-icon>\n    </button>\n    <button mat-icon-button\n        *ngIf=\"options.canShowMoreItems\"\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-MORE' | translate }}\"\n        (click)=\"options.showMoreItems()\">\n        <mat-icon>keyboard_arrow_down</mat-icon>\n    </button>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-radio' },
                styles: [".adf-search-radio .mat-radio-group{display:inline-flex;flex-direction:column}.adf-search-radio .mat-radio-button{margin:5px}"]
            }] }
];
/** @nocollapse */
SearchRadioComponent.ctorParameters = () => [];
SearchRadioComponent.propDecorators = {
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchSliderComponent {
    constructor() {
        this.thumbLabel = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            if (this.settings.hasOwnProperty('min')) {
                this.min = this.settings['min'];
            }
            if (this.settings.hasOwnProperty('max')) {
                this.max = this.settings['max'];
            }
            if (this.settings.hasOwnProperty('step')) {
                this.step = this.settings['step'];
            }
            this.thumbLabel = this.settings['thumbLabel'] ? true : false;
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.value = this.min || 0;
        this.updateQuery(null);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangedHandler(event) {
        this.value = event.value;
        this.updateQuery(this.value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateQuery(value) {
        if (this.id && this.context && this.settings && this.settings.field) {
            if (value === null) {
                this.context.queryFragments[this.id] = '';
            }
            else {
                this.context.queryFragments[this.id] = `${this.settings.field}:[0 TO ${value}]`;
            }
            this.context.update();
        }
    }
}
SearchSliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-slider',
                template: "<mat-slider\n    [(value)]=\"value\"\n    [min]=\"min\"\n    [max]=\"max\"\n    [step]=\"step\"\n    [thumbLabel]=\"thumbLabel\"\n    (change)=\"onChangedHandler($event)\">\n</mat-slider>\n\n<div class=\"facet-buttons\">\n    <button mat-button color=\"primary\" (click)=\"reset()\">\n        {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n    </button>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-slider' },
                styles: [".adf-search-slider .mat-slider{width:100%}"]
            }] }
];
SearchSliderComponent.propDecorators = {
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LiveErrorStateMatcher {
    /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    isErrorState(control, form) {
        /** @type {?} */
        const isSubmitted = form && form.submitted;
        return !!(control && control.invalid && (control.dirty || control.touched || (!control.pristine && isSubmitted)));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchNumberRangeComponent {
    constructor() {
        this.matcher = new LiveErrorStateMatcher();
        this.format = '[{FROM} TO {TO}]';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            this.field = this.settings.field;
            this.format = this.settings["format"] || '[{FROM} TO {TO}]';
        }
        this.validators = Validators.compose([
            Validators.required,
            Validators.pattern(/^-?(0|[1-9]\d*)?$/),
            Validators.min(0)
        ]);
        this.from = new FormControl('', this.validators);
        this.to = new FormControl('', this.validators);
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        }, this.formValidator);
    }
    /**
     * @param {?} formGroup
     * @return {?}
     */
    formValidator(formGroup) {
        return parseInt(formGroup.get('from').value, 10) < parseInt(formGroup.get('to').value, 10) ? null : { 'mismatch': true };
    }
    /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    apply(model, isValid) {
        if (isValid && this.id && this.context && this.field) {
            /** @type {?} */
            const map$$1 = new Map();
            map$$1.set('FROM', model.from);
            map$$1.set('TO', model.to);
            /** @type {?} */
            const value = this.formatString(this.format, map$$1);
            this.context.queryFragments[this.id] = `${this.field}:${value}`;
            this.context.update();
        }
    }
    /**
     * @param {?} str
     * @param {?} map
     * @return {?}
     */
    formatString(str, map$$1) {
        /** @type {?} */
        let result = str;
        map$$1.forEach((value, key) => {
            /** @type {?} */
            const expr = new RegExp('{' + key + '}', 'gm');
            result = result.replace(expr, value);
        });
        return result;
    }
    /**
     * @return {?}
     */
    reset() {
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    }
}
SearchNumberRangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-number-range',
                template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n\n    <mat-form-field>\n        <input\n            matInput [formControl]=\"from\" [errorStateMatcher]=\"matcher\"\n            placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM' | translate }}\"\n            autocomplete=\"off\">\n        <mat-error *ngIf=\"from.hasError('pattern') || from.hasError('min')\">\n            {{ 'SEARCH.FILTER.VALIDATION.INVALID-FORMAT' | translate }}\n        </mat-error>\n        <mat-error *ngIf=\"from.hasError('required')\">\n            {{ 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' | translate }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input\n            matInput [formControl]=\"to\" [errorStateMatcher]=\"matcher\"\n            placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO' | translate }}\"\n            autocomplete=\"off\">\n        <mat-error *ngIf=\"to.hasError('pattern') || to.hasError('min')\">\n            {{ 'SEARCH.FILTER.VALIDATION.INVALID-FORMAT' | translate }}\n        </mat-error>\n        <mat-error *ngIf=\"to.hasError('required')\">\n            {{ 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' | translate }}\n        </mat-error>\n    </mat-form-field>\n\n\n    <div class=\"facet-buttons\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"reset()\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-number-range' },
                styles: [".adf-search-number-range>form{display:inline-flex;flex-direction:column;width:100%}"]
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchCheckListComponent {
    constructor() {
        this.operator = 'OR';
        this.pageSize = 5;
        this.options = new SearchFilterList();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            this.operator = this.settings["operator"] || 'OR';
            this.pageSize = this.settings["pageSize"] || 5;
            if (this.settings["options"] && this.settings["options"].length > 0) {
                this.options = new SearchFilterList(this.settings["options"], this.pageSize);
            }
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.options.items.forEach(opt => {
            opt.checked = false;
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    }
    /**
     * @param {?} event
     * @param {?} option
     * @return {?}
     */
    changeHandler(event, option) {
        option.checked = event.checked;
        this.flush();
    }
    /**
     * @return {?}
     */
    flush() {
        /** @type {?} */
        const checkedValues = this.options.items
            .filter(option => option.checked)
            .map(option => option.value);
        /** @type {?} */
        const query = checkedValues.join(` ${this.operator} `);
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = query;
            this.context.update();
        }
    }
}
SearchCheckListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-check-list',
                template: "<div class=\"checklist\">\n    <mat-checkbox\n        *ngFor=\"let option of options\"\n        [checked]=\"option.checked\"\n        (change)=\"changeHandler($event, option)\">\n        {{ option.name | translate }}\n    </mat-checkbox>\n</div>\n\n<div class=\"facet-buttons\" *ngIf=\"options.fitsPage\">\n    <button mat-button color=\"primary\" (click)=\"reset()\">\n        {{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\n    </button>\n</div>\n\n<div class=\"facet-buttons\" *ngIf=\"!options.fitsPage\">\n    <button mat-icon-button\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.CLEAR-ALL' | translate }}\"\n        (click)=\"reset()\">\n        <mat-icon>clear</mat-icon>\n    </button>\n    <button mat-icon-button\n        *ngIf=\"options.canShowLessItems\"\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-LESS' | translate }}\"\n        (click)=\"options.showLessItems()\">\n        <mat-icon>keyboard_arrow_up</mat-icon>\n    </button>\n    <button mat-icon-button\n        *ngIf=\"options.canShowMoreItems\"\n        title=\"{{ 'SEARCH.FILTER.ACTIONS.SHOW-MORE' | translate }}\"\n        (click)=\"options.showMoreItems()\">\n        <mat-icon>keyboard_arrow_down</mat-icon>\n    </button>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-check-list' },
                styles: [".adf-search-check-list{display:flex;flex-direction:column}"]
            }] }
];
/** @nocollapse */
SearchCheckListComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_FORMAT_DATE = 'DD/MM/YYYY';
const ɵ0 = MOMENT_DATE_FORMATS;
class SearchDateRangeComponent {
    /**
     * @param {?} dateAdapter
     * @param {?} userPreferencesService
     */
    constructor(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.matcher = new LiveErrorStateMatcher();
        this.datePickerDateFormat = DEFAULT_FORMAT_DATE;
    }
    /**
     * @return {?}
     */
    getFromValidationMessage() {
        return this.from.hasError('invalidOnChange') || this.hasParseError(this.from) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.from.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                this.from.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                    '';
    }
    /**
     * @return {?}
     */
    getToValidationMessage() {
        return this.to.hasError('invalidOnChange') || this.hasParseError(this.to) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.to.hasError('matDatepickerMin') ? 'SEARCH.FILTER.VALIDATION.NO-DAYS' :
                this.to.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                    this.to.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                        '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            this.datePickerDateFormat = this.settings["dateFormat"] || DEFAULT_FORMAT_DATE;
        }
        /** @type {?} */
        const theCustomDateAdapter = /** @type {?} */ (/** @type {?} */ (this.dateAdapter));
        theCustomDateAdapter.overrideDisplyaFormat = this.datePickerDateFormat;
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((locale) => {
            this.setLocale(locale);
        });
        /** @type {?} */
        const validators = Validators.compose([
            Validators.required
        ]);
        this.from = new FormControl('', validators);
        this.to = new FormControl('', validators);
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        });
        this.maxDate = this.dateAdapter.today().startOf('day');
    }
    /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    apply(model, isValid) {
        if (isValid && this.id && this.context && this.settings && this.settings.field) {
            /** @type {?} */
            const start = moment(model.from).startOf('day').format();
            /** @type {?} */
            const end = moment(model.to).endOf('day').format();
            this.context.queryFragments[this.id] = `${this.settings.field}:['${start}' TO '${end}']`;
            this.context.update();
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    }
    /**
     * @param {?} event
     * @param {?} formControl
     * @return {?}
     */
    onChangedHandler(event, formControl) {
        /** @type {?} */
        const inputValue = event.srcElement.value;
        /** @type {?} */
        const formatDate = this.dateAdapter.parse(inputValue, this.datePickerDateFormat);
        if (formatDate && formatDate.isValid()) {
            formControl.setValue(formatDate);
        }
        else if (formatDate) {
            formControl.setErrors({
                'invalidOnChange': true
            });
        }
        else {
            formControl.setErrors({
                'required': true
            });
        }
    }
    /**
     * @param {?} locale
     * @return {?}
     */
    setLocale(locale) {
        this.dateAdapter.setLocale(locale);
        moment.locale(locale);
    }
    /**
     * @param {?} formControl
     * @return {?}
     */
    hasParseError(formControl) {
        return formControl.hasError('matDatepickerParse') && formControl.getError('matDatepickerParse').text;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    forcePlaceholder(event) {
        event.srcElement.click();
    }
}
SearchDateRangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-date-range',
                template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"from\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM-DATE' | translate }}\"\n                [matDatepicker]=\"fromDatepicker\"\n                [max]=\"maxDate\"\n                (focusout)=\"onChangedHandler($event, from)\">\n        <mat-datepicker-toggle matSuffix [for]=\"fromDatepicker\"></mat-datepicker-toggle>\n        <mat-datepicker #fromDatepicker></mat-datepicker>\n        <mat-error *ngIf=\"from.invalid\">\n            {{ getFromValidationMessage() | translate: { requiredFormat: datePickerDateFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"to\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO-DATE' | translate }}\"\n                [matDatepicker]=\"toDatepicker\"\n                [min]=\"from.value\"\n                [max]=\"maxDate\"\n                (focusout)=\"onChangedHandler($event, to)\">\n        <mat-datepicker-toggle matSuffix [for]=\"toDatepicker\"></mat-datepicker-toggle>\n        <mat-datepicker #toDatepicker></mat-datepicker>\n        <mat-error *ngIf=\"to.invalid\">\n            {{ getToValidationMessage() | translate: { requiredFormat: datePickerDateFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <div class=\"facet-buttons facet-buttons--topSpace\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"reset()\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE] },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                ],
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-date-range' },
                styles: [".adf-search-date-range>form{display:inline-flex;flex-direction:column;width:100%}"]
            }] }
];
/** @nocollapse */
SearchDateRangeComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: UserPreferencesService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchFilterService {
    constructor() {
        /**
         * Contains string-to-type mappings for registered widgets.
         */
        this.widgets = {
            'text': SearchTextComponent,
            'radio': SearchRadioComponent,
            'slider': SearchSliderComponent,
            'number-range': SearchNumberRangeComponent,
            'check-list': SearchCheckListComponent,
            'date-range': SearchDateRangeComponent
        };
    }
}
SearchFilterService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchChipListComponent {
}
SearchChipListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-chip-list',
                template: "<mat-chip-list>\n    <ng-container *ngIf=\"searchFilter && searchFilter.selectedFacetQueries.length\">\n        <mat-chip\n            *ngFor=\"let query of searchFilter.selectedFacetQueries\"\n            [removable]=\"true\"\n            (removed)=\"searchFilter.unselectFacetQuery(query)\">\n            {{ query.label | translate }}\n            <mat-icon matChipRemove>cancel</mat-icon>\n        </mat-chip>\n    </ng-container>\n    <ng-container *ngIf=\"searchFilter && searchFilter.selectedBuckets.length\">\n        <mat-chip\n            *ngFor=\"let selection of searchFilter.selectedBuckets\"\n            [removable]=\"true\"\n            (removed)=\"searchFilter.unselectFacetBucket(selection.field, selection.bucket)\">\n            {{ (selection.bucket.display || selection.bucket.label) | translate }}\n            <mat-icon matChipRemove>cancel</mat-icon>\n        </mat-chip>\n    </ng-container>\n</mat-chip-list>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-chip-list' }
            }] }
];
SearchChipListComponent.propDecorators = {
    searchFilter: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchSortingPickerComponent {
    /**
     * @param {?} queryBuilder
     */
    constructor(queryBuilder) {
        this.queryBuilder = queryBuilder;
        this.options = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.options = this.queryBuilder.getSortingOptions();
        /** @type {?} */
        const primary = this.queryBuilder.getPrimarySorting();
        if (primary) {
            this.value = primary.key;
            this.ascending = primary.ascending;
        }
    }
    /**
     * @param {?} sorting
     * @return {?}
     */
    onChanged(sorting) {
        this.value = sorting.key;
        this.ascending = sorting.ascending;
        this.applySorting();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    findOptionByKey(key) {
        if (key) {
            return this.options.find(opt => opt.key === key);
        }
        return null;
    }
    /**
     * @return {?}
     */
    applySorting() {
        /** @type {?} */
        const option = this.findOptionByKey(this.value);
        if (option) {
            this.queryBuilder.sorting = [Object.assign({}, option, { ascending: this.ascending })];
            this.queryBuilder.update();
        }
    }
}
SearchSortingPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-sorting-picker',
                template: "<adf-sorting-picker\n    [options]=\"options\"\n    [selected]=\"value\"\n    [ascending]=\"ascending\"\n    (change)=\"onChanged($event)\">\n</adf-sorting-picker>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-sorting-picker' }
            }] }
];
/** @nocollapse */
SearchSortingPickerComponent.ctorParameters = () => [
    { type: SearchQueryBuilderService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SearchWidgetContainerComponent {
    /**
     * @param {?} searchFilterService
     * @param {?} queryBuilder
     * @param {?} componentFactoryResolver
     */
    constructor(searchFilterService, queryBuilder, componentFactoryResolver) {
        this.searchFilterService = searchFilterService;
        this.queryBuilder = queryBuilder;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const componentType = this.searchFilterService.widgets[this.selector];
        if (componentType) {
            /** @type {?} */
            const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            if (factory) {
                this.content.clear();
                this.componentRef = this.content.createComponent(factory, 0);
                this.setupWidget(this.componentRef);
            }
        }
    }
    /**
     * @param {?} ref
     * @return {?}
     */
    setupWidget(ref) {
        if (ref && ref.instance) {
            ref.instance.id = this.id;
            ref.instance.settings = Object.assign({}, this.settings);
            ref.instance.context = this.queryBuilder;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
}
SearchWidgetContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-widget-container',
                template: '<div #content></div>'
            }] }
];
/** @nocollapse */
SearchWidgetContainerComponent.ctorParameters = () => [
    { type: SearchFilterService },
    { type: SearchQueryBuilderService },
    { type: ComponentFactoryResolver }
];
SearchWidgetContainerComponent.propDecorators = {
    content: [{ type: ViewChild, args: ['content', { read: ViewContainerRef },] }],
    id: [{ type: Input }],
    selector: [{ type: Input }],
    settings: [{ type: Input }],
    config: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const ALFRESCO_SEARCH_DIRECTIVES = [
    SearchComponent,
    SearchControlComponent,
    SearchTriggerDirective,
    EmptySearchResultComponent,
    SearchFilterComponent,
    SearchChipListComponent
];
class SearchModule {
}
SearchModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    CoreModule.forChild()
                ],
                declarations: [
                    ...ALFRESCO_SEARCH_DIRECTIVES,
                    SearchWidgetContainerComponent,
                    SearchTextComponent,
                    SearchRadioComponent,
                    SearchSliderComponent,
                    SearchNumberRangeComponent,
                    SearchCheckListComponent,
                    SearchDateRangeComponent,
                    SearchSortingPickerComponent
                ],
                exports: [
                    ...ALFRESCO_SEARCH_DIRECTIVES,
                    SearchWidgetContainerComponent,
                    SearchTextComponent,
                    SearchRadioComponent,
                    SearchSliderComponent,
                    SearchNumberRangeComponent,
                    SearchCheckListComponent,
                    SearchDateRangeComponent,
                    SearchSortingPickerComponent
                ],
                entryComponents: [
                    SearchWidgetContainerComponent,
                    SearchTextComponent,
                    SearchRadioComponent,
                    SearchSliderComponent,
                    SearchNumberRangeComponent,
                    SearchCheckListComponent,
                    SearchDateRangeComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {string} */
const Relations = {
    Members: 'members',
    Containers: 'containers',
};
class DropdownSitesComponent {
    /**
     * @param {?} sitesService
     * @param {?} logService
     */
    constructor(sitesService, logService) {
        this.sitesService = sitesService;
        this.logService = logService;
        /**
         * Hide the "My Files" option.
         */
        this.hideMyFiles = false;
        /**
         * A custom list of sites to be displayed by the dropdown. If no value
         * is given, the sites of the current user are displayed by default. A
         * list of objects only with properties 'title' and 'guid' is enough to
         * be able to display the dropdown.
         */
        this.siteList = null;
        /**
         * Id of the selected site
         */
        this.value = null;
        /**
         * Text or a translation key to act as a placeholder. Default value is the
         * key "DROPDOWN.PLACEHOLDER_LABEL".
         */
        this.placeholder = 'DROPDOWN.PLACEHOLDER_LABEL';
        /**
         * Emitted when the user selects a site. When the default option is selected,
         * an empty model is emitted.
         */
        this.change = new EventEmitter();
        this.selected = null;
        this.MY_FILES_VALUE = '-my-';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.siteList) {
            this.setDefaultSiteList();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    selectedSite(event) {
        this.change.emit(event.value);
    }
    /**
     * @return {?}
     */
    setDefaultSiteList() {
        /** @type {?} */
        let extendedOptions = null;
        if (this.relations) {
            extendedOptions = { relations: [this.relations] };
        }
        this.sitesService.getSites(extendedOptions).subscribe((result) => {
            this.siteList = this.relations === Relations.Members ? this.filteredResultsByMember(result) : result;
            if (!this.hideMyFiles) {
                /** @type {?} */
                let myItem = { entry: { id: '-my-', guid: '-my-', title: 'DROPDOWN.MY_FILES_OPTION' } };
                this.siteList.list.entries.unshift(myItem);
                if (!this.value) {
                    this.value = '-my-';
                }
            }
            this.selected = this.siteList.list.entries.find(site => site.entry.id === this.value);
        }, (error) => {
            this.logService.error(error);
        });
    }
    /**
     * @param {?} sites
     * @return {?}
     */
    filteredResultsByMember(sites) {
        /** @type {?} */
        const loggedUserName = this.sitesService.getEcmCurrentLoggedUserName();
        sites.list.entries = sites.list.entries.filter((site) => this.isCurrentUserMember(site, loggedUserName));
        return sites;
    }
    /**
     * @param {?} site
     * @param {?} loggedUserName
     * @return {?}
     */
    isCurrentUserMember(site, loggedUserName) {
        return site.entry.visibility === 'PUBLIC' ||
            !!site.relations.members.list.entries.find((member) => {
                return member.entry.id.toLowerCase() === loggedUserName.toLowerCase();
            });
    }
}
DropdownSitesComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sites-dropdown',
                template: "<div id=\"site-dropdown-container\" class=\"adf-site-dropdown-container\">\n    <mat-form-field>\n        <mat-select\n            data-automation-id=\"site-my-files-option\"\n            class=\"adf-site-dropdown-list-element\"\n            id=\"site-dropdown\"\n            placeholder=\"{{placeholder | translate}}\"\n            floatPlaceholder=\"never\"\n            data-automation-id=\"site-my-files-select\"\n            [(value)]=\"selected\"\n            (selectionChange)=\"selectedSite($event)\">\n            <mat-option *ngFor=\"let site of siteList?.list.entries\" [value]=\"site\">\n                {{ site.entry.title | translate}}\n            </mat-option>\n        </mat-select>\n    </mat-form-field>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-sites-dropdown' },
                styles: [".adf-sites-dropdown.full-width .mat-form-field{width:100%}"]
            }] }
];
/** @nocollapse */
DropdownSitesComponent.ctorParameters = () => [
    { type: SitesService },
    { type: LogService }
];
DropdownSitesComponent.propDecorators = {
    hideMyFiles: [{ type: Input }],
    siteList: [{ type: Input }],
    value: [{ type: Input }],
    placeholder: [{ type: Input }],
    relations: [{ type: Input }],
    change: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SitesDropdownModule {
}
SitesDropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CoreModule.forChild()
                ],
                exports: [
                    DropdownSitesComponent
                ],
                declarations: [
                    DropdownSitesComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class BreadcrumbComponent {
    constructor() {
        /**
         * Active node, builds UI based on folderNode.path.elements collection.
         */
        this.folderNode = null;
        /**
         * (optional) Name of the root element of the breadcrumb. You can use
         * this property to rename "Company Home" to "Personal Files" for
         * example. You can use an i18n resource key for the property value.
         */
        this.root = null;
        /**
         * (optional) The id of the root element. You can use this property
         * to set a custom element the breadcrumb should start with.
         */
        this.rootId = null;
        this.route = [];
        /**
         * Emitted when the user clicks on a breadcrumb.
         */
        this.navigate = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get hasRoot() {
        return !!this.root;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.transform = this.transform ? this.transform : null;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["folderNode"]) {
            /** @type {?} */
            let node = null;
            node = this.transform ? this.transform(changes["folderNode"].currentValue) : changes["folderNode"].currentValue;
            this.route = this.parseRoute(node);
        }
        if (changes["transform"]) {
            /** @type {?} */
            let node = this.transform ? this.transform(this.folderNode) : this.folderNode;
            this.route = this.parseRoute(node);
        }
        this.recalculateNodes();
    }
    /**
     * @return {?}
     */
    recalculateNodes() {
        if (this.maxItems && this.route.length > this.maxItems) {
            this.lastNodes = this.route.slice(this.route.length - this.maxItems);
            this.previousNodes = this.route.slice(0, this.route.length - this.maxItems);
            this.previousNodes.reverse();
        }
        else {
            this.lastNodes = this.route;
            this.previousNodes = null;
        }
    }
    /**
     * @return {?}
     */
    open() {
        if (this.dropdown) {
            this.dropdown.open();
        }
    }
    /**
     * @return {?}
     */
    hasPreviousNodes() {
        return this.previousNodes ? true : false;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    parseRoute(node) {
        if (node && node.path) {
            /** @type {?} */
            const route = /** @type {?} */ ((node.path.elements || []).slice());
            route.push(/** @type {?} */ ({
                id: node.id,
                name: node.name
            }));
            /** @type {?} */
            const rootPos = this.getElementPosition(route, this.rootId);
            if (rootPos > 0) {
                route.splice(0, rootPos);
            }
            if (rootPos === -1 && this.rootId) {
                route[0].id = this.rootId;
            }
            if (this.root) {
                route[0].name = this.root;
            }
            return route;
        }
        return [];
    }
    /**
     * @param {?} route
     * @param {?} nodeId
     * @return {?}
     */
    getElementPosition(route, nodeId) {
        /** @type {?} */
        let result = -1;
        if (route && route.length > 0 && nodeId) {
            result = route.findIndex(el => el.id === nodeId);
        }
        return result;
    }
    /**
     * @param {?} route
     * @param {?=} event
     * @return {?}
     */
    onRoutePathClick(route, event) {
        if (event) {
            event.preventDefault();
        }
        if (route) {
            this.navigate.emit(route);
            if (this.target) {
                this.target.navigateTo(route.id);
            }
        }
    }
}
BreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-breadcrumb',
                template: "<nav *ngIf=\"folderNode\" data-automation-id=\"breadcrumb\" class=\"adf-breadcrumb-container\" role=\"list\">\n    <button\n        *ngIf=\"hasPreviousNodes()\"\n        tabindex=\"0\"\n        class=\"adf-breadcrumb-dropdown-trigger\"\n        (click)=\"open()\">\n        <div class=\"adf-breadcrumb-dropdown-trigger-icon\">\n            <mat-icon [class.isRoot]=\"!hasPreviousNodes()\">folder</mat-icon>\n            <mat-icon [class.isRoot]=\"!hasPreviousNodes()\" class=\"adf-breadcrumb-dropdown-trigger-arrow\">arrow_drop_down</mat-icon>\n        </div>\n    </button>\n\n    <mat-select\n        #dropdown\n        *ngIf=\"hasPreviousNodes()\"\n        class=\"adf-breadcrumb-dropdown-path\"\n        tabindex=\"0\">\n\n        <mat-option\n            *ngFor=\"let node of previousNodes;\"\n            (click)=\"onRoutePathClick(node, $event)\"\n            class=\"adf-breadcrumb-path-option\"\n            tabindex=\"0\">\n            {{ node.name | translate }}\n        </mat-option>\n    </mat-select>\n\n    <div *ngFor=\"let item of lastNodes; let last = last\"\n        [class.active]=\"last\"\n        [ngSwitch]=\"last\"\n        title=\"{{ item.name | translate }}\"\n        class=\"adf-breadcrumb-item\"\n        role=\"listitem\">\n\n        <a *ngSwitchDefault href=\"#\" [attr.data-automation-id]=\"'breadcrumb_' + item.name\"\n            class=\"adf-breadcrumb-item-anchor\"\n            (click)=\"onRoutePathClick(item, $event)\">\n            {{ item.name | translate }}\n        </a>\n\n        <div *ngSwitchCase=\"true\" class=\"adf-breadcrumb-item-current\">\n            {{ item.name | translate }}\n        </div>\n\n        <mat-icon class=\"adf-breadcrumb-item-chevron\" *ngIf=\"!last\">\n            chevron_right\n        </mat-icon>\n    </div>\n</nav>\n\n<nav *ngIf=\"!folderNode && hasRoot\" data-automation-id=\"breadcrumb\" role=\"navigation\">\n    <div class=\"adf-breadcrumb-item active\" role=\"listitem\">\n        <div class=\"adf-breadcrumb-item-current\">\n            {{ root | translate }}\n        </div>\n    </div>\n</nav>\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-breadcrumb'
                },
                styles: [""]
            }] }
];
BreadcrumbComponent.propDecorators = {
    folderNode: [{ type: Input }],
    root: [{ type: Input }],
    rootId: [{ type: Input }],
    target: [{ type: Input }],
    transform: [{ type: Input }],
    dropdown: [{ type: ViewChild, args: ['dropdown',] }],
    maxItems: [{ type: Input }],
    navigate: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DropdownBreadcrumbComponent extends BreadcrumbComponent {
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["folderNode"]) {
            /** @type {?} */
            let node = null;
            node = this.transform ? this.transform(changes["folderNode"].currentValue) : changes["folderNode"].currentValue;
            this.route = this.parseRoute(node);
        }
        if (changes["transform"]) {
            /** @type {?} */
            let node = this.transform ? this.transform(this.folderNode) : this.folderNode;
            this.route = this.parseRoute(node);
        }
        this.recalculateNodes();
    }
    /**
     * Calculate the current and previous nodes from the route array
     * @return {?}
     */
    recalculateNodes() {
        this.currentNode = this.route[this.route.length - 1];
        this.previousNodes = this.route.slice(0, this.route.length - 1).reverse();
    }
    /**
     * Opens the node picker menu
     * @return {?}
     */
    open() {
        if (this.dropdown) {
            this.dropdown.open();
        }
    }
    /**
     * Return if route has more than one element (means: we are not in the root directory)
     * @return {?}
     */
    hasPreviousNodes() {
        return this.previousNodes.length > 0;
    }
}
DropdownBreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dropdown-breadcrumb',
                template: "<ng-container *ngIf=\"route.length > 0\">\n\n    <button\n        tabindex=\"0\"\n        class=\"adf-dropdown-breadcrumb-trigger\"\n        (click)=\"open()\"\n        data-automation-id=\"dropdown-breadcrumb-trigger\">\n        <mat-icon [class.isRoot]=\"!hasPreviousNodes()\">folder</mat-icon>\n    </button>\n    <mat-icon class=\"adf-dropdown-breadcrumb-item-chevron\">chevron_right</mat-icon>\n\n    <mat-select\n        #dropdown\n        *ngIf=\"hasPreviousNodes()\"\n        class=\"adf-dropdown-breadcrumb-path\"\n        tabindex=\"0\"\n        data-automation-id=\"dropdown-breadcrumb-path\" >\n\n        <mat-option\n            *ngFor=\"let node of previousNodes;\"\n            (click)=\"onRoutePathClick(node, $event)\"\n            class=\"adf-dropdown-breadcrumb-path-option\"\n            tabindex=\"0\"\n            data-automation-class=\"dropdown-breadcrumb-path-option\">\n            {{ node.name | translate }}\n        </mat-option>\n    </mat-select>\n\n    <span\n        class=\"adf-current-folder\"\n        [class.isRoot]=\"!hasPreviousNodes()\"\n        data-automation-id=\"current-folder\">{{ currentNode.name }}</span>\n</ng-container>\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-dropdown-breadcrumb'
                },
                styles: [""]
            }] }
];
DropdownBreadcrumbComponent.propDecorators = {
    dropdown: [{ type: ViewChild, args: ['dropdown',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class BreadcrumbModule {
}
BreadcrumbModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    CoreModule.forChild()
                ],
                exports: [
                    BreadcrumbComponent,
                    DropdownBreadcrumbComponent
                ],
                declarations: [
                    BreadcrumbComponent,
                    DropdownBreadcrumbComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ConfirmDialogComponent {
    /**
     * @param {?} data
     */
    constructor(data) {
        data = data || {};
        this.title = data.title || 'ADF_CONFIRM_DIALOG.CONFIRM';
        this.message = data.message || 'ADF_CONFIRM_DIALOG.MESSAGE';
        this.yesLabel = data.yesLabel || 'ADF_CONFIRM_DIALOG.YES_LABEL';
        this.noLabel = data.noLabel || 'ADF_CONFIRM_DIALOG.NO_LABEL';
    }
}
ConfirmDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-confirm-dialog',
                template: `
        <h1 mat-dialog-title>{{ title | translate }}</h1>
        <mat-dialog-content>
            <p>{{ message | translate }}</p>
        </mat-dialog-content>
        <mat-dialog-actions>
            <span class="spacer"></span>
            <button id="adf-confirm-accept" mat-button color="primary" [mat-dialog-close]="true">{{ yesLabel | translate }}</button>
            <button id="adf-confirm-cancel" mat-button [mat-dialog-close]="false" cdkFocusInitial>{{ noLabel | translate }}</button>
        </mat-dialog-actions>
    `,
                host: { 'class': 'adf-confirm-dialog' },
                encapsulation: ViewEncapsulation.None,
                styles: [`
        .spacer { flex: 1 1 auto; }

        .adf-confirm-dialog .mat-dialog-actions .mat-button-wrapper {
            text-transform: uppercase;
        }
    `]
            }] }
];
/** @nocollapse */
ConfirmDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class VersionListComponent {
    /**
     * @param {?} alfrescoApi
     * @param {?} contentService
     * @param {?} dialog
     */
    constructor(alfrescoApi, contentService, dialog) {
        this.alfrescoApi = alfrescoApi;
        this.contentService = contentService;
        this.dialog = dialog;
        this.versions = [];
        this.isLoading = true;
        /**
         * Toggles showing/hiding of comments
         */
        this.showComments = true;
        /**
         * Enable/disable downloading a version of the current node.
         */
        this.allowDownload = true;
        /**
         * Toggles showing/hiding of version actions
         */
        this.showActions = true;
        /**
         * Emitted when a version is restored
         */
        this.restored = new EventEmitter();
        /**
         * Emitted when a version is deleted
         */
        this.deleted = new EventEmitter();
        this.versionsApi = this.alfrescoApi.versionsApi;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.loadVersionHistory();
    }
    /**
     * @return {?}
     */
    canUpdate() {
        return this.contentService.hasPermission(this.node, 'update') && this.versions.length > 1;
    }
    /**
     * @return {?}
     */
    canDelete() {
        return this.contentService.hasPermission(this.node, 'delete') && this.versions.length > 1;
    }
    /**
     * @param {?} versionId
     * @return {?}
     */
    restore(versionId) {
        if (this.canUpdate()) {
            this.versionsApi
                .revertVersion(this.node.id, versionId, { majorVersion: true, comment: '' })
                .then(() => this.onVersionRestored(this.node));
        }
    }
    /**
     * @return {?}
     */
    loadVersionHistory() {
        this.isLoading = true;
        this.versionsApi.listVersionHistory(this.node.id).then((data) => {
            this.versions = data.list.entries;
            this.isLoading = false;
        });
    }
    /**
     * @param {?} versionId
     * @return {?}
     */
    downloadVersion(versionId) {
        if (this.allowDownload) {
            /** @type {?} */
            const versionDownloadUrl = this.getVersionContentUrl(this.node.id, versionId, true);
            this.downloadContent(versionDownloadUrl);
        }
    }
    /**
     * @param {?} versionId
     * @return {?}
     */
    deleteVersion(versionId) {
        if (this.canUpdate()) {
            /** @type {?} */
            const dialogRef = this.dialog.open(ConfirmDialogComponent, {
                data: {
                    title: 'ADF_VERSION_LIST.CONFIRM_DELETE.TITLE',
                    message: 'ADF_VERSION_LIST.CONFIRM_DELETE.MESSAGE',
                    yesLabel: 'ADF_VERSION_LIST.CONFIRM_DELETE.YES_LABEL',
                    noLabel: 'ADF_VERSION_LIST.CONFIRM_DELETE.NO_LABEL'
                },
                minWidth: '250px'
            });
            dialogRef.afterClosed().subscribe(result => {
                if (result === true) {
                    this.alfrescoApi.versionsApi
                        .deleteVersion(this.node.id, versionId)
                        .then(() => this.onVersionDeleted(this.node));
                }
            });
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onVersionDeleted(node) {
        this.loadVersionHistory();
        this.deleted.emit(node);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onVersionRestored(node) {
        this.loadVersionHistory();
        this.restored.emit(node);
    }
    /**
     * @param {?} nodeId
     * @param {?} versionId
     * @param {?=} attachment
     * @return {?}
     */
    getVersionContentUrl(nodeId, versionId, attachment) {
        /** @type {?} */
        const nodeDownloadUrl = this.alfrescoApi.contentApi.getContentUrl(nodeId, attachment);
        return nodeDownloadUrl.replace('/content', '/versions/' + versionId + '/content');
    }
    /**
     * @param {?} url
     * @return {?}
     */
    downloadContent(url) {
        if (url) {
            /** @type {?} */
            const link = document.createElement('a');
            link.style.display = 'none';
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }
}
VersionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-version-list',
                template: "<mat-list class=\"adf-version-list\" *ngIf=\"!isLoading; else loading_template\">\n    <mat-list-item *ngFor=\"let version of versions; let idx = index\">\n        <mat-icon mat-list-icon>insert_drive_file</mat-icon>\n        <h4 mat-line class=\"adf-version-list-item-name\" [id]=\"'adf-version-list-item-name-' + version.entry.id\" >{{version.entry.name}}</h4>\n        <p mat-line>\n            <span class=\"adf-version-list-item-version\"  [id]=\"'adf-version-list-item-version-' + version.entry.id\" >{{version.entry.id}}</span> -\n            <span class=\"adf-version-list-item-date\"     [id]=\"'adf-version-list-item-date-' + version.entry.id\" >{{version.entry.modifiedAt | date}}</span>\n        </p>\n        <p mat-line [id]=\"'adf-version-list-item-comment-'+ version.entry.id\" class=\"adf-version-list-item-comment\"\n           *ngIf=\"showComments\">{{version.entry.versionComment}}</p>\n\n        <div *ngIf=\"showActions\">\n            <mat-menu [id]=\"'adf-version-list-action-menu-'+version.entry.id\"\n                      #versionMenu=\"matMenu\" yPosition=\"below\" xPosition=\"before\">\n                <button\n                    [id]=\"'adf-version-list-action-restore-'+version.entry.id\"\n                    [disabled]=\"!canUpdate()\"\n                    mat-menu-item\n                    (click)=\"restore(version.entry.id)\">\n                    {{ 'ADF_VERSION_LIST.ACTIONS.RESTORE' | translate }}\n                </button>\n                <button *ngIf=\"allowDownload\"\n                        [id]=\"'adf-version-list-action-download-'+version.entry.id\"\n                        mat-menu-item\n                        (click)=\"downloadVersion(version.entry.id)\">\n                    {{ 'ADF_VERSION_LIST.ACTIONS.DOWNLOAD' | translate }}\n                </button>\n                <button\n                    [disabled]=\"!canDelete()\"\n                    [id]=\"'adf-version-list-action-delete-'+version.entry.id\"\n                    (click)=\"deleteVersion(version.entry.id)\"\n                    mat-menu-item>\n                    {{ 'ADF_VERSION_LIST.ACTIONS.DELETE' | translate }}\n                </button>\n            </mat-menu>\n\n            <button mat-icon-button [matMenuTriggerFor]=\"versionMenu\" [id]=\"'adf-version-list-action-menu-button-'+version.entry.id\">\n                <mat-icon>more_vert</mat-icon>\n            </button>\n        </div>\n    </mat-list-item>\n</mat-list>\n\n<ng-template #loading_template>\n    <mat-progress-bar data-automation-id=\"version-history-loading-bar\" mode=\"indeterminate\"\n                      color=\"accent\"></mat-progress-bar>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-version-list'
                },
                styles: [".adf-version-list .mat-list-item-content{border-bottom:1px solid #d8d8d8}.adf-version-list-item-version{font-weight:700}.adf-version-list-item-date{opacity:.6}.adf-version-list-item-comment{opacity:.5}"]
            }] }
];
/** @nocollapse */
VersionListComponent.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: ContentService },
    { type: MatDialog }
];
VersionListComponent.propDecorators = {
    id: [{ type: Input }],
    node: [{ type: Input }],
    showComments: [{ type: Input }],
    allowDownload: [{ type: Input }],
    showActions: [{ type: Input }],
    restored: [{ type: Output }],
    deleted: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class VersionManagerComponent {
    /**
     * @param {?} config
     * @param {?} contentService
     * @param {?} alfrescoApiService
     */
    constructor(config, contentService, alfrescoApiService) {
        this.contentService = contentService;
        this.alfrescoApiService = alfrescoApiService;
        /**
         * Toggles showing/hiding of comments.
         */
        this.showComments = true;
        /**
         * Enable/disable downloading a version of the current node.
         */
        this.allowDownload = true;
        /**
         * Emitted when a file is uploaded successfully.
         */
        this.uploadSuccess = new EventEmitter();
        /**
         * Emitted when an error occurs during upload.
         */
        this.uploadError = new EventEmitter();
        this.uploadState = 'close';
    }
    /**
     * @param {?} node
     * @return {?}
     */
    refresh(node) {
        this.alfrescoApiService.nodeUpdated.next(node);
        this.versionListComponent.loadVersionHistory();
        this.uploadSuccess.emit(node);
        this.uploadState = 'close';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onUploadSuccess(event) {
        this.alfrescoApiService.nodeUpdated.next(event.value.entry);
        this.versionListComponent.loadVersionHistory();
        this.uploadSuccess.emit(event.value.entry);
        this.uploadState = 'close';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onUploadError(event) {
        this.uploadError.emit(event);
    }
    /**
     * @return {?}
     */
    onUploadCancel() {
        this.uploadState = 'close';
    }
    /**
     * @return {?}
     */
    toggleNewVersion() {
        this.uploadState = this.uploadState === 'open' ? 'close' : 'open';
    }
    /**
     * @return {?}
     */
    canUpdate() {
        return this.contentService.hasPermission(this.node, 'update');
    }
}
VersionManagerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-version-manager',
                template: "<div class=\"adf-new-version-container\">\n    <div class=\"adf-new-version-uploader-container\" id=\"adf-new-version-uploader-container\" fxLayout=\"row\" fxLayoutAlign=\"end center\" [@uploadToggle]=\"uploadState\">\n        <table class=\"adf-version-upload\" *ngIf=\"uploadState !== 'close'\">\n            <tr>\n                <td>\n                    <adf-version-upload\n                        id=\"adf-version-upload-button\"\n                        [node]=\"node\"\n                        (success)=\"onUploadSuccess($event)\"\n                        (cancel)=\"onUploadCancel()\"\n                        (error)=\"onUploadError($event)\">\n                    </adf-version-upload>\n                </td>\n            </tr>\n        </table>\n    </div>\n\n    <div class=\"adf-version-list-container\">\n        <div class=\"adf-version-list-table\">\n            <div>\n                <button mat-raised-button\n                        id=\"adf-show-version-upload-button\"\n                        (click)=\"toggleNewVersion()\" color=\"primary\"\n                        *ngIf=\"uploadState ==='close'\">{{\n                    'ADF_VERSION_LIST.ACTIONS.UPLOAD.ADD'|\n                    translate }}\n                </button>\n            </div>\n            <div>\n\n                <adf-version-list\n                    #versionList\n                    [node]=\"node\"\n                    [allowDownload]=\"allowDownload\"\n                    [showComments]=\"showComments\"\n                    (deleted)=\"refresh($event)\"\n                    (restored)=\"refresh($event)\">\n                </adf-version-list>\n            </div>\n        </div>\n    </div>\n</div>\n",
                animations: [
                    trigger('uploadToggle', [
                        state('open', style({ height: '175px', opacity: 1, visibility: 'visible' })),
                        state('close', style({ height: '0%', opacity: 0, visibility: 'hidden' })),
                        transition('open => close', [
                            style({ visibility: 'hidden' }),
                            animate('0.4s cubic-bezier(0.25, 0.8, 0.25, 1)')
                        ]),
                        transition('close => open', [
                            style({ visibility: 'visible' }),
                            animate('0.4s cubic-bezier(0.25, 0.8, 0.25, 1)')
                        ])
                    ])
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-button.upload-new-version{box-shadow:none;width:100%;height:175px;float:left;position:relative}.adf-new-version-uploader-container{border-bottom:1px solid #d8d8d8;padding:16px 0;width:100%;height:0%;position:relative;display:hidden;float:left!important}.adf-new-version-container{height:800px;overflow:hidden}.adf-version-list-table,.adf-version-upload-table{width:100%}.adf-version-list{width:100%!important;float:left!important}"]
            }] }
];
/** @nocollapse */
VersionManagerComponent.ctorParameters = () => [
    { type: AppConfigService },
    { type: ContentService },
    { type: AlfrescoApiService }
];
VersionManagerComponent.propDecorators = {
    node: [{ type: Input }],
    showComments: [{ type: Input }],
    allowDownload: [{ type: Input }],
    uploadSuccess: [{ type: Output }],
    uploadError: [{ type: Output }],
    versionListComponent: [{ type: ViewChild, args: ['versionList',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class VersionUploadComponent {
    /**
     * @param {?} contentService
     */
    constructor(contentService) {
        this.contentService = contentService;
        this.semanticVersion = 'minor';
        this.uploadVersion = false;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.cancel = new EventEmitter();
    }
    /**
     * @return {?}
     */
    canUpload() {
        return this.contentService.hasPermission(this.node, 'update');
    }
    /**
     * @return {?}
     */
    isMajorVersion() {
        return this.semanticVersion === 'minor' ? false : true;
    }
    /**
     * @return {?}
     */
    cancelUpload() {
        this.cancel.emit();
    }
}
VersionUploadComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-version-upload',
                template: "<div class=\"adf-new-version-max-width\">\n    <mat-radio-group class=\"adf-new-version-radio-group\" [(ngModel)]=\"semanticVersion\">\n        <mat-radio-button class=\"adf-new-version-radio-button\" id=\"adf-new-version-minor\"[value]=\"'minor'\">{{\n            'ADF_VERSION_LIST.ACTIONS.UPLOAD.MINOR' |\n            translate }}\n        </mat-radio-button>\n        <mat-radio-button class=\"adf-new-version-radio-button\" id=\"adf-new-version-major\" [value]=\"'major'\">{{\n            'ADF_VERSION_LIST.ACTIONS.UPLOAD.MAJOR' |\n            translate }}\n        </mat-radio-button>\n    </mat-radio-group>\n    <mat-form-field class=\"adf-new-version-max-width\">\n                    <textarea matInput [(ngModel)]=\"comment\" class=\"adf-new-version-text-area\" id=\"adf-new-version-text-area\"\n                              placeholder=\"{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.COMMENT' | translate }}\"></textarea>\n    </mat-form-field>\n\n</div>\n<div class=\"adf-version-upload-buttons\">\n    <adf-upload-version-button\n        data-automation-id=\"adf-new-version-file-upload\"\n        staticTitle=\"{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.TITLE' | translate }}\"\n        [node]=\"node\"\n        [disabled]=\"!canUpload()\"\n        [rootFolderId]=\"node.parentId\"\n        tooltip=\"{{ 'ADF_VERSION_LIST.ACTIONS.UPLOAD.TOOLTIP' | translate }}\"\n        [comment]=\"comment\"\n        [versioning]=\"true\"\n        [majorVersion]=\"isMajorVersion()\"\n        (success)=\"success.emit($event)\"\n        (error)=\"error.emit($event)\">\n    </adf-upload-version-button>\n    <button mat-raised-button (click)=\"cancelUpload()\" id=\"adf-new-version-cancel\"  >{{\n        'ADF_VERSION_LIST.ACTIONS.UPLOAD.CANCEL'| translate }}\n    </button>\n</div>\n\n",
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-version-upload' },
                styles: [".adf-new-version-radio-group{display:inline-flex;flex-direction:column}.adf-new-version-radio-button{margin:5px}.adf-version-upload-buttons{display:flex;float:right;justify-content:space-between;width:100%}.adf-new-version-max-width{width:100%;float:right}.adf-new-version-text-area{resize:none!important}"]
            }] }
];
/** @nocollapse */
VersionUploadComponent.ctorParameters = () => [
    { type: ContentService }
];
VersionUploadComponent.propDecorators = {
    node: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    cancel: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class VersionManagerModule {
}
VersionManagerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    CoreModule.forChild(),
                    UploadModule,
                    FormsModule
                ],
                exports: [
                    VersionUploadComponent,
                    VersionManagerComponent,
                    VersionListComponent,
                    FormsModule
                ],
                declarations: [
                    VersionUploadComponent,
                    VersionManagerComponent,
                    VersionListComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NameLocationCellComponent {
    constructor() {
        this.name = '';
        this.path = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.row) {
            this.name = this.row.getValue('name');
            /** @type {?} */
            const fullPath = this.row.getValue('path');
            if (fullPath) {
                this.path = fullPath.name || '';
            }
        }
    }
}
NameLocationCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-name-location-cell',
                template: `
        <div class="adf-name-location-cell-name">{{ name }}</div>
        <div class="adf-name-location-cell-location" [title]="path">{{ path }}</div>
    `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-name-location-cell' },
                styles: [""]
            }] }
];
NameLocationCellComponent.propDecorators = {
    row: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Internal service used by ContentNodeSelector component.
 */
class ContentNodeSelectorService {
    /**
     * @param {?} searchService
     */
    constructor(searchService) {
        this.searchService = searchService;
    }
    /**
     * Performs a search for content node selection
     *
     * @param {?} searchTerm    The term to search for
     * @param {?=} rootNodeId    The root is to start the search from
     * @param {?=} skipCount     From where to start the loading
     * @param {?=} maxItems      How many items to load
     * @param {?=} extraNodeIds
     * @return {?}
     */
    search(searchTerm, rootNodeId = null, skipCount = 0, maxItems = 25, extraNodeIds) {
        /** @type {?} */
        let extraParentFiltering = '';
        if (extraNodeIds && extraNodeIds.length) {
            extraNodeIds
                .filter(id => id !== rootNodeId)
                .forEach(extraId => {
                extraParentFiltering += ` OR ANCESTOR:'workspace://SpacesStore/${extraId}'`;
            });
        }
        /** @type {?} */
        const parentFiltering = rootNodeId ? [{ query: `ANCESTOR:'workspace://SpacesStore/${rootNodeId}'${extraParentFiltering}` }] : [];
        /** @type {?} */
        let defaultSearchNode = {
            query: {
                query: `${searchTerm}* OR name:${searchTerm}*`
            },
            include: ['path', 'allowableOperations'],
            paging: {
                maxItems: maxItems,
                skipCount: skipCount
            },
            filterQueries: [
                { query: "TYPE:'cm:folder'" },
                { query: 'NOT cm:creator:System' },
                ...parentFiltering
            ],
            scope: {
                locations: ['nodes']
            }
        };
        return this.searchService.searchByQueryBody(defaultSearchNode);
    }
}
ContentNodeSelectorService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ContentNodeSelectorService.ctorParameters = () => [
    { type: SearchService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultValidation = () => true;
class ContentNodeSelectorPanelComponent {
    /**
     * @param {?} contentNodeSelectorService
     * @param {?} apiService
     * @param {?} customResourcesService
     * @param {?} preferences
     */
    constructor(contentNodeSelectorService, apiService, customResourcesService, preferences) {
        this.contentNodeSelectorService = contentNodeSelectorService;
        this.apiService = apiService;
        this.customResourcesService = customResourcesService;
        this.preferences = preferences;
        /**
         * Node ID of the folder currently listed.
         */
        this.currentFolderId = null;
        /**
         * Hide the "My Files" option added to the site list by default.
         * See the [Sites Dropdown component](sites-dropdown.component.md)
         * for more information.
         */
        this.dropdownHideMyFiles = false;
        /**
         * Custom site for site dropdown same as siteList. See the
         * [Sites Dropdown component](sites-dropdown.component.md)
         * for more information.
         */
        this.dropdownSiteList = null;
        /**
         * Custom row filter function. See the
         * [Document List component](document-list.component.md#custom-row-filter)
         * for more information.
         */
        this.rowFilter = null;
        /**
         * Custom image resolver function. See the
         * [Document List component](document-list.component.md#custom-row-filter)
         * for more information.
         */
        this.imageResolver = null;
        /**
         * Function used to decide if the selected node has permission to be selected.
         * Default value is a function that always returns true.
         */
        this.isSelectionValid = defaultValidation;
        /**
         * Emitted when the user has chosen an item.
         */
        this.select = new EventEmitter();
        this.nodes = null;
        this.searchTerm = '';
        this.showingSearchResults = false;
        this.loadingSearchResults = false;
        this.inDialog = false;
        this._chosenNode = null;
        this.folderIdToShow = null;
        this.paginationStrategy = PaginationStrategy.Infinite;
        this.skipCount = 0;
        this.infiniteScroll = false;
        this.debounceSearch = 200;
        this.searchInput = new FormControl();
        this.searchInput.valueChanges
            .pipe(debounceTime(this.debounceSearch))
            .subscribe((searchValue) => {
            this.search(searchValue);
        });
        this.pageSize = this.preferences.paginationSize;
        /** @type {?} */
        let defaultPagination = /** @type {?} */ ({
            maxItems: this.pageSize,
            skipCount: 0,
            totalItems: 0,
            hasMoreItems: false
        });
        this.pagination = new BehaviorSubject(defaultPagination);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set chosenNode(value) {
        this._chosenNode = value;
        /** @type {?} */
        let valuesArray = null;
        if (value) {
            valuesArray = [value];
        }
        this.select.next(valuesArray);
    }
    /**
     * @return {?}
     */
    get chosenNode() {
        return this._chosenNode;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.folderIdToShow = this.currentFolderId;
        this.breadcrumbTransform = this.breadcrumbTransform ? this.breadcrumbTransform : null;
        this.isSelectionValid = this.isSelectionValid ? this.isSelectionValid : defaultValidation;
    }
    /**
     * Updates the site attribute and starts a new search
     *
     * @param {?} chosenSite SiteEntry to search within
     * @return {?}
     */
    siteChanged(chosenSite) {
        this.siteId = chosenSite.entry.guid;
        this.updateResults();
    }
    /**
     * Updates the searchTerm attribute and starts a new search
     *
     * @param {?} searchTerm string value to search against
     * @return {?}
     */
    search(searchTerm) {
        this.searchTerm = searchTerm;
        this.updateResults();
    }
    /**
     * Returns the actually selected|entered folder node or null in case of searching for the breadcrumb
     * @return {?}
     */
    get breadcrumbFolderNode() {
        /** @type {?} */
        let folderNode;
        if (this.showingSearchResults && this.chosenNode) {
            folderNode = this.chosenNode;
        }
        else {
            folderNode = this.documentList.folderNode;
        }
        return folderNode;
    }
    /**
     * Clear the search input and reset to last folder node in which search was performed
     * @return {?}
     */
    clear() {
        this.clearSearch();
        this.folderIdToShow = this.siteId || this.currentFolderId;
    }
    /**
     * Clear the search input and search related data
     * @return {?}
     */
    clearSearch() {
        this.searchTerm = '';
        this.nodes = null;
        this.skipCount = 0;
        this.chosenNode = null;
        this.showingSearchResults = false;
    }
    /**
     * Update the result list depending on the criterias
     * @return {?}
     */
    updateResults() {
        if (this.searchTerm.length === 0) {
            this.clear();
        }
        else {
            this.startNewSearch();
        }
    }
    /**
     * Load the first page of a new search result
     * @return {?}
     */
    startNewSearch() {
        this.nodes = null;
        this.skipCount = 0;
        this.chosenNode = null;
        this.folderIdToShow = null;
        this.querySearch();
    }
    /**
     * Loads the next batch of search results
     *
     * @param {?} pagination
     * @return {?}
     */
    updatePagination(pagination) {
        this.infiniteScroll = true;
        this.skipCount = pagination.skipCount;
        if (this.searchTerm.length > 0) {
            this.querySearch();
        }
    }
    /**
     * Perform the call to searchService with the proper parameters
     * @return {?}
     */
    querySearch() {
        this.loadingSearchResults = true;
        if (this.customResourcesService.hasCorrespondingNodeIds(this.siteId)) {
            this.customResourcesService.getCorrespondingNodeIds(this.siteId)
                .subscribe(nodeIds => {
                this.contentNodeSelectorService.search(this.searchTerm, this.siteId, this.skipCount, this.pageSize, nodeIds)
                    .subscribe(this.showSearchResults.bind(this));
            }, () => {
                this.showSearchResults({ list: { entries: [] } });
            });
        }
        else {
            this.contentNodeSelectorService.search(this.searchTerm, this.siteId, this.skipCount, this.pageSize)
                .subscribe(this.showSearchResults.bind(this));
        }
    }
    /**
     * Show the results of the search
     *
     * @param {?} nodePaging
     * @return {?}
     */
    showSearchResults(nodePaging) {
        this.showingSearchResults = true;
        this.loadingSearchResults = false;
        // Documentlist hack, since data displaying for preloaded nodes is a little bit messy there
        if (!this.nodes) {
            this.nodes = nodePaging;
        }
        else {
            this.documentList.data.loadPage(nodePaging, true);
        }
        this.pagination.next(nodePaging.list.pagination);
        this.highlight();
    }
    /**
     * Hightlight the actual searchterm in the next frame
     * @return {?}
     */
    highlight() {
        setTimeout(() => {
            this.highlighter.highlight(this.searchTerm);
        }, 0);
    }
    /**
     * Sets showingSearchResults state to be able to differentiate between search results or folder results
     * @return {?}
     */
    onFolderChange() {
        this.showingSearchResults = false;
        this.infiniteScroll = false;
        this.clearSearch();
    }
    /**
     * Attempts to set the currently loaded node
     * @param {?} nodePaging
     * @return {?}
     */
    onFolderLoaded(nodePaging) {
        if (!this.showingSearchResults) {
            this.attemptNodeSelection(this.documentList.folderNode);
        }
    }
    /**
     * Returns whether breadcrumb has to be shown or not
     * @return {?}
     */
    showBreadcrumbs() {
        return !this.showingSearchResults || this.chosenNode;
    }
    /**
     * Loads the next batch of search results
     *
     * @param {?} event Pagination object
     * @return {?}
     */
    getNextPageOfSearch(event) {
        this.infiniteScroll = true;
        this.skipCount = event.skipCount;
        if (this.searchTerm.length > 0) {
            this.querySearch();
        }
    }
    /**
     * Selects node as chosen if it has the right permission, clears the selection otherwise
     *
     * @param {?} entry
     * @return {?}
     */
    attemptNodeSelection(entry) {
        if (this.isSelectionValid(entry)) {
            this.chosenNode = entry;
        }
        else {
            this.resetChosenNode();
        }
    }
    /**
     * Clears the chosen node
     * @return {?}
     */
    resetChosenNode() {
        this.chosenNode = null;
    }
    /**
     * Invoked when user selects a node
     *
     * @param {?} event CustomEvent for node-select
     * @return {?}
     */
    onNodeSelect(event) {
        this.attemptNodeSelection(event.detail.node.entry);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onNodeDoubleClick(e) {
        /** @type {?} */
        const node = e.detail.node.entry;
        if (node && node.guid) {
            /** @type {?} */
            const options = {
                maxItems: this.pageSize,
                skipCount: this.skipCount,
                include: ['path', 'properties', 'allowableOperations']
            };
            this.apiService.nodesApi.getNode(node.guid, options)
                .then(documentLibrary => {
                this.documentList.performCustomSourceNavigation(documentLibrary);
            });
        }
    }
}
ContentNodeSelectorPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-node-selector-panel',
                template: "<div class=\"adf-content-node-selector-content\" (node-select)=\"onNodeSelect($event)\">\n    <mat-form-field floatPlaceholder=\"never\" class=\"adf-content-node-selector-content-input\">\n        <input matInput\n            id=\"searchInput\"\n            [formControl]=\"searchInput\"\n            type=\"text\"\n            placeholder=\"{{'NODE_SELECTOR.SEARCH' | translate}}\"\n            [value]=\"searchTerm\"\n            data-automation-id=\"content-node-selector-search-input\">\n\n        <mat-icon *ngIf=\"searchTerm.length > 0\"\n            matSuffix (click)=\"clear()\"\n            class=\"adf-content-node-selector-content-input-icon\"\n            data-automation-id=\"content-node-selector-search-clear\">clear\n        </mat-icon>\n\n        <mat-icon *ngIf=\"searchTerm.length === 0\"\n            matSuffix\n            class=\"adf-content-node-selector-content-input-icon\"\n            data-automation-id=\"content-node-selector-search-icon\">search\n        </mat-icon>\n\n    </mat-form-field>\n\n    <adf-sites-dropdown\n        class=\"full-width\"\n        (change)=\"siteChanged($event)\"\n        [placeholder]=\"'NODE_SELECTOR.SELECT_LOCATION'\"\n        [hideMyFiles]=\"dropdownHideMyFiles\"\n        [siteList]=\"dropdownSiteList\"\n        data-automation-id=\"content-node-selector-sites-combo\">\n    </adf-sites-dropdown>\n\n    <adf-toolbar>\n        <adf-toolbar-title>\n            <ng-container *ngIf=\"!showBreadcrumbs()\">\n                <span class=\"search-results-label\">{{ 'NODE_SELECTOR.SEARCH_RESULTS' | translate }}</span>\n            </ng-container>\n            <adf-dropdown-breadcrumb *ngIf=\"showBreadcrumbs()\"\n                class=\"adf-content-node-selector-content-breadcrumb\"\n                (navigate)=\"clearSearch()\"\n                [target]=\"documentList\"\n                [transform]=\"breadcrumbTransform\"\n                [folderNode]=\"breadcrumbFolderNode\"\n                data-automation-id=\"content-node-selector-content-breadcrumb\">\n            </adf-dropdown-breadcrumb>\n        </adf-toolbar-title>\n    </adf-toolbar>\n\n    <div\n        class=\"adf-content-node-selector-content-list\"\n        [class.adf-content-node-selector-content-list-searchLayout]=\"showingSearchResults\"\n        data-automation-id=\"content-node-selector-content-list\">\n        <adf-document-list\n            #documentList\n            adf-highlight\n            adf-highlight-selector=\"adf-name-location-cell .adf-name-location-cell-name\"\n            [showHeader]=\"false\"\n            [node]=\"nodes\"\n            [maxItems]=\"pageSize\"\n            [rowFilter]=\"rowFilter\"\n            [imageResolver]=\"imageResolver\"\n            [currentFolderId]=\"folderIdToShow\"\n            selectionMode=\"single\"\n            [contextMenuActions]=\"false\"\n            [contentActions]=\"false\"\n            [allowDropFiles]=\"false\"\n            (folderChange)=\"onFolderChange()\"\n            (ready)=\"onFolderLoaded($event)\"\n            (node-dblclick)=\"onNodeDoubleClick($event)\"\n            data-automation-id=\"content-node-selector-document-list\">\n            <empty-folder-content>\n                <ng-template>\n                    <div>{{ 'NODE_SELECTOR.NO_RESULTS' | translate }}</div>\n                </ng-template>\n            </empty-folder-content>\n\n            <data-columns>\n                <data-column key=\"$thumbnail\" type=\"image\"></data-column>\n                <data-column key=\"name\" type=\"text\" class=\"full-width ellipsis-cell\">\n                    <ng-template let-context>\n                        <adf-name-location-cell [row]=\"context.row\"></adf-name-location-cell>\n                    </ng-template>\n                </data-column>\n                <data-column key=\"modifiedAt\" type=\"date\" format=\"timeAgo\" class=\"adf-content-selector-modified-cell\"></data-column>\n                <data-column key=\"modifiedByUser.displayName\" type=\"text\" class=\"adf-content-selector-modifier-cell\"></data-column>\n                <data-column key=\"visibility\" type=\"text\"></data-column>\n            </data-columns>\n\n        </adf-document-list>\n\n        <adf-infinite-pagination\n            [target]=\"documentList\"\n            [loading]=\"loadingSearchResults\"\n            (loadMore)=\"getNextPageOfSearch($event)\"\n            data-automation-id=\"content-node-selector-search-pagination\">\n            {{ 'ADF-DOCUMENT-LIST.LAYOUT.LOAD_MORE' | translate }}\n        </adf-infinite-pagination>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-content-node-selector-panel' },
                styles: [""]
            }] }
];
/** @nocollapse */
ContentNodeSelectorPanelComponent.ctorParameters = () => [
    { type: ContentNodeSelectorService },
    { type: AlfrescoApiService },
    { type: CustomResourcesService },
    { type: UserPreferencesService }
];
ContentNodeSelectorPanelComponent.propDecorators = {
    currentFolderId: [{ type: Input }],
    dropdownHideMyFiles: [{ type: Input }],
    dropdownSiteList: [{ type: Input }],
    rowFilter: [{ type: Input }],
    imageResolver: [{ type: Input }],
    pageSize: [{ type: Input }],
    isSelectionValid: [{ type: Input }],
    breadcrumbTransform: [{ type: Input }],
    select: [{ type: Output }],
    documentList: [{ type: ViewChild, args: ['documentList',] }],
    highlighter: [{ type: ViewChild, args: [HighlightDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentNodeSelectorModule {
}
ContentNodeSelectorModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    CoreModule.forChild(),
                    CommonModule,
                    MaterialModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    DocumentListModule
                ],
                exports: [
                    ContentNodeSelectorPanelComponent,
                    NameLocationCellComponent,
                    ContentNodeSelectorComponent
                ],
                entryComponents: [
                    ContentNodeSelectorPanelComponent,
                    ContentNodeSelectorComponent
                ],
                declarations: [
                    ContentNodeSelectorPanelComponent,
                    NameLocationCellComponent,
                    ContentNodeSelectorComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
const I18N_ERRORS_PATH = 'CORE.FOLDER_DIALOG.FOLDER_NAME.ERRORS';
/**
 * @param {?} __0
 * @return {?}
 */
function forbidSpecialCharacters({ value }) {
    /** @type {?} */
    const specialCharacters = /([\*\"\<\>\\\/\?\:\|])/;
    /** @type {?} */
    const isValid = !specialCharacters.test(value);
    return (isValid) ? null : {
        message: `${I18N_ERRORS_PATH}.SPECIAL_CHARACTERS`
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function forbidEndingDot({ value }) {
    /** @type {?} */
    const isValid = ((value || '').trim().split('').pop() !== '.');
    return isValid ? null : {
        message: `${I18N_ERRORS_PATH}.ENDING_DOT`
    };
}
/**
 * @param {?} __0
 * @return {?}
 */
function forbidOnlySpaces({ value }) {
    /** @type {?} */
    const isValid = !!((value || '')).trim();
    return isValid ? null : {
        message: `${I18N_ERRORS_PATH}.ONLY_SPACES`
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FolderDialogComponent {
    /**
     * @param {?} formBuilder
     * @param {?} dialog
     * @param {?} nodesApi
     * @param {?} translation
     * @param {?} data
     */
    constructor(formBuilder, dialog, nodesApi, translation, data) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.nodesApi = nodesApi;
        this.translation = translation;
        this.data = data;
        this.folder = null;
        /**
         * Emitted when the edit/create folder give error for example a folder with same name already exist
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the edit/create folder is successfully created/mmodified
         */
        this.success = new EventEmitter();
        this.editTitle = 'CORE.FOLDER_DIALOG.EDIT_FOLDER_TITLE';
        this.createTitle = 'CORE.FOLDER_DIALOG.CREATE_FOLDER_TITLE';
        this.nodeType = 'cm:folder';
        if (data) {
            this.editTitle = data.editTitle || this.editTitle;
            this.createTitle = data.createTitle || this.createTitle;
            this.nodeType = data.nodeType || this.nodeType;
        }
    }
    /**
     * @return {?}
     */
    get editing() {
        return !!this.data.folder;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        const { folder } = this.data;
        /** @type {?} */
        let name = '';
        /** @type {?} */
        let description = '';
        if (folder) {
            const { properties } = folder;
            name = folder.name || '';
            description = properties ? properties['cm:description'] : '';
        }
        /** @type {?} */
        const validators = {
            name: [
                Validators.required,
                forbidSpecialCharacters,
                forbidEndingDot,
                forbidOnlySpaces
            ]
        };
        this.form = this.formBuilder.group({
            name: [name, validators.name],
            description: [description]
        });
    }
    /**
     * @return {?}
     */
    get name() {
        let { name } = this.form.value;
        return (name || '').trim();
    }
    /**
     * @return {?}
     */
    get description() {
        let { description } = this.form.value;
        return (description || '').trim();
    }
    /**
     * @return {?}
     */
    get properties() {
        const { name: title, description } = this;
        return {
            'cm:title': title,
            'cm:description': description
        };
    }
    /**
     * @return {?}
     */
    create() {
        const { name, properties, nodeType, nodesApi, data: { parentNodeId } } = this;
        return nodesApi.createFolder(parentNodeId, { name, properties, nodeType });
    }
    /**
     * @return {?}
     */
    edit() {
        const { name, properties, nodesApi, data: { folder: { id: nodeId } } } = this;
        return nodesApi.updateNode(nodeId, { name, properties });
    }
    /**
     * @return {?}
     */
    submit() {
        const { form, dialog, editing } = this;
        if (!form.valid) {
            return;
        }
        (editing ? this.edit() : this.create())
            .subscribe((folder) => {
            this.success.emit(folder);
            dialog.close(folder);
        }, (error) => this.handleError(error));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        /** @type {?} */
        let errorMessage = 'CORE.MESSAGES.ERRORS.GENERIC';
        try {
            const { error: { statusCode } } = JSON.parse(error.message);
            if (statusCode === 409) {
                errorMessage = 'CORE.MESSAGES.ERRORS.EXISTENT_FOLDER';
            }
        }
        catch (err) { /* Do nothing, keep the original message */
            /* Do nothing, keep the original message */ 
        }
        this.error.emit(this.translation.instant(errorMessage));
        return error;
    }
}
FolderDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-folder-dialog',
                template: "<h2 mat-dialog-title>\n    {{ (editing ? editTitle : createTitle) | translate }}\n</h2>\n\n<mat-dialog-content>\n    <form [formGroup]=\"form\" (submit)=\"submit()\">\n        <mat-form-field class=\"adf-full-width\">\n            <input\n                id=\"adf-folder-name-input\"\n                placeholder=\"{{ 'CORE.FOLDER_DIALOG.FOLDER_NAME.LABEL' | translate }}\"\n                matInput\n                required\n                [formControl]=\"form.controls['name']\"/>\n\n            <mat-hint *ngIf=\"form.controls['name'].dirty\">\n                <span *ngIf=\"form.controls['name'].errors?.required\">\n                    {{ 'CORE.FOLDER_DIALOG.FOLDER_NAME.ERRORS.REQUIRED' | translate }}\n                </span>\n\n                <span *ngIf=\"!form.controls['name'].errors?.required && form.controls['name'].errors?.message\">\n                    {{ form.controls['name'].errors?.message | translate }}\n                </span>\n            </mat-hint>\n        </mat-form-field>\n\n        <br />\n        <br />\n\n        <mat-form-field class=\"adf-full-width\">\n            <textarea\n                id=\"adf-folder-description-input\"\n                matInput\n                placeholder=\"{{ 'CORE.FOLDER_DIALOG.FOLDER_DESCRIPTION.LABEL' | translate }}\"\n                rows=\"4\"\n                [formControl]=\"form.controls['description']\"></textarea>\n        </mat-form-field>\n    </form>\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-dialog-buttons\">\n    <span class=\"adf-fill-remaining-space\"></span>\n\n    <button\n        mat-button\n        id=\"adf-folder-cancel-button\"\n        mat-dialog-close>\n        {{ 'CORE.FOLDER_DIALOG.CANCEL_BUTTON.LABEL' | translate }}\n    </button>\n\n    <button class=\"adf-dialog-action-button\"\n            id=\"adf-folder-create-button\"\n            mat-button\n            (click)=\"submit()\"\n            [disabled]=\"!form.valid\">\n        {{\n        (editing\n        ? 'CORE.FOLDER_DIALOG.UPDATE_BUTTON.LABEL'\n        : 'CORE.FOLDER_DIALOG.CREATE_BUTTON.LABEL'\n        ) | translate\n        }}\n    </button>\n</mat-dialog-actions>\n",
                styles: [".adf-fill-remaining-space{flex:1 1 auto}.adf-full-width,.adf-lock-file-name .mat-checkbox-layout{width:100%}.adf-lock-file-name .mat-checkbox-label{text-overflow:ellipsis;overflow:hidden}.adf-lock-file-name .mat-checkbox-inner-container{margin:auto 8px auto 0}"]
            }] }
];
/** @nocollapse */
FolderDialogComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: MatDialogRef },
    { type: NodesApiService },
    { type: TranslationService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
FolderDialogComponent.propDecorators = {
    error: [{ type: Output }],
    success: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DialogModule {
}
DialogModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    CoreModule.forChild(),
                    FormsModule,
                    ReactiveFormsModule,
                    MatMomentDatetimeModule,
                    MatDatetimepickerModule
                ],
                declarations: [
                    DownloadZipDialogComponent,
                    FolderDialogComponent,
                    NodeLockDialogComponent,
                    ConfirmDialogComponent
                ],
                exports: [
                    DownloadZipDialogComponent,
                    FolderDialogComponent,
                    NodeLockDialogComponent,
                    ConfirmDialogComponent
                ],
                entryComponents: [
                    DownloadZipDialogComponent,
                    FolderDialogComponent,
                    NodeLockDialogComponent,
                    ConfirmDialogComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_FOLDER_PARENT_ID = '-my-';
class FolderCreateDirective {
    /**
     * @param {?} dialogRef
     * @param {?} content
     */
    constructor(dialogRef, content) {
        this.dialogRef = dialogRef;
        this.content = content;
        /**
         * Parent folder where the new folder will be located after creation.
         */
        this.parentNodeId = DEFAULT_FOLDER_PARENT_ID;
        /**
         * Title of folder creation dialog.
         */
        this.title = null;
        /**
         * Type of node to create.
         */
        this.nodeType = 'cm:folder';
        /**
         * Emitted when an error occurs (eg, a folder with same name already exists).
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the folder is created successfully.
         */
        this.success = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        event.preventDefault();
        this.openDialog();
    }
    /**
     * @return {?}
     */
    get dialogConfig() {
        const { DIALOG_WIDTH: width } = FolderCreateDirective;
        const { parentNodeId, title: createTitle, nodeType } = this;
        return {
            data: { parentNodeId, createTitle, nodeType },
            width: `${width}px`
        };
    }
    /**
     * @return {?}
     */
    openDialog() {
        const { dialogRef, dialogConfig, content } = this;
        /** @type {?} */
        const dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.componentInstance.error.subscribe((error) => {
            this.error.emit(error);
        });
        dialogInstance.componentInstance.success.subscribe((node) => {
            this.success.emit(node);
        });
        dialogInstance.afterClosed().subscribe((node) => {
            if (node) {
                content.folderCreate.next(node);
            }
        });
    }
}
FolderCreateDirective.DIALOG_WIDTH = 400;
FolderCreateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-create-folder]'
            },] }
];
/** @nocollapse */
FolderCreateDirective.ctorParameters = () => [
    { type: MatDialog },
    { type: ContentService }
];
FolderCreateDirective.propDecorators = {
    parentNodeId: [{ type: Input, args: ['adf-create-folder',] }],
    title: [{ type: Input }],
    nodeType: [{ type: Input }],
    error: [{ type: Output }],
    success: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FolderEditDirective {
    /**
     * @param {?} dialogRef
     * @param {?} elementRef
     * @param {?} content
     */
    constructor(dialogRef, elementRef, content) {
        this.dialogRef = dialogRef;
        this.elementRef = elementRef;
        this.content = content;
        /**
         * Emitted when an error occurs (eg, a folder with same name already exists).
         */
        this.error = new EventEmitter();
        /**
         * Title of folder edit dialog.
         */
        this.title = null;
        /**
         * Emitted when the folder has been edited successfully.
         */
        this.success = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        event.preventDefault();
        if (this.folder) {
            this.openDialog();
        }
    }
    /**
     * @return {?}
     */
    get dialogConfig() {
        const { DIALOG_WIDTH: width } = FolderEditDirective;
        const { folder } = this;
        return {
            data: {
                folder,
                editTitle: this.title
            },
            width: `${width}px`
        };
    }
    /**
     * @return {?}
     */
    openDialog() {
        const { dialogRef, dialogConfig, content } = this;
        /** @type {?} */
        const dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.componentInstance.error.subscribe((error) => {
            this.error.emit(error);
        });
        dialogInstance.componentInstance.success.subscribe((node) => {
            this.success.emit(node);
        });
        dialogInstance.afterClosed().subscribe((node) => {
            if (node) {
                content.folderEdit.next(node);
            }
        });
    }
}
FolderEditDirective.DIALOG_WIDTH = 400;
FolderEditDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-edit-folder]'
            },] }
];
/** @nocollapse */
FolderEditDirective.ctorParameters = () => [
    { type: MatDialog },
    { type: ElementRef },
    { type: ContentService }
];
FolderEditDirective.propDecorators = {
    folder: [{ type: Input, args: ['adf-edit-folder',] }],
    error: [{ type: Output }],
    title: [{ type: Input }],
    success: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FolderDirectiveModule {
}
FolderDirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    FolderCreateDirective,
                    FolderEditDirective
                ],
                exports: [
                    FolderCreateDirective,
                    FolderEditDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentMetadataCardComponent {
    /**
     * @param {?} contentService
     */
    constructor(contentService) {
        this.contentService = contentService;
        /**
         * (optional) This flag displays/hides empty metadata
         * fields.
         */
        this.displayEmpty = false;
        /**
         * (optional) This flag sets the metadata in read only mode
         * preventing changes.
         */
        this.readOnly = false;
        /**
         * (optional) This flag allows the component to display more
         * than one accordion at a time.
         */
        this.multi = false;
        this._displayDefaultProperties = true;
        this.editable = false;
    }
    /**
     * (optional) This flag displays/hides the metadata
     * properties.
     * @param {?} value
     * @return {?}
     */
    set displayDefaultProperties(value) {
        this._displayDefaultProperties = value;
        this.onDisplayDefaultPropertiesChange();
    }
    /**
     * @return {?}
     */
    get displayDefaultProperties() {
        return this._displayDefaultProperties;
    }
    /**
     * @return {?}
     */
    onDisplayDefaultPropertiesChange() {
        this.expanded = !this._displayDefaultProperties;
    }
    /**
     * @return {?}
     */
    toggleEdit() {
        this.editable = !this.editable;
    }
    /**
     * @return {?}
     */
    toggleExpanded() {
        this.expanded = !this.expanded;
    }
    /**
     * @return {?}
     */
    hasPermission() {
        return this.contentService.hasPermission(this.node, PermissionsEnum.UPDATE);
    }
}
ContentMetadataCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-metadata-card',
                template: "<mat-card *ngIf=\"node\">\n    <mat-card-content>\n        <adf-content-metadata\n            [displayDefaultProperties]=\"displayDefaultProperties\"\n            [expanded]=\"expanded\"\n            [node]=\"node\"\n            [displayEmpty]=\"displayEmpty\"\n            [editable]=\"editable\"\n            [multi]=\"multi\"\n            [preset]=\"preset\">\n        </adf-content-metadata>\n    </mat-card-content>\n    <mat-card-footer class=\"adf-content-metadata-card-footer\" fxLayout=\"row\" fxLayoutAlign=\"space-between stretch\">\n        <div>\n            <button *ngIf=\"!readOnly && hasPermission()\"\n                mat-icon-button\n                (click)=\"toggleEdit()\"\n                [attr.title]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n                data-automation-id=\"meta-data-card-toggle-edit\">\n                <mat-icon>mode_edit</mat-icon>\n            </button>\n        </div>\n        <button *ngIf=\"displayDefaultProperties\" mat-button (click)=\"toggleExpanded()\" data-automation-id=\"meta-data-card-toggle-expand\">\n            <ng-container *ngIf=\"!expanded\">\n                <span data-automation-id=\"meta-data-card-toggle-expand-label\">{{ 'ADF_VIEWER.SIDEBAR.METADATA.MORE_INFORMATION' | translate }}</span>\n                <mat-icon>keyboard_arrow_down</mat-icon>\n            </ng-container>\n            <ng-container *ngIf=\"expanded\">\n                <span data-automation-id=\"meta-data-card-toggle-expand-label\">{{ 'ADF_VIEWER.SIDEBAR.METADATA.LESS_INFORMATION' | translate }}</span>\n                <mat-icon>keyboard_arrow_up</mat-icon>\n            </ng-container>\n        </button>\n    </mat-card-footer>\n</mat-card>\n",
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-content-metadata-card' },
                styles: [""]
            }] }
];
/** @nocollapse */
ContentMetadataCardComponent.ctorParameters = () => [
    { type: ContentService }
];
ContentMetadataCardComponent.propDecorators = {
    node: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    preset: [{ type: Input }],
    readOnly: [{ type: Input }],
    multi: [{ type: Input }],
    displayDefaultProperties: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class BasicPropertiesService {
    /**
     * @param {?} fileSizePipe
     */
    constructor(fileSizePipe) {
        this.fileSizePipe = fileSizePipe;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getProperties(node) {
        /** @type {?} */
        const sizeInBytes = node.content ? node.content.sizeInBytes : '';
        /** @type {?} */
        const mimeTypeName = node.content ? node.content.mimeTypeName : '';
        /** @type {?} */
        const author = node.properties ? node.properties['cm:author'] : '';
        /** @type {?} */
        const description = node.properties ? node.properties['cm:description'] : '';
        /** @type {?} */
        const title = node.properties ? node.properties['cm:title'] : '';
        return [
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.NAME',
                value: node.name,
                key: 'name',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.TITLE',
                value: title,
                key: 'properties.cm:title',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.CREATOR',
                value: node.createdByUser.displayName,
                key: 'createdByUser.displayName',
                editable: false
            }),
            new CardViewDateItemModel({
                label: 'CORE.METADATA.BASIC.CREATED_DATE',
                value: node.createdAt,
                key: 'createdAt',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.SIZE',
                value: sizeInBytes,
                key: 'content.sizeInBytes',
                pipes: [{ pipe: this.fileSizePipe }],
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.MODIFIER',
                value: node.modifiedByUser.displayName,
                key: 'modifiedByUser.displayName',
                editable: false
            }),
            new CardViewDateItemModel({
                label: 'CORE.METADATA.BASIC.MODIFIED_DATE',
                value: node.modifiedAt,
                key: 'modifiedAt',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.MIMETYPE',
                value: mimeTypeName,
                key: 'content.mimeTypeName',
                editable: false
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.AUTHOR',
                value: author,
                key: 'properties.cm:author',
                editable: true
            }),
            new CardViewTextItemModel({
                label: 'CORE.METADATA.BASIC.DESCRIPTION',
                value: description,
                key: 'properties.cm:description',
                multiline: true,
                editable: true
            })
        ];
    }
}
BasicPropertiesService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
BasicPropertiesService.ctorParameters = () => [
    { type: FileSizePipe }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const D_TEXT = 'd:text';
/** @type {?} */
const D_MLTEXT = 'd:mltext';
/** @type {?} */
const D_DATE = 'd:date';
/** @type {?} */
const D_DATETIME = 'd:datetime';
/** @type {?} */
const D_INT = 'd:int';
/** @type {?} */
const D_LONG = 'd:long';
/** @type {?} */
const D_FLOAT = 'd:float';
/** @type {?} */
const D_DOUBLE = 'd:double';
/** @type {?} */
const D_BOOLEAN = 'd:boolean';
class PropertyGroupTranslatorService {
    /**
     * @param {?} logService
     */
    constructor(logService) {
        this.logService = logService;
    }
    /**
     * @param {?} propertyGroups
     * @param {?} propertyValues
     * @return {?}
     */
    translateToCardViewGroups(propertyGroups, propertyValues) {
        return propertyGroups.map(propertyGroup => {
            /** @type {?} */
            const translatedPropertyGroup = Object.assign({}, propertyGroup);
            translatedPropertyGroup.properties = this.translateArray(propertyGroup.properties, propertyValues);
            return translatedPropertyGroup;
        });
    }
    /**
     * @param {?} properties
     * @param {?} propertyValues
     * @return {?}
     */
    translateArray(properties, propertyValues) {
        return properties.map(property => {
            return this.translate(property, propertyValues[property.name]);
        });
    }
    /**
     * @param {?} property
     * @param {?} propertyValue
     * @return {?}
     */
    translate(property, propertyValue) {
        this.checkECMTypeValidity(property.dataType);
        /** @type {?} */
        const prefix = 'properties.';
        /** @type {?} */
        let propertyDefinition = {
            label: property.title,
            value: propertyValue,
            key: `${prefix}${property.name}`,
            default: property.defaultValue,
            editable: true
        };
        /** @type {?} */
        let cardViewItemProperty;
        switch (property.dataType) {
            case D_MLTEXT:
                cardViewItemProperty = new CardViewTextItemModel(Object.assign(propertyDefinition, {
                    multiline: true
                }));
                break;
            case D_INT:
            case D_LONG:
                cardViewItemProperty = new CardViewIntItemModel(propertyDefinition);
                break;
            case D_FLOAT:
            case D_DOUBLE:
                cardViewItemProperty = new CardViewFloatItemModel(propertyDefinition);
                break;
            case D_DATE:
                cardViewItemProperty = new CardViewDateItemModel(propertyDefinition);
                break;
            case D_DATETIME:
                cardViewItemProperty = new CardViewDatetimeItemModel(propertyDefinition);
                break;
            case D_BOOLEAN:
                cardViewItemProperty = new CardViewBoolItemModel(propertyDefinition);
                break;
            case D_TEXT:
            default:
                cardViewItemProperty = new CardViewTextItemModel(Object.assign(propertyDefinition, {
                    multiline: false
                }));
        }
        return cardViewItemProperty;
    }
    /**
     * @param {?} ecmPropertyType
     * @return {?}
     */
    checkECMTypeValidity(ecmPropertyType) {
        if (PropertyGroupTranslatorService.RECOGNISED_ECM_TYPES.indexOf(ecmPropertyType) === -1) {
            this.logService.error(`Unknown type for mapping: ${ecmPropertyType}`);
        }
    }
}
PropertyGroupTranslatorService.RECOGNISED_ECM_TYPES = [D_TEXT, D_MLTEXT, D_DATE, D_DATETIME, D_INT, D_LONG, D_FLOAT, D_DOUBLE, D_BOOLEAN];
PropertyGroupTranslatorService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
PropertyGroupTranslatorService.ctorParameters = () => [
    { type: LogService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @type {?} */
const emptyGroup = {
    properties: {}
};
/**
 * @param {?} object
 * @return {?}
 */
function convertObjectToArray(object) {
    return Object.keys(object).map(key => object[key]);
}
/**
 * @param {?} propertyGroups
 * @param {?} groupName
 * @return {?}
 */
function getGroup(propertyGroups, groupName) {
    return propertyGroups[groupName];
}
/**
 * @param {?} propertyGroups
 * @param {?} groupName
 * @param {?} propertyName
 * @return {?}
 */
function getProperty(propertyGroups, groupName, propertyName) {
    /** @type {?} */
    const groupDefinition = getGroup(propertyGroups, groupName) || emptyGroup;
    /** @type {?} */
    let propertyDefinitions;
    if (propertyName === '*') {
        propertyDefinitions = convertObjectToArray(groupDefinition.properties);
    }
    else {
        propertyDefinitions = groupDefinition.properties[propertyName];
    }
    return propertyDefinitions;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AspectOrientedConfigService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} groupName
     * @return {?}
     */
    isGroupAllowed(groupName) {
        /** @type {?} */
        const groupNames = Object.keys(this.config);
        return groupNames.indexOf(groupName) !== -1;
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    reorganiseByConfig(propertyGroups) {
        /** @type {?} */
        const aspects = this.config;
        /** @type {?} */
        const aspectNames = Object.keys(aspects);
        return aspectNames
            .reduce((groupAccumulator, aspectName) => {
            /** @type {?} */
            const newGroup = this.getOrganisedPropertyGroup(propertyGroups, aspectName);
            return groupAccumulator.concat(newGroup);
        }, [])
            .filter(organisedPropertyGroup => organisedPropertyGroup.properties.length > 0);
    }
    /**
     * @param {?} propertyGroups
     * @param {?} aspectName
     * @return {?}
     */
    getOrganisedPropertyGroup(propertyGroups, aspectName) {
        /** @type {?} */
        const group = getGroup(propertyGroups, aspectName);
        /** @type {?} */
        let newGroup = [];
        if (group) {
            /** @type {?} */
            const aspectProperties = this.config[aspectName];
            /** @type {?} */
            let properties;
            if (aspectProperties === '*') {
                properties = getProperty(propertyGroups, aspectName, aspectProperties);
            }
            else {
                properties = (/** @type {?} */ (aspectProperties))
                    .map((propertyName) => getProperty(propertyGroups, aspectName, propertyName))
                    .filter(props => props !== undefined);
            }
            newGroup = [{ title: group.title, properties }];
        }
        return newGroup;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IndifferentConfigService {
    /**
     * @param {?} config
     */
    constructor(config) { }
    /**
     * @param {?} groupName
     * @return {?}
     */
    isGroupAllowed(groupName) {
        return true;
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    reorganiseByConfig(propertyGroups) {
        return Object.keys(propertyGroups)
            .map((groupName) => {
            /** @type {?} */
            const propertyGroup = propertyGroups[groupName];
            /** @type {?} */
            const properties = propertyGroup.properties;
            return Object.assign({}, propertyGroup, {
                properties: Object.keys(properties).map(propertyName => properties[propertyName])
            });
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class LayoutOrientedConfigService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} groupName
     * @return {?}
     */
    isGroupAllowed(groupName) {
        return this.getMatchingGroups(groupName).length > 0;
    }
    /**
     * @param {?} propertyGroups
     * @return {?}
     */
    reorganiseByConfig(propertyGroups) {
        /** @type {?} */
        const layoutBlocks = this.config;
        return layoutBlocks.map((layoutBlock) => {
            /** @type {?} */
            const flattenedItems = this.flattenItems(layoutBlock.items);
            /** @type {?} */
            const properties = flattenedItems.reduce((props, explodedItem) => {
                /** @type {?} */
                const property = getProperty(propertyGroups, explodedItem.groupName, explodedItem.propertyName) || [];
                return props.concat(property);
            }, []);
            return {
                title: layoutBlock.title,
                properties
            };
        });
    }
    /**
     * @param {?} items
     * @return {?}
     */
    flattenItems(items) {
        return items.reduce((accumulator, item) => {
            /** @type {?} */
            const properties = Array.isArray(item.properties) ? item.properties : [item.properties];
            /** @type {?} */
            const flattenedProperties = properties.map(propertyName => {
                return {
                    groupName: item.aspect || item.type,
                    propertyName
                };
            });
            return accumulator.concat(flattenedProperties);
        }, []);
    }
    /**
     * @param {?} groupName
     * @return {?}
     */
    getMatchingGroups(groupName) {
        return this.config
            .map(layoutBlock => layoutBlock.items)
            .reduce((accumulator, items) => accumulator.concat(items), [])
            .filter((item) => item.aspect === groupName || item.type === groupName);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentMetadataConfigFactory {
    /**
     * @param {?} appConfigService
     * @param {?} logService
     */
    constructor(appConfigService, logService) {
        this.appConfigService = appConfigService;
        this.logService = logService;
    }
    /**
     * @param {?=} presetName
     * @return {?}
     */
    get(presetName = 'default') {
        /** @type {?} */
        let presetConfig;
        try {
            presetConfig = this.appConfigService.config['content-metadata'].presets[presetName];
        }
        catch (_a) {
            if (presetName !== ContentMetadataConfigFactory.DEFAULT_PRESET_NAME) {
                this.logService.error(`No content-metadata preset for: ${presetName}`);
            }
            presetConfig = ContentMetadataConfigFactory.INDIFFERENT_PRESET;
        }
        return this.createConfig(presetConfig);
    }
    /**
     * @param {?} presetConfig
     * @return {?}
     */
    createConfig(presetConfig) {
        /** @type {?} */
        let config;
        if (this.isLayoutOrientedPreset(presetConfig)) {
            config = new LayoutOrientedConfigService(/** @type {?} */ (presetConfig));
        }
        else if (this.isAspectOrientedPreset(presetConfig)) {
            config = new AspectOrientedConfigService(/** @type {?} */ (presetConfig));
        }
        else {
            config = new IndifferentConfigService(/** @type {?} */ (presetConfig));
        }
        Object.freeze(config);
        return config;
    }
    /**
     * @param {?} presetConfig
     * @return {?}
     */
    isAspectOrientedPreset(presetConfig) {
        return this.isObject(presetConfig);
    }
    /**
     * @param {?} presetConfig
     * @return {?}
     */
    isLayoutOrientedPreset(presetConfig) {
        return Array.isArray(presetConfig);
    }
    /**
     * @param {?} x
     * @return {?}
     */
    isObject(x) {
        return x != null && typeof x === 'object';
    }
}
ContentMetadataConfigFactory.INDIFFERENT_PRESET = '*';
ContentMetadataConfigFactory.DEFAULT_PRESET_NAME = 'default';
ContentMetadataConfigFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ContentMetadataConfigFactory.ctorParameters = () => [
    { type: AppConfigService },
    { type: LogService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PropertyDescriptorsService {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    /**
     * @param {?} groupNames
     * @return {?}
     */
    load(groupNames) {
        /** @type {?} */
        const groupFetchStreams = groupNames
            .map(groupName => groupName.replace(':', '_'))
            .map(groupName => defer(() => this.alfrescoApiService.classesApi.getClass(groupName)));
        return forkJoin(groupFetchStreams).pipe(map(this.convertToObject));
    }
    /**
     * @param {?} propertyGroupsArray
     * @return {?}
     */
    convertToObject(propertyGroupsArray) {
        return propertyGroupsArray.reduce((propertyGroups, propertyGroup) => {
            return Object.assign({}, propertyGroups, {
                [propertyGroup.name]: propertyGroup
            });
        }, {});
    }
}
PropertyDescriptorsService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
PropertyDescriptorsService.ctorParameters = () => [
    { type: AlfrescoApiService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentMetadataService {
    /**
     * @param {?} basicPropertiesService
     * @param {?} contentMetadataConfigFactory
     * @param {?} propertyGroupTranslatorService
     * @param {?} propertyDescriptorsService
     */
    constructor(basicPropertiesService, contentMetadataConfigFactory, propertyGroupTranslatorService, propertyDescriptorsService) {
        this.basicPropertiesService = basicPropertiesService;
        this.contentMetadataConfigFactory = contentMetadataConfigFactory;
        this.propertyGroupTranslatorService = propertyGroupTranslatorService;
        this.propertyDescriptorsService = propertyDescriptorsService;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getBasicProperties(node) {
        return of(this.basicPropertiesService.getProperties(node));
    }
    /**
     * @param {?} node
     * @param {?=} presetName
     * @return {?}
     */
    getGroupedProperties(node, presetName = 'default') {
        /** @type {?} */
        let groupedProperties = of([]);
        if (node.aspectNames) {
            /** @type {?} */
            const config = this.contentMetadataConfigFactory.get(presetName);
            /** @type {?} */
            const groupNames = node.aspectNames
                .concat(node.nodeType)
                .filter(groupName => config.isGroupAllowed(groupName));
            if (groupNames.length > 0) {
                groupedProperties = this.propertyDescriptorsService.load(groupNames).pipe(map(groups => config.reorganiseByConfig(groups)), map(groups => this.propertyGroupTranslatorService.translateToCardViewGroups(groups, node.properties)));
            }
        }
        return groupedProperties;
    }
}
ContentMetadataService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ContentMetadataService.ctorParameters = () => [
    { type: BasicPropertiesService },
    { type: ContentMetadataConfigFactory },
    { type: PropertyGroupTranslatorService },
    { type: PropertyDescriptorsService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentMetadataComponent {
    /**
     * @param {?} contentMetadataService
     * @param {?} cardViewUpdateService
     * @param {?} nodesApiService
     * @param {?} logService
     * @param {?} alfrescoApiService
     */
    constructor(contentMetadataService, cardViewUpdateService, nodesApiService, logService, alfrescoApiService) {
        this.contentMetadataService = contentMetadataService;
        this.cardViewUpdateService = cardViewUpdateService;
        this.nodesApiService = nodesApiService;
        this.logService = logService;
        this.alfrescoApiService = alfrescoApiService;
        /**
         * Toggles whether the edit button should be shown
         */
        this.editable = false;
        /**
         * Toggles whether to display empty values in the card view
         */
        this.displayEmpty = false;
        /**
         * Toggles between expanded (ie, full information) and collapsed
         * (ie, reduced information) in the display
         */
        this.expanded = false;
        /**
         * The multi parameter of the underlying material expansion panel, set to true to allow multi accordion to be expanded at the same time
         */
        this.multi = false;
        /**
         * Toggles whether the metadata properties should be shown
         */
        this.displayDefaultProperties = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.disposableNodeUpdate = this.cardViewUpdateService.itemUpdated$
            .pipe(switchMap(this.saveNode.bind(this)))
            .subscribe(updatedNode => {
            Object.assign(this.node, updatedNode);
            this.alfrescoApiService.nodeUpdated.next(this.node);
        }, error => this.logService.error(error));
        this.loadProperties(this.node);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["node"] && !changes["node"].firstChange) {
            this.loadProperties(changes["node"].currentValue);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    loadProperties(node) {
        if (node) {
            this.basicProperties$ = this.contentMetadataService.getBasicProperties(node);
            this.groupedProperties$ = this.contentMetadataService.getGroupedProperties(node, this.preset);
        }
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    saveNode({ changed: nodeBody }) {
        return this.nodesApiService.updateNode(this.node.id, nodeBody);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.disposableNodeUpdate.unsubscribe();
    }
}
ContentMetadataComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content-metadata',
                template: "<div class=\"adf-metadata-properties\">\n    <mat-accordion displayMode=\"flat\" [multi]=\"multi\">\n        <mat-expansion-panel\n            *ngIf=\"displayDefaultProperties\"\n            [expanded]=\"!expanded\"\n            [hideToggle]=\"!expanded\"\n            [attr.data-automation-id]=\"'adf-metadata-group-properties'\" >\n            <mat-expansion-panel-header>\n                <mat-panel-title>\n                    {{ 'CORE.METADATA.BASIC.HEADER' | translate }}\n                </mat-panel-title>\n            </mat-expansion-panel-header>\n\n            <adf-card-view\n                [properties]=\"basicProperties$ | async\"\n                [editable]=\"editable\"\n                [displayEmpty]=\"displayEmpty\">\n            </adf-card-view>\n        </mat-expansion-panel>\n\n        <ng-container *ngIf=\"expanded\">\n            <ng-container *ngIf=\"groupedProperties$ | async; else loading; let groupedProperties\">\n                <div *ngFor=\"let group of groupedProperties; let first = first;\" class=\"adf-metadata-grouped-properties-container\">\n                    <mat-expansion-panel\n                    [attr.data-automation-id]=\"'adf-metadata-group-' + group.title\"\n                    [expanded]=\"!displayDefaultProperties && first\">\n                        <mat-expansion-panel-header>\n                            <mat-panel-title>\n                                {{ group.title | translate }}\n                            </mat-panel-title>\n                        </mat-expansion-panel-header>\n\n                        <adf-card-view\n                            [properties]=\"group.properties\"\n                            [editable]=\"editable\"\n                            [displayEmpty]=\"displayEmpty\">\n                        </adf-card-view>\n                    </mat-expansion-panel>\n\n                </div>\n            </ng-container>\n            <ng-template #loading>\n                <mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>\n            </ng-template>\n        </ng-container>\n    </mat-accordion>\n</div>\n",
                host: { 'class': 'adf-content-metadata' },
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
ContentMetadataComponent.ctorParameters = () => [
    { type: ContentMetadataService },
    { type: CardViewUpdateService },
    { type: NodesApiService },
    { type: LogService },
    { type: AlfrescoApiService }
];
ContentMetadataComponent.propDecorators = {
    node: [{ type: Input }],
    editable: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    expanded: [{ type: Input }],
    multi: [{ type: Input }],
    preset: [{ type: Input }],
    displayDefaultProperties: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentMetadataModule {
}
ContentMetadataModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    FlexLayoutModule,
                    CoreModule.forChild()
                ],
                exports: [
                    ContentMetadataComponent,
                    ContentMetadataCardComponent
                ],
                declarations: [
                    ContentMetadataComponent,
                    ContentMetadataCardComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PermissionDisplayModel {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.isInherited = false;
        if (obj) {
            this.authorityId = obj.authorityId;
            this.name = obj.name;
            this.accessStatus = obj.accessStatus;
            this.isInherited = obj.isInherited !== null && obj.isInherited !== undefined ? obj.isInherited : false;
            this.icon = obj.icon ? obj.icon : 'vpn_key';
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NodePermissionService {
    /**
     * @param {?} apiService
     * @param {?} searchApiService
     * @param {?} nodeService
     * @param {?} translation
     */
    constructor(apiService, searchApiService, nodeService, translation) {
        this.apiService = apiService;
        this.searchApiService = searchApiService;
        this.nodeService = nodeService;
        this.translation = translation;
    }
    /**
     * Gets a list of roles for the current node.
     * @param {?} node The target node
     * @return {?} Array of strings representing the roles
     */
    getNodeRoles(node) {
        /** @type {?} */
        const retrieveSiteQueryBody = this.buildRetrieveSiteQueryBody(node.path.elements);
        return this.searchApiService.searchByQueryBody(retrieveSiteQueryBody)
            .pipe(switchMap((siteNodeList) => {
            if (siteNodeList.list.entries.length > 0) {
                /** @type {?} */
                let siteName = siteNodeList.list.entries[0].entry.name;
                return this.getGroupMembersBySiteName(siteName);
            }
            else {
                return of(node.permissions.settable);
            }
        }));
    }
    /**
     * Updates the permission role for a node.
     * @param {?} node Target node
     * @param {?} updatedPermissionRole Permission role to update or add
     * @return {?} Node with updated permission
     */
    updatePermissionRole(node, updatedPermissionRole) {
        /** @type {?} */
        let permissionBody = { permissions: { locallySet: [] } };
        /** @type {?} */
        const index = node.permissions.locallySet.map((permission) => permission.authorityId).indexOf(updatedPermissionRole.authorityId);
        permissionBody.permissions.locallySet = permissionBody.permissions.locallySet.concat(node.permissions.locallySet);
        if (index !== -1) {
            permissionBody.permissions.locallySet[index] = updatedPermissionRole;
        }
        else {
            permissionBody.permissions.locallySet.push(updatedPermissionRole);
        }
        return this.nodeService.updateNode(node.id, permissionBody);
    }
    /**
     * Update permissions for a node.
     * @param {?} nodeId ID of the target node
     * @param {?} permissionList New permission settings
     * @return {?} Node with updated permissions
     */
    updateNodePermissions(nodeId, permissionList) {
        return this.nodeService.getNode(nodeId).pipe(switchMap(node => {
            return this.getNodeRoles(node).pipe(switchMap((nodeRoles) => of({ node, nodeRoles })));
        }), switchMap(({ node, nodeRoles }) => this.updateLocallySetPermissions(node, permissionList, nodeRoles)));
    }
    /**
     * Updates the locally set permissions for a node.
     * @param {?} node ID of the target node
     * @param {?} nodes Permission settings
     * @param {?} nodeRole Permission role
     * @return {?} Node with updated permissions
     */
    updateLocallySetPermissions(node, nodes, nodeRole) {
        /** @type {?} */
        let permissionBody = { permissions: { locallySet: [] } };
        /** @type {?} */
        const permissionList = this.transformNodeToPermissionElement(nodes, nodeRole[0]);
        /** @type {?} */
        const duplicatedPermissions = this.getDuplicatedPermissions(node.permissions.locallySet, permissionList);
        if (duplicatedPermissions.length > 0) {
            /** @type {?} */
            const list = duplicatedPermissions.map((permission) => 'authority -> ' + permission.authorityId + ' / role -> ' + permission.name).join(', ');
            /** @type {?} */
            const duplicatePermissionMessage = this.translation.instant('PERMISSION_MANAGER.ERROR.DUPLICATE-PERMISSION', { list });
            return throwError(duplicatePermissionMessage);
        }
        permissionBody.permissions.locallySet = node.permissions.locallySet ? node.permissions.locallySet.concat(permissionList) : permissionList;
        return this.nodeService.updateNode(node.id, permissionBody);
    }
    /**
     * @param {?} nodeLocallySet
     * @param {?} permissionListAdded
     * @return {?}
     */
    getDuplicatedPermissions(nodeLocallySet, permissionListAdded) {
        /** @type {?} */
        let duplicatePermissions = [];
        if (nodeLocallySet) {
            permissionListAdded.forEach((permission) => {
                /** @type {?} */
                const duplicate = nodeLocallySet.find((localPermission) => this.isEqualPermission(localPermission, permission));
                if (duplicate) {
                    duplicatePermissions.push(duplicate);
                }
            });
        }
        return duplicatePermissions;
    }
    /**
     * @param {?} oldPermission
     * @param {?} newPermission
     * @return {?}
     */
    isEqualPermission(oldPermission, newPermission) {
        return oldPermission.accessStatus === newPermission.accessStatus &&
            oldPermission.authorityId === newPermission.authorityId &&
            oldPermission.name === newPermission.name;
    }
    /**
     * @param {?} nodes
     * @param {?} nodeRole
     * @return {?}
     */
    transformNodeToPermissionElement(nodes, nodeRole) {
        return nodes.map((node) => {
            /** @type {?} */
            let newPermissionElement = /** @type {?} */ ({
                'authorityId': node.entry.properties['cm:authorityName'] ?
                    node.entry.properties['cm:authorityName'] :
                    node.entry.properties['cm:userName'],
                'name': nodeRole,
                'accessStatus': 'ALLOWED'
            });
            return newPermissionElement;
        });
    }
    /**
     * Removes a permission setting from a node.
     * @param {?} node ID of the target node
     * @param {?} permissionToRemove Permission setting to remove
     * @return {?} Node with modified permissions
     */
    removePermission(node, permissionToRemove) {
        /** @type {?} */
        let permissionBody = { permissions: { locallySet: [] } };
        /** @type {?} */
        const index = node.permissions.locallySet.map((permission) => permission.authorityId).indexOf(permissionToRemove.authorityId);
        if (index !== -1) {
            node.permissions.locallySet.splice(index, 1);
            permissionBody.permissions.locallySet = node.permissions.locallySet;
            return this.nodeService.updateNode(node.id, permissionBody);
        }
    }
    /**
     * @param {?} siteName
     * @return {?}
     */
    getGroupMembersBySiteName(siteName) {
        /** @type {?} */
        const groupName = 'GROUP_site_' + siteName;
        return this.getGroupMemeberByGroupName(groupName)
            .pipe(map((res) => {
            /** @type {?} */
            let displayResult = [];
            res.list.entries.forEach((member) => {
                displayResult.push(this.formattedRoleName(member.entry.displayName, 'site_' + siteName));
            });
            return displayResult;
        }));
    }
    /**
     * Gets all members related to a group name.
     * @param {?} groupName Name of group to look for members
     * @param {?=} opts Extra options supported by JSAPI
     * @return {?} List of members
     */
    getGroupMemeberByGroupName(groupName, opts) {
        return from(this.apiService.groupsApi.getGroupMembers(groupName, opts));
    }
    /**
     * @param {?} displayName
     * @param {?} siteName
     * @return {?}
     */
    formattedRoleName(displayName, siteName) {
        return displayName.replace(siteName + '_', '');
    }
    /**
     * @param {?} nodePath
     * @return {?}
     */
    buildRetrieveSiteQueryBody(nodePath) {
        /** @type {?} */
        const pathNames = nodePath.map((node) => 'name: "' + node.name + '"');
        /** @type {?} */
        const buildedPathNames = pathNames.join(' OR ');
        return {
            'query': {
                'query': buildedPathNames
            },
            'paging': {
                'maxItems': 100,
                'skipCount': 0
            },
            'include': ['aspectNames', 'properties'],
            'filterQueries': [
                {
                    'query': "TYPE:'st:site'"
                }
            ]
        };
    }
}
NodePermissionService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NodePermissionService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: SearchService },
    { type: NodesApiService },
    { type: TranslationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PermissionListComponent {
    /**
     * @param {?} nodeService
     * @param {?} nodePermissionService
     */
    constructor(nodeService, nodePermissionService) {
        this.nodeService = nodeService;
        this.nodePermissionService = nodePermissionService;
        /**
         * ID of the node whose permissions you want to show.
         */
        this.nodeId = '';
        /**
         * Emitted when the permission is updated.
         */
        this.update = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.fetchNodePermissions();
    }
    /**
     * @return {?}
     */
    reload() {
        this.fetchNodePermissions();
    }
    /**
     * @return {?}
     */
    fetchNodePermissions() {
        this.nodeService.getNode(this.nodeId).subscribe((node) => {
            this.actualNode = node;
            this.permissionList = this.getPermissionList(node);
            this.nodePermissionService.getNodeRoles(node).subscribe((settableList) => {
                this.settableRoles = settableList;
            });
        });
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getPermissionList(node) {
        /** @type {?} */
        let allPermissions = [];
        if (node.permissions.locallySet) {
            node.permissions.locallySet.map((element) => {
                /** @type {?} */
                let permission = new PermissionDisplayModel(element);
                allPermissions.push(permission);
            });
        }
        if (node.permissions.inherited) {
            node.permissions.inherited.map((element) => {
                /** @type {?} */
                let permissionInherited = new PermissionDisplayModel(element);
                permissionInherited.isInherited = true;
                allPermissions.push(permissionInherited);
            });
        }
        return allPermissions;
    }
    /**
     * @param {?} event
     * @param {?} permissionRow
     * @return {?}
     */
    saveNewRole(event, permissionRow) {
        /** @type {?} */
        let updatedPermissionRole = this.buildUpdatedPermission(event.value, permissionRow);
        this.nodePermissionService.updatePermissionRole(this.actualNode, updatedPermissionRole)
            .subscribe((node) => {
            this.update.emit(updatedPermissionRole);
        });
    }
    /**
     * @param {?} newRole
     * @param {?} permissionRow
     * @return {?}
     */
    buildUpdatedPermission(newRole, permissionRow) {
        /** @type {?} */
        let permissionRole = {};
        permissionRole.accessStatus = permissionRow.accessStatus;
        permissionRole.name = newRole;
        permissionRole.authorityId = permissionRow.authorityId;
        return permissionRole;
    }
    /**
     * @param {?} permissionRow
     * @return {?}
     */
    removePermission(permissionRow) {
        this.nodePermissionService.removePermission(this.actualNode, permissionRow).subscribe((node) => {
            this.update.emit(node);
        }, (error) => this.error.emit(error));
    }
}
PermissionListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-permission-list',
                template: "<div id=\"adf-permission-display-container\" class=\"adf-display-permission-container\">\n\n    <div *ngIf=\"!permissionList || !permissionList.length\" id=\"adf-no-permissions-template\">\n        <div #ref>\n            <ng-content select=\"adf-no-permission-template\"></ng-content>\n        </div>\n\n        <p *ngIf=\"ref.children.length == 0\">\n            {{ 'PERMISSION_MANAGER.PERMISSION_DISPLAY.NO_PERMISSIONS' | translate }}\n        </p>\n    </div>\n\n    <adf-datatable [rows]=\"permissionList\" class=\"adf-datatable-permission\" *ngIf=\"permissionList && permissionList.length\">\n        <data-columns>\n            <data-column key=\"icon\" type=\"icon\" [sortable]=\"false\">\n            </data-column>\n            <data-column title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.AUTHORITY_ID' | translate}}\" key=\"authorityId\"></data-column>\n            <data-column title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.ROLE' | translate}}\" key=\"name\">\n                <ng-template let-entry=\"$implicit\">\n                    <mat-form-field *ngIf=\"!entry.row.getValue('isInherited') else show_only_label\">\n                        <mat-select id=\"adf-select-role-permission\"\n                                    [placeholder]=\"entry.data.getValue(entry.row, entry.col)\"\n                                    value=\"{{entry.data.getValue(entry.row, entry.col)}}\"\n                                    (selectionChange)=\"saveNewRole($event, entry.row.obj)\">\n                          <mat-option *ngFor=\"let role of settableRoles\" [value]=\"role\">\n                            {{ role }}\n                          </mat-option>\n                        </mat-select>\n                      </mat-form-field>\n                      <ng-template #show_only_label>\n                          <span>{{entry.data.getValue(entry.row, entry.col)}}</span>\n                      </ng-template>\n                </ng-template>\n            </data-column>\n            <data-column title=\"{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}\" key=\"isInherited\">\n                <ng-template let-entry=\"$implicit\">\n                    <mat-chip-list>\n                        <mat-chip *ngIf=\"!!entry.data.getValue(entry.row, entry.col) else locally_set_chip\"\n                                id=\"adf-permission-inherited-label\"\n                                color=\"primary\" selected=\"true\">{{'PERMISSION_MANAGER.PERMISSION_DISPLAY.INHERITED' | translate}}</mat-chip>\n                    </mat-chip-list>\n                    <ng-template #locally_set_chip>\n                            <mat-chip-list>\n                                    <mat-chip id=\"adf-permission-locallyset-label\"\n                                              color=\"accent\" selected=\"true\">\n                                              {{'PERMISSION_MANAGER.PERMISSION_DISPLAY.LOCALLY_SET' | translate}}\n                                    </mat-chip>\n                            </mat-chip-list>\n                    </ng-template>\n                </ng-template>\n            </data-column>\n            <data-column key=\"delete\">\n            <ng-template let-entry=\"$implicit\">\n                <button *ngIf=\"!entry.row.getValue('isInherited')\" mat-icon-button color=\"primary\" (click)=\"removePermission(entry.row.obj)\">\n                    <mat-icon>highlight_off</mat-icon>\n                </button>\n            </ng-template>\n        </data-column>\n        </data-columns>\n    </adf-datatable>\n</div>\n\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
PermissionListComponent.ctorParameters = () => [
    { type: NodesApiService },
    { type: NodePermissionService }
];
PermissionListComponent.propDecorators = {
    nodeId: [{ type: Input }],
    update: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NoPermissionTemplateComponent {
}
NoPermissionTemplateComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-no-permission-template',
                template: '<ng-content></ng-content>'
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class InheritPermissionDirective {
    /**
     * @param {?} nodeService
     * @param {?} contentService
     */
    constructor(nodeService, contentService) {
        this.nodeService = nodeService;
        this.contentService = contentService;
        /**
         * Emitted when the node is updated.
         */
        this.updated = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
    }
    /**
     * @return {?}
     */
    onInheritPermissionClicked() {
        this.nodeService.getNode(this.nodeId).subscribe((node) => {
            if (this.contentService.hasPermission(node, PermissionsEnum.UPDATEPERMISSIONS)) {
                /** @type {?} */
                const nodeBody = { permissions: { isInheritanceEnabled: !node.permissions.isInheritanceEnabled } };
                this.nodeService.updateNode(this.nodeId, nodeBody, { include: ['permissions'] }).subscribe((nodeUpdated) => {
                    this.updated.emit(nodeUpdated);
                }, (error) => this.error.emit(error));
            }
            else {
                this.error.emit('PERMISSION_MANAGER.ERROR.NOT-ALLOWED');
            }
        });
    }
}
InheritPermissionDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[adf-inherit-permission], mat-button-toggle[adf-inherit-permission]',
                host: {
                    'role': 'button',
                    '(click)': 'onInheritPermissionClicked()'
                }
            },] }
];
/** @nocollapse */
InheritPermissionDirective.ctorParameters = () => [
    { type: NodesApiService },
    { type: ContentService }
];
InheritPermissionDirective.propDecorators = {
    nodeId: [{ type: Input }],
    updated: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AddPermissionComponent {
    /**
     * @param {?} nodePermissionService
     * @param {?} nodeApiService
     * @param {?} contentService
     */
    constructor(nodePermissionService, nodeApiService, contentService) {
        this.nodePermissionService = nodePermissionService;
        this.nodeApiService = nodeApiService;
        this.contentService = contentService;
        /**
         * Emitted when the node is updated successfully.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs during the update.
         */
        this.error = new EventEmitter();
        this.selectedItems = [];
        this.nodeApiService.getNode(this.nodeId).subscribe((node) => this.currentNode = node);
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    onSelect(selection) {
        this.selectedItems = selection;
    }
    /**
     * @return {?}
     */
    isAddEnabled() {
        return this.contentService.hasPermission(this.currentNode, PermissionsEnum.UPDATEPERMISSIONS) &&
            this.selectedItems.length !== 0;
    }
    /**
     * @return {?}
     */
    applySelection() {
        if (this.contentService.hasPermission(this.currentNode, PermissionsEnum.UPDATEPERMISSIONS)) {
            this.nodePermissionService.updateNodePermissions(this.nodeId, this.selectedItems)
                .subscribe((node) => {
                this.success.emit(node);
            }, (error) => {
                this.error.emit(error);
            });
        }
    }
}
AddPermissionComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-add-permission',
                template: "<adf-add-permission-panel\n    (select)=\"onSelect($event)\">\n</adf-add-permission-panel>\n<div id=\"adf-add-permission-actions\">\n   <button mat-button\n          id=\"adf-add-permission-action-button\"\n          class=\"adf-permission-action\"\n          [disabled]=\"!isAddEnabled()\"\n          (click)=\"applySelection()\">\n     {{'PERMISSION_MANAGER.ADD-PERMISSION.ADD-ACTION' | translate}}\n    </button>\n</div>\n\n\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
AddPermissionComponent.ctorParameters = () => [
    { type: NodePermissionService },
    { type: NodesApiService },
    { type: ContentService }
];
AddPermissionComponent.propDecorators = {
    nodeId: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AddPermissionDialogComponent {
    /**
     * @param {?} data
     */
    constructor(data) {
        this.data = data;
        this.currentSelection = [];
    }
    /**
     * @param {?} items
     * @return {?}
     */
    onSelect(items) {
        this.currentSelection = items;
    }
    /**
     * @return {?}
     */
    onAddClicked() {
        this.data.confirm.next(this.currentSelection);
        this.data.confirm.complete();
    }
}
AddPermissionDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-add-permission-dialog',
                template: "<h2 mat-dialog-title id=\"add-permission-dialog-title\">\n    {{(data?.title ? data?.title : 'PERMISSION_MANAGER.ADD-PERMISSION.BASE-DIALOG-TITLE') | translate}}\n</h2>\n<mat-dialog-content>\n    <adf-add-permission-panel\n        (select)=\"onSelect($event)\">\n    </adf-add-permission-panel>\n</mat-dialog-content>\n<mat-dialog-actions>\n    <button mat-button mat-dialog-close id=\"add-permission-dialog-close-button\">{{'PERMISSION_MANAGER.ADD-PERMISSION.CLOSE-ACTION' | translate}}</button>\n    <button mat-button id=\"add-permission-dialog-confirm-button\" [mat-dialog-close]=\"true\"\n            class=\"choose-action\"\n            [disabled]=\"currentSelection?.length === 0\"\n            (click)=\"onAddClicked()\">{{'PERMISSION_MANAGER.ADD-PERMISSION.ADD-ACTION' | translate}}</button>\n</mat-dialog-actions>\n\n",
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
AddPermissionDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
AddPermissionDialogComponent.propDecorators = {
    addPermissionComponent: [{ type: ViewChild, args: ['addPermission',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NodePermissionDialogService {
    /**
     * @param {?} dialog
     * @param {?} nodePermissionService
     * @param {?} contentService
     */
    constructor(dialog, nodePermissionService, contentService) {
        this.dialog = dialog;
        this.nodePermissionService = nodePermissionService;
        this.contentService = contentService;
    }
    /**
     * Opens a dialog to add permissions to a node.
     * @param {?} node ID of the target node
     * @param {?=} title Dialog title
     * @return {?} Node with updated permissions
     */
    openAddPermissionDialog(node, title) {
        if (this.contentService.hasPermission(node, PermissionsEnum.UPDATEPERMISSIONS)) {
            /** @type {?} */
            const confirm = new Subject();
            confirm.subscribe({
                complete: this.close.bind(this)
            });
            /** @type {?} */
            const data = {
                nodeId: node.id,
                title: title,
                confirm: confirm
            };
            this.openDialog(data, 'adf-add-permission-dialog', '630px');
            return confirm;
        }
        else {
            /** @type {?} */
            let errors = new Error(JSON.stringify({ error: { statusCode: 403 } }));
            errors.message = 'PERMISSION_MANAGER.ERROR.NOT-ALLOWED';
            return throwError(errors);
        }
    }
    /**
     * @param {?} data
     * @param {?} currentPanelClass
     * @param {?} chosenWidth
     * @return {?}
     */
    openDialog(data, currentPanelClass, chosenWidth) {
        this.dialog.open(AddPermissionDialogComponent, { data, panelClass: currentPanelClass, width: chosenWidth });
    }
    /**
     * Closes the currently-open dialog.
     * @return {?}
     */
    close() {
        this.dialog.closeAll();
    }
    /**
     * Opens a dialog to update permissions for a node.
     * @param {?=} nodeId ID of the target node
     * @param {?=} title Dialog title
     * @return {?} Node with updated permissions
     */
    updateNodePermissionByDialog(nodeId, title) {
        return this.contentService.getNode(nodeId, { include: ['allowableOperations'] })
            .pipe(switchMap(node => {
            return this.openAddPermissionDialog(node.entry, title)
                .pipe(switchMap(selection => {
                return this.nodePermissionService.updateNodePermissions(nodeId, selection);
            }));
        }));
    }
}
NodePermissionDialogService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NodePermissionDialogService.ctorParameters = () => [
    { type: MatDialog },
    { type: NodePermissionService },
    { type: ContentService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SearchPermissionConfigurationService {
    constructor() {
    }
    /**
     * @param {?} searchTerm
     * @param {?} maxResults
     * @param {?} skipCount
     * @return {?}
     */
    generateQueryBody(searchTerm, maxResults, skipCount) {
        /** @type {?} */
        const defaultQueryBody = {
            query: {
                query: searchTerm ? `authorityName:*${searchTerm}* OR userName:*${searchTerm}*` : searchTerm
            },
            include: ['properties', 'aspectNames'],
            paging: {
                maxItems: maxResults,
                skipCount: skipCount
            },
            filterQueries: [
                /*tslint:disable-next-line */
                { query: "TYPE:'cm:authority'" }
            ]
        };
        return defaultQueryBody;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AddPermissionPanelComponent {
    constructor() {
        /**
         * Emitted when a permission list item is selected.
         */
        this.select = new EventEmitter();
        this.searchInput = new FormControl();
        this.searchedWord = '';
        this.debounceSearch = 200;
        this.selectedItems = [];
        this.EVERYONE = { entry: { properties: { 'cm:authorityName': 'GROUP_EVERYONE' } } };
        this.searchInput.valueChanges
            .pipe(debounceTime(this.debounceSearch))
            .subscribe((searchValue) => {
            this.searchedWord = searchValue;
            if (!searchValue) {
                this.search.resetResults();
            }
        });
    }
    /**
     * @param {?} item
     * @return {?}
     */
    elementClicked(item) {
        if (this.isAlreadySelected(item)) {
            this.selectedItems.splice(this.selectedItems.indexOf(item), 1);
        }
        else {
            this.selectedItems.push(item);
        }
        this.select.emit(this.selectedItems);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    isAlreadySelected(item) {
        return this.selectedItems.indexOf(item) >= 0;
    }
    /**
     * @return {?}
     */
    clearSearch() {
        this.searchedWord = '';
        this.selectedItems.splice(0, this.selectedItems.length);
        this.search.resetResults();
    }
}
AddPermissionPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-add-permission-panel',
                template: "<mat-form-field floatPlaceholder=\"never\" class=\"adf-permission-search-input\">\n    <input matInput\n        id=\"searchInput\"\n        [formControl]=\"searchInput\"\n        type=\"text\"\n        placeholder=\"{{'PERMISSION_MANAGER.ADD-PERMISSION.SEARCH' | translate}}\"\n        [value]=\"searchedWord\">\n\n    <mat-icon *ngIf=\"searchedWord?.length > 0\"\n        class=\"adf-permission-search-icon\"\n        data-automation-id=\"adf-permission-clear-input\"\n        id=\"adf-permission-clear-input\"\n        matSuffix (click)=\"clearSearch()\">clear\n    </mat-icon>\n\n    <mat-icon *ngIf=\"searchedWord?.length === 0\"\n        class=\"adf-permission-search-icon\"\n        data-automation-id=\"adf-permission-search-icon\"\n        matSuffix>search\n    </mat-icon>\n</mat-form-field>\n\n<div *ngIf=\"searchedWord?.length === 0\" id=\"adf-add-permission-type-search\">\n    <span class=\"adf-permission-start-message\">{{'PERMISSION_MANAGER.ADD-PERMISSION.TYPE-MESSAGE' | translate}}</span>\n</div>\n\n<adf-search #search [searchTerm]=\"searchedWord\"\n        id=\"adf-add-permission-authority-results\"\n        class=\"adf-permission-result-list\"\n        [class.adf-permission-result-list-search]=\"searchedWord.length === 0\">\n<ng-template let-data>\n    <mat-selection-list class=\"adf-permission-result-list-elements\">\n        <mat-list-option\n            id=\"adf-add-permission-group-everyone\"\n            class=\"adf-list-option-item\"\n            (click)=\"elementClicked(EVERYONE)\">\n            <mat-icon mat-list-icon id=\"add-group-icon\">\n                group_add\n            </mat-icon>\n            <p>\n                {{'PERMISSION_MANAGER.ADD-PERMISSION.EVERYONE' | translate}}\n            </p>\n        </mat-list-option>\n\n        <mat-list-option *ngFor=\"let item of data?.list?.entries; let idx = index\"\n                            (click)=\"elementClicked(item)\"\n                            class=\"adf-list-option-item\"\n                            id=\"result_option_{{idx}}\">\n            <mat-icon mat-list-icon id=\"add-group-icon\"\n                      *ngIf=\"item?.entry?.nodeType === 'cm:authorityContainer' else show_person_icon\">\n                      group_add\n            </mat-icon>\n            <ng-template #show_person_icon>\n                <mat-icon id=\"add-person-icon\" mat-list-icon>person_add</mat-icon>\n            </ng-template>\n            <p>\n             {{item.entry?.properties['cm:authorityName']?\n                                    item.entry?.properties['cm:authorityName'] :\n                                    item.entry?.properties['cm:firstName']}}</p>\n        </mat-list-option>\n    </mat-selection-list>\n</ng-template>\n</adf-search>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    { provide: SearchConfigurationService, useClass: SearchPermissionConfigurationService },
                    SearchService
                ],
                styles: [""]
            }] }
];
/** @nocollapse */
AddPermissionPanelComponent.ctorParameters = () => [];
AddPermissionPanelComponent.propDecorators = {
    search: [{ type: ViewChild, args: ['search',] }],
    select: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PermissionManagerModule {
}
PermissionManagerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    SearchModule
                ],
                declarations: [
                    PermissionListComponent,
                    NoPermissionTemplateComponent,
                    AddPermissionPanelComponent,
                    InheritPermissionDirective,
                    AddPermissionComponent,
                    AddPermissionDialogComponent
                ],
                entryComponents: [
                    AddPermissionPanelComponent,
                    AddPermissionComponent,
                    AddPermissionDialogComponent
                ],
                exports: [
                    PermissionListComponent,
                    NoPermissionTemplateComponent,
                    AddPermissionPanelComponent,
                    InheritPermissionDirective,
                    AddPermissionComponent,
                    AddPermissionDialogComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ShareDialogComponent {
    /**
     * @param {?} sharedLinksApiService
     * @param {?} dialogRef
     * @param {?} dialog
     * @param {?} nodesApiService
     * @param {?} contentService
     * @param {?} data
     */
    constructor(sharedLinksApiService, dialogRef, dialog, nodesApiService, contentService, data) {
        this.sharedLinksApiService = sharedLinksApiService;
        this.dialogRef = dialogRef;
        this.dialog = dialog;
        this.nodesApiService = nodesApiService;
        this.contentService = contentService;
        this.data = data;
        this.subscriptions = [];
        this.minDate = moment$1().add(1, 'd');
        this.isFileShared = false;
        this.isDisabled = false;
        this.form = new FormGroup({
            'sharedUrl': new FormControl(''),
            'time': new FormControl({ value: '', disabled: false })
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.canUpdate) {
            this.form.controls['time'].disable();
        }
        this.subscriptions.push(this.form.valueChanges
            .pipe(skip(1), tap((updates) => {
            this.updateNode(updates);
        }))
            .subscribe((updates) => this.updateEntryExpiryDate(updates)));
        if (this.data.node && this.data.node.entry) {
            this.fileName = this.data.node.entry.name;
            this.baseShareUrl = this.data.baseShareUrl;
            /** @type {?} */
            const properties = this.data.node.entry.properties;
            if (properties && !properties['qshare:sharedId']) {
                this.createSharedLinks(this.data.node.entry.id);
            }
            else {
                this.sharedId = properties['qshare:sharedId'];
                this.isFileShared = true;
                this.updateForm();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((subscription) => subscription.unsubscribe);
    }
    /**
     * @return {?}
     */
    removeShare() {
        this.deleteSharedLink(this.sharedId);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSlideShareChange(event) {
        if (event.checked) {
            this.createSharedLinks(this.data.node.entry.id);
        }
        else {
            this.openConfirmationDialog();
        }
    }
    /**
     * @return {?}
     */
    get canUpdate() {
        return this.contentService.hasPermission(this.data.node.entry, 'update');
    }
    /**
     * @return {?}
     */
    openConfirmationDialog() {
        this.isFileShared = false;
        this.dialog
            .open(ConfirmDialogComponent, {
            data: {
                title: 'SHARE.CONFIRMATION.DIALOG-TITLE',
                message: 'SHARE.CONFIRMATION.MESSAGE',
                yesLabel: 'SHARE.CONFIRMATION.REMOVE',
                noLabel: 'SHARE.CONFIRMATION.CANCEL'
            },
            minWidth: '250px',
            closeOnNavigation: true
        })
            .beforeClose().subscribe(deleteSharedLink => {
            if (deleteSharedLink) {
                this.deleteSharedLink(this.sharedId);
            }
            else {
                this.isFileShared = true;
            }
        });
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    createSharedLinks(nodeId) {
        this.isDisabled = true;
        this.sharedLinksApiService.createSharedLinks(nodeId)
            .subscribe((sharedLink) => {
            if (sharedLink.entry) {
                this.sharedId = sharedLink.entry.id;
                this.data.node.entry.properties['qshare:sharedId'] = this.sharedId;
                this.isDisabled = false;
                this.isFileShared = true;
                this.updateForm();
            }
        }, () => {
            this.isDisabled = false;
            this.isFileShared = false;
        });
    }
    /**
     * @param {?} sharedId
     * @return {?}
     */
    deleteSharedLink(sharedId) {
        this.isDisabled = true;
        this.sharedLinksApiService.deleteSharedLink(sharedId).subscribe(() => {
            this.data.node.entry.properties['qshare:sharedId'] = null;
            this.data.node.entry.properties['qshare:expiryDate'] = null;
            this.dialogRef.close(false);
        }, () => {
            this.isDisabled = false;
            this.isFileShared = false;
        });
    }
    /**
     * @return {?}
     */
    updateForm() {
        const { entry } = this.data.node;
        /** @type {?} */
        const expiryDate = entry.properties['qshare:expiryDate'];
        this.form.setValue({
            'sharedUrl': `${this.baseShareUrl}${this.sharedId}`,
            'time': expiryDate ? expiryDate : null
        });
    }
    /**
     * @param {?} updates
     * @return {?}
     */
    updateNode(updates) {
        return this.nodesApiService.updateNode(this.data.node.entry.id, {
            properties: {
                'qshare:expiryDate': updates.time ? updates.time.utc().format() : null
            }
        });
    }
    /**
     * @param {?} updates
     * @return {?}
     */
    updateEntryExpiryDate(updates) {
        const { properties } = this.data.node.entry;
        properties['qshare:expiryDate'] = updates.time
            ? updates.time.local()
            : null;
    }
}
ShareDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-share-dialog',
                template: "<div class=\"adf-share-link__dialog-content\">\n    <h1 data-automation-id=\"adf-share-dialog-title\"\n        class=\"adf-share-link__title\">\n        {{ 'SHARE.DIALOG-TITLE' | translate }} {{ fileName }}\n    </h1>\n\n    <mat-dialog-content>\n        <p class=\"adf-share-link__info\">{{ 'SHARE.DESCRIPTION' | translate }}</p>\n\n        <div class=\"adf-share-link--row\">\n            <h1 class=\"adf-share-link__label\">{{ 'SHARE.TITLE' | translate }}</h1>\n\n            <mat-slide-toggle\n                color=\"primary\"\n                data-automation-id=\"adf-share-toggle\"\n                [checked]=\"isFileShared\"\n                [disabled]=\"!canUpdate || isDisabled\"\n                (change)=\"onSlideShareChange($event)\">\n            </mat-slide-toggle>\n        </div>\n\n        <form [formGroup]=\"form\">\n            <mat-form-field class=\"full-width\">\n                <input #sharedLinkInput\n                    data-automation-id=\"adf-share-link\"\n                    class=\"adf-share-link__input\"\n                    matInput\n                    cdkFocusInitial\n                    placeholder=\"{{ 'SHARE.PUBLIC-LINK' | translate }}\"\n                    formControlName=\"sharedUrl\"\n                    readonly=\"readonly\">\n                    <mat-icon class=\"input-action\" matSuffix\n                          [clipboard-notification]=\"'SHARE.CLIPBOARD-MESSAGE' | translate\"\n                          [adf-clipboard]=\"sharedLinkInput\">\n                        link\n                    </mat-icon>\n            </mat-form-field>\n\n            <h1 class=\"adf-share-link__label\">{{ 'SHARE.EXPIRES' | translate }}</h1>\n            <mat-form-field class=\"full-width\">\n                <mat-datetimepicker-toggle [for]=\"datetimePicker\" matSuffix></mat-datetimepicker-toggle>\n                <mat-datetimepicker #datetimePicker type=\"datetime\" openOnFocus=\"true\" timeInterval=\"1\"></mat-datetimepicker>\n                <input class=\"adf-share-link__input\"\n                    matInput\n                    [min]=\"minDate\"\n                    formControlName=\"time\"\n                    [matDatetimepicker]=\"datetimePicker\">\n            </mat-form-field>\n        </form>\n    </mat-dialog-content>\n\n    <div mat-dialog-actions>\n        <button\n            data-automation-id=\"adf-share-dialog-close\"\n            mat-button color=\"primary\" mat-dialog-close>\n            {{ 'SHARE.CLOSE' | translate }}\n        </button>\n    </div>\n</div>\n",
                host: { 'class': 'adf-share-dialog' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-share-link-dialog .adf-share-link__dialog-content{display:flex;flex-direction:column}.adf-share-link-dialog .adf-share-link__label{letter-spacing:-.4px;line-height:2;font-weight:400;font-style:normal;font-stretch:normal;font-size:16px;opacity:.87;flex:1 1 auto}.adf-share-link-dialog .adf-share-link__title{letter-spacing:-.4px;line-height:2;font-weight:400;font-style:normal;font-stretch:normal;font-size:16px;opacity:.87}.adf-share-link-dialog .adf-share-link__info{letter-spacing:-.4px;line-height:2;font-weight:400;font-style:normal;font-stretch:normal;opacity:.87;opacity:.54;font-size:13px}.adf-share-link-dialog .adf-share-link--row{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center}.adf-share-link-dialog .adf-share-link__input{opacity:.54}.adf-share-link-dialog .input-action{cursor:pointer}.adf-share-link-dialog .full-width{width:100%}.adf-share-link-dialog .mat-form-field-infix{border-top:unset}.adf-share-link-dialog .mat-dialog-actions{justify-content:flex-end}.adf-share-link-dialog .mat-dialog-actions>button{text-transform:uppercase}.adf-share-link-dialog .mat-form-field-flex{align-items:center}"]
            }] }
];
/** @nocollapse */
ShareDialogComponent.ctorParameters = () => [
    { type: SharedLinksApiService },
    { type: MatDialogRef },
    { type: MatDialog },
    { type: NodesApiService },
    { type: ContentService },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
ShareDialogComponent.propDecorators = {
    sharedLinkInput: [{ type: ViewChild, args: ['sharedLinkInput',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NodeSharedDirective {
    /**
     * @param {?} dialog
     * @param {?} zone
     */
    constructor(dialog, zone) {
        this.dialog = dialog;
        this.zone = zone;
        this.isFile = false;
        this.isShared = false;
    }
    /**
     * @return {?}
     */
    onClick() {
        if (this.node) {
            this.shareNode(this.node);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    shareNode(node) {
        if (node && node.entry && node.entry.isFile) {
            this.dialog.open(ShareDialogComponent, {
                width: '600px',
                panelClass: 'adf-share-link-dialog',
                data: {
                    node: node,
                    baseShareUrl: this.baseShareUrl
                }
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.zone.onStable.subscribe(() => {
            if (this.node) {
                this.isFile = this.node.entry.isFile;
                this.isShared = this.node.entry.properties['qshare:sharedId'];
            }
        });
    }
}
NodeSharedDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-share]',
                exportAs: 'adfShare'
            },] }
];
/** @nocollapse */
NodeSharedDirective.ctorParameters = () => [
    { type: MatDialog },
    { type: NgZone }
];
NodeSharedDirective.propDecorators = {
    node: [{ type: Input, args: ['adf-share',] }],
    baseShareUrl: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ContentNodeShareModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ContentNodeShareModule
        };
    }
    /**
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: ContentNodeShareModule
        };
    }
}
ContentNodeShareModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    CommonModule,
                    MaterialModule
                ],
                declarations: [
                    ShareDialogComponent,
                    NodeSharedDirective
                ],
                exports: [
                    ShareDialogComponent,
                    NodeSharedDirective
                ],
                entryComponents: [
                    ShareDialogComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function providers() {
    return [
        RatingService,
        ContentMetadataService,
        PropertyDescriptorsService,
        ContentMetadataConfigFactory,
        BasicPropertiesService,
        PropertyGroupTranslatorService,
        SearchQueryBuilderService,
        SearchFilterService,
        ContentNodeSelectorService,
        ContentNodeDialogService,
        DocumentListService,
        FolderActionsService,
        DocumentActionsService,
        NodeActionsService,
        CustomResourcesService,
        NodePermissionDialogService,
        NodePermissionService,
        TagService
    ];
}
class ContentModuleLazy {
}
ContentModuleLazy.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    SocialModule,
                    TagModule,
                    CommonModule,
                    WebScriptModule,
                    FormsModule,
                    ReactiveFormsModule,
                    DialogModule,
                    SearchModule,
                    DocumentListModule,
                    UploadModule,
                    MaterialModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ContentNodeSelectorModule,
                    ContentNodeShareModule,
                    ContentMetadataModule,
                    FolderDirectiveModule,
                    ContentDirectiveModule,
                    PermissionManagerModule,
                    VersionManagerModule
                ],
                exports: [
                    SocialModule,
                    TagModule,
                    WebScriptModule,
                    DocumentListModule,
                    UploadModule,
                    SearchModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ContentNodeSelectorModule,
                    ContentNodeShareModule,
                    ContentMetadataModule,
                    DialogModule,
                    FolderDirectiveModule,
                    ContentDirectiveModule,
                    PermissionManagerModule,
                    VersionManagerModule
                ]
            },] }
];
const ɵ0$2 = {
    name: 'adf-content-services',
    source: 'assets/adf-content-services'
};
class ContentModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ContentModule,
            providers: [
                ...providers(),
                {
                    provide: TRANSLATION_PROVIDER,
                    multi: true,
                    useValue: {
                        name: 'adf-content-services',
                        source: 'assets/adf-content-services'
                    }
                }
            ]
        };
    }
    /**
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: ContentModuleLazy
        };
    }
}
ContentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule.forChild(),
                    SocialModule,
                    TagModule,
                    CommonModule,
                    WebScriptModule,
                    FormsModule,
                    ReactiveFormsModule,
                    DialogModule,
                    SearchModule,
                    DocumentListModule,
                    UploadModule,
                    MaterialModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ContentNodeSelectorModule,
                    ContentNodeShareModule,
                    ContentMetadataModule,
                    FolderDirectiveModule,
                    ContentDirectiveModule,
                    PermissionManagerModule,
                    VersionManagerModule
                ],
                providers: [
                    ...providers(),
                    {
                        provide: TRANSLATION_PROVIDER,
                        multi: true,
                        useValue: ɵ0$2
                    }
                ],
                exports: [
                    SocialModule,
                    TagModule,
                    WebScriptModule,
                    DocumentListModule,
                    UploadModule,
                    SearchModule,
                    SitesDropdownModule,
                    BreadcrumbModule,
                    ContentNodeSelectorModule,
                    ContentNodeShareModule,
                    ContentMetadataModule,
                    DialogModule,
                    FolderDirectiveModule,
                    ContentDirectiveModule,
                    PermissionManagerModule,
                    VersionManagerModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { NodeDownloadDirective, ContentDirectiveModule, RatingComponent, LikeComponent, RatingService, SocialModule, TagActionsComponent, TagListComponent, TagNodeListComponent, TagService, TagModule, WebscriptComponent, WebScriptModule, PaginationStrategy, DocumentListComponent, NodeEntityEvent, NodeEntryEvent, ContentColumnComponent, ContentColumnListComponent, ContentActionComponent, ContentActionListComponent, EmptyFolderContentDirective, NoPermissionContentDirective, ShareDataTableAdapter, ShareDataRow, FolderActionsService, DocumentActionsService, DocumentListService, NodeActionsService, CustomResourcesService, ContentActionModel, ContentActionTarget, DocumentActionModel, FolderActionModel, NodePaging, NodePagingList, NodeMinimalEntry, Pagination, NodeMinimal, UserInfo, ContentInfo, PathInfoEntity, PathElementEntity, PermissionModel, PermissionStyleModel, DocumentListModule, UploadButtonComponent, UploadVersionButtonComponent, FileUploadingDialogComponent, UploadDragAreaComponent, FileUploadingListComponent, FileUploadingListRowComponent, UploadFilesEvent, FileDraggableDirective, UploadBase, UploadModule, SearchQueryBuilderService, SearchComponent, SearchControlComponent, SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR, SearchTriggerDirective, EmptySearchResultComponent, SearchFilterComponent, SearchFilterService, SearchChipListComponent, SearchSortingPickerComponent, ALFRESCO_SEARCH_DIRECTIVES, SearchModule, Relations, DropdownSitesComponent, SitesDropdownModule, BreadcrumbComponent, DropdownBreadcrumbComponent, BreadcrumbModule, VersionListComponent, VersionManagerComponent, VersionUploadComponent, VersionManagerModule, NameLocationCellComponent, ContentNodeSelectorPanelComponent, ContentNodeSelectorComponent, ContentNodeSelectorService, ContentNodeDialogService, ContentNodeSelectorModule, DownloadZipDialogComponent, FolderDialogComponent, NodeLockDialogComponent, ConfirmDialogComponent, DialogModule, FolderCreateDirective, FolderEditDirective, FolderDirectiveModule, ContentMetadataCardComponent, BasicPropertiesService, ContentMetadataService, PropertyDescriptorsService, PropertyGroupTranslatorService, ContentMetadataConfigFactory, IndifferentConfigService, LayoutOrientedConfigService, AspectOrientedConfigService, ContentMetadataModule, PermissionListComponent, NoPermissionTemplateComponent, InheritPermissionDirective, PermissionDisplayModel, NodePermissionDialogService, NodePermissionService, AddPermissionPanelComponent, AddPermissionComponent, AddPermissionDialogComponent, PermissionManagerModule, ShareDialogComponent, NodeSharedDirective, ContentNodeShareModule, providers, ContentModuleLazy, ContentModule, ContentMetadataComponent as ɵk, NodeLockDirective as ɵc, MaterialModule as ɵb, modules as ɵa, SearchPermissionConfigurationService as ɵl, SearchCheckListComponent as ɵi, SearchDateRangeComponent as ɵj, SearchNumberRangeComponent as ɵh, SearchRadioComponent as ɵf, SearchSliderComponent as ɵg, SearchTextComponent as ɵe, SearchWidgetContainerComponent as ɵd };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRmLWNvbnRlbnQtc2VydmljZXMuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kaWFsb2dzL2Rvd25sb2FkLXppcC5kaWFsb2cudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kaXJlY3RpdmVzL25vZGUtZG93bmxvYWQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvbWF0ZXJpYWwubW9kdWxlLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvZG9jdW1lbnQtbGlzdC9zZXJ2aWNlcy9kb2N1bWVudC1saXN0LnNlcnZpY2UudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9jb250ZW50LW5vZGUtc2VsZWN0b3IvY29udGVudC1ub2RlLXNlbGVjdG9yLmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RpYWxvZ3Mvbm9kZS1sb2NrLmRpYWxvZy50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci9jb250ZW50LW5vZGUtZGlhbG9nLnNlcnZpY2UudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kaXJlY3RpdmVzL25vZGUtbG9jay5kaXJlY3RpdmUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kaXJlY3RpdmVzL2NvbnRlbnQtZGlyZWN0aXZlLm1vZHVsZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3NvY2lhbC9zZXJ2aWNlcy9yYXRpbmcuc2VydmljZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3NvY2lhbC9yYXRpbmcuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvc29jaWFsL2xpa2UuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvc29jaWFsL3NvY2lhbC5tb2R1bGUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy90YWcvc2VydmljZXMvdGFnLnNlcnZpY2UudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy90YWcvdGFnLWFjdGlvbnMuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvdGFnL3RhZy1saXN0LmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3RhZy90YWctbm9kZS1saXN0LmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3RhZy90YWcubW9kdWxlLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvd2Vic2NyaXB0L3dlYnNjcmlwdC5jb21wb25lbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy93ZWJzY3JpcHQvd2Vic2NyaXB0Lm1vZHVsZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RvY3VtZW50LWxpc3QvZGF0YS9zaGFyZS1kYXRhLXJvdy5tb2RlbC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RvY3VtZW50LWxpc3QvZGF0YS9zaGFyZS1kYXRhdGFibGUtYWRhcHRlci50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RvY3VtZW50LWxpc3QvbW9kZWxzL3ByZXNldC5tb2RlbC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RvY3VtZW50LWxpc3QvbW9kZWxzL2NvbnRlbnQtYWN0aW9uLm1vZGVsLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvZG9jdW1lbnQtbGlzdC9jb21wb25lbnRzL25vZGUuZXZlbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kb2N1bWVudC1saXN0L3NlcnZpY2VzL2N1c3RvbS1yZXNvdXJjZXMuc2VydmljZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RvY3VtZW50LWxpc3QvY29tcG9uZW50cy9kb2N1bWVudC1saXN0LmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RvY3VtZW50LWxpc3QvY29tcG9uZW50cy9jb250ZW50LWNvbHVtbi9jb250ZW50LWNvbHVtbi1saXN0LmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RvY3VtZW50LWxpc3QvY29tcG9uZW50cy9jb250ZW50LWNvbHVtbi9jb250ZW50LWNvbHVtbi5jb21wb25lbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kb2N1bWVudC1saXN0L21vZGVscy9wZXJtaXNzaW9ucy5tb2RlbC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RvY3VtZW50LWxpc3Qvc2VydmljZXMvbm9kZS1hY3Rpb25zLnNlcnZpY2UudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kb2N1bWVudC1saXN0L3NlcnZpY2VzL2RvY3VtZW50LWFjdGlvbnMuc2VydmljZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RvY3VtZW50LWxpc3Qvc2VydmljZXMvZm9sZGVyLWFjdGlvbnMuc2VydmljZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RvY3VtZW50LWxpc3QvY29tcG9uZW50cy9jb250ZW50LWFjdGlvbi9jb250ZW50LWFjdGlvbi1saXN0LmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RvY3VtZW50LWxpc3QvY29tcG9uZW50cy9jb250ZW50LWFjdGlvbi9jb250ZW50LWFjdGlvbi5jb21wb25lbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kb2N1bWVudC1saXN0L2NvbXBvbmVudHMvZW1wdHktZm9sZGVyL2VtcHR5LWZvbGRlci1jb250ZW50LmRpcmVjdGl2ZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2RvY3VtZW50LWxpc3QvY29tcG9uZW50cy9uby1wZXJtaXNzaW9uL25vLXBlcm1pc3Npb24tY29udGVudC5kaXJlY3RpdmUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kb2N1bWVudC1saXN0L21vZGVscy9kb2N1bWVudC1saWJyYXJ5Lm1vZGVsLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvZG9jdW1lbnQtbGlzdC9tb2RlbHMvcGVybWlzc2lvbnMtc3R5bGUubW9kZWwudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy91cGxvYWQvY29tcG9uZW50cy9maWxlLXVwbG9hZGluZy1saXN0LmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3VwbG9hZC9jb21wb25lbnRzL2ZpbGUtdXBsb2FkaW5nLWRpYWxvZy5jb21wb25lbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy91cGxvYWQvY29tcG9uZW50cy9maWxlLXVwbG9hZGluZy1saXN0LXJvdy5jb21wb25lbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy91cGxvYWQvY29tcG9uZW50cy91cGxvYWQtZmlsZXMuZXZlbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy91cGxvYWQvY29tcG9uZW50cy9iYXNlLXVwbG9hZC91cGxvYWQtYmFzZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3VwbG9hZC9jb21wb25lbnRzL3VwbG9hZC1idXR0b24uY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvdXBsb2FkL2NvbXBvbmVudHMvdXBsb2FkLXZlcnNpb24tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3VwbG9hZC9jb21wb25lbnRzL3VwbG9hZC1kcmFnLWFyZWEuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvdXBsb2FkL2RpcmVjdGl2ZXMvZmlsZS1kcmFnZ2FibGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvdXBsb2FkL3VwbG9hZC5tb2R1bGUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kb2N1bWVudC1saXN0L2RvY3VtZW50LWxpc3QubW9kdWxlLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvc2VhcmNoL3NlYXJjaC1xdWVyeS1idWlsZGVyLnNlcnZpY2UudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9zZWFyY2gvY29tcG9uZW50cy9zZWFyY2guY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvc2VhcmNoL2NvbXBvbmVudHMvZW1wdHktc2VhcmNoLXJlc3VsdC5jb21wb25lbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9zZWFyY2gvY29tcG9uZW50cy9zZWFyY2gtY29udHJvbC5jb21wb25lbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9zZWFyY2gvY29tcG9uZW50cy9zZWFyY2gtdHJpZ2dlci5kaXJlY3RpdmUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9zZWFyY2gvY29tcG9uZW50cy9zZWFyY2gtZmlsdGVyL21vZGVscy9zZWFyY2gtZmlsdGVyLWxpc3QubW9kZWwudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9zZWFyY2gvY29tcG9uZW50cy9zZWFyY2gtZmlsdGVyL21vZGVscy9yZXNwb25zZS1mYWNldC1xdWVyeS1saXN0Lm1vZGVsLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvc2VhcmNoL2NvbXBvbmVudHMvc2VhcmNoLWZpbHRlci9zZWFyY2gtZmlsdGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3NlYXJjaC9jb21wb25lbnRzL3NlYXJjaC10ZXh0L3NlYXJjaC10ZXh0LmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3NlYXJjaC9jb21wb25lbnRzL3NlYXJjaC1yYWRpby9zZWFyY2gtcmFkaW8uY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvc2VhcmNoL2NvbXBvbmVudHMvc2VhcmNoLXNsaWRlci9zZWFyY2gtc2xpZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3NlYXJjaC9mb3Jtcy9saXZlLWVycm9yLXN0YXRlLW1hdGNoZXIudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9zZWFyY2gvY29tcG9uZW50cy9zZWFyY2gtbnVtYmVyLXJhbmdlL3NlYXJjaC1udW1iZXItcmFuZ2UuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvc2VhcmNoL2NvbXBvbmVudHMvc2VhcmNoLWNoZWNrLWxpc3Qvc2VhcmNoLWNoZWNrLWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvc2VhcmNoL2NvbXBvbmVudHMvc2VhcmNoLWRhdGUtcmFuZ2Uvc2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvc2VhcmNoL2NvbXBvbmVudHMvc2VhcmNoLWZpbHRlci9zZWFyY2gtZmlsdGVyLnNlcnZpY2UudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9zZWFyY2gvY29tcG9uZW50cy9zZWFyY2gtY2hpcC1saXN0L3NlYXJjaC1jaGlwLWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvc2VhcmNoL2NvbXBvbmVudHMvc2VhcmNoLXNvcnRpbmctcGlja2VyL3NlYXJjaC1zb3J0aW5nLXBpY2tlci5jb21wb25lbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9zZWFyY2gvY29tcG9uZW50cy9zZWFyY2gtd2lkZ2V0LWNvbnRhaW5lci9zZWFyY2gtd2lkZ2V0LWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9zZWFyY2gvc2VhcmNoLm1vZHVsZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3NpdGUtZHJvcGRvd24vc2l0ZXMtZHJvcGRvd24uY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvc2l0ZS1kcm9wZG93bi9zaXRlcy1kcm9wZG93bi5tb2R1bGUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9icmVhZGNydW1iL2JyZWFkY3J1bWIuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvYnJlYWRjcnVtYi9kcm9wZG93bi1icmVhZGNydW1iLmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2JyZWFkY3J1bWIvYnJlYWRjcnVtYi5tb2R1bGUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kaWFsb2dzL2NvbmZpcm0uZGlhbG9nLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvdmVyc2lvbi1tYW5hZ2VyL3ZlcnNpb24tbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy92ZXJzaW9uLW1hbmFnZXIvdmVyc2lvbi1tYW5hZ2VyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3ZlcnNpb24tbWFuYWdlci92ZXJzaW9uLXVwbG9hZC5jb21wb25lbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy92ZXJzaW9uLW1hbmFnZXIvdmVyc2lvbi1tYW5hZ2VyLm1vZHVsZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci9uYW1lLWxvY2F0aW9uLWNlbGwvbmFtZS1sb2NhdGlvbi1jZWxsLmNvbXBvbmVudC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci9jb250ZW50LW5vZGUtc2VsZWN0b3Iuc2VydmljZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci9jb250ZW50LW5vZGUtc2VsZWN0b3ItcGFuZWwuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvY29udGVudC1ub2RlLXNlbGVjdG9yL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci5tb2R1bGUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kaWFsb2dzL2ZvbGRlci1uYW1lLnZhbGlkYXRvcnMudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kaWFsb2dzL2ZvbGRlci5kaWFsb2cudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9kaWFsb2dzL2RpYWxvZy5tb2R1bGUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9mb2xkZXItZGlyZWN0aXZlL2ZvbGRlci1jcmVhdGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvZm9sZGVyLWRpcmVjdGl2ZS9mb2xkZXItZWRpdC5kaXJlY3RpdmUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9mb2xkZXItZGlyZWN0aXZlL2ZvbGRlci1kaXJlY3RpdmUubW9kdWxlLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvY29udGVudC1tZXRhZGF0YS9jb21wb25lbnRzL2NvbnRlbnQtbWV0YWRhdGEtY2FyZC9jb250ZW50LW1ldGFkYXRhLWNhcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvY29udGVudC1tZXRhZGF0YS9zZXJ2aWNlcy9iYXNpYy1wcm9wZXJ0aWVzLnNlcnZpY2UudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9jb250ZW50LW1ldGFkYXRhL3NlcnZpY2VzL3Byb3BlcnR5LWdyb3Vwcy10cmFuc2xhdG9yLnNlcnZpY2UudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9jb250ZW50LW1ldGFkYXRhL3NlcnZpY2VzL2NvbmZpZy9wcm9wZXJ0eS1ncm91cC1yZWFkZXIudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9jb250ZW50LW1ldGFkYXRhL3NlcnZpY2VzL2NvbmZpZy9hc3BlY3Qtb3JpZW50ZWQtY29uZmlnLnNlcnZpY2UudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9jb250ZW50LW1ldGFkYXRhL3NlcnZpY2VzL2NvbmZpZy9pbmRpZmZlcmVudC1jb25maWcuc2VydmljZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2NvbnRlbnQtbWV0YWRhdGEvc2VydmljZXMvY29uZmlnL2xheW91dC1vcmllbnRlZC1jb25maWcuc2VydmljZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2NvbnRlbnQtbWV0YWRhdGEvc2VydmljZXMvY29uZmlnL2NvbnRlbnQtbWV0YWRhdGEtY29uZmlnLmZhY3RvcnkudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9jb250ZW50LW1ldGFkYXRhL3NlcnZpY2VzL3Byb3BlcnR5LWRlc2NyaXB0b3JzLnNlcnZpY2UudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9jb250ZW50LW1ldGFkYXRhL3NlcnZpY2VzL2NvbnRlbnQtbWV0YWRhdGEuc2VydmljZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2NvbnRlbnQtbWV0YWRhdGEvY29tcG9uZW50cy9jb250ZW50LW1ldGFkYXRhL2NvbnRlbnQtbWV0YWRhdGEuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvY29udGVudC1tZXRhZGF0YS9jb250ZW50LW1ldGFkYXRhLm1vZHVsZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3Blcm1pc3Npb24tbWFuYWdlci9tb2RlbHMvcGVybWlzc2lvbi5tb2RlbC50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3Blcm1pc3Npb24tbWFuYWdlci9zZXJ2aWNlcy9ub2RlLXBlcm1pc3Npb24uc2VydmljZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3Blcm1pc3Npb24tbWFuYWdlci9jb21wb25lbnRzL3Blcm1pc3Npb24tbGlzdC9wZXJtaXNzaW9uLWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvcGVybWlzc2lvbi1tYW5hZ2VyL2NvbXBvbmVudHMvcGVybWlzc2lvbi1saXN0L25vLXBlcm1pc3Npb24uY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvcGVybWlzc2lvbi1tYW5hZ2VyL2NvbXBvbmVudHMvaW5oZXJpdGVkLWJ1dHRvbi5kaXJlY3RpdmUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9wZXJtaXNzaW9uLW1hbmFnZXIvY29tcG9uZW50cy9hZGQtcGVybWlzc2lvbi9hZGQtcGVybWlzc2lvbi5jb21wb25lbnQudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9wZXJtaXNzaW9uLW1hbmFnZXIvY29tcG9uZW50cy9hZGQtcGVybWlzc2lvbi9hZGQtcGVybWlzc2lvbi1kaWFsb2cuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvcGVybWlzc2lvbi1tYW5hZ2VyL3NlcnZpY2VzL25vZGUtcGVybWlzc2lvbi1kaWFsb2cuc2VydmljZS50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL3Blcm1pc3Npb24tbWFuYWdlci9jb21wb25lbnRzL2FkZC1wZXJtaXNzaW9uL3NlYXJjaC1jb25maWctcGVybWlzc2lvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvcGVybWlzc2lvbi1tYW5hZ2VyL2NvbXBvbmVudHMvYWRkLXBlcm1pc3Npb24vYWRkLXBlcm1pc3Npb24tcGFuZWwuY29tcG9uZW50LnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvcGVybWlzc2lvbi1tYW5hZ2VyL3Blcm1pc3Npb24tbWFuYWdlci5tb2R1bGUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9jb250ZW50LW5vZGUtc2hhcmUvY29udGVudC1ub2RlLXNoYXJlLmRpYWxvZy50cyIsIm5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzL2NvbnRlbnQtbm9kZS1zaGFyZS9jb250ZW50LW5vZGUtc2hhcmUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvY29udGVudC1ub2RlLXNoYXJlL2NvbnRlbnQtbm9kZS1zaGFyZS5tb2R1bGUudHMiLCJuZzovL0BhbGZyZXNjby9hZGYtY29udGVudC1zZXJ2aWNlcy9jb250ZW50Lm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEluamVjdCwgT25Jbml0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTUFUX0RJQUxPR19EQVRBLCBNYXREaWFsb2dSZWYgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgeyBEb3dubG9hZEVudHJ5LCBNaW5pbWFsTm9kZUVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBMb2dTZXJ2aWNlLCBBbGZyZXNjb0FwaVNlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1kb3dubG9hZC16aXAtZGlhbG9nJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZG93bmxvYWQtemlwLmRpYWxvZy5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9kb3dubG9hZC16aXAuZGlhbG9nLnNjc3MnXSxcbiAgICBob3N0OiB7ICdjbGFzcyc6ICdhZGYtZG93bmxvYWQtemlwLWRpYWxvZycgfSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIERvd25sb2FkWmlwRGlhbG9nQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIC8vIGZsYWcgZm9yIGFzeW5jIHRocmVhZHNcbiAgICBwcml2YXRlIGNhbmNlbGxlZCA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBkaWFsb2dSZWY6IE1hdERpYWxvZ1JlZjxEb3dubG9hZFppcERpYWxvZ0NvbXBvbmVudD4sXG4gICAgICAgICAgICAgICAgQEluamVjdChNQVRfRElBTE9HX0RBVEEpIHByaXZhdGUgZGF0YTogYW55LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgbG9nU2VydmljZTogTG9nU2VydmljZSkge1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5ub2RlSWRzICYmIHRoaXMuZGF0YS5ub2RlSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkWmlwKHRoaXMuZGF0YS5ub2RlSWRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dTZXJ2aWNlLmxvZygnQ2FuY2VsbGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYW5jZWxEb3dubG9hZCgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpYWxvZ1JlZi5jbG9zZShmYWxzZSk7XG4gICAgfVxuXG4gICAgZG93bmxvYWRaaXAobm9kZUlkczogc3RyaW5nW10pIHtcbiAgICAgICAgaWYgKG5vZGVJZHMgJiYgbm9kZUlkcy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2U6IGFueSA9IHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLmNvcmUuZG93bmxvYWRzQXBpLmNyZWF0ZURvd25sb2FkKHsgbm9kZUlkcyB9KTtcblxuICAgICAgICAgICAgcHJvbWlzZS5vbigncHJvZ3Jlc3MnLCBwcm9ncmVzcyA9PiB0aGlzLmxvZ1NlcnZpY2UubG9nKCdQcm9ncmVzcycsIHByb2dyZXNzKSk7XG4gICAgICAgICAgICBwcm9taXNlLm9uKCdlcnJvcicsIGVycm9yID0+IHRoaXMubG9nU2VydmljZS5lcnJvcignRXJyb3InLCBlcnJvcikpO1xuICAgICAgICAgICAgcHJvbWlzZS5vbignYWJvcnQnLCBkYXRhID0+IHRoaXMubG9nU2VydmljZS5sb2coJ0Fib3J0JywgZGF0YSkpO1xuXG4gICAgICAgICAgICBwcm9taXNlLm9uKCdzdWNjZXNzJywgKGRhdGE6IERvd25sb2FkRW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmVudHJ5ICYmIGRhdGEuZW50cnkuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gdGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuY29udGVudC5nZXRDb250ZW50VXJsKGRhdGEuZW50cnkuaWQsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLmNvcmUubm9kZXNBcGkuZ2V0Tm9kZShkYXRhLmVudHJ5LmlkKS50aGVuKChkb3dubG9hZE5vZGU6IE1pbmltYWxOb2RlRW50aXR5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ1NlcnZpY2UubG9nKGRvd25sb2FkTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGRvd25sb2FkTm9kZS5lbnRyeS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YWl0QW5kRG93bmxvYWQoZGF0YS5lbnRyeS5pZCwgdXJsLCBmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2FpdEFuZERvd25sb2FkKGRvd25sb2FkSWQ6IHN0cmluZywgdXJsOiBzdHJpbmcsIGZpbGVOYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5jb3JlLmRvd25sb2Fkc0FwaS5nZXREb3dubG9hZChkb3dubG9hZElkKS50aGVuKChkb3dubG9hZEVudHJ5OiBEb3dubG9hZEVudHJ5KSA9PiB7XG4gICAgICAgICAgICBpZiAoZG93bmxvYWRFbnRyeS5lbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmIChkb3dubG9hZEVudHJ5LmVudHJ5LnN0YXR1cyA9PT0gJ0RPTkUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWQodXJsLCBmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndhaXRBbmREb3dubG9hZChkb3dubG9hZElkLCB1cmwsIGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkb3dubG9hZCh1cmw6IHN0cmluZywgZmlsZU5hbWU6IHN0cmluZykge1xuICAgICAgICBpZiAodXJsICYmIGZpbGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXG4gICAgICAgICAgICBsaW5rLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBsaW5rLmRvd25sb2FkID0gZmlsZU5hbWU7XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICAgICAgICBsaW5rLmNsaWNrKCk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlhbG9nUmVmLmNsb3NlKHRydWUpO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0RGlhbG9nIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRpdHkgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuaW1wb3J0IHsgRG93bmxvYWRaaXBEaWFsb2dDb21wb25lbnQgfSBmcm9tICcuLi9kaWFsb2dzL2Rvd25sb2FkLXppcC5kaWFsb2cnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1thZGZOb2RlRG93bmxvYWRdJ1xufSlcbmV4cG9ydCBjbGFzcyBOb2RlRG93bmxvYWREaXJlY3RpdmUge1xuXG4gICAgLyoqIE5vZGVzIHRvIGRvd25sb2FkLiAqL1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnB1dC1yZW5hbWVcbiAgICBASW5wdXQoJ2FkZk5vZGVEb3dubG9hZCcpXG4gICAgbm9kZXM6IE1pbmltYWxOb2RlRW50aXR5W107XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gICAgb25DbGljaygpIHtcbiAgICAgICAgdGhpcy5kb3dubG9hZE5vZGVzKHRoaXMubm9kZXMpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBkaWFsb2c6IE1hdERpYWxvZykge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBtdWx0aXBsZSBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKiBQYWNrcyByZXN1bHQgaW50byBhIC5aSVAgYXJjaGl2ZSBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIG5vZGUgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHNlbGVjdGlvbiBNdWx0aXBsZSBzZWxlY3RlZCBub2RlcyB0byBkb3dubG9hZFxuICAgICAqL1xuICAgIGRvd25sb2FkTm9kZXMoc2VsZWN0aW9uOiBBcnJheTxNaW5pbWFsTm9kZUVudGl0eT4pIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWROb2RlKHNlbGVjdGlvblswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRvd25sb2FkWmlwKHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBzaW5nbGUgbm9kZS5cbiAgICAgKiBQYWNrcyByZXN1bHQgaW50byBhIC5aSVAgYXJjaGl2ZSBpcyB0aGUgbm9kZSBpcyBhIEZvbGRlci5cbiAgICAgKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGRvd25sb2FkXG4gICAgICovXG4gICAgZG93bmxvYWROb2RlKG5vZGU6IE1pbmltYWxOb2RlRW50aXR5KSB7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUuZW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gbm9kZS5lbnRyeTtcblxuICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW50cnkuaXNGb2xkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkWmlwKFtub2RlXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3Mgbm9kZUlkIGZvciBTaGFyZWQgRmlsZXNcbiAgICAgICAgICAgIGlmICghZW50cnkuaXNGaWxlICYmICFlbnRyeS5pc0ZvbGRlciAmJiAoPGFueT4gZW50cnkpLm5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb3dubG9hZEZpbGUobm9kZTogTWluaW1hbE5vZGVFbnRpdHkpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5lbnRyeSkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudEFwaSA9IHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLmNvbnRlbnQ7XG4gICAgICAgICAgICAvLyBub2RlSWQgZm9yIFNoYXJlZCBub2RlXG4gICAgICAgICAgICBjb25zdCBpZCA9ICg8YW55PiBub2RlLmVudHJ5KS5ub2RlSWQgfHwgbm9kZS5lbnRyeS5pZDtcblxuICAgICAgICAgICAgY29uc3QgdXJsID0gY29udGVudEFwaS5nZXRDb250ZW50VXJsKGlkLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gbm9kZS5lbnRyeS5uYW1lO1xuXG4gICAgICAgICAgICB0aGlzLmRvd25sb2FkKHVybCwgZmlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb3dubG9hZFppcChzZWxlY3Rpb246IEFycmF5PE1pbmltYWxOb2RlRW50aXR5Pikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBub2RlSWQgZm9yIFNoYXJlZCBub2RlXG4gICAgICAgICAgICBjb25zdCBub2RlSWRzID0gc2VsZWN0aW9uLm1hcCgobm9kZTogYW55KSA9PiAobm9kZS5lbnRyeS5ub2RlSWQgfHwgbm9kZS5lbnRyeS5pZCkpO1xuXG4gICAgICAgICAgICB0aGlzLmRpYWxvZy5vcGVuKERvd25sb2FkWmlwRGlhbG9nQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICc2MDBweCcsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUNsb3NlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb3dubG9hZCh1cmw6IHN0cmluZywgZmlsZU5hbWU6IHN0cmluZykge1xuICAgICAgICBpZiAodXJsICYmIGZpbGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXG4gICAgICAgICAgICBsaW5rLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBsaW5rLmRvd25sb2FkID0gZmlsZU5hbWU7XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICAgICAgICBsaW5rLmNsaWNrKCk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgTWF0QnV0dG9uTW9kdWxlLFxuICAgIE1hdENoaXBzTW9kdWxlLFxuICAgIE1hdERpYWxvZ01vZHVsZSxcbiAgICBNYXRJY29uTW9kdWxlLFxuICAgIE1hdENhcmRNb2R1bGUsXG4gICAgTWF0SW5wdXRNb2R1bGUsXG4gICAgTWF0TGlzdE1vZHVsZSxcbiAgICBNYXRNZW51TW9kdWxlLFxuICAgIE1hdE9wdGlvbk1vZHVsZSxcbiAgICBNYXRQcm9ncmVzc0Jhck1vZHVsZSxcbiAgICBNYXRQcm9ncmVzc1NwaW5uZXJNb2R1bGUsXG4gICAgTWF0UmlwcGxlTW9kdWxlLFxuICAgIE1hdEV4cGFuc2lvbk1vZHVsZSxcbiAgICBNYXRTZWxlY3RNb2R1bGUsXG4gICAgTWF0Q2hlY2tib3hNb2R1bGUsXG4gICAgTWF0RGF0ZXBpY2tlck1vZHVsZSxcbiAgICBNYXRTbGlkZVRvZ2dsZU1vZHVsZSxcbiAgICBNYXRSYWRpb01vZHVsZSxcbiAgICBNYXRTbGlkZXJNb2R1bGVcbn0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gbW9kdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBNYXRCdXR0b25Nb2R1bGUsXG4gICAgICAgIE1hdENoaXBzTW9kdWxlLFxuICAgICAgICBNYXREaWFsb2dNb2R1bGUsXG4gICAgICAgIE1hdEljb25Nb2R1bGUsXG4gICAgICAgIE1hdENhcmRNb2R1bGUsXG4gICAgICAgIE1hdElucHV0TW9kdWxlLFxuICAgICAgICBNYXRMaXN0TW9kdWxlLFxuICAgICAgICBNYXRQcm9ncmVzc1NwaW5uZXJNb2R1bGUsXG4gICAgICAgIE1hdFByb2dyZXNzQmFyTW9kdWxlLFxuICAgICAgICBNYXRSaXBwbGVNb2R1bGUsXG4gICAgICAgIE1hdE1lbnVNb2R1bGUsXG4gICAgICAgIE1hdE9wdGlvbk1vZHVsZSxcbiAgICAgICAgTWF0RXhwYW5zaW9uTW9kdWxlLFxuICAgICAgICBNYXRTZWxlY3RNb2R1bGUsXG4gICAgICAgIE1hdENoZWNrYm94TW9kdWxlLFxuICAgICAgICBNYXREYXRlcGlja2VyTW9kdWxlLFxuICAgICAgICBNYXRTbGlkZVRvZ2dsZU1vZHVsZSxcbiAgICAgICAgTWF0UmFkaW9Nb2R1bGUsXG4gICAgICAgIE1hdFNsaWRlck1vZHVsZVxuICAgIF07XG59XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogbW9kdWxlcygpLFxuICAgIGV4cG9ydHM6IG1vZHVsZXMoKVxufSlcbmV4cG9ydCBjbGFzcyBNYXRlcmlhbE1vZHVsZSB7XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIEFsZnJlc2NvQXBpU2VydmljZSwgQXV0aGVudGljYXRpb25TZXJ2aWNlLCBDb250ZW50U2VydmljZSwgTG9nU2VydmljZSxcbiAgICBQZXJtaXNzaW9uc0VudW0sIFRodW1ibmFpbFNlcnZpY2Vcbn0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRpdHksIE1pbmltYWxOb2RlRW50cnlFbnRpdHksICBOb2RlRW50cnksIE5vZGVQYWdpbmcgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZnJvbSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERvY3VtZW50TGlzdFNlcnZpY2Uge1xuXG4gICAgc3RhdGljIFJPT1RfSUQgPSAnLXJvb3QtJztcblxuICAgIGNvbnN0cnVjdG9yKGF1dGhTZXJ2aWNlOiBBdXRoZW50aWNhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBjb250ZW50U2VydmljZTogQ29udGVudFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdGh1bWJuYWlsU2VydmljZTogVGh1bWJuYWlsU2VydmljZSkge1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Tm9kZXNQcm9taXNlKGZvbGRlcjogc3RyaW5nLCBvcHRzPzogYW55LCBpbmNsdWRlRmllbGRzOiBzdHJpbmdbXSA9IFtdKTogUHJvbWlzZTxOb2RlUGFnaW5nPiB7XG5cbiAgICAgICAgbGV0IHJvb3ROb2RlSWQgPSBEb2N1bWVudExpc3RTZXJ2aWNlLlJPT1RfSUQ7XG4gICAgICAgIGlmIChvcHRzICYmIG9wdHMucm9vdEZvbGRlcklkKSB7XG4gICAgICAgICAgICByb290Tm9kZUlkID0gb3B0cy5yb290Rm9sZGVySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW5jbHVkZUZpZWxkc1JlcXVlc3QgPSBbJ3BhdGgnLCAncHJvcGVydGllcycsICdhbGxvd2FibGVPcGVyYXRpb25zJywgJ3Blcm1pc3Npb25zJywgJ2FzcGVjdE5hbWVzJywgLi4uaW5jbHVkZUZpZWxkc11cbiAgICAgICAgICAgIC5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gaW5kZXggPT09IGFycmF5LmluZGV4T2YoZWxlbWVudCkpO1xuXG4gICAgICAgIGxldCBwYXJhbXM6IGFueSA9IHtcbiAgICAgICAgICAgIGluY2x1ZGVTb3VyY2U6IHRydWUsXG4gICAgICAgICAgICBpbmNsdWRlOiBpbmNsdWRlRmllbGRzUmVxdWVzdFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChmb2xkZXIpIHtcbiAgICAgICAgICAgIHBhcmFtcy5yZWxhdGl2ZVBhdGggPSBmb2xkZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cykge1xuICAgICAgICAgICAgaWYgKG9wdHMubWF4SXRlbXMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMubWF4SXRlbXMgPSBvcHRzLm1heEl0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuc2tpcENvdW50KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnNraXBDb3VudCA9IG9wdHMuc2tpcENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLm5vZGVzLmdldE5vZGVDaGlsZHJlbihyb290Tm9kZUlkLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBub2RlLlxuICAgICAqIEBwYXJhbSBub2RlSWQgSUQgb2YgdGhlIG5vZGUgdG8gZGVsZXRlXG4gICAgICogQHJldHVybnMgRW1wdHkgcmVzcG9uc2Ugd2hlbiB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlXG4gICAgICovXG4gICAgZGVsZXRlTm9kZShub2RlSWQ6IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLm5vZGVzLmRlbGV0ZU5vZGUobm9kZUlkKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29weSBhIG5vZGUgdG8gZGVzdGluYXRpb24gbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGVJZCBUaGUgaWQgb2YgdGhlIG5vZGUgdG8gYmUgY29waWVkXG4gICAgICogQHBhcmFtIHRhcmdldFBhcmVudElkIFRoZSBpZCBvZiB0aGUgZm9sZGVyIHdoZXJlIHRoZSBub2RlIHdpbGwgYmUgY29waWVkXG4gICAgICogQHJldHVybnMgTm9kZUVudHJ5IGZvciB0aGUgY29waWVkIG5vZGVcbiAgICAgKi9cbiAgICBjb3B5Tm9kZShub2RlSWQ6IHN0cmluZywgdGFyZ2V0UGFyZW50SWQ6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5ub2Rlcy5jb3B5Tm9kZShub2RlSWQsIHsgdGFyZ2V0UGFyZW50SWQgfSkpLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVyciA9PiB0aGlzLmhhbmRsZUVycm9yKGVycikpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBub2RlIHRvIGRlc3RpbmF0aW9uIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZUlkIFRoZSBpZCBvZiB0aGUgbm9kZSB0byBiZSBtb3ZlZFxuICAgICAqIEBwYXJhbSB0YXJnZXRQYXJlbnRJZCBUaGUgaWQgb2YgdGhlIGZvbGRlciB3aGVyZSB0aGUgbm9kZSB3aWxsIGJlIG1vdmVkXG4gICAgICogQHJldHVybnMgTm9kZUVudHJ5IGZvciB0aGUgbW92ZWQgbm9kZVxuICAgICAqL1xuICAgIG1vdmVOb2RlKG5vZGVJZDogc3RyaW5nLCB0YXJnZXRQYXJlbnRJZDogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLm5vZGVzLm1vdmVOb2RlKG5vZGVJZCwgeyB0YXJnZXRQYXJlbnRJZCB9KSkucGlwZShcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGZvbGRlciBpbiB0aGUgcGF0aC5cbiAgICAgKiBAcGFyYW0gbmFtZSBGb2xkZXIgbmFtZVxuICAgICAqIEBwYXJhbSBwYXJlbnRJZCBQYXJlbnQgZm9sZGVyIElEXG4gICAgICogQHJldHVybnMgRGV0YWlscyBvZiB0aGUgY3JlYXRlZCBmb2xkZXIgbm9kZVxuICAgICAqL1xuICAgIGNyZWF0ZUZvbGRlcihuYW1lOiBzdHJpbmcsIHBhcmVudElkOiBzdHJpbmcpOiBPYnNlcnZhYmxlPE1pbmltYWxOb2RlRW50aXR5PiB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLm5vZGVzLmNyZWF0ZUZvbGRlcihuYW1lLCAnLycsIHBhcmVudElkKSlcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZm9sZGVyIG5vZGUgd2l0aCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIG5hbWUgcGF0aCBiZWxvdyB0aGUgcm9vdCBub2RlLlxuICAgICAqIEBwYXJhbSBmb2xkZXIgUGF0aCB0byBmb2xkZXIuXG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gaW5jbHVkZUZpZWxkcyBFeHRyYSBpbmZvcm1hdGlvbiB0byBpbmNsdWRlIChhdmFpbGFibGUgb3B0aW9ucyBhcmUgXCJhc3BlY3ROYW1lc1wiLCBcImlzTGlua1wiIGFuZCBcImFzc29jaWF0aW9uXCIpXG4gICAgICogQHJldHVybnMgRGV0YWlscyBvZiB0aGUgZm9sZGVyXG4gICAgICovXG4gICAgZ2V0Rm9sZGVyKGZvbGRlcjogc3RyaW5nLCBvcHRzPzogYW55LCBpbmNsdWRlRmllbGRzOiBzdHJpbmdbXSA9IFtdKTogT2JzZXJ2YWJsZTxOb2RlUGFnaW5nPiB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuZ2V0Tm9kZXNQcm9taXNlKGZvbGRlciwgb3B0cywgaW5jbHVkZUZpZWxkcykpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBjYXRjaEVycm9yKGVyciA9PiB0aGlzLmhhbmRsZUVycm9yKGVycikpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBub2RlIHZpYSBpdHMgbm9kZSBJRC5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIElEIG9mIHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIEBwYXJhbSBpbmNsdWRlRmllbGRzIEV4dHJhIGluZm9ybWF0aW9uIHRvIGluY2x1ZGUgKGF2YWlsYWJsZSBvcHRpb25zIGFyZSBcImFzcGVjdE5hbWVzXCIsIFwiaXNMaW5rXCIgYW5kIFwiYXNzb2NpYXRpb25cIilcbiAgICAgKiBAcmV0dXJucyBEZXRhaWxzIG9mIHRoZSBmb2xkZXJcbiAgICAgKi9cbiAgICBnZXROb2RlKG5vZGVJZDogc3RyaW5nLCBpbmNsdWRlRmllbGRzOiBzdHJpbmdbXSA9IFtdKTogT2JzZXJ2YWJsZTxOb2RlRW50cnk+IHtcblxuICAgICAgICBsZXQgaW5jbHVkZUZpZWxkc1JlcXVlc3QgPSBbJ3BhdGgnLCAncHJvcGVydGllcycsICdhbGxvd2FibGVPcGVyYXRpb25zJywgJ3Blcm1pc3Npb25zJywgLi4uaW5jbHVkZUZpZWxkc11cbiAgICAgICAgICAgIC5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gaW5kZXggPT09IGFycmF5LmluZGV4T2YoZWxlbWVudCkpO1xuXG4gICAgICAgIGxldCBvcHRzOiBhbnkgPSB7XG4gICAgICAgICAgICBpbmNsdWRlU291cmNlOiB0cnVlLFxuICAgICAgICAgICAgaW5jbHVkZTogaW5jbHVkZUZpZWxkc1JlcXVlc3RcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50U2VydmljZS5nZXROb2RlKG5vZGVJZCwgb3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGZvbGRlciBub2RlIHZpYSBpdHMgbm9kZSBJRC5cbiAgICAgKiBAZGVwcmVjYXRlZCAyLjMuMFxuICAgICAqIEBwYXJhbSBub2RlSWQgSUQgb2YgdGhlIGZvbGRlciBub2RlXG4gICAgICogQHBhcmFtIGluY2x1ZGVGaWVsZHMgRXh0cmEgaW5mb3JtYXRpb24gdG8gaW5jbHVkZSAoYXZhaWxhYmxlIG9wdGlvbnMgYXJlIFwiYXNwZWN0TmFtZXNcIiwgXCJpc0xpbmtcIiBhbmQgXCJhc3NvY2lhdGlvblwiKVxuICAgICAqIEByZXR1cm5zIERldGFpbHMgb2YgdGhlIGZvbGRlclxuICAgICAqL1xuICAgIGdldEZvbGRlck5vZGUobm9kZUlkOiBzdHJpbmcsIGluY2x1ZGVGaWVsZHM6IHN0cmluZ1tdID0gW10pOiBPYnNlcnZhYmxlPE1pbmltYWxOb2RlRW50cnlFbnRpdHk+IHtcblxuICAgICAgICBsZXQgaW5jbHVkZUZpZWxkc1JlcXVlc3QgPSBbJ3BhdGgnLCAncHJvcGVydGllcycsICdhbGxvd2FibGVPcGVyYXRpb25zJywgJ3Blcm1pc3Npb25zJywgJ2FzcGVjdE5hbWVzJywgLi4uaW5jbHVkZUZpZWxkc11cbiAgICAgICAgICAgIC5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gaW5kZXggPT09IGFycmF5LmluZGV4T2YoZWxlbWVudCkpO1xuXG4gICAgICAgIGxldCBvcHRzOiBhbnkgPSB7XG4gICAgICAgICAgICBpbmNsdWRlU291cmNlOiB0cnVlLFxuICAgICAgICAgICAgaW5jbHVkZTogaW5jbHVkZUZpZWxkc1JlcXVlc3RcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5ub2Rlcy5nZXROb2RlSW5mbyhub2RlSWQsIG9wdHMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRodW1ibmFpbCBVUkwgZm9yIHRoZSBnaXZlbiBkb2N1bWVudCBub2RlLlxuICAgICAqIEBwYXJhbSBub2RlIE5vZGUgdG8gZ2V0IFVSTCBmb3IuXG4gICAgICogQHJldHVybnMgVGh1bWJuYWlsIFVSTCBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXREb2N1bWVudFRodW1ibmFpbFVybChub2RlOiBNaW5pbWFsTm9kZUVudGl0eSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnRodW1ibmFpbFNlcnZpY2UuZ2V0RG9jdW1lbnRUaHVtYm5haWxVcmwobm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaWNvbiB0aGF0IHJlcHJlc2VudHMgYSBNSU1FIHR5cGUuXG4gICAgICogQHBhcmFtIG1pbWVUeXBlIE1JTUUgdHlwZSB0byBnZXQgdGhlIGljb24gZm9yXG4gICAgICogQHJldHVybnMgUGF0aCB0byB0aGUgaWNvbiBmaWxlXG4gICAgICovXG4gICAgZ2V0TWltZVR5cGVJY29uKG1pbWVUeXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50aHVtYm5haWxTZXJ2aWNlLmdldE1pbWVUeXBlSWNvbihtaW1lVHlwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGRlZmF1bHQgaWNvbiBmb3IgTUlNRSB0eXBlcyB3aXRoIG5vIHNwZWNpZmljIGljb24uXG4gICAgICogQHJldHVybnMgUGF0aCB0byB0aGUgaWNvbiBmaWxlXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdE1pbWVUeXBlSWNvbigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50aHVtYm5haWxTZXJ2aWNlLmdldERlZmF1bHRNaW1lVHlwZUljb24oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBub2RlIGhhcyB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb24uXG4gICAgICogQGRlcHJlY2F0ZWQgMi4zLjAgLSB1c2UgdGhlIGVxdWl2YWxlbnQgaW4gdGhlIGNvbnRlbnQgc2VydmljZVxuICAgICAqIEBwYXJhbSBub2RlIFRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gUGVybWlzc2lvbiBsZXZlbCB0byBxdWVyeVxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5vZGUgaGFzIHRoZSBwZXJtaXNzaW9uLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBoYXNQZXJtaXNzaW9uKG5vZGU6IGFueSwgcGVybWlzc2lvbjogUGVybWlzc2lvbnNFbnVtIHwgc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRTZXJ2aWNlLmhhc1Blcm1pc3Npb24obm9kZSwgcGVybWlzc2lvbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVFcnJvcihlcnJvcjogYW55KSB7XG4gICAgICAgIHRoaXMubG9nU2VydmljZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yIHx8ICdTZXJ2ZXIgZXJyb3InKTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEluamVjdCwgVmlld0VuY2Fwc3VsYXRpb24sIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNQVRfRElBTE9HX0RBVEEgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudHJ5RW50aXR5LCBTaXRlUGFnaW5nIH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IENvbnRlbnROb2RlU2VsZWN0b3JDb21wb25lbnREYXRhIH0gZnJvbSAnLi9jb250ZW50LW5vZGUtc2VsZWN0b3IuY29tcG9uZW50LWRhdGEuaW50ZXJmYWNlJztcbmltcG9ydCB7IFJvd0ZpbHRlciB9IGZyb20gJy4uL2RvY3VtZW50LWxpc3QvZGF0YS9yb3ctZmlsdGVyLm1vZGVsJztcbmltcG9ydCB7IEltYWdlUmVzb2x2ZXIgfSBmcm9tICcuLi9kb2N1bWVudC1saXN0L2RhdGEvaW1hZ2UtcmVzb2x2ZXIubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1jb250ZW50LW5vZGUtc2VsZWN0b3InLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9jb250ZW50LW5vZGUtc2VsZWN0b3IuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgQ29udGVudE5vZGVTZWxlY3RvckNvbXBvbmVudCB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBpbiAyLjEuMFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBpbiAyLjEuMFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY3VycmVudEZvbGRlcklkOiBzdHJpbmcgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgaW4gMi4xLjBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRyb3Bkb3duSGlkZU15RmlsZXM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIGluIDIuMS4wXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkcm9wZG93blNpdGVMaXN0OiBTaXRlUGFnaW5nID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIGluIDIuMS4wXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICByb3dGaWx0ZXI6IFJvd0ZpbHRlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBpbiAyLjEuMFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW1hZ2VSZXNvbHZlcjogSW1hZ2VSZXNvbHZlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBpbiAyLjEuMFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcGFnZVNpemU6IG51bWJlcjtcblxuICAgIGJ1dHRvbkFjdGlvbk5hbWU6IHN0cmluZztcbiAgICBjaG9zZW5Ob2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5W107XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KE1BVF9ESUFMT0dfREFUQSkgcHVibGljIGRhdGE6IENvbnRlbnROb2RlU2VsZWN0b3JDb21wb25lbnREYXRhKSB7XG4gICAgICAgIHRoaXMuYnV0dG9uQWN0aW9uTmFtZSA9IGRhdGEuYWN0aW9uTmFtZSA/IGBOT0RFX1NFTEVDVE9SLiR7ZGF0YS5hY3Rpb25OYW1lLnRvVXBwZXJDYXNlKCl9YCA6ICdOT0RFX1NFTEVDVE9SLkNIT09TRSc7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZGF0YS5zZWxlY3QuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBvblNlbGVjdChub2RlTGlzdDogTWluaW1hbE5vZGVFbnRyeUVudGl0eVtdKSB7XG4gICAgICAgIHRoaXMuY2hvc2VuTm9kZSA9IG5vZGVMaXN0O1xuICAgIH1cblxuICAgIG9uQ2xpY2soKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGF0YS5zZWxlY3QubmV4dCh0aGlzLmNob3Nlbk5vZGUpO1xuICAgICAgICB0aGlzLmRhdGEuc2VsZWN0LmNvbXBsZXRlKCk7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQtZXM2JztcblxuaW1wb3J0IHsgQ29tcG9uZW50LCBJbmplY3QsIE9uSW5pdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1BVF9ESUFMT0dfREFUQSwgTWF0RGlhbG9nUmVmIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgRm9ybUJ1aWxkZXIsIEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRyeUVudGl0eSwgTm9kZUVudHJ5IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IEFsZnJlc2NvQXBpU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLW5vZGUtbG9jaycsXG4gICAgc3R5bGVVcmxzOiBbJy4vZm9sZGVyLmRpYWxvZy5zY3NzJ10sXG4gICAgdGVtcGxhdGVVcmw6ICcuL25vZGUtbG9jay5kaWFsb2cuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgTm9kZUxvY2tEaWFsb2dDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgZm9ybTogRm9ybUdyb3VwO1xuICAgIG5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkgPSBudWxsO1xuICAgIG5vZGVOYW1lOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBmb3JtQnVpbGRlcjogRm9ybUJ1aWxkZXIsXG4gICAgICAgIHB1YmxpYyBkaWFsb2c6IE1hdERpYWxvZ1JlZjxOb2RlTG9ja0RpYWxvZ0NvbXBvbmVudD4sXG4gICAgICAgIHByaXZhdGUgYWxmcmVzY29BcGk6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgQE9wdGlvbmFsKClcbiAgICAgICAgQEluamVjdChNQVRfRElBTE9HX0RBVEEpXG4gICAgICAgIHB1YmxpYyBkYXRhOiBhbnlcbiAgICApIHt9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgY29uc3QgeyBub2RlIH0gPSB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMubm9kZU5hbWUgPSBub2RlLm5hbWU7XG5cbiAgICAgICAgdGhpcy5mb3JtID0gdGhpcy5mb3JtQnVpbGRlci5ncm91cCh7XG4gICAgICAgICAgICBpc0xvY2tlZDogbm9kZS5pc0xvY2tlZCB8fCBmYWxzZSxcbiAgICAgICAgICAgIGFsbG93T3duZXI6IG5vZGUucHJvcGVydGllc1snY206bG9ja1R5cGUnXSA9PT0gJ1dSSVRFX0xPQ0snLFxuICAgICAgICAgICAgaXNUaW1lTG9jazogISFub2RlLnByb3BlcnRpZXNbJ2NtOmV4cGlyeURhdGUnXSxcbiAgICAgICAgICAgIHRpbWU6ICEhbm9kZS5wcm9wZXJ0aWVzWydjbTpleHBpcnlEYXRlJ10gPyBtb21lbnQobm9kZS5wcm9wZXJ0aWVzWydjbTpleHBpcnlEYXRlJ10pIDogbW9tZW50KClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgbG9ja1RpbWVJblNlY29uZHMoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMuZm9ybS52YWx1ZS5pc1RpbWVMb2NrKSB7XG4gICAgICAgICAgICBsZXQgZHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24obW9tZW50KHRoaXMuZm9ybS52YWx1ZS50aW1lKS5kaWZmKG1vbWVudCgpKSk7XG4gICAgICAgICAgICByZXR1cm4gZHVyYXRpb24uYXNTZWNvbmRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBub2RlQm9keUxvY2soKTogb2JqZWN0IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lVG9FeHBpcmUnOiB0aGlzLmxvY2tUaW1lSW5TZWNvbmRzLFxuICAgICAgICAgICAgJ3R5cGUnOiB0aGlzLmZvcm0udmFsdWUuYWxsb3dPd25lciA/ICdBTExPV19PV05FUl9DSEFOR0VTJyA6ICdGVUxMJyxcbiAgICAgICAgICAgICdsaWZldGltZSc6ICdQRVJTSVNURU5UJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgdG9nZ2xlTG9jaygpOiBQcm9taXNlPE5vZGVFbnRyeT4ge1xuICAgICAgICBjb25zdCB7IGFsZnJlc2NvQXBpOiB7IG5vZGVzQXBpIH0sIGRhdGE6IHsgbm9kZSB9IH0gPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmZvcm0udmFsdWUuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBub2Rlc0FwaS5sb2NrTm9kZShub2RlLmlkLCB0aGlzLm5vZGVCb2R5TG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZXNBcGkudW5sb2NrTm9kZShub2RlLmlkKTtcbiAgICB9XG5cbiAgICBzdWJtaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMudG9nZ2xlTG9jaygpXG4gICAgICAgICAgICAudGhlbihub2RlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEubm9kZS5pc0xvY2tlZCA9IHRoaXMuZm9ybS52YWx1ZS5pc0xvY2tlZDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZy5jbG9zZShub2RlLmVudHJ5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gdGhpcy5kYXRhLm9uRXJyb3IoZXJyb3IpKTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBNYXREaWFsb2cgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIEluamVjdGFibGUsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udGVudFNlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCwgT2JzZXJ2YWJsZSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU2hhcmVEYXRhUm93IH0gZnJvbSAnLi4vZG9jdW1lbnQtbGlzdC9kYXRhL3NoYXJlLWRhdGEtcm93Lm1vZGVsJztcbmltcG9ydCB7IE1pbmltYWxOb2RlRW50cnlFbnRpdHksIFNpdGVQYWdpbmcgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgRGF0YUNvbHVtbiwgU2l0ZXNTZXJ2aWNlLCBUcmFuc2xhdGlvblNlcnZpY2UsIFBlcm1pc3Npb25zRW51bSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBEb2N1bWVudExpc3RTZXJ2aWNlIH0gZnJvbSAnLi4vZG9jdW1lbnQtbGlzdC9zZXJ2aWNlcy9kb2N1bWVudC1saXN0LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udGVudE5vZGVTZWxlY3RvckNvbXBvbmVudCB9IGZyb20gJy4vY29udGVudC1ub2RlLXNlbGVjdG9yLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb250ZW50Tm9kZVNlbGVjdG9yQ29tcG9uZW50RGF0YSB9IGZyb20gJy4vY29udGVudC1ub2RlLXNlbGVjdG9yLmNvbXBvbmVudC1kYXRhLmludGVyZmFjZSc7XG5pbXBvcnQgeyBOb2RlTG9ja0RpYWxvZ0NvbXBvbmVudCB9IGZyb20gJy4uL2RpYWxvZ3Mvbm9kZS1sb2NrLmRpYWxvZyc7XG5pbXBvcnQgeyBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb250ZW50Tm9kZURpYWxvZ1NlcnZpY2Uge1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMuICovXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRpYWxvZzogTWF0RGlhbG9nLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY29udGVudFNlcnZpY2U6IENvbnRlbnRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZG9jdW1lbnRMaXN0U2VydmljZTogRG9jdW1lbnRMaXN0U2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHNpdGVTZXJ2aWNlOiBTaXRlc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSB0cmFuc2xhdGlvbjogVHJhbnNsYXRpb25TZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBmaWxlIGJyb3dzZXIgYXQgYSBjaG9zZW4gZm9sZGVyIGxvY2F0aW9uLlxuICAgICAqIEBwYXJhbSBmb2xkZXJOb2RlSWQgSUQgb2YgdGhlIGZvbGRlciB0byB1c2VcbiAgICAgKiBAcmV0dXJucyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgc2VsZWN0ZWQgZmlsZShzKVxuICAgICAqL1xuICAgIG9wZW5GaWxlQnJvd3NlRGlhbG9nQnlGb2xkZXJJZChmb2xkZXJOb2RlSWQ6IHN0cmluZyk6IE9ic2VydmFibGU8TWluaW1hbE5vZGVFbnRyeUVudGl0eVtdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50TGlzdFNlcnZpY2UuZ2V0Rm9sZGVyTm9kZShmb2xkZXJOb2RlSWQpLnBpcGUoc3dpdGNoTWFwKChub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuVXBsb2FkRmlsZURpYWxvZygnQ2hvb3NlJywgbm9kZSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIGxvY2sgbm9kZSBkaWFsb2cuXG4gICAgICogQHBhcmFtIGNvbnRlbnRFbnRyeSBOb2RlIHRvIGxvY2tcbiAgICAgKiBAcmV0dXJucyBFcnJvci9zdGF0dXMgbWVzc2FnZSAoaWYgYW55KVxuICAgICAqL1xuICAgIHB1YmxpYyBvcGVuTG9ja05vZGVEaWFsb2coY29udGVudEVudHJ5OiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KTogU3ViamVjdDxzdHJpbmc+IHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZTogU3ViamVjdDxzdHJpbmc+ID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRTZXJ2aWNlLmhhc1Blcm1pc3Npb24oY29udGVudEVudHJ5LCBQZXJtaXNzaW9uc0VudW0uTE9DSykpIHtcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nLm9wZW4oTm9kZUxvY2tEaWFsb2dDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IGNvbnRlbnRFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yLmVtaXQoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2YWJsZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnNDAwcHgnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmFibGUuZXJyb3IoJ09QRVJBVElPTi5GQUlMLk5PREUuTk9fUEVSTUlTU0lPTicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBmaWxlIGJyb3dzZXIgYXQgYSBjaG9zZW4gc2l0ZSBsb2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgc2VsZWN0ZWQgZmlsZShzKVxuICAgICAqL1xuICAgIG9wZW5GaWxlQnJvd3NlRGlhbG9nQnlTaXRlKCk6IE9ic2VydmFibGU8TWluaW1hbE5vZGVFbnRyeUVudGl0eVtdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpdGVTZXJ2aWNlLmdldFNpdGVzKCkucGlwZShzd2l0Y2hNYXAoKHJlc3BvbnNlOiBTaXRlUGFnaW5nKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuRmlsZUJyb3dzZURpYWxvZ0J5Rm9sZGVySWQocmVzcG9uc2UubGlzdC5lbnRyaWVzWzBdLmVudHJ5Lmd1aWQpO1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBmb2xkZXIgYnJvd3NlciBhdCBhIGNob3NlbiBzaXRlIGxvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIEluZm9ybWF0aW9uIGFib3V0IHRoZSBzZWxlY3RlZCBmb2xkZXIocylcbiAgICAgKi9cbiAgICBvcGVuRm9sZGVyQnJvd3NlRGlhbG9nQnlTaXRlKCk6IE9ic2VydmFibGU8TWluaW1hbE5vZGVFbnRyeUVudGl0eVtdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpdGVTZXJ2aWNlLmdldFNpdGVzKCkucGlwZShzd2l0Y2hNYXAoKHJlc3BvbnNlOiBTaXRlUGFnaW5nKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuRm9sZGVyQnJvd3NlRGlhbG9nQnlGb2xkZXJJZChyZXNwb25zZS5saXN0LmVudHJpZXNbMF0uZW50cnkuZ3VpZCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIGZvbGRlciBicm93c2VyIGF0IGEgY2hvc2VuIGZvbGRlciBsb2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gZm9sZGVyTm9kZUlkIElEIG9mIHRoZSBmb2xkZXIgdG8gdXNlXG4gICAgICogQHJldHVybnMgSW5mb3JtYXRpb24gYWJvdXQgdGhlIHNlbGVjdGVkIGZvbGRlcihzKVxuICAgICAqL1xuICAgIG9wZW5Gb2xkZXJCcm93c2VEaWFsb2dCeUZvbGRlcklkKGZvbGRlck5vZGVJZDogc3RyaW5nKTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5W10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRMaXN0U2VydmljZS5nZXRGb2xkZXJOb2RlKGZvbGRlck5vZGVJZCkucGlwZShzd2l0Y2hNYXAoKG5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW5VcGxvYWRGb2xkZXJEaWFsb2coJ0Nob29zZScsIG5vZGUpO1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBkaWFsb2cgdG8gY29weSBvciBtb3ZlIGFuIGl0ZW0gdG8gYSBuZXcgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIGFjdGlvbiBOYW1lIG9mIHRoZSBhY3Rpb24gKGVnLCBcIkNvcHlcIiBvciBcIk1vdmVcIikgdG8gc2hvdyBpbiB0aGUgdGl0bGVcbiAgICAgKiBAcGFyYW0gY29udGVudEVudHJ5IEl0ZW0gdG8gYmUgY29waWVkIG9yIG1vdmVkXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gUGVybWlzc2lvbiBmb3IgdGhlIG9wZXJhdGlvblxuICAgICAqIEByZXR1cm5zIEluZm9ybWF0aW9uIGFib3V0IGZpbGVzIHRoYXQgd2VyZSBjb3BpZWQvbW92ZWRcbiAgICAgKi9cbiAgICBvcGVuQ29weU1vdmVEaWFsb2coYWN0aW9uOiBzdHJpbmcsIGNvbnRlbnRFbnRyeTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSwgcGVybWlzc2lvbj86IHN0cmluZyk6IE9ic2VydmFibGU8TWluaW1hbE5vZGVFbnRyeUVudGl0eVtdPiB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRTZXJ2aWNlLmhhc1Blcm1pc3Npb24oY29udGVudEVudHJ5LCBwZXJtaXNzaW9uKSkge1xuXG4gICAgICAgICAgICBjb25zdCBzZWxlY3QgPSBuZXcgU3ViamVjdDxNaW5pbWFsTm9kZUVudHJ5RW50aXR5W10+KCk7XG4gICAgICAgICAgICBzZWxlY3Quc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLmdldFRpdGxlVHJhbnNsYXRpb24oYWN0aW9uLCBjb250ZW50RW50cnkubmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGE6IENvbnRlbnROb2RlU2VsZWN0b3JDb21wb25lbnREYXRhID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgY3VycmVudEZvbGRlcklkOiBjb250ZW50RW50cnkucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgaW1hZ2VSZXNvbHZlcjogdGhpcy5pbWFnZVJlc29sdmVyLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgcm93RmlsdGVyOiB0aGlzLnJvd0ZpbHRlci5iaW5kKHRoaXMsIGNvbnRlbnRFbnRyeS5pZCksXG4gICAgICAgICAgICAgICAgaXNTZWxlY3Rpb25WYWxpZDogdGhpcy5pc0NvcHlNb3ZlU2VsZWN0aW9uVmFsaWQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHNlbGVjdFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5vcGVuQ29udGVudE5vZGVEaWFsb2coZGF0YSwgJ2FkZi1jb250ZW50LW5vZGUtc2VsZWN0b3ItZGlhbG9nJywgJzYzMHB4Jyk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZXJyb3JzID0gbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6IHsgc3RhdHVzQ29kZTogNDAzIH0gfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRyYW5zbGF0aW9uIG9mIHRoZSBkaWFsb2cgdGl0bGUuXG4gICAgICogQHBhcmFtIGFjdGlvbiBOYW1lIG9mIHRoZSBhY3Rpb24gdG8gZGlzcGxheSBpbiB0aGUgZGlhbG9nIHRpdGxlXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgaXRlbSBvbiB3aGljaCB0aGUgYWN0aW9uIGlzIGJlaW5nIHBlcmZvcm1lZFxuICAgICAqIEByZXR1cm5zIFRyYW5zbGF0ZWQgdmVyc2lvbiBvZiB0aGUgdGl0bGVcbiAgICAgKi9cbiAgICBnZXRUaXRsZVRyYW5zbGF0aW9uKGFjdGlvbjogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGlvbi5pbnN0YW50KGBOT0RFX1NFTEVDVE9SLiR7YWN0aW9uLnRvVXBwZXJDYXNlKCl9X0lURU1gLCB7IG5hbWUgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBkaWFsb2cgdG8gY2hvb3NlIGZvbGRlcnMgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSBhY3Rpb24gTmFtZSBvZiB0aGUgYWN0aW9uIHRvIHNob3cgaW4gdGhlIHRpdGxlXG4gICAgICogQHBhcmFtIGNvbnRlbnRFbnRyeSAgSXRlbSB0byB1cGxvYWRcbiAgICAgKiBAcmV0dXJucyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hvc2VkIGZvbGRlcihzKVxuICAgICAqL1xuICAgIG9wZW5VcGxvYWRGb2xkZXJEaWFsb2coYWN0aW9uOiBzdHJpbmcsIGNvbnRlbnRFbnRyeTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSk6IE9ic2VydmFibGU8TWluaW1hbE5vZGVFbnRyeUVudGl0eVtdPiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdCA9IG5ldyBTdWJqZWN0PE1pbmltYWxOb2RlRW50cnlFbnRpdHlbXT4oKTtcbiAgICAgICAgc2VsZWN0LnN1YnNjcmliZSh7XG4gICAgICAgICAgICBjb21wbGV0ZTogdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGRhdGE6IENvbnRlbnROb2RlU2VsZWN0b3JDb21wb25lbnREYXRhID0ge1xuICAgICAgICAgICAgdGl0bGU6IGAke2FjdGlvbn0gJyR7Y29udGVudEVudHJ5Lm5hbWV9JyB0byAuLi5gLFxuICAgICAgICAgICAgYWN0aW9uTmFtZTogYWN0aW9uLFxuICAgICAgICAgICAgY3VycmVudEZvbGRlcklkOiBjb250ZW50RW50cnkuaWQsXG4gICAgICAgICAgICBpbWFnZVJlc29sdmVyOiB0aGlzLmltYWdlUmVzb2x2ZXIuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGlzU2VsZWN0aW9uVmFsaWQ6IHRoaXMuaGFzUGVybWlzc2lvbk9uTm9kZUZvbGRlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcm93RmlsdGVyOiB0aGlzLnJvd0ZpbHRlci5iaW5kKHRoaXMsIGNvbnRlbnRFbnRyeS5pZCksXG4gICAgICAgICAgICBzZWxlY3Q6IHNlbGVjdFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub3BlbkNvbnRlbnROb2RlRGlhbG9nKGRhdGEsICdhZGYtY29udGVudC1ub2RlLXNlbGVjdG9yLWRpYWxvZycsICc2MzBweCcpO1xuICAgICAgICByZXR1cm4gc2VsZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgZGlhbG9nIHRvIGNob29zZSBhIGZpbGUgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSBhY3Rpb24gTmFtZSBvZiB0aGUgYWN0aW9uIHRvIHNob3cgaW4gdGhlIHRpdGxlXG4gICAgICogQHBhcmFtIGNvbnRlbnRFbnRyeSBJdGVtIHRvIHVwbG9hZFxuICAgICAqIEByZXR1cm5zIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjaG9zZW4gZmlsZShzKVxuICAgICAqL1xuICAgIG9wZW5VcGxvYWRGaWxlRGlhbG9nKGFjdGlvbjogc3RyaW5nLCBjb250ZW50RW50cnk6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkpOiBPYnNlcnZhYmxlPE1pbmltYWxOb2RlRW50cnlFbnRpdHlbXT4ge1xuICAgICAgICBjb25zdCBzZWxlY3QgPSBuZXcgU3ViamVjdDxNaW5pbWFsTm9kZUVudHJ5RW50aXR5W10+KCk7XG4gICAgICAgIHNlbGVjdC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgY29tcGxldGU6IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBkYXRhOiBDb250ZW50Tm9kZVNlbGVjdG9yQ29tcG9uZW50RGF0YSA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBgJHthY3Rpb259ICcke2NvbnRlbnRFbnRyeS5uYW1lfScgdG8gLi4uYCxcbiAgICAgICAgICAgIGFjdGlvbk5hbWU6IGFjdGlvbixcbiAgICAgICAgICAgIGN1cnJlbnRGb2xkZXJJZDogY29udGVudEVudHJ5LmlkLFxuICAgICAgICAgICAgaW1hZ2VSZXNvbHZlcjogdGhpcy5pbWFnZVJlc29sdmVyLmJpbmQodGhpcyksXG4gICAgICAgICAgICBpc1NlbGVjdGlvblZhbGlkOiB0aGlzLmlzTm9kZUZpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGVjdDogc2VsZWN0XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vcGVuQ29udGVudE5vZGVEaWFsb2coZGF0YSwgJ2FkZi1jb250ZW50LW5vZGUtc2VsZWN0b3ItZGlhbG9nJywgJzYzMHB4Jyk7XG4gICAgICAgIHJldHVybiBzZWxlY3Q7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvcGVuQ29udGVudE5vZGVEaWFsb2coZGF0YTogQ29udGVudE5vZGVTZWxlY3RvckNvbXBvbmVudERhdGEsIGN1cnJlbnRQYW5lbENsYXNzOiBzdHJpbmcsIGNob3NlbldpZHRoOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5kaWFsb2cub3BlbihDb250ZW50Tm9kZVNlbGVjdG9yQ29tcG9uZW50LCB7IGRhdGEsIHBhbmVsQ2xhc3M6IGN1cnJlbnRQYW5lbENsYXNzLCB3aWR0aDogY2hvc2VuV2lkdGggfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbWFnZVJlc29sdmVyKHJvdzogU2hhcmVEYXRhUm93LCBjb2w6IERhdGFDb2x1bW4pOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgY29uc3QgZW50cnk6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkgPSByb3cubm9kZS5lbnRyeTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRTZXJ2aWNlLmhhc1Blcm1pc3Npb24oZW50cnksICdjcmVhdGUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRMaXN0U2VydmljZS5nZXRNaW1lVHlwZUljb24oJ2Rpc2FibGUvZm9sZGVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJvd0ZpbHRlcihjdXJyZW50Tm9kZUlkLCByb3c6IFNoYXJlRGF0YVJvdyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5ID0gcm93Lm5vZGUuZW50cnk7XG5cbiAgICAgICAgaWYgKG5vZGUuaWQgPT09IGN1cnJlbnROb2RlSWQgfHwgbm9kZS5pc0ZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc05vZGVGaWxlKGVudHJ5OiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBlbnRyeS5pc0ZpbGU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYXNQZXJtaXNzaW9uT25Ob2RlRm9sZGVyKGVudHJ5OiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTm9kZUZvbGRlcihlbnRyeSkgJiYgdGhpcy5jb250ZW50U2VydmljZS5oYXNQZXJtaXNzaW9uKGVudHJ5LCAnY3JlYXRlJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc05vZGVGb2xkZXIoZW50cnk6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LmlzRm9sZGVyO1xuICAgIH1cblxuICAgIHByaXZhdGUgaXNDb3B5TW92ZVNlbGVjdGlvblZhbGlkKGVudHJ5OiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0VudGl0eUNyZWF0ZVBlcm1pc3Npb24oZW50cnkpICYmICF0aGlzLmlzU2l0ZShlbnRyeSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYXNFbnRpdHlDcmVhdGVQZXJtaXNzaW9uKGVudHJ5OiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRTZXJ2aWNlLmhhc1Blcm1pc3Npb24oZW50cnksICdjcmVhdGUnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzU2l0ZShlbnRyeSkge1xuICAgICAgICByZXR1cm4gISFlbnRyeS5ndWlkIHx8IGVudHJ5Lm5vZGVUeXBlID09PSAnc3Q6c2l0ZScgfHwgZW50cnkubm9kZVR5cGUgPT09ICdzdDpzaXRlcyc7XG4gICAgfVxuXG4gICAgLyoqIENsb3NlcyB0aGUgY3VycmVudGx5IG9wZW4gZGlhbG9nLiAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmRpYWxvZy5jbG9zZUFsbCgpO1xuICAgIH1cblxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogdHNsaW50OmRpc2FibGU6bm8taW5wdXQtcmVuYW1lICAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIFJlbmRlcmVyMiwgSG9zdExpc3RlbmVyLCBJbnB1dCwgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRyeUVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBQZXJtaXNzaW9uc0VudW0sIENvbnRlbnRTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IENvbnRlbnROb2RlRGlhbG9nU2VydmljZSB9IGZyb20gJy4uL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci9jb250ZW50LW5vZGUtZGlhbG9nLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1thZGYtbm9kZS1sb2NrXSdcbn0pXG5leHBvcnQgY2xhc3MgTm9kZUxvY2tEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAgIC8qKiBOb2RlIHRvIGxvY2svdW5sb2NrLiAqL1xuICAgIEBJbnB1dCgnYWRmLW5vZGUtbG9jaycpXG4gICAgbm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eTtcblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyAnJGV2ZW50JyBdKVxuICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5jb250ZW50Tm9kZURpYWxvZ1NlcnZpY2Uub3BlbkxvY2tOb2RlRGlhbG9nKHRoaXMubm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBlbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgIHByaXZhdGUgY29udGVudFNlcnZpY2U6IENvbnRlbnRTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGNvbnRlbnROb2RlRGlhbG9nU2VydmljZTogQ29udGVudE5vZGVEaWFsb2dTZXJ2aWNlXG4gICAgKSB7fVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBjb25zdCBoYXNQZXJtaXNzaW9uID0gdGhpcy5jb250ZW50U2VydmljZS5oYXNQZXJtaXNzaW9uKHRoaXMubm9kZSwgUGVybWlzc2lvbnNFbnVtLkxPQ0spO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCAhaGFzUGVybWlzc2lvbik7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXRlcmlhbE1vZHVsZSB9IGZyb20gJy4uL21hdGVyaWFsLm1vZHVsZSc7XG5cbmltcG9ydCB7IE5vZGVEb3dubG9hZERpcmVjdGl2ZSB9IGZyb20gJy4vbm9kZS1kb3dubG9hZC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTm9kZUxvY2tEaXJlY3RpdmUgfSBmcm9tICcuL25vZGUtbG9jay5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBNYXRlcmlhbE1vZHVsZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIE5vZGVEb3dubG9hZERpcmVjdGl2ZSxcbiAgICAgICAgTm9kZUxvY2tEaXJlY3RpdmVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgTm9kZURvd25sb2FkRGlyZWN0aXZlLFxuICAgICAgICBOb2RlTG9ja0RpcmVjdGl2ZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQ29udGVudERpcmVjdGl2ZU1vZHVsZSB7XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBbGZyZXNjb0FwaVNlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzcG9uc2UgfSBmcm9tICdAYW5ndWxhci9odHRwJztcbmltcG9ydCB7IFJhdGluZ0JvZHkgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgZnJvbSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFJhdGluZ1NlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHVzZXIncyByYXRpbmcgZm9yIGEgbm9kZS5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIE5vZGUgdG8gZ2V0IHRoZSByYXRpbmcgZnJvbVxuICAgICAqIEBwYXJhbSByYXRpbmdUeXBlIFR5cGUgb2YgcmF0aW5nIChjYW4gYmUgXCJsaWtlc1wiIG9yIFwiZml2ZVN0YXJcIilcbiAgICAgKiBAcmV0dXJucyBUaGUgcmF0aW5nIHZhbHVlXG4gICAgICovXG4gICAgZ2V0UmF0aW5nKG5vZGVJZDogc3RyaW5nLCByYXRpbmdUeXBlOiBhbnkpOiBhbnkge1xuICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5jb3JlLnJhdGluZ3NBcGkuZ2V0UmF0aW5nKG5vZGVJZCwgcmF0aW5nVHlwZSkpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBjYXRjaEVycm9yKHRoaXMuaGFuZGxlRXJyb3IpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGN1cnJlbnQgdXNlcidzIHJhdGluZyBmb3IgYSBub2RlLlxuICAgICAqIEBwYXJhbSBub2RlSWQgVGFyZ2V0IG5vZGUgZm9yIHRoZSByYXRpbmdcbiAgICAgKiBAcGFyYW0gcmF0aW5nVHlwZSBUeXBlIG9mIHJhdGluZyAoY2FuIGJlIFwibGlrZXNcIiBvciBcImZpdmVTdGFyXCIpXG4gICAgICogQHBhcmFtIHZvdGUgUmF0aW5nIHZhbHVlIChib29sZWFuIGZvciBcImxpa2VzXCIsIG51bWVyaWMgMC4uNSBmb3IgXCJmaXZlU3RhclwiKVxuICAgICAqIEByZXR1cm5zIERldGFpbHMgYWJvdXQgdGhlIHJhdGluZywgaW5jbHVkaW5nIHRoZSBuZXcgdmFsdWVcbiAgICAgKi9cbiAgICBwb3N0UmF0aW5nKG5vZGVJZDogc3RyaW5nLCByYXRpbmdUeXBlOiBhbnksIHZvdGU6IGFueSk6IGFueSB7XG4gICAgICAgIGxldCByYXRpbmdCb2R5OiBSYXRpbmdCb2R5ID0ge1xuICAgICAgICAgICAgJ2lkJzogcmF0aW5nVHlwZSxcbiAgICAgICAgICAgICdteVJhdGluZyc6IHZvdGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuY29yZS5yYXRpbmdzQXBpLnJhdGUobm9kZUlkLCByYXRpbmdCb2R5KSlcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIGNhdGNoRXJyb3IodGhpcy5oYW5kbGVFcnJvcilcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgY3VycmVudCB1c2VyJ3MgcmF0aW5nIGZvciBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGVJZCBUYXJnZXQgbm9kZVxuICAgICAqIEBwYXJhbSByYXRpbmdUeXBlIFR5cGUgb2YgcmF0aW5nIHRvIHJlbW92ZSAoY2FuIGJlIFwibGlrZXNcIiBvciBcImZpdmVTdGFyXCIpXG4gICAgICogQHJldHVybnMgTnVsbCByZXNwb25zZSBpbmRpY2F0aW5nIHRoYXQgdGhlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZVxuICAgICAqL1xuICAgIGRlbGV0ZVJhdGluZyhub2RlSWQ6IHN0cmluZywgcmF0aW5nVHlwZTogYW55KTogYW55IHtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuY29yZS5yYXRpbmdzQXBpLnJlbW92ZVJhdGluZyhub2RlSWQsIHJhdGluZ1R5cGUpKVxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgY2F0Y2hFcnJvcih0aGlzLmhhbmRsZUVycm9yKVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUVycm9yKGVycm9yOiBSZXNwb25zZSk6IGFueSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvciB8fCAnU2VydmVyIGVycm9yJyk7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE91dHB1dCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJhdGluZ1NlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL3JhdGluZy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtcmF0aW5nJyxcbiAgICBzdHlsZVVybHM6IFsnLi9yYXRpbmcuY29tcG9uZW50LnNjc3MnXSxcbiAgICB0ZW1wbGF0ZVVybDogJy4vcmF0aW5nLmNvbXBvbmVudC5odG1sJyxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIFJhdGluZ0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG5cbiAgICAvKiogSWRlbnRpZmllciBvZiB0aGUgbm9kZSB0byBhcHBseSB0aGUgcmF0aW5nIHRvLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9kZUlkOiBzdHJpbmc7XG5cbiAgICBhdmVyYWdlOiBudW1iZXIgPSAwO1xuXG4gICAgcmF0aW5nVHlwZTogc3RyaW5nID0gJ2ZpdmVTdGFyJztcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIFwidm90ZVwiIGdldHMgY2hhbmdlZC4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBjaGFuZ2VWb3RlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgc3RhcnM6IEFycmF5PGFueT4gPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmF0aW5nU2VydmljZTogUmF0aW5nU2VydmljZSkge1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICBsZXQgcmF0aW5nT2JzZXJ2ZXIgPSB0aGlzLnJhdGluZ1NlcnZpY2UuZ2V0UmF0aW5nKHRoaXMubm9kZUlkLCB0aGlzLnJhdGluZ1R5cGUpO1xuXG4gICAgICAgIHJhdGluZ09ic2VydmVyLnN1YnNjcmliZShcbiAgICAgICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZW50cnkuYWdncmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXZlcmFnZSA9IGRhdGEuZW50cnkuYWdncmVnYXRlLmF2ZXJhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlU3RhcnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHJhdGluZ09ic2VydmVyO1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZVN0YXJzKCkge1xuICAgICAgICB0aGlzLnN0YXJzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgdGhpcy5hdmVyYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFycy5wdXNoKHtmaWxsOiB0cnVlfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnMucHVzaCh7ZmlsbDogZmFsc2V9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2hhbmdlVm90ZS5lbWl0KHRoaXMuYXZlcmFnZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlVm90ZSh2b3RlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5yYXRpbmdTZXJ2aWNlLnBvc3RSYXRpbmcodGhpcy5ub2RlSWQsIHRoaXMucmF0aW5nVHlwZSwgdm90ZSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5lbnRyeS5hZ2dyZWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXZlcmFnZSAhPT0gZGF0YS5lbnRyeS5hZ2dyZWdhdGUuYXZlcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdmVyYWdlID0gZGF0YS5lbnRyeS5hZ2dyZWdhdGUuYXZlcmFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlU3RhcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT3V0cHV0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmF0aW5nU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvcmF0aW5nLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1saWtlJyxcbiAgICBzdHlsZVVybHM6IFsnLi9saWtlLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgdGVtcGxhdGVVcmw6ICcuL2xpa2UuY29tcG9uZW50Lmh0bWwnLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgTGlrZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gICAgLyoqIElkZW50aWZpZXIgb2YgYSBub2RlIHRvIGFwcGx5IGxpa2VzIHRvLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9kZUlkOiBzdHJpbmc7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSBcInZvdGVcIiBnZXRzIGNoYW5nZWQuICovXG4gICAgQE91dHB1dCgpXG4gICAgY2hhbmdlVm90ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIGxpa2VzQ291bnRlcjogbnVtYmVyID0gMDtcbiAgICByYXRpbmdUeXBlOiBzdHJpbmcgPSAnbGlrZXMnO1xuICAgIGlzTGlrZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByYXRpbmdTZXJ2aWNlOiBSYXRpbmdTZXJ2aWNlKSB7fVxuXG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMuY2xlYW4oKTtcblxuICAgICAgICB0aGlzLnJhdGluZ1NlcnZpY2UuZ2V0UmF0aW5nKHRoaXMubm9kZUlkLCB0aGlzLnJhdGluZ1R5cGUpLnN1YnNjcmliZShcbiAgICAgICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZW50cnkuYWdncmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlrZXNDb3VudGVyID0gZGF0YS5lbnRyeS5hZ2dyZWdhdGUubnVtYmVyT2ZSYXRpbmdzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5lbnRyeS5yYXRlZEF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTGlrZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbGlrZUNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xpa2UpIHtcbiAgICAgICAgICAgIHRoaXMucmF0aW5nU2VydmljZS5kZWxldGVSYXRpbmcodGhpcy5ub2RlSWQsIHRoaXMucmF0aW5nVHlwZSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saWtlc0NvdW50ZXIgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0xpa2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VWb3RlLmVtaXQodGhpcy5saWtlc0NvdW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJhdGluZ1NlcnZpY2UucG9zdFJhdGluZyh0aGlzLm5vZGVJZCwgdGhpcy5yYXRpbmdUeXBlLCB0cnVlKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgICAgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saWtlc0NvdW50ZXIgPSBkYXRhLmVudHJ5LmFnZ3JlZ2F0ZS5udW1iZXJPZlJhdGluZ3M7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNMaWtlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VWb3RlLmVtaXQodGhpcy5saWtlc0NvdW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhbigpIHtcbiAgICAgICAgdGhpcy5pc0xpa2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saWtlc0NvdW50ZXIgPSAwO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0ZXJpYWxNb2R1bGUgfSBmcm9tICcuLi9tYXRlcmlhbC5tb2R1bGUnO1xuXG5pbXBvcnQgeyBMaWtlQ29tcG9uZW50IH0gZnJvbSAnLi9saWtlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBSYXRpbmdDb21wb25lbnQgfSBmcm9tICcuL3JhdGluZy5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBNYXRlcmlhbE1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSYXRpbmdDb21wb25lbnQsXG4gICAgICAgIExpa2VDb21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBSYXRpbmdDb21wb25lbnQsXG4gICAgICAgIExpa2VDb21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFNvY2lhbE1vZHVsZSB7fVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlLCBMb2dTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgSW5qZWN0YWJsZSwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmcm9tLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGFnUGFnaW5nIH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRhZ1NlcnZpY2Uge1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiB0YWcgaW5mb3JtYXRpb24gaXMgdXBkYXRlZC4gKi9cbiAgICBAT3V0cHV0KClcbiAgICByZWZyZXNoID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgdGFncyBhZGRlZCB0byBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGVJZCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcmV0dXJucyBUYWdQYWdpbmcgb2JqZWN0IChkZWZpbmVkIGluIEpTQVBJKSBjb250YWluaW5nIHRoZSB0YWdzXG4gICAgICovXG4gICAgZ2V0VGFnc0J5Tm9kZUlkKG5vZGVJZDogc3RyaW5nKTogYW55IHtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuY29yZS50YWdzQXBpLmdldE5vZGVUYWdzKG5vZGVJZCkpLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVyciA9PiB0aGlzLmhhbmRsZUVycm9yKGVycikpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgYWxsIHRoZSB0YWdzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgcmVwb3NpdG9yeS5cbiAgICAgKiBAcGFyYW0gb3B0cyBPcHRpb25zIHN1cHBvcnRlZCBieSBKU0FQSVxuICAgICAqIEByZXR1cm5zIFRhZ1BhZ2luZyBvYmplY3QgKGRlZmluZWQgaW4gSlNBUEkpIGNvbnRhaW5pbmcgdGhlIHRhZ3NcbiAgICAgKi9cbiAgICBnZXRBbGxUaGVUYWdzKG9wdHM/OiBhbnkpOiBPYnNlcnZhYmxlPFRhZ1BhZ2luZz4ge1xuICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5jb3JlLnRhZ3NBcGkuZ2V0VGFncyhvcHRzKSlcbiAgICAgICAgICAgIC5waXBlKGNhdGNoRXJyb3IoZXJyID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0YWcgdG8gYSBub2RlLlxuICAgICAqIEBwYXJhbSBub2RlSWQgSUQgb2YgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIHRhZ05hbWUgTmFtZSBvZiB0aGUgdGFnIHRvIGFkZFxuICAgICAqIEByZXR1cm5zIFRhZ0VudHJ5IG9iamVjdCAoZGVmaW5lZCBpbiBKU0FQSSkgd2l0aCBkZXRhaWxzIG9mIHRoZSBuZXcgdGFnXG4gICAgICovXG4gICAgYWRkVGFnKG5vZGVJZDogc3RyaW5nLCB0YWdOYW1lOiBzdHJpbmcpOiBhbnkge1xuICAgICAgICBjb25zdCBhbGZyZXNjb0FwaTogYW55ID0gdGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IHRhZ0JvZHkgPSBuZXcgYWxmcmVzY29BcGkuY29yZS5UYWdCb2R5KCk7XG4gICAgICAgIHRhZ0JvZHkudGFnID0gdGFnTmFtZTtcblxuICAgICAgICBsZXQgcHJvbWlzZUFkZCA9IGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuY29yZS50YWdzQXBpLmFkZFRhZyhub2RlSWQsIHRhZ0JvZHkpKTtcblxuICAgICAgICBwcm9taXNlQWRkLnN1YnNjcmliZSgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoLmVtaXQoZGF0YSk7XG4gICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2VBZGQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHRhZyBmcm9tIGEgbm9kZS5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIElEIG9mIHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIEBwYXJhbSB0YWcgTmFtZSBvZiB0aGUgdGFnIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm5zIE51bGwgb2JqZWN0IHdoZW4gdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXNcbiAgICAgKi9cbiAgICByZW1vdmVUYWcobm9kZUlkOiBzdHJpbmcsIHRhZzogc3RyaW5nKTogYW55IHtcbiAgICAgICAgY29uc3QgcHJvbWlzZVJlbW92ZSA9IGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuY29yZS50YWdzQXBpLnJlbW92ZVRhZyhub2RlSWQsIHRhZykpO1xuXG4gICAgICAgIHByb21pc2VSZW1vdmUuc3Vic2NyaWJlKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2guZW1pdChkYXRhKTtcbiAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZVJlbW92ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUVycm9yKGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhpcy5sb2dTZXJ2aWNlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZXJyb3IgfHwgJ1NlcnZlciBlcnJvcicpO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFRyYW5zbGF0aW9uU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT3V0cHV0LCBWaWV3RW5jYXBzdWxhdGlvbiwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRhZ1NlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL3RhZy5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqXG4gKiBUaGlzIGNvbXBvbmVudCwgcHJvdmlkZSBhIGxpc3Qgb2YgdGhlIHRhZ3MgcmVsYXRpdmUgYSBub2RlIHdpdGggYWN0aW9ucyBidXR0b24gdG8gYWRkIG9yIHJlbW92ZSBuZXcgdGFnXG4gKi9cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtdGFnLW5vZGUtYWN0aW9ucy1saXN0JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdGFnLWFjdGlvbnMuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3RhZy1hY3Rpb25zLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBUYWdBY3Rpb25zQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKiogVGhlIGlkZW50aWZpZXIgb2YgYSBub2RlLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9kZUlkOiBzdHJpbmc7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGEgdGFnIGlzIGFkZGVkIHN1Y2Nlc3NmdWxseS4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBzdWNjZXNzQWRkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGVycm9yOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYW4gYWN0aW9uIGlzIGNob3Nlbi4gKi9cbiAgICBAT3V0cHV0KClcbiAgICByZXN1bHQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBuZXdUYWdOYW1lOiBzdHJpbmc7XG4gICAgdGFnc0VudHJpZXM6IGFueTtcbiAgICBlcnJvck1zZzogc3RyaW5nO1xuICAgIGRpc2FibGVBZGRUYWc6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB0YWdTZXJ2aWNlOiBUYWdTZXJ2aWNlLCBwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0aW9uU2VydmljZSkge31cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgICAgIHRoaXMudGFnU2VydmljZS5yZWZyZXNoLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoVGFnKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoVGFnKCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YnNjcmlwdGlvbiA9PiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgIH1cblxuICAgIHJlZnJlc2hUYWcoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVJZCkge1xuICAgICAgICAgICAgdGhpcy50YWdTZXJ2aWNlLmdldFRhZ3NCeU5vZGVJZCh0aGlzLm5vZGVJZCkuc3Vic2NyaWJlKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzRW50cmllcyA9IGRhdGEubGlzdC5lbnRyaWVzO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZUFkZFRhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LmVtaXQodGhpcy50YWdzRW50cmllcyk7XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzRW50cmllcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlQWRkVGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5lbWl0KHRoaXMudGFnc0VudHJpZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRUYWcoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlYXJjaFRhZyh0aGlzLm5ld1RhZ05hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZVNlcnZpY2UuZ2V0KCdUQUcuTUVTU0FHRVMuRVhJU1QnKS5zdWJzY3JpYmUoKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvck1zZyA9IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVycm9yLmVtaXQodGhpcy5lcnJvck1zZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhZ1NlcnZpY2UuYWRkVGFnKHRoaXMubm9kZUlkLCB0aGlzLm5ld1RhZ05hbWUpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdUYWdOYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWNjZXNzQWRkLmVtaXQodGhpcy5ub2RlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWFyY2hUYWcoc2VhcmNoVGFnTmFtZTogc3RyaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLnRhZ3NFbnRyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWdzRW50cmllcy5maW5kKChjdXJyZW50VGFnKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzZWFyY2hUYWdOYW1lID09PSBjdXJyZW50VGFnLmVudHJ5LnRhZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFuRXJyb3JNc2coKSB7XG4gICAgICAgIHRoaXMuZXJyb3JNc2cgPSAnJztcbiAgICB9XG5cbiAgICByZW1vdmVUYWcodGFnOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy50YWdTZXJ2aWNlLnJlbW92ZVRhZyh0aGlzLm5vZGVJZCwgdGFnKTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgT25Jbml0LCBPdXRwdXQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUYWdTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy90YWcuc2VydmljZSc7XG5pbXBvcnQgeyBQYWdpbmF0aW9uTW9kZWwgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHByb3ZpZGUgYSBsaXN0IG9mIGFsbCB0aGUgdGFnIGluc2lkZSB0aGUgRUNNXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXRhZy1saXN0JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdGFnLWxpc3QuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3RhZy1saXN0LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBUYWdMaXN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYSB0YWcgaXMgc2VsZWN0ZWQuICovXG4gICAgQE91dHB1dCgpXG4gICAgcmVzdWx0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgdGFncyB0aGF0IGFyZSBkaXNwbGF5ZWRcbiAgICAgKi9cbiAgICB0YWdzRW50cmllczogYW55ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgaXRlbXMgcGVyIGl0ZXJhdGlvblxuICAgICAqL1xuICAgIHNpemU6IG51bWJlciA9IDEwO1xuXG4gICAgZGVmYXVsdFBhZ2luYXRpb246IFBhZ2luYXRpb25Nb2RlbDtcbiAgICBwYWdpbmF0aW9uOiBQYWdpbmF0aW9uTW9kZWw7XG5cbiAgICBpc0xvYWRpbmcgPSBmYWxzZTtcbiAgICBpc1NpemVNaW5pbXVtID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHRhZ1NlcnZpY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRhZ1NlcnZpY2U6IFRhZ1NlcnZpY2UpIHtcblxuICAgICAgICB0aGlzLmRlZmF1bHRQYWdpbmF0aW9uID0ge1xuICAgICAgICAgICAgc2tpcENvdW50OiAwLFxuICAgICAgICAgICAgbWF4SXRlbXM6IHRoaXMuc2l6ZSxcbiAgICAgICAgICAgIGhhc01vcmVJdGVtczogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBhZ2luYXRpb24gPSB0aGlzLmRlZmF1bHRQYWdpbmF0aW9uO1xuXG4gICAgICAgIHRoaXMudGFnU2VydmljZS5yZWZyZXNoLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRhZ3NFbnRyaWVzID0gW107XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUYWcodGhpcy5kZWZhdWx0UGFnaW5hdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoVGFnKHRoaXMuZGVmYXVsdFBhZ2luYXRpb24pO1xuICAgIH1cblxuICAgIHJlZnJlc2hUYWcob3B0cz86IGFueSkge1xuICAgICAgICB0aGlzLnRhZ1NlcnZpY2UuZ2V0QWxsVGhlVGFncyhvcHRzKS5zdWJzY3JpYmUoKHRhZ3M6IGFueSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50YWdzRW50cmllcyA9IHRoaXMudGFnc0VudHJpZXMuY29uY2F0KHRhZ3MubGlzdC5lbnRyaWVzKTtcbiAgICAgICAgICAgIHRoaXMucGFnaW5hdGlvbiA9IHRhZ3MubGlzdC5wYWdpbmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuZW1pdCh0aGlzLnRhZ3NFbnRyaWVzKTtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxvYWRNb3JlVGFncygpIHtcbiAgICAgICAgaWYgKHRoaXMucGFnaW5hdGlvbi5oYXNNb3JlSXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaXNTaXplTWluaW11bSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUYWcoe1xuICAgICAgICAgICAgICAgIHNraXBDb3VudDogdGhpcy5wYWdpbmF0aW9uLnNraXBDb3VudCArIHRoaXMucGFnaW5hdGlvbi5jb3VudCxcbiAgICAgICAgICAgICAgICBtYXhJdGVtczogdGhpcy5zaXplXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvYWRMZXNzVGFncygpIHtcbiAgICAgICAgdGhpcy5pc1NpemVNaW5pbXVtID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGFnc0VudHJpZXMgPSB0aGlzLnRhZ3NFbnRyaWVzLnNsaWNlKDAsIHRoaXMudGFnc0VudHJpZXMubGVuZ3RoIC0gdGhpcy5wYWdpbmF0aW9uLmNvdW50KTtcbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uLnNraXBDb3VudCA9IHRoaXMucGFnaW5hdGlvbi5za2lwQ291bnQgLSB0aGlzLnBhZ2luYXRpb24uY291bnQ7XG4gICAgICAgIHRoaXMucGFnaW5hdGlvbi5oYXNNb3JlSXRlbXMgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLnRhZ3NFbnRyaWVzLmxlbmd0aCA8PSB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTaXplTWluaW11bSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT3V0cHV0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVGFnU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvdGFnLnNlcnZpY2UnO1xuXG4vKipcbiAqXG4gKiBUaGlzIGNvbXBvbmVudCwgU2hvd05vZGVUYWcgYSBsaXN0IG9mIHRoZSB0YWcgb24gcmVsYXRpdmUgYSBub2RlXG4gKi9cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtdGFnLW5vZGUtbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3RhZy1ub2RlLWxpc3QuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3RhZy1ub2RlLWxpc3QuY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIFRhZ05vZGVMaXN0Q29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgICAvKiogVGhlIGlkZW50aWZpZXIgb2YgYSBub2RlLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9kZUlkOiBzdHJpbmc7XG5cbiAgICAvKiogU2hvdyBkZWxldGUgYnV0dG9uICovXG4gICAgQElucHV0KClcbiAgICBzaG93RGVsZXRlID0gdHJ1ZTtcblxuICAgIHRhZ3NFbnRyaWVzOiBhbnk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGEgdGFnIGlzIHNlbGVjdGVkLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHJlc3VsdHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB0YWdTZXJ2aWNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB0YWdTZXJ2aWNlOiBUYWdTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMudGFnU2VydmljZS5yZWZyZXNoLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUYWcoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hUYWcoKTtcbiAgICB9XG5cbiAgICByZWZyZXNoVGFnKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlSWQpIHtcbiAgICAgICAgICAgIHRoaXMudGFnU2VydmljZS5nZXRUYWdzQnlOb2RlSWQodGhpcy5ub2RlSWQpLnN1YnNjcmliZSgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudGFnc0VudHJpZXMgPSBkYXRhLmxpc3QuZW50cmllcztcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMuZW1pdCh0aGlzLnRhZ3NFbnRyaWVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlVGFnKHRhZzogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMudGFnU2VydmljZS5yZW1vdmVUYWcodGhpcy5ub2RlSWQsIHRhZykuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFRhZygpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBNYXRlcmlhbE1vZHVsZSB9IGZyb20gJy4uL21hdGVyaWFsLm1vZHVsZSc7XG5pbXBvcnQgeyBUYWdBY3Rpb25zQ29tcG9uZW50IH0gZnJvbSAnLi90YWctYWN0aW9ucy5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGFnTGlzdENvbXBvbmVudCB9IGZyb20gJy4vdGFnLWxpc3QuY29tcG9uZW50JztcbmltcG9ydCB7IFRhZ05vZGVMaXN0Q29tcG9uZW50IH0gZnJvbSAnLi90YWctbm9kZS1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb3JlTW9kdWxlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgTWF0ZXJpYWxNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBDb3JlTW9kdWxlLmZvckNoaWxkKClcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgVGFnQWN0aW9uc0NvbXBvbmVudCxcbiAgICAgICAgVGFnTGlzdENvbXBvbmVudCxcbiAgICAgICAgVGFnTm9kZUxpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBUYWdBY3Rpb25zQ29tcG9uZW50LFxuICAgICAgICBUYWdMaXN0Q29tcG9uZW50LFxuICAgICAgICBUYWdOb2RlTGlzdENvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgVGFnTW9kdWxlIHt9XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBPYmplY3REYXRhVGFibGVBZGFwdGVyIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IEFsZnJlc2NvQXBpU2VydmljZSwgTG9nU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogPGFkZi13ZWJzY3JpcHQtZ2V0IFtzY3JpcHRQYXRoXT1cInN0cmluZ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBbc2NyaXB0QXJnc109XCJPYmplY3RcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgW2NvbnRleHRSb290XT1cInN0cmluZ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBbc2VydmljZVBhdGhdPVwic3RyaW5nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFtjb250ZW50VHlwZV09XCJKU09OfEhUTUx8REFUQVRBQkxFXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIChzdWNjZXNzKT1cImN1c3RvbU1ldGhvZCgkZXZlbnQpPlxuICogPC9hZGYtd2Vic2NyaXB0LWdldD5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCwgcHJvdmlkZSBhIGdldCB3ZWJzY3JpcHQgdmlld2VyXG4gKlxuICogQElucHV0UGFyYW0ge3N0cmluZ30gc2NyaXB0UGF0aCBwYXRoIHRvIFdlYiBTY3JpcHQgKGFzIGRlZmluZWQgYnkgV2ViIFNjcmlwdClcbiAqIEBJbnB1dFBhcmFtIHtPYmplY3R9IHNjcmlwdEFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gV2ViIFNjcmlwdFxuICogQElucHV0UGFyYW0ge3N0cmluZ30gY29udGV4dFJvb3QgcGF0aCB3aGVyZSBhcHBsaWNhdGlvbiBpcyBkZXBsb3llZCBkZWZhdWx0IHZhbHVlICdhbGZyZXNjbydcbiAqIEBJbnB1dFBhcmFtIHtzdHJpbmd9IHNlcnZpY2VQYXRoIHBhdGggd2hlcmUgV2ViIFNjcmlwdCBzZXJ2aWNlIGlzIG1hcHBlZCBkZWZhdWx0IHZhbHVlICdzZXJ2aWNlJ1xuICogQElucHV0UGFyYW0ge3N0cmluZ30gY29udGVudFR5cGUgSlNPTiB8IEhUTUwgfCBEQVRBVEFCTEUgfCBURVhUXG4gKlxuICogQE91dHB1dCAtIHN1Y2Nlc3MgLSBUaGUgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRoZSBkYXRhIGFyZSByZWNpdmVkXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi13ZWJzY3JpcHQtZ2V0JyxcbiAgICB0ZW1wbGF0ZVVybDogJ3dlYnNjcmlwdC5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgV2Vic2NyaXB0Q29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcblxuICAgIC8qKiAocmVxdWlyZWQpIFBhdGggdG8gdGhlIHdlYnNjcmlwdCAoYXMgZGVmaW5lZCBieSB3ZWJzY3JpcHQpLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2NyaXB0UGF0aDogc3RyaW5nO1xuXG4gICAgLyoqIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSB3ZWJzY3JpcHQuICovXG4gICAgQElucHV0KClcbiAgICBzY3JpcHRBcmdzOiBhbnk7XG5cbiAgICAvKiogVG9nZ2xlcyB3aGV0aGVyIHRvIHNob3cgb3IgaGlkZSB0aGUgZGF0YS4gKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dEYXRhOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKiBQYXRoIHdoZXJlIHRoZSBhcHBsaWNhdGlvbiBpcyBkZXBsb3llZCAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29udGV4dFJvb3Q6IHN0cmluZyA9ICdhbGZyZXNjbyc7XG5cbiAgICAvKiogUGF0aCB0aGF0IHRoZSB3ZWJzY3JpcHQgc2VydmljZSBpcyBtYXBwZWQgdG8uICovXG4gICAgQElucHV0KClcbiAgICBzZXJ2aWNlUGF0aDogc3RyaW5nID0gJ3NlcnZpY2UnO1xuXG4gICAgLyoqIENvbnRlbnQgdHlwZSB0byBpbnRlcnByZXQgdGhlIGRhdGEgcmVjZWl2ZWQgZnJvbSB0aGUgd2Vic2NyaXB0LlxuICAgICAqIENhbiBiZSBcIkpTT05cIiAsIFwiSFRNTFwiICwgXCJEQVRBVEFCTEVcIiBvciBcIlRFWFRcIlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29udGVudFR5cGU6IHN0cmluZyA9ICdURVhUJztcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIG9wZXJhdGlvbiBzdWNjZWVkcy4gWW91IGNhbiBnZXQgdGhlIHBsYWluIGRhdGEgZnJvbVxuICAgICAqIHRoZSB3ZWJzY3JpcHQgdGhyb3VnaCB0aGUgKipzdWNjZXNzKiogZXZlbnQgcGFyYW1ldGVyIGFuZCB1c2UgaXQgYXMgeW91XG4gICAgICogbmVlZCBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHN1Y2Nlc3MgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBkYXRhOiBhbnkgPSB1bmRlZmluZWQ7XG4gICAgc2hvd0Vycm9yOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGxvZ1NlcnZpY2U6IExvZ1NlcnZpY2UpIHtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3dEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkud2ViU2NyaXB0LmV4ZWN1dGVXZWJTY3JpcHQoJ0dFVCcsIHRoaXMuc2NyaXB0UGF0aCwgdGhpcy5zY3JpcHRBcmdzLCB0aGlzLmNvbnRleHRSb290LCB0aGlzLnNlcnZpY2VQYXRoKS50aGVuKCh3ZWJTY3JpcHRkYXRhKSA9PiB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSB3ZWJTY3JpcHRkYXRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudFR5cGUgPT09ICdEQVRBVEFCTEUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnNob3dEYXRhQXNEYXRhVGFibGUod2ViU2NyaXB0ZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3MuZW1pdCh0aGlzLmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dTZXJ2aWNlLmxvZygnRXJyb3InICsgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNob3cgdGhlIGRhdGEgaW4gYSBuZzItYWxmcmVzY28tZGF0YXRhYmxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqXG4gICAgICogQHJldHV0bnMgdGhlIGRhdGEgYXMgZGF0YXRhYmxlXG4gICAgICovXG4gICAgc2hvd0RhdGFBc0RhdGFUYWJsZShkYXRhOiBhbnkpIHtcbiAgICAgICAgbGV0IGRhdGF0YWJsZURhdGE6IGFueSA9IG51bGw7XG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIGlmICghZGF0YS5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnNjaGVtYSA9IE9iamVjdERhdGFUYWJsZUFkYXB0ZXIuZ2VuZXJhdGVTY2hlbWEoZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEuc2NoZW1hICYmIGRhdGEuc2NoZW1hLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgT2JqZWN0RGF0YVRhYmxlQWRhcHRlcihkYXRhLmRhdGEsIGRhdGEuc2NoZW1hKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ1NlcnZpY2UuZXJyb3IoJ2Vycm9yIGR1cmluZyB0aGUgY2FzdCBhcyBkYXRhdGFibGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhdGFibGVEYXRhO1xuICAgIH1cblxuICAgIGNsZWFuKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaXNEYXRhVGFibGVDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50VHlwZSA9PT0gJ0RBVEFUQUJMRSc7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29yZU1vZHVsZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgTWF0ZXJpYWxNb2R1bGUgfSBmcm9tICcuLi9tYXRlcmlhbC5tb2R1bGUnO1xuaW1wb3J0IHsgV2Vic2NyaXB0Q29tcG9uZW50IH0gZnJvbSAnLi93ZWJzY3JpcHQuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgTWF0ZXJpYWxNb2R1bGUsXG4gICAgICAgIENvcmVNb2R1bGUuZm9yQ2hpbGQoKVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBXZWJzY3JpcHRDb21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBXZWJzY3JpcHRDb21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFdlYlNjcmlwdE1vZHVsZSB7fVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRGF0YVJvdywgT2JqZWN0VXRpbHMsIFRodW1ibmFpbFNlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgTWluaW1hbE5vZGUsIE1pbmltYWxOb2RlRW50aXR5IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IFBlcm1pc3Npb25TdHlsZU1vZGVsIH0gZnJvbSAnLi8uLi9tb2RlbHMvcGVybWlzc2lvbnMtc3R5bGUubW9kZWwnO1xuaW1wb3J0IHsgRG9jdW1lbnRMaXN0U2VydmljZSB9IGZyb20gJy4vLi4vc2VydmljZXMvZG9jdW1lbnQtbGlzdC5zZXJ2aWNlJztcblxuZXhwb3J0IGNsYXNzIFNoYXJlRGF0YVJvdyBpbXBsZW1lbnRzIERhdGFSb3cge1xuXG4gICAgc3RhdGljIEVSUl9PQkpFQ1RfTk9UX0ZPVU5EOiBzdHJpbmcgPSAnT2JqZWN0IHNvdXJjZSBub3QgZm91bmQnO1xuXG4gICAgY2FjaGU6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcbiAgICBpc1NlbGVjdGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgaXNEcm9wVGFyZ2V0OiBib29sZWFuO1xuICAgIGNzc0NsYXNzOiBzdHJpbmcgPSAnJztcblxuICAgIGdldCBub2RlKCk6IE1pbmltYWxOb2RlRW50aXR5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgb2JqOiBNaW5pbWFsTm9kZUVudGl0eSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGRvY3VtZW50TGlzdFNlcnZpY2U6IERvY3VtZW50TGlzdFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBwZXJtaXNzaW9uc1N0eWxlOiBQZXJtaXNzaW9uU3R5bGVNb2RlbFtdLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdGh1bWJuYWlsU2VydmljZT86IFRodW1ibmFpbFNlcnZpY2UpIHtcbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihTaGFyZURhdGFSb3cuRVJSX09CSkVDVF9OT1RfRk9VTkQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0Ryb3BUYXJnZXQgPSB0aGlzLmlzRm9sZGVyQW5kSGFzUGVybWlzc2lvblRvVXBsb2FkKG9iaik7XG5cbiAgICAgICAgaWYgKHBlcm1pc3Npb25zU3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3NzQ2xhc3MgPSB0aGlzLmdldFBlcm1pc3Npb25DbGFzcyhvYmopO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UGVybWlzc2lvbkNsYXNzKG5vZGVFbnRpdHk6IE1pbmltYWxOb2RlRW50aXR5KTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHBlcm1pc3Npb25zQ2xhc3NlcyA9ICcnO1xuXG4gICAgICAgIHRoaXMucGVybWlzc2lvbnNTdHlsZS5mb3JFYWNoKChjdXJyZW50UGVybWlzc2lvbnNTdHlsZTogUGVybWlzc2lvblN0eWxlTW9kZWwpID0+IHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwbHlQZXJtaXNzaW9uU3R5bGVUb0ZvbGRlcihub2RlRW50aXR5LmVudHJ5LCBjdXJyZW50UGVybWlzc2lvbnNTdHlsZSkgfHwgdGhpcy5hcHBseVBlcm1pc3Npb25TdHlsZVRvRmlsZShub2RlRW50aXR5LmVudHJ5LCBjdXJyZW50UGVybWlzc2lvbnNTdHlsZSkpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvY3VtZW50TGlzdFNlcnZpY2UuaGFzUGVybWlzc2lvbihub2RlRW50aXR5LmVudHJ5LCBjdXJyZW50UGVybWlzc2lvbnNTdHlsZS5wZXJtaXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uc0NsYXNzZXMgKz0gYCAke2N1cnJlbnRQZXJtaXNzaW9uc1N0eWxlLmNzc31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGVybWlzc2lvbnNDbGFzc2VzO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXBwbHlQZXJtaXNzaW9uU3R5bGVUb0ZpbGUobm9kZTogTWluaW1hbE5vZGUsIGN1cnJlbnRQZXJtaXNzaW9uc1N0eWxlOiBQZXJtaXNzaW9uU3R5bGVNb2RlbCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKGN1cnJlbnRQZXJtaXNzaW9uc1N0eWxlLmlzRmlsZSAmJiBub2RlLmlzRmlsZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhcHBseVBlcm1pc3Npb25TdHlsZVRvRm9sZGVyKG5vZGU6IE1pbmltYWxOb2RlLCBjdXJyZW50UGVybWlzc2lvbnNTdHlsZTogUGVybWlzc2lvblN0eWxlTW9kZWwpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChjdXJyZW50UGVybWlzc2lvbnNTdHlsZS5pc0ZvbGRlciAmJiBub2RlLmlzRm9sZGVyKTtcbiAgICB9XG5cbiAgICBpc0ZvbGRlckFuZEhhc1Blcm1pc3Npb25Ub1VwbG9hZChvYmo6IE1pbmltYWxOb2RlRW50aXR5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRm9sZGVyKG9iaikgJiYgdGhpcy5kb2N1bWVudExpc3RTZXJ2aWNlLmhhc1Blcm1pc3Npb24ob2JqLmVudHJ5LCAnY3JlYXRlJyk7XG4gICAgfVxuXG4gICAgaXNGb2xkZXIob2JqOiBNaW5pbWFsTm9kZUVudGl0eSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gb2JqLmVudHJ5ICYmIG9iai5lbnRyeS5pc0ZvbGRlcjtcbiAgICB9XG5cbiAgICBjYWNoZVZhbHVlKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXRWYWx1ZShrZXk6IHN0cmluZyk6IGFueSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0VXRpbHMuZ2V0VmFsdWUodGhpcy5vYmouZW50cnksIGtleSk7XG4gICAgfVxuXG4gICAgaW1hZ2VFcnJvclJlc29sdmVyKGV2ZW50OiBFdmVudCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRodW1ibmFpbFNlcnZpY2UuZ2V0TWltZVR5cGVJY29uKHRoaXMub2JqLmVudHJ5LmNvbnRlbnQubWltZVR5cGUpO1xuICAgIH1cblxuICAgIGhhc1ZhbHVlKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKGtleSkgIT09IHVuZGVmaW5lZDtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBEYXRhQ29sdW1uLCBEYXRhUm93LCBEYXRhU29ydGluZywgRGF0YVRhYmxlQWRhcHRlciwgVGh1bWJuYWlsU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBOb2RlUGFnaW5nIH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IFBlcm1pc3Npb25TdHlsZU1vZGVsIH0gZnJvbSAnLi8uLi9tb2RlbHMvcGVybWlzc2lvbnMtc3R5bGUubW9kZWwnO1xuaW1wb3J0IHsgRG9jdW1lbnRMaXN0U2VydmljZSB9IGZyb20gJy4vLi4vc2VydmljZXMvZG9jdW1lbnQtbGlzdC5zZXJ2aWNlJztcbmltcG9ydCB7IFNoYXJlRGF0YVJvdyB9IGZyb20gJy4vc2hhcmUtZGF0YS1yb3cubW9kZWwnO1xuXG5leHBvcnQgY2xhc3MgU2hhcmVEYXRhVGFibGVBZGFwdGVyIGltcGxlbWVudHMgRGF0YVRhYmxlQWRhcHRlciB7XG5cbiAgICBFUlJfUk9XX05PVF9GT1VORDogc3RyaW5nID0gJ1JvdyBub3QgZm91bmQnO1xuICAgIEVSUl9DT0xfTk9UX0ZPVU5EOiBzdHJpbmcgPSAnQ29sdW1uIG5vdCBmb3VuZCc7XG5cbiAgICBwcml2YXRlIF9zb3J0aW5nTW9kZTogc3RyaW5nO1xuICAgIHByaXZhdGUgc29ydGluZzogRGF0YVNvcnRpbmc7XG4gICAgcHJpdmF0ZSByb3dzOiBEYXRhUm93W107XG4gICAgcHJpdmF0ZSBjb2x1bW5zOiBEYXRhQ29sdW1uW107XG5cbiAgICBwcml2YXRlIGZpbHRlcjogYW55O1xuICAgIHByaXZhdGUgaW1hZ2VSZXNvbHZlcjogYW55O1xuXG4gICAgdGh1bWJuYWlsczogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHBlcm1pc3Npb25zU3R5bGU6IFBlcm1pc3Npb25TdHlsZU1vZGVsW107XG4gICAgc2VsZWN0ZWRSb3c6IERhdGFSb3c7XG5cbiAgICBzZXQgc29ydGluZ01vZGUodmFsdWU6IHN0cmluZykge1xuICAgICAgICBsZXQgbmV3VmFsdWUgPSAodmFsdWUgfHwgJ2NsaWVudCcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gJ2NsaWVudCcgJiYgbmV3VmFsdWUgIT09ICdzZXJ2ZXInKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9ICdjbGllbnQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvcnRpbmdNb2RlID0gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IHNvcnRpbmdNb2RlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3J0aW5nTW9kZTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRvY3VtZW50TGlzdFNlcnZpY2U6IERvY3VtZW50TGlzdFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSB0aHVtYm5haWxTZXJ2aWNlOiBUaHVtYm5haWxTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogRGF0YUNvbHVtbltdID0gW10sXG4gICAgICAgICAgICAgICAgc29ydGluZz86IERhdGFTb3J0aW5nLFxuICAgICAgICAgICAgICAgIHNvcnRpbmdNb2RlOiBzdHJpbmcgPSAnY2xpZW50Jykge1xuICAgICAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gc2NoZW1hIHx8IFtdO1xuICAgICAgICB0aGlzLnNvcnRpbmcgPSBzb3J0aW5nO1xuICAgICAgICB0aGlzLnNvcnRpbmdNb2RlID0gc29ydGluZ01vZGU7XG4gICAgfVxuXG4gICAgZ2V0Um93cygpOiBBcnJheTxEYXRhUm93PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd3M7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogZGlzYWJsZSB0aGlzIGFwaVxuICAgIHNldFJvd3Mocm93czogQXJyYXk8RGF0YVJvdz4pIHtcbiAgICAgICAgdGhpcy5yb3dzID0gcm93cyB8fCBbXTtcbiAgICAgICAgdGhpcy5zb3J0KCk7XG4gICAgfVxuXG4gICAgZ2V0Q29sdW1ucygpOiBBcnJheTxEYXRhQ29sdW1uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnM7XG4gICAgfVxuXG4gICAgc2V0Q29sdW1ucyhjb2x1bW5zOiBBcnJheTxEYXRhQ29sdW1uPikge1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zIHx8IFtdO1xuICAgIH1cblxuICAgIGdldFZhbHVlKHJvdzogRGF0YVJvdywgY29sOiBEYXRhQ29sdW1uKTogYW55IHtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLkVSUl9ST1dfTk9UX0ZPVU5EKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuRVJSX0NPTF9OT1RfRk9VTkQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhUm93OiBTaGFyZURhdGFSb3cgPSA8U2hhcmVEYXRhUm93PiByb3c7XG4gICAgICAgIGxldCB2YWx1ZTogYW55ID0gcm93LmdldFZhbHVlKGNvbC5rZXkpO1xuICAgICAgICBpZiAoZGF0YVJvdy5jYWNoZVtjb2wua2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVJvdy5jYWNoZVtjb2wua2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2wua2V5ID09PSAnJHRodW1ibmFpbCcpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaW1hZ2VSZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IHRoaXMuaW1hZ2VSZXNvbHZlcihyb3csIGNvbCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSAoPFNoYXJlRGF0YVJvdz4gcm93KS5ub2RlO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5lbnRyeS5pc0ZvbGRlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU21hcnRGb2xkZXIobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRMaXN0U2VydmljZS5nZXRNaW1lVHlwZUljb24oJ3NtYXJ0Rm9sZGVyJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRMaXN0U2VydmljZS5nZXRNaW1lVHlwZUljb24oJ2ZvbGRlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUuZW50cnkuaXNGaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGh1bWJuYWlscykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudExpc3RTZXJ2aWNlLmdldERvY3VtZW50VGh1bWJuYWlsVXJsKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUuZW50cnkuY29udGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbWVUeXBlID0gbm9kZS5lbnRyeS5jb250ZW50Lm1pbWVUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChtaW1lVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudExpc3RTZXJ2aWNlLmdldE1pbWVUeXBlSWNvbihtaW1lVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudExpc3RTZXJ2aWNlLmdldERlZmF1bHRNaW1lVHlwZUljb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2wudHlwZSA9PT0gJ2ltYWdlJykge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pbWFnZVJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdGhpcy5pbWFnZVJlc29sdmVyKHJvdywgY29sKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhUm93LmNhY2hlVmFsdWUoY29sLmtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGdldFNvcnRpbmcoKTogRGF0YVNvcnRpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0aW5nO1xuICAgIH1cblxuICAgIHNldFNvcnRpbmcoc29ydGluZzogRGF0YVNvcnRpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zb3J0aW5nID0gc29ydGluZztcblxuICAgICAgICB0aGlzLnNvcnRSb3dzKHRoaXMucm93cywgdGhpcy5zb3J0aW5nKTtcbiAgICB9XG5cbiAgICBzb3J0KGtleT86IHN0cmluZywgZGlyZWN0aW9uPzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGxldCBzb3J0aW5nID0gdGhpcy5zb3J0aW5nIHx8IG5ldyBEYXRhU29ydGluZygpO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBzb3J0aW5nLmtleSA9IGtleTtcbiAgICAgICAgICAgIHNvcnRpbmcuZGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8ICdhc2MnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U29ydGluZyhzb3J0aW5nKTtcbiAgICB9XG5cbiAgICBzZXRGaWx0ZXIoZmlsdGVyOiBhbnkpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgfVxuXG4gICAgc2V0SW1hZ2VSZXNvbHZlcihyZXNvbHZlcjogYW55KSB7XG4gICAgICAgIHRoaXMuaW1hZ2VSZXNvbHZlciA9IHJlc29sdmVyO1xuICAgIH1cblxuICAgIGlzU21hcnRGb2xkZXIobm9kZTogYW55KSB7XG4gICAgICAgIGxldCBub2RlQXNwZWN0cyA9IHRoaXMuZ2V0Tm9kZUFzcGVjdE5hbWVzKG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZUFzcGVjdHMuaW5kZXhPZignc21mOmN1c3RvbUNvbmZpZ1NtYXJ0Rm9sZGVyJykgPiAtMSB8fFxuICAgICAgICAgICAgKG5vZGVBc3BlY3RzLmluZGV4T2YoJ3NtZjpzeXN0ZW1Db25maWdTbWFydEZvbGRlcicpID4gLTEpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Tm9kZUFzcGVjdE5hbWVzKG5vZGU6IGFueSk6IGFueVtdIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuZW50cnkgJiYgbm9kZS5lbnRyeS5hc3BlY3ROYW1lcyA/IG5vZGUuZW50cnkuYXNwZWN0TmFtZXMgOiBub2RlLmFzcGVjdE5hbWVzID8gbm9kZS5hc3BlY3ROYW1lcyA6IFtdO1xuICAgIH1cblxuICAgIHByaXZhdGUgc29ydFJvd3Mocm93czogRGF0YVJvd1tdLCBzb3J0aW5nOiBEYXRhU29ydGluZykge1xuICAgICAgICBpZiAodGhpcy5zb3J0aW5nTW9kZSA9PT0gJ3NlcnZlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IEludGwuQ29sbGF0b3JPcHRpb25zID0ge307XG5cbiAgICAgICAgaWYgKHNvcnRpbmcgJiYgc29ydGluZy5rZXkgJiYgcm93cyAmJiByb3dzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgaWYgKHNvcnRpbmcua2V5LmluY2x1ZGVzKCdzaXplSW5CeXRlcycpIHx8IHNvcnRpbmcua2V5ID09PSAnbmFtZScpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm51bWVyaWMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByb3dzLnNvcnQoKGE6IFNoYXJlRGF0YVJvdywgYjogU2hhcmVEYXRhUm93KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGEubm9kZS5lbnRyeS5pc0ZvbGRlciAhPT0gYi5ub2RlLmVudHJ5LmlzRm9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLm5vZGUuZW50cnkuaXNGb2xkZXIgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSBhLmdldFZhbHVlKHNvcnRpbmcua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKGxlZnQgaW5zdGFuY2VvZiBEYXRlKSA/IGxlZnQudmFsdWVPZigpLnRvU3RyaW5nKCkgOiBsZWZ0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCByaWdodCA9IGIuZ2V0VmFsdWUoc29ydGluZy5rZXkpO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IChyaWdodCBpbnN0YW5jZW9mIERhdGUpID8gcmlnaHQudmFsdWVPZigpLnRvU3RyaW5nKCkgOiByaWdodC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRpbmcuZGlyZWN0aW9uID09PSAnYXNjJ1xuICAgICAgICAgICAgICAgICAgICA/IGxlZnQubG9jYWxlQ29tcGFyZShyaWdodCwgdW5kZWZpbmVkLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICA6IHJpZ2h0LmxvY2FsZUNvbXBhcmUobGVmdCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGxvYWRQYWdlKHBhZ2U6IE5vZGVQYWdpbmcsIG1lcmdlOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJvd3MgPSBbXTtcblxuICAgICAgICBpZiAocGFnZSAmJiBwYWdlLmxpc3QpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gcGFnZS5saXN0LmVudHJpZXM7XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByb3dzID0gZGF0YS5tYXAoaXRlbSA9PiBuZXcgU2hhcmVEYXRhUm93KGl0ZW0sIHRoaXMuZG9jdW1lbnRMaXN0U2VydmljZSwgdGhpcy5wZXJtaXNzaW9uc1N0eWxlLCB0aGlzLnRodW1ibmFpbFNlcnZpY2UpKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICByb3dzID0gcm93cy5maWx0ZXIodGhpcy5maWx0ZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvcnRpbmdNb2RlICE9PSAnc2VydmVyJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTb3J0IGJ5IGZpcnN0IHNvcnRhYmxlIG9yIGp1c3QgZmlyc3QgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbnMgJiYgdGhpcy5jb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzb3J0aW5nID0gdGhpcy5nZXRTb3J0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydFJvd3Mocm93cywgc29ydGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzb3J0YWJsZSA9IHRoaXMuY29sdW1ucy5maWx0ZXIoYyA9PiBjLnNvcnRhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGFibGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnQoc29ydGFibGVbMF0ua2V5LCAnYXNjJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0KHRoaXMuY29sdW1uc1swXS5rZXksICdhc2MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgIGxldCBsaXN0UHJ1bmVkRHVwbGljYXRlID0gcm93cy5maWx0ZXIoKGVsZW1udFRvRmlsdGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGlzUHJlc2VudCA9IHRoaXMucm93cy5maW5kKChjdXJyZW5Sb3c6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVuUm93Lm9iai5lbnRyeS5pZCA9PT0gZWxlbW50VG9GaWx0ZXIub2JqLmVudHJ5LmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICFpc1ByZXNlbnQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5yb3dzID0gdGhpcy5yb3dzLmNvbmNhdChsaXN0UHJ1bmVkRHVwbGljYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgbGV0IHByZXNldHNEZWZhdWx0TW9kZWwgPSB7XG4gICAgJy10cmFzaGNhbi0nOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJyR0aHVtYm5haWwnLFxuICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgIHNyVGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuVEhVTUJOQUlMJyxcbiAgICAgICAgICAgIHNvcnRhYmxlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICduYW1lJyxcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHRpdGxlOiAnQURGLURPQ1VNRU5ULUxJU1QuTEFZT1VULk5BTUUnLFxuICAgICAgICAgICAgY3NzQ2xhc3M6ICdmdWxsLXdpZHRoIGVsbGlwc2lzLWNlbGwnLFxuICAgICAgICAgICAgc29ydGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAncGF0aCcsXG4gICAgICAgICAgICB0eXBlOiAnbG9jYXRpb24nLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuTE9DQVRJT04nLFxuICAgICAgICAgICAgc29ydGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnY29udGVudC5zaXplSW5CeXRlcycsXG4gICAgICAgICAgICB0eXBlOiAnZmlsZVNpemUnLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuU0laRScsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdhcmNoaXZlZEF0JyxcbiAgICAgICAgICAgIHR5cGU6ICdkYXRlJyxcbiAgICAgICAgICAgIHRpdGxlOiAnQURGLURPQ1VNRU5ULUxJU1QuTEFZT1VULkRFTEVURURfT04nLFxuICAgICAgICAgICAgZm9ybWF0OiAndGltZUFnbycsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdhcmNoaXZlZEJ5VXNlci5kaXNwbGF5TmFtZScsXG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICB0aXRsZTogJ0FERi1ET0NVTUVOVC1MSVNULkxBWU9VVC5ERUxFVEVEX0JZJyxcbiAgICAgICAgICAgIHNvcnRhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICBdLFxuICAgICctc2l0ZXMtJzogW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICckdGh1bWJuYWlsJyxcbiAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICBzclRpdGxlOiAnQURGLURPQ1VNRU5ULUxJU1QuTEFZT1VULlRIVU1CTkFJTCcsXG4gICAgICAgICAgICBzb3J0YWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAndGl0bGUnLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuTkFNRScsXG4gICAgICAgICAgICBjc3NDbGFzczogJ2Z1bGwtd2lkdGggZWxsaXBzaXMtY2VsbCcsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICd2aXNpYmlsaXR5JyxcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHRpdGxlOiAnQURGLURPQ1VNRU5ULUxJU1QuTEFZT1VULlNUQVRVUycsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgXSxcbiAgICAnLW15c2l0ZXMtJzogW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICckdGh1bWJuYWlsJyxcbiAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICBzclRpdGxlOiAnQURGLURPQ1VNRU5ULUxJU1QuTEFZT1VULlRIVU1CTkFJTCcsXG4gICAgICAgICAgICBzb3J0YWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAndGl0bGUnLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuTkFNRScsXG4gICAgICAgICAgICBjc3NDbGFzczogJ2Z1bGwtd2lkdGggZWxsaXBzaXMtY2VsbCcsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICd2aXNpYmlsaXR5JyxcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHRpdGxlOiAnQURGLURPQ1VNRU5ULUxJU1QuTEFZT1VULlNUQVRVUycsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgXSxcbiAgICAnLWZhdm9yaXRlcy0nOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJyR0aHVtYm5haWwnLFxuICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgIHNyVGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuVEhVTUJOQUlMJyxcbiAgICAgICAgICAgIHNvcnRhYmxlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICduYW1lJyxcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHRpdGxlOiAnQURGLURPQ1VNRU5ULUxJU1QuTEFZT1VULk5BTUUnLFxuICAgICAgICAgICAgY3NzQ2xhc3M6ICdmdWxsLXdpZHRoIGVsbGlwc2lzLWNlbGwnLFxuICAgICAgICAgICAgc29ydGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAncGF0aCcsXG4gICAgICAgICAgICB0eXBlOiAnbG9jYXRpb24nLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuTE9DQVRJT04nLFxuICAgICAgICAgICAgc29ydGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnY29udGVudC5zaXplSW5CeXRlcycsXG4gICAgICAgICAgICB0eXBlOiAnZmlsZVNpemUnLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuU0laRScsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdtb2RpZmllZEF0JyxcbiAgICAgICAgICAgIHR5cGU6ICdkYXRlJyxcbiAgICAgICAgICAgIHRpdGxlOiAnQURGLURPQ1VNRU5ULUxJU1QuTEFZT1VULk1PRElGSUVEX09OJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ3RpbWVBZ28nLFxuICAgICAgICAgICAgc29ydGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnbW9kaWZpZWRCeVVzZXIuZGlzcGxheU5hbWUnLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuTU9ESUZJRURfQlknLFxuICAgICAgICAgICAgc29ydGFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIF0sXG4gICAgJy1yZWNlbnQtJzogW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICckdGh1bWJuYWlsJyxcbiAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICBzclRpdGxlOiAnQURGLURPQ1VNRU5ULUxJU1QuTEFZT1VULlRIVU1CTkFJTCcsXG4gICAgICAgICAgICBzb3J0YWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnbmFtZScsXG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICB0aXRsZTogJ0FERi1ET0NVTUVOVC1MSVNULkxBWU9VVC5OQU1FJyxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnZnVsbC13aWR0aCBlbGxpcHNpcy1jZWxsJyxcbiAgICAgICAgICAgIHNvcnRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ3BhdGgnLFxuICAgICAgICAgICAgdHlwZTogJ2xvY2F0aW9uJyxcbiAgICAgICAgICAgIHRpdGxlOiAnQURGLURPQ1VNRU5ULUxJU1QuTEFZT1VULkxPQ0FUSU9OJyxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnZWxsaXBzaXMtY2VsbCcsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdjb250ZW50LnNpemVJbkJ5dGVzJyxcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlU2l6ZScsXG4gICAgICAgICAgICB0aXRsZTogJ0FERi1ET0NVTUVOVC1MSVNULkxBWU9VVC5TSVpFJyxcbiAgICAgICAgICAgIHNvcnRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ21vZGlmaWVkQXQnLFxuICAgICAgICAgICAgdHlwZTogJ2RhdGUnLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuTU9ESUZJRURfT04nLFxuICAgICAgICAgICAgZm9ybWF0OiAndGltZUFnbycsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgXSxcbiAgICAnLXNoYXJlZGxpbmtzLSc6IFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnJHRodW1ibmFpbCcsXG4gICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgc3JUaXRsZTogJ0FERi1ET0NVTUVOVC1MSVNULkxBWU9VVC5USFVNQk5BSUwnLFxuICAgICAgICAgICAgc29ydGFibGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ25hbWUnLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuTkFNRScsXG4gICAgICAgICAgICBjc3NDbGFzczogJ2Z1bGwtd2lkdGggZWxsaXBzaXMtY2VsbCcsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdwYXRoJyxcbiAgICAgICAgICAgIHR5cGU6ICdsb2NhdGlvbicsXG4gICAgICAgICAgICB0aXRsZTogJ0FERi1ET0NVTUVOVC1MSVNULkxBWU9VVC5MT0NBVElPTicsXG4gICAgICAgICAgICBjc3NDbGFzczogJ2VsbGlwc2lzLWNlbGwnLFxuICAgICAgICAgICAgc29ydGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnY29udGVudC5zaXplSW5CeXRlcycsXG4gICAgICAgICAgICB0eXBlOiAnZmlsZVNpemUnLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuU0laRScsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdtb2RpZmllZEF0JyxcbiAgICAgICAgICAgIHR5cGU6ICdkYXRlJyxcbiAgICAgICAgICAgIHRpdGxlOiAnQURGLURPQ1VNRU5ULUxJU1QuTEFZT1VULk1PRElGSUVEX09OJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ3RpbWVBZ28nLFxuICAgICAgICAgICAgc29ydGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnbW9kaWZpZWRCeVVzZXIuZGlzcGxheU5hbWUnLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuTU9ESUZJRURfQlknLFxuICAgICAgICAgICAgc29ydGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnc2hhcmVkQnlVc2VyLmRpc3BsYXlOYW1lJyxcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHRpdGxlOiAnQURGLURPQ1VNRU5ULUxJU1QuTEFZT1VULlNIQVJFRF9CWScsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgXSxcbiAgICAnZGVmYXVsdCc6IFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnJHRodW1ibmFpbCcsXG4gICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgc3JUaXRsZTogJ0FERi1ET0NVTUVOVC1MSVNULkxBWU9VVC5USFVNQk5BSUwnLFxuICAgICAgICAgICAgc29ydGFibGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ25hbWUnLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuTkFNRScsXG4gICAgICAgICAgICBjc3NDbGFzczogJ2Z1bGwtd2lkdGggZWxsaXBzaXMtY2VsbCcsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdjb250ZW50LnNpemVJbkJ5dGVzJyxcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlU2l6ZScsXG4gICAgICAgICAgICB0aXRsZTogJ0FERi1ET0NVTUVOVC1MSVNULkxBWU9VVC5TSVpFJyxcbiAgICAgICAgICAgIHNvcnRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ21vZGlmaWVkQXQnLFxuICAgICAgICAgICAgdHlwZTogJ2RhdGUnLFxuICAgICAgICAgICAgdGl0bGU6ICdBREYtRE9DVU1FTlQtTElTVC5MQVlPVVQuTU9ESUZJRURfT04nLFxuICAgICAgICAgICAgZm9ybWF0OiAndGltZUFnbycsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdtb2RpZmllZEJ5VXNlci5kaXNwbGF5TmFtZScsXG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICB0aXRsZTogJ0FERi1ET0NVTUVOVC1MSVNULkxBWU9VVC5NT0RJRklFRF9CWScsXG4gICAgICAgICAgICBzb3J0YWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgXVxufTtcbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjbGFzcyBDb250ZW50QWN0aW9uTW9kZWwge1xuICAgIGljb246IHN0cmluZztcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGhhbmRsZXI6IENvbnRlbnRBY3Rpb25IYW5kbGVyO1xuICAgIGV4ZWN1dGU6IEZ1bmN0aW9uO1xuICAgIHRhcmdldDogc3RyaW5nO1xuICAgIHBlcm1pc3Npb246IHN0cmluZztcbiAgICBkaXNhYmxlV2l0aE5vUGVybWlzc2lvbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGRpc2FibGVkOiBib29sZWFuIHwgRnVuY3Rpb24gPSBmYWxzZTtcbiAgICB2aXNpYmxlOiBib29sZWFuIHwgRnVuY3Rpb24gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3Iob2JqPzogYW55KSB7XG4gICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIHRoaXMuaWNvbiA9IG9iai5pY29uO1xuICAgICAgICAgICAgdGhpcy50aXRsZSA9IG9iai50aXRsZTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IG9iai5oYW5kbGVyO1xuICAgICAgICAgICAgdGhpcy5leGVjdXRlID0gb2JqLmV4ZWN1dGU7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IG9iai50YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb24gPSBvYmoucGVybWlzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZVdpdGhOb1Blcm1pc3Npb24gPSBvYmouZGlzYWJsZVdpdGhOb1Blcm1pc3Npb247XG5cbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVkID0gb2JqLmRpc2FibGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCd2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2libGUgPSBvYmoudmlzaWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGVudW0gQ29udGVudEFjdGlvblRhcmdldCB7XG4gICAgRG9jdW1lbnQgPSAnZG9jdW1lbnQnLFxuICAgIEZvbGRlciA9ICdmb2xkZXInLFxuICAgIEFsbCA9ICdhbGwnXG59XG5cbmV4cG9ydCB0eXBlIENvbnRlbnRBY3Rpb25IYW5kbGVyID0gKG9iajogYW55LCB0YXJnZXQ/OiBhbnksIHBlcm1pc3Npb24/OiBzdHJpbmcpID0+IGFueTtcblxuZXhwb3J0IGNsYXNzIERvY3VtZW50QWN0aW9uTW9kZWwgZXh0ZW5kcyBDb250ZW50QWN0aW9uTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKGpzb24/OiBhbnkpICB7XG4gICAgICAgIHN1cGVyKGpzb24pO1xuICAgICAgICB0aGlzLnRhcmdldCA9ICdkb2N1bWVudCc7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRm9sZGVyQWN0aW9uTW9kZWwgZXh0ZW5kcyAgQ29udGVudEFjdGlvbk1vZGVsIHtcbiAgICBjb25zdHJ1Y3Rvcihqc29uPzogYW55KSAge1xuICAgICAgICBzdXBlcihqc29uKTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSAnZm9sZGVyJztcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBCYXNlRXZlbnQgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRpdHksIE1pbmltYWxOb2RlRW50cnlFbnRpdHkgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuXG5leHBvcnQgY2xhc3MgTm9kZUVudGl0eUV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50PE1pbmltYWxOb2RlRW50aXR5PiB7XG5cbiAgICB2YWx1ZTogTWluaW1hbE5vZGVFbnRpdHk7XG5cbiAgICBkZWZhdWx0UHJldmVudGVkOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IoZW50aXR5OiBNaW5pbWFsTm9kZUVudGl0eSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gZW50aXR5O1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5vZGVFbnRyeUV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50PE1pbmltYWxOb2RlRW50cnlFbnRpdHk+IHtcblxuICAgIHZhbHVlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5O1xuXG4gICAgZGVmYXVsdFByZXZlbnRlZDogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKGVudGl0eTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gZW50aXR5O1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgQWxmcmVzY29BcGlTZXJ2aWNlLFxuICAgIExvZ1NlcnZpY2UsXG4gICAgUGFnaW5hdGlvbk1vZGVsXG59IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5cbmltcG9ydCB7XG4gICAgTm9kZVBhZ2luZyxcbiAgICBQZXJzb25FbnRyeSxcbiAgICBTaXRlUGFnaW5nLFxuICAgIERlbGV0ZWROb2Rlc1BhZ2luZyxcbiAgICBTZWFyY2hSZXF1ZXN0XG59IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmcm9tLCBvZiwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ3VzdG9tUmVzb3VyY2VzU2VydmljZSB7XG5cbiAgICBwcml2YXRlIENSRUFURV9QRVJNSVNTSU9OID0gJ2NyZWF0ZSc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGxvZ1NlcnZpY2U6IExvZ1NlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGZpbGVzIHJlY2VudGx5IGFjY2Vzc2VkIGJ5IGEgdXNlci5cbiAgICAgKiBAcGFyYW0gcGVyc29uSWQgSUQgb2YgdGhlIHVzZXJcbiAgICAgKiBAcGFyYW0gcGFnaW5hdGlvbiBTcGVjaWZpZXMgaG93IHRvIHBhZ2luYXRlIHRoZSByZXN1bHRzXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBub2RlcyBmb3IgdGhlIHJlY2VudGx5IHVzZWQgZmlsZXNcbiAgICAgKi9cbiAgICBnZXRSZWNlbnRGaWxlcyhwZXJzb25JZDogc3RyaW5nLCBwYWdpbmF0aW9uOiBQYWdpbmF0aW9uTW9kZWwpOiBPYnNlcnZhYmxlPE5vZGVQYWdpbmc+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXBpU2VydmljZS5wZW9wbGVBcGkuZ2V0UGVyc29uKHBlcnNvbklkKVxuICAgICAgICAgICAgICAgIC50aGVuKChwZXJzb246IFBlcnNvbkVudHJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VybmFtZSA9IHBlcnNvbi5lbnRyeS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5OiBTZWFyY2hSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAnKicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiAnYWZ0cydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclF1ZXJpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBxdWVyeTogYGNtOm1vZGlmaWVkOltOT1cvREFZLTMwREFZUyBUTyBOT1cvREFZKzFEQVldYCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHF1ZXJ5OiBgY206bW9kaWZpZXI6JHt1c2VybmFtZX0gT1IgY206Y3JlYXRvcjoke3VzZXJuYW1lfWAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBxdWVyeTogYFRZUEU6XCJjb250ZW50XCIgQU5EIC1UWVBFOlwiYXBwOmZpbGVsaW5rXCIgQU5EIC1UWVBFOlwiZm06cG9zdFwiYCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiBbJ3BhdGgnLCAncHJvcGVydGllcycsICdhbGxvd2FibGVPcGVyYXRpb25zJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZJRUxEJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdjbTptb2RpZmllZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzY2VuZGluZzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SXRlbXM6IHBhZ2luYXRpb24ubWF4SXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBDb3VudDogcGFnaW5hdGlvbi5za2lwQ291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpU2VydmljZS5zZWFyY2hBcGkuc2VhcmNoKHF1ZXJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChzZWFyY2hSZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoc2VhcmNoUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5waXBlKGNhdGNoRXJyb3IoZXJyID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgZmF2b3JpdGUgZmlsZXMgZm9yIHRoZSBjdXJyZW50IHVzZXIuXG4gICAgICogQHBhcmFtIHBhZ2luYXRpb24gU3BlY2lmaWVzIGhvdyB0byBwYWdpbmF0ZSB0aGUgcmVzdWx0c1xuICAgICAqIEBwYXJhbSBpbmNsdWRlRmllbGRzIExpc3Qgb2YgZGF0YSBmaWVsZCBuYW1lcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHRzXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBmYXZvcml0ZSBmaWxlc1xuICAgICAqL1xuICAgIGxvYWRGYXZvcml0ZXMocGFnaW5hdGlvbjogUGFnaW5hdGlvbk1vZGVsLCBpbmNsdWRlRmllbGRzOiBzdHJpbmdbXSA9IFtdKTogT2JzZXJ2YWJsZTxOb2RlUGFnaW5nPiB7XG4gICAgICAgIGxldCBpbmNsdWRlRmllbGRzUmVxdWVzdCA9IHRoaXMuZ2V0SW5jbHVkZXNGaWVsZHMoaW5jbHVkZUZpZWxkcyk7XG5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1heEl0ZW1zOiBwYWdpbmF0aW9uLm1heEl0ZW1zLFxuICAgICAgICAgICAgc2tpcENvdW50OiBwYWdpbmF0aW9uLnNraXBDb3VudCxcbiAgICAgICAgICAgIHdoZXJlOiAnKEVYSVNUUyh0YXJnZXQvZmlsZSkgT1IgRVhJU1RTKHRhcmdldC9mb2xkZXIpKScsXG4gICAgICAgICAgICBpbmNsdWRlOiBpbmNsdWRlRmllbGRzUmVxdWVzdFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShvYnNlcnZlciA9PiB7XG4gICAgICAgICAgICB0aGlzLmFwaVNlcnZpY2UuZmF2b3JpdGVzQXBpLmdldEZhdm9yaXRlcygnLW1lLScsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdDogTm9kZVBhZ2luZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhZ2U6IE5vZGVQYWdpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzOiByZXN1bHQubGlzdC5lbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKCh7IGVudHJ5OiB7IHRhcmdldCB9IH06IGFueSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeTogdGFyZ2V0LmZpbGUgfHwgdGFyZ2V0LmZvbGRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKCh7IGVudHJ5IH06IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjbTp0aXRsZSc6IGVudHJ5LnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY206ZGVzY3JpcHRpb24nOiBlbnRyeS5kZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZW50cnkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uOiByZXN1bHQubGlzdC5wYWdpbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChwYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSkucGlwZShjYXRjaEVycm9yKGVyciA9PiB0aGlzLmhhbmRsZUVycm9yKGVycikpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHNpdGVzIHRoYXQgdGhlIGN1cnJlbnQgdXNlciBpcyBhIG1lbWJlciBvZi5cbiAgICAgKiBAcGFyYW0gcGFnaW5hdGlvbiBTcGVjaWZpZXMgaG93IHRvIHBhZ2luYXRlIHRoZSByZXN1bHRzXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBzaXRlc1xuICAgICAqL1xuICAgIGxvYWRNZW1iZXJTaXRlcyhwYWdpbmF0aW9uOiBQYWdpbmF0aW9uTW9kZWwpOiBPYnNlcnZhYmxlPE5vZGVQYWdpbmc+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGluY2x1ZGU6IFsncHJvcGVydGllcyddLFxuICAgICAgICAgICAgbWF4SXRlbXM6IHBhZ2luYXRpb24ubWF4SXRlbXMsXG4gICAgICAgICAgICBza2lwQ291bnQ6IHBhZ2luYXRpb24uc2tpcENvdW50XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXBpU2VydmljZS5wZW9wbGVBcGkuZ2V0U2l0ZU1lbWJlcnNoaXAoJy1tZS0nLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXN1bHQ6IFNpdGVQYWdpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYWdlOiBOb2RlUGFnaW5nID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllczogcmVzdWx0Lmxpc3QuZW50cmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoeyBlbnRyeTogeyBzaXRlIH0gfTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZS5hbGxvd2FibGVPcGVyYXRpb25zID0gc2l0ZS5hbGxvd2FibGVPcGVyYXRpb25zID8gc2l0ZS5hbGxvd2FibGVPcGVyYXRpb25zIDogW3RoaXMuQ1JFQVRFX1BFUk1JU1NJT05dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpdGUubmFtZSA9IHNpdGUubmFtZSB8fCBzaXRlLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5OiBzaXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uOiByZXN1bHQubGlzdC5wYWdpbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChwYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSkucGlwZShjYXRjaEVycm9yKGVyciA9PiB0aGlzLmhhbmRsZUVycm9yKGVycikpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBzaXRlcyBpbiB0aGUgcmVzcG9zaXRvcnkuXG4gICAgICogQHBhcmFtIHBhZ2luYXRpb24gU3BlY2lmaWVzIGhvdyB0byBwYWdpbmF0ZSB0aGUgcmVzdWx0c1xuICAgICAqIEByZXR1cm5zIExpc3Qgb2Ygc2l0ZXNcbiAgICAgKi9cbiAgICBsb2FkU2l0ZXMocGFnaW5hdGlvbjogUGFnaW5hdGlvbk1vZGVsKTogT2JzZXJ2YWJsZTxOb2RlUGFnaW5nPiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbmNsdWRlOiBbJ3Byb3BlcnRpZXMnLCAnYXNwZWN0TmFtZXMnXSxcbiAgICAgICAgICAgIG1heEl0ZW1zOiBwYWdpbmF0aW9uLm1heEl0ZW1zLFxuICAgICAgICAgICAgc2tpcENvdW50OiBwYWdpbmF0aW9uLnNraXBDb3VudFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShvYnNlcnZlciA9PiB7XG4gICAgICAgICAgICB0aGlzLmFwaVNlcnZpY2Uuc2l0ZXNBcGkuZ2V0U2l0ZXMob3B0aW9ucylcbiAgICAgICAgICAgICAgICAudGhlbigocGFnZTogTm9kZVBhZ2luZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS5saXN0LmVudHJpZXMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh7IGVudHJ5IH06IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5uYW1lID0gZW50cnkubmFtZSB8fCBlbnRyeS50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZW50cnkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChwYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSkucGlwZShjYXRjaEVycm9yKGVyciA9PiB0aGlzLmhhbmRsZUVycm9yKGVycikpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBpdGVtcyBjdXJyZW50bHkgaW4gdGhlIHRyYXNoLlxuICAgICAqIEBwYXJhbSBwYWdpbmF0aW9uIFNwZWNpZmllcyBob3cgdG8gcGFnaW5hdGUgdGhlIHJlc3VsdHNcbiAgICAgKiBAcGFyYW0gaW5jbHVkZUZpZWxkcyBMaXN0IG9mIGRhdGEgZmllbGQgbmFtZXMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzdWx0c1xuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgZGVsZXRlZCBpdGVtc1xuICAgICAqL1xuICAgIGxvYWRUcmFzaGNhbihwYWdpbmF0aW9uOiBQYWdpbmF0aW9uTW9kZWwsIGluY2x1ZGVGaWVsZHM6IHN0cmluZ1tdID0gW10pOiBPYnNlcnZhYmxlPERlbGV0ZWROb2Rlc1BhZ2luZz4ge1xuICAgICAgICBsZXQgaW5jbHVkZUZpZWxkc1JlcXVlc3QgPSB0aGlzLmdldEluY2x1ZGVzRmllbGRzKGluY2x1ZGVGaWVsZHMpO1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbmNsdWRlOiBpbmNsdWRlRmllbGRzUmVxdWVzdCxcbiAgICAgICAgICAgIG1heEl0ZW1zOiBwYWdpbmF0aW9uLm1heEl0ZW1zLFxuICAgICAgICAgICAgc2tpcENvdW50OiBwYWdpbmF0aW9uLnNraXBDb3VudFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5ub2Rlc0FwaS5nZXREZWxldGVkTm9kZXMob3B0aW9ucykpXG4gICAgICAgICAgICAucGlwZShjYXRjaEVycm9yKGVyciA9PiB0aGlzLmhhbmRsZUVycm9yKGVycikpKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgc2hhcmVkIGxpbmtzIGZvciB0aGUgY3VycmVudCB1c2VyLlxuICAgICAqIEBwYXJhbSBwYWdpbmF0aW9uIFNwZWNpZmllcyBob3cgdG8gcGFnaW5hdGUgdGhlIHJlc3VsdHNcbiAgICAgKiBAcGFyYW0gaW5jbHVkZUZpZWxkcyBMaXN0IG9mIGRhdGEgZmllbGQgbmFtZXMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzdWx0c1xuICAgICAqIEByZXR1cm5zIExpc3Qgb2Ygc2hhcmVkIGxpbmtzXG4gICAgICovXG4gICAgbG9hZFNoYXJlZExpbmtzKHBhZ2luYXRpb246IFBhZ2luYXRpb25Nb2RlbCwgaW5jbHVkZUZpZWxkczogc3RyaW5nW10gPSBbXSk6IE9ic2VydmFibGU8Tm9kZVBhZ2luZz4ge1xuICAgICAgICBsZXQgaW5jbHVkZUZpZWxkc1JlcXVlc3QgPSB0aGlzLmdldEluY2x1ZGVzRmllbGRzKGluY2x1ZGVGaWVsZHMpO1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbmNsdWRlOiBpbmNsdWRlRmllbGRzUmVxdWVzdCxcbiAgICAgICAgICAgIG1heEl0ZW1zOiBwYWdpbmF0aW9uLm1heEl0ZW1zLFxuICAgICAgICAgICAgc2tpcENvdW50OiBwYWdpbmF0aW9uLnNraXBDb3VudFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5zaGFyZWRMaW5rc0FwaS5maW5kU2hhcmVkTGlua3Mob3B0aW9ucykpXG4gICAgICAgICAgICAucGlwZShjYXRjaEVycm9yKGVyciA9PiB0aGlzLmhhbmRsZUVycm9yKGVycikpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgZm9sZGVyIElEIG9uZSBvZiB0aGUgd2VsbC1rbm93biBhbGlhc2VzP1xuICAgICAqIEBwYXJhbSBmb2xkZXJJZCBGb2xkZXIgSUQgbmFtZSB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIElEIGlzIGEgd2VsbC1rbm93biBuYW1lLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc0N1c3RvbVNvdXJjZShmb2xkZXJJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBpc0N1c3RvbVNvdXJjZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc291cmNlcyA9IFsnLXRyYXNoY2FuLScsICctc2hhcmVkbGlua3MtJywgJy1zaXRlcy0nLCAnLW15c2l0ZXMtJywgJy1mYXZvcml0ZXMtJywgJy1yZWNlbnQtJ107XG5cbiAgICAgICAgaWYgKHNvdXJjZXMuaW5kZXhPZihmb2xkZXJJZCkgPiAtMSkge1xuICAgICAgICAgICAgaXNDdXN0b21Tb3VyY2VzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0N1c3RvbVNvdXJjZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXMgdGhlIGZvbGRlciBJRCBhIFwiLW15XCIsIFwiLXJvb3QtXCIsIG9yIFwiLXNoYXJlZC1cIiBhbGlhcz9cbiAgICAgKiBAcGFyYW0gZm9sZGVySWQgRm9sZGVyIElEIG5hbWUgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBJRCBpcyBvbmUgb2YgdGhlIHN1cHBvcmVkIHNvdXJjZXMsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzU3VwcG9ydGVkU291cmNlKGZvbGRlcklkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGlzU3VwcG9ydGVkU291cmNlcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gWyctbXktJywgJy1yb290LScsICctc2hhcmVkLSddO1xuXG4gICAgICAgIGlmIChzb3VyY2VzLmluZGV4T2YoZm9sZGVySWQpID4gLTEpIHtcbiAgICAgICAgICAgIGlzU3VwcG9ydGVkU291cmNlcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNTdXBwb3J0ZWRTb3VyY2VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBmb2xkZXIncyBjb250ZW50cy5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIElEIG9mIHRoZSB0YXJnZXQgZm9sZGVyIG5vZGVcbiAgICAgKiBAcGFyYW0gcGFnaW5hdGlvbiBTcGVjaWZpZXMgaG93IHRvIHBhZ2luYXRlIHRoZSByZXN1bHRzXG4gICAgICogQHBhcmFtIGluY2x1ZGVGaWVsZHMgTGlzdCBvZiBkYXRhIGZpZWxkIG5hbWVzIHRvIGluY2x1ZGUgaW4gdGhlIHJlc3VsdHNcbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIGl0ZW1zIGNvbnRhaW5lZCBpbiB0aGUgZm9sZGVyXG4gICAgICovXG4gICAgbG9hZEZvbGRlckJ5Tm9kZUlkKG5vZGVJZDogc3RyaW5nLCBwYWdpbmF0aW9uOiBQYWdpbmF0aW9uTW9kZWwsIGluY2x1ZGVGaWVsZHM6IHN0cmluZ1tdKTogT2JzZXJ2YWJsZTxOb2RlUGFnaW5nPiB7XG4gICAgICAgIGlmIChub2RlSWQgPT09ICctdHJhc2hjYW4tJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZFRyYXNoY2FuKHBhZ2luYXRpb24sIGluY2x1ZGVGaWVsZHMpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVJZCA9PT0gJy1zaGFyZWRsaW5rcy0nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkU2hhcmVkTGlua3MocGFnaW5hdGlvbiwgaW5jbHVkZUZpZWxkcyk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZUlkID09PSAnLXNpdGVzLScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRTaXRlcyhwYWdpbmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlSWQgPT09ICctbXlzaXRlcy0nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkTWVtYmVyU2l0ZXMocGFnaW5hdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZUlkID09PSAnLWZhdm9yaXRlcy0nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkRmF2b3JpdGVzKHBhZ2luYXRpb24sIGluY2x1ZGVGaWVsZHMpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVJZCA9PT0gJy1yZWNlbnQtJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVjZW50RmlsZXMoJy1tZS0nLCBwYWdpbmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSBpdCBmcm9tIGhlcmVcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIG9uZSBvZiB0aGUgd2VsbC1rbm93biBhbGlhc2VzIGluIHRoZSBmb3JtIG9mIG5vZGUgSUQgc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIElEIG9mIHRoZSB0YXJnZXQgZm9sZGVyIG5vZGVcbiAgICAgKiBAcGFyYW0gcGFnaW5hdGlvbiBTcGVjaWZpZXMgaG93IHRvIHBhZ2luYXRlIHRoZSByZXN1bHRzXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBub2RlIElEc1xuICAgICAqL1xuICAgIGdldENvcnJlc3BvbmRpbmdOb2RlSWRzKG5vZGVJZDogc3RyaW5nLCBwYWdpbmF0aW9uOiBQYWdpbmF0aW9uTW9kZWwgPSB7fSk6IE9ic2VydmFibGU8c3RyaW5nW10+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNDdXN0b21Tb3VyY2Uobm9kZUlkKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkRm9sZGVyQnlOb2RlSWQobm9kZUlkLCBwYWdpbmF0aW9uLCBbXSlcbiAgICAgICAgICAgICAgICAucGlwZShtYXAocmVzdWx0ID0+IHJlc3VsdC5saXN0LmVudHJpZXMubWFwKChub2RlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVJZCA9PT0gJy1zaGFyZWRsaW5rcy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5lbnRyeS5ub2RlSWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlSWQgPT09ICctc2l0ZXMtJyB8fCBub2RlSWQgPT09ICctbXlzaXRlcy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5lbnRyeS5ndWlkO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZUlkID09PSAnLWZhdm9yaXRlcy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5lbnRyeS50YXJnZXRHdWlkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZW50cnkuaWQ7XG4gICAgICAgICAgICAgICAgfSkpKTtcblxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVJZCkge1xuICAgICAgICAgICAgLy8gY2FzZXMgd2hlbiBub2RlSWQgaXMgJy1teS0nLCAnLXJvb3QtJyBvciAnLXNoYXJlZC0nXG4gICAgICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmFwaVNlcnZpY2Uubm9kZXNBcGkuZ2V0Tm9kZShub2RlSWQpXG4gICAgICAgICAgICAgICAgLnRoZW4obm9kZSA9PiBbbm9kZS5lbnRyeS5pZF0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvZihbXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd2VsbC1rbm93biBhbGlhcyBoYXZlIGEgY29ycmVzcG9uZGluZyBub2RlIElEP1xuICAgICAqIEBwYXJhbSBub2RlSWQgTm9kZSB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGFsaWFzIGhhcyBhIGNvcnJlc3BvbmRpbmcgbm9kZSBJRCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaGFzQ29ycmVzcG9uZGluZ05vZGVJZHMobm9kZUlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDdXN0b21Tb3VyY2Uobm9kZUlkKSB8fCB0aGlzLmlzU3VwcG9ydGVkU291cmNlKG5vZGVJZCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRJbmNsdWRlc0ZpZWxkcyhpbmNsdWRlRmllbGRzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFsncGF0aCcsICdwcm9wZXJ0aWVzJywgJ2FsbG93YWJsZU9wZXJhdGlvbnMnLCAncGVybWlzc2lvbnMnLCAnYXNwZWN0TmFtZXMnLCAuLi5pbmNsdWRlRmllbGRzXVxuICAgICAgICAgICAgLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBpbmRleCA9PT0gYXJyYXkuaW5kZXhPZihlbGVtZW50KSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVFcnJvcihlcnJvcjogUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5sb2dTZXJ2aWNlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZXJyb3IgfHwgJ1NlcnZlciBlcnJvcicpO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbnB1dCwgTmdab25lLFxuICAgIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgU2ltcGxlQ2hhbmdlcywgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCwgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7XG4gICAgQ29udGVudFNlcnZpY2UsIERhdGFDZWxsRXZlbnQsIERhdGFDb2x1bW4sIERhdGFSb3dBY3Rpb25FdmVudCwgRGF0YVNvcnRpbmcsIERhdGFUYWJsZUNvbXBvbmVudCxcbiAgICBEaXNwbGF5TW9kZSwgT2JqZWN0RGF0YUNvbHVtbiwgUGFnaW5hdGVkQ29tcG9uZW50LCBBcHBDb25maWdTZXJ2aWNlLCBEYXRhQ29sdW1uTGlzdENvbXBvbmVudCxcbiAgICBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlLCBQYWdpbmF0aW9uTW9kZWwsIFRodW1ibmFpbFNlcnZpY2Vcbn0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRpdHksIE1pbmltYWxOb2RlRW50cnlFbnRpdHksIE5vZGVQYWdpbmcgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgU3ViamVjdCwgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24sIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTaGFyZURhdGFSb3cgfSBmcm9tICcuLy4uL2RhdGEvc2hhcmUtZGF0YS1yb3cubW9kZWwnO1xuaW1wb3J0IHsgU2hhcmVEYXRhVGFibGVBZGFwdGVyIH0gZnJvbSAnLi8uLi9kYXRhL3NoYXJlLWRhdGF0YWJsZS1hZGFwdGVyJztcbmltcG9ydCB7IHByZXNldHNEZWZhdWx0TW9kZWwgfSBmcm9tICcuLi9tb2RlbHMvcHJlc2V0Lm1vZGVsJztcbmltcG9ydCB7IENvbnRlbnRBY3Rpb25Nb2RlbCB9IGZyb20gJy4vLi4vbW9kZWxzL2NvbnRlbnQtYWN0aW9uLm1vZGVsJztcbmltcG9ydCB7IFBlcm1pc3Npb25TdHlsZU1vZGVsIH0gZnJvbSAnLi8uLi9tb2RlbHMvcGVybWlzc2lvbnMtc3R5bGUubW9kZWwnO1xuaW1wb3J0IHsgRG9jdW1lbnRMaXN0U2VydmljZSB9IGZyb20gJy4vLi4vc2VydmljZXMvZG9jdW1lbnQtbGlzdC5zZXJ2aWNlJztcbmltcG9ydCB7IE5vZGVFbnRpdHlFdmVudCwgTm9kZUVudHJ5RXZlbnQgfSBmcm9tICcuL25vZGUuZXZlbnQnO1xuaW1wb3J0IHsgQ3VzdG9tUmVzb3VyY2VzU2VydmljZSB9IGZyb20gJy4vLi4vc2VydmljZXMvY3VzdG9tLXJlc291cmNlcy5zZXJ2aWNlJztcbmltcG9ydCB7IE5hdmlnYWJsZUNvbXBvbmVudEludGVyZmFjZSB9IGZyb20gJy4uLy4uL2JyZWFkY3J1bWIvbmF2aWdhYmxlLWNvbXBvbmVudC5pbnRlcmZhY2UnO1xuXG5leHBvcnQgZW51bSBQYWdpbmF0aW9uU3RyYXRlZ3kge1xuICAgIEZpbml0ZSxcbiAgICBJbmZpbml0ZVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1kb2N1bWVudC1saXN0JyxcbiAgICBzdHlsZVVybHM6IFsnLi9kb2N1bWVudC1saXN0LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgdGVtcGxhdGVVcmw6ICcuL2RvY3VtZW50LWxpc3QuY29tcG9uZW50Lmh0bWwnLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgRG9jdW1lbnRMaXN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCwgUGFnaW5hdGVkQ29tcG9uZW50LCBOYXZpZ2FibGVDb21wb25lbnRJbnRlcmZhY2Uge1xuXG4gICAgc3RhdGljIFNJTkdMRV9DTElDS19OQVZJR0FUSU9OOiBzdHJpbmcgPSAnY2xpY2snO1xuICAgIHN0YXRpYyBET1VCTEVfQ0xJQ0tfTkFWSUdBVElPTjogc3RyaW5nID0gJ2RibGNsaWNrJztcbiAgICBzdGF0aWMgREVGQVVMVF9QQUdFX1NJWkU6IG51bWJlciA9IDIwO1xuXG4gICAgQENvbnRlbnRDaGlsZChEYXRhQ29sdW1uTGlzdENvbXBvbmVudClcbiAgICBjb2x1bW5MaXN0OiBEYXRhQ29sdW1uTGlzdENvbXBvbmVudDtcblxuICAgIC8qKiBJbmNsdWRlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG5vZGUgaW4gdGhlIHNlcnZlciByZXF1ZXN0LmZvciBleGFtcGxlOiBhc3NvY2lhdGlvbiwgaXNMaW5rLCBpc0xvY2tlZCBhbmQgb3RoZXJzLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW5jbHVkZUZpZWxkczogc3RyaW5nW107XG5cbiAgICAvKiogQ2hhbmdlIHRoZSBkaXNwbGF5IG1vZGUgb2YgdGhlIHRhYmxlLiBDYW4gYmUgXCJsaXN0XCIgb3IgXCJnYWxsZXJ5XCIuICovXG4gICAgQElucHV0KClcbiAgICBkaXNwbGF5OiBzdHJpbmcgPSBEaXNwbGF5TW9kZS5MaXN0O1xuXG4gICAgLyoqIERlZmluZSBhIHNldCBvZiBDU1Mgc3R5bGVzIHN0eWxlcyB0byBhcHBseSBkZXBlbmRpbmcgb24gdGhlIHBlcm1pc3Npb25cbiAgICAgKiBvZiB0aGUgdXNlciBvbiB0aGF0IG5vZGUuIFNlZSB0aGUgUGVybWlzc2lvbiBTdHlsZSBtb2RlbFxuICAgICAqIHBhZ2UgZm9yIGZ1cnRoZXIgZGV0YWlscyBhbmQgZXhhbXBsZXMuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwZXJtaXNzaW9uc1N0eWxlOiBQZXJtaXNzaW9uU3R5bGVNb2RlbFtdID0gW107XG5cbiAgICAvKiogVGhlIGRlZmF1bHQgcm91dGUgZm9yIGFsbCB0aGUgbG9jYXRpb24tYmFzZWQgY29sdW1ucyAoaWYgZGVjbGFyZWQpLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgbG9jYXRpb25Gb3JtYXQ6IHN0cmluZyA9ICcvJztcblxuICAgIC8qKiBUb2dnbGVzIG5hdmlnYXRpb24gdG8gZm9sZGVyIGNvbnRlbnQgb3IgZmlsZSBwcmV2aWV3ICovXG4gICAgQElucHV0KClcbiAgICBuYXZpZ2F0ZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogVG9nZ2xlcyB0aGUgaGVhZGVyICovXG4gICAgQElucHV0KClcbiAgICBzaG93SGVhZGVyOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKiBVc2VyIGludGVyYWN0aW9uIGZvciBmb2xkZXIgbmF2aWdhdGlvbiBvciBmaWxlIHByZXZpZXcuXG4gICAgICogVmFsaWQgdmFsdWVzIGFyZSBcImNsaWNrXCIgYW5kIFwiZGJsY2xpY2tcIi4gRGVmYXVsdCB2YWx1ZTogXCJkYmxjbGlja1wiXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBuYXZpZ2F0aW9uTW9kZTogc3RyaW5nID0gRG9jdW1lbnRMaXN0Q29tcG9uZW50LkRPVUJMRV9DTElDS19OQVZJR0FUSU9OOyAvLyBjbGlja3xkYmxjbGlja1xuXG4gICAgLyoqIFNob3cgZG9jdW1lbnQgdGh1bWJuYWlscyByYXRoZXIgdGhhbiBpY29ucyAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGh1bWJuYWlsczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIFJvdyBzZWxlY3Rpb24gbW9kZS4gQ2FuIGJlIG51bGwsIGBzaW5nbGVgIG9yIGBtdWx0aXBsZWAuIEZvciBgbXVsdGlwbGVgIG1vZGUsXG4gICAgICogeW91IGNhbiB1c2UgQ21kIChtYWNPUykgb3IgQ3RybCAoV2luKSBtb2RpZmllciBrZXkgdG8gdG9nZ2xlIHNlbGVjdGlvbiBmb3IgbXVsdGlwbGUgcm93cy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbk1vZGU6IHN0cmluZyA9ICdzaW5nbGUnOyAvLyBudWxsfHNpbmdsZXxtdWx0aXBsZVxuXG4gICAgLyoqIFRvZ2dsZXMgbXVsdGlzZWxlY3QgbW9kZSAqL1xuICAgIEBJbnB1dCgpXG4gICAgbXVsdGlzZWxlY3Q6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBUb2dnbGVzIGNvbnRlbnQgYWN0aW9ucyBmb3IgZWFjaCByb3cgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRlbnRBY3Rpb25zOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogUG9zaXRpb24gb2YgdGhlIGNvbnRlbnQgYWN0aW9ucyBkcm9wZG93biBtZW51LiBDYW4gYmUgc2V0IHRvIFwibGVmdFwiIG9yIFwicmlnaHRcIi4gKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRlbnRBY3Rpb25zUG9zaXRpb246IHN0cmluZyA9ICdyaWdodCc7IC8vIGxlZnR8cmlnaHRcblxuICAgIC8qKiBUb2dnbGVzIGNvbnRleHQgbWVudXMgZm9yIGVhY2ggcm93ICovXG4gICAgQElucHV0KClcbiAgICBjb250ZXh0TWVudUFjdGlvbnM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBDdXN0b20gaW1hZ2UgZm9yIGVtcHR5IGZvbGRlci4gRGVmYXVsdCB2YWx1ZTogJy4vYXNzZXRzL2ltYWdlcy9lbXB0eV9kb2NfbGliLnN2ZycgKi9cbiAgICBASW5wdXQoKVxuICAgIGVtcHR5Rm9sZGVySW1hZ2VVcmw6IHN0cmluZyA9ICcuL2Fzc2V0cy9pbWFnZXMvZW1wdHlfZG9jX2xpYi5zdmcnO1xuXG4gICAgLyoqIFRvZ2dsZSBmaWxlIGRyb3Agc3VwcG9ydCBmb3Igcm93cyAoc2VlIFVwbG9hZCBEaXJlY3RpdmUgZm9yIGZ1cnRoZXIgZGV0YWlscyAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWxsb3dEcm9wRmlsZXM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBEZWZpbmVzIGRlZmF1bHQgc29ydGluZy4gVGhlIGZvcm1hdCBpcyBhbiBhcnJheSBvZiAyIHN0cmluZ3MgYFtrZXksIGRpcmVjdGlvbl1gXG4gICAgICogaS5lLiBgWyduYW1lJywgJ2Rlc2MnXWAgb3IgYFsnbmFtZScsICdhc2MnXWAuIFNldCB0aGlzIHZhbHVlIG9ubHkgaWYgeW91IHdhbnQgdG9cbiAgICAgKiBvdmVycmlkZSB0aGUgZGVmYXVsdCBzb3J0aW5nIGRldGVjdGVkIGJ5IHRoZSBjb21wb25lbnQgYmFzZWQgb24gY29sdW1ucy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNvcnRpbmcgPSBbJ25hbWUnLCAnYXNjJ107XG5cbiAgICAvKiogRGVmaW5lcyBzb3J0aW5nIG1vZGUuIENhbiBiZSBlaXRoZXIgYGNsaWVudGAgb3IgYHNlcnZlcmAuICovXG4gICAgQElucHV0KClcbiAgICBzb3J0aW5nTW9kZSA9ICdjbGllbnQnO1xuXG4gICAgLyoqIFRoZSBpbmxpbmUgc3R5bGUgdG8gYXBwbHkgdG8gZXZlcnkgcm93LiBTZWVcbiAgICAgKiB0aGUgQW5ndWxhciBOZ1N0eWxlXG4gICAgICogZG9jcyBmb3IgbW9yZSBkZXRhaWxzIGFuZCB1c2FnZSBleGFtcGxlcy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJvd1N0eWxlOiBzdHJpbmc7XG5cbiAgICAvKiogVGhlIENTUyBjbGFzcyB0byBhcHBseSB0byBldmVyeSByb3cgKi9cbiAgICBASW5wdXQoKVxuICAgIHJvd1N0eWxlQ2xhc3M6IHN0cmluZztcblxuICAgIC8qKiBUb2dnbGVzIHRoZSBsb2FkaW5nIHN0YXRlIGFuZCBhbmltYXRlZCBzcGlubmVycyBmb3IgdGhlIGNvbXBvbmVudC4gVXNlZCBpblxuICAgICAqIGNvbWJpbmF0aW9uIHdpdGggYG5hdmlnYXRlPWZhbHNlYCB0byBwZXJmb3JtIGN1c3RvbSBuYXZpZ2F0aW9uIGFuZCBsb2FkaW5nXG4gICAgICogc3RhdGUgaW5kaWNhdGlvbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxvYWRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBDdXN0b20gcm93IGZpbHRlciAqL1xuICAgIEBJbnB1dCgpXG4gICAgcm93RmlsdGVyOiBhbnkgfCBudWxsID0gbnVsbDtcblxuICAgIC8qKiBDdXN0b20gaW1hZ2UgcmVzb2x2ZXIgKi9cbiAgICBASW5wdXQoKVxuICAgIGltYWdlUmVzb2x2ZXI6IGFueSB8IG51bGwgPSBudWxsO1xuXG4gICAgLyoqIFRoZSBJRCBvZiB0aGUgZm9sZGVyIG5vZGUgdG8gZGlzcGxheSBvciBhIHJlc2VydmVkIHN0cmluZyBhbGlhcyBmb3Igc3BlY2lhbCBzb3VyY2VzICovXG4gICAgQElucHV0KClcbiAgICBjdXJyZW50Rm9sZGVySWQ6IHN0cmluZyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50bHkgZGlzcGxheWVkIGZvbGRlciBub2RlXG4gICAgICogQGRlcHJlY2F0ZWQgMi4zLjAgLSB1c2UgY3VycmVudEZvbGRlcklkIG9yIG5vZGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvbGRlck5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkgPSBudWxsO1xuXG4gICAgLyoqIFRoZSBEb2N1bWVudCBsaXN0IHdpbGwgc2hvdyBhbGwgdGhlIG5vZGVzIGNvbnRhaW5lZCBpbiB0aGUgTm9kZVBhZ2luZyBlbnRpdHkgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vZGU6IE5vZGVQYWdpbmcgPSBudWxsO1xuXG4gICAgLyoqIERlZmF1bHQgdmFsdWUgaXMgc3RvcmVkIGludG8gdXNlciBwcmVmZXJlbmNlIHNldHRpbmdzIHVzZSBpdCBvbmx5IGlmIHlvdSBhcmUgbm90IHVzaW5nIHRoZSBwYWdpbmF0aW9uICovXG4gICAgQElucHV0KClcbiAgICBtYXhJdGVtczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgb3ZlciBmb3IgcGFnaW5hdGlvbiBwdXJwb3Nlc1xuICAgICAqIEBkZXByZWNhdGVkIDIuMy4wIC0gZGVmaW5lIGl0IGluIHBhZ2luYXRpb25cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNraXBDb3VudDogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCBkb2N1bWVudCBsaXN0IHRvIHdvcmsgaW4gaW5maW5pdGUgc2Nyb2xsaW5nIG1vZGVcbiAgICAgKiBAZGVwcmVjYXRlZCAyLjMuMFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZW5hYmxlSW5maW5pdGVTY3JvbGxpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGEgbGlzdCBub2RlICovXG4gICAgQE91dHB1dCgpXG4gICAgbm9kZUNsaWNrOiBFdmVudEVtaXR0ZXI8Tm9kZUVudGl0eUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8Tm9kZUVudGl0eUV2ZW50PigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIGEgbGlzdCBub2RlICovXG4gICAgQE91dHB1dCgpXG4gICAgbm9kZURibENsaWNrOiBFdmVudEVtaXR0ZXI8Tm9kZUVudGl0eUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8Tm9kZUVudGl0eUV2ZW50PigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgY3VycmVudCBkaXNwbGF5IGZvbGRlciBjaGFuZ2VzICovXG4gICAgQE91dHB1dCgpXG4gICAgZm9sZGVyQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Tm9kZUVudHJ5RXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxOb2RlRW50cnlFdmVudD4oKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIHVzZXIgYWN0cyB1cG9uIGZpbGVzIHdpdGggZWl0aGVyIHNpbmdsZSBvciBkb3VibGUgY2xpY2tcbiAgICAgKiAoZGVwZW5kcyBvbiBgbmF2aWdhdGlvbi1tb2RlYCkuIFVzZWZ1bCBmb3IgaW50ZWdyYXRpb24gd2l0aCB0aGVcbiAgICAgKiBWaWV3ZXIgY29tcG9uZW50LlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHByZXZpZXc6IEV2ZW50RW1pdHRlcjxOb2RlRW50aXR5RXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxOb2RlRW50aXR5RXZlbnQ+KCk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSBEb2N1bWVudCBMaXN0IGhhcyBsb2FkZWQgYWxsIGl0ZW1zIGFuZCBpcyByZWFkeSBmb3IgdXNlICovXG4gICAgQE91dHB1dCgpXG4gICAgcmVhZHk6IEV2ZW50RW1pdHRlcjxOb2RlUGFnaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIEFQSSBmYWlscyB0byBnZXQgdGhlIERvY3VtZW50IExpc3QgZGF0YSAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGVycm9yOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIEBWaWV3Q2hpbGQoJ2RhdGFUYWJsZScpXG4gICAgZGF0YVRhYmxlOiBEYXRhVGFibGVDb21wb25lbnQ7XG5cbiAgICBhY3Rpb25zOiBDb250ZW50QWN0aW9uTW9kZWxbXSA9IFtdO1xuICAgIGVtcHR5Rm9sZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgbm9QZXJtaXNzaW9uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgY29udGV4dEFjdGlvbkhhbmRsZXI6IFN1YmplY3Q8YW55PiA9IG5ldyBTdWJqZWN0KCk7XG4gICAgZGF0YTogU2hhcmVEYXRhVGFibGVBZGFwdGVyO1xuICAgIG5vUGVybWlzc2lvbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHNlbGVjdGlvbiA9IG5ldyBBcnJheTxNaW5pbWFsTm9kZUVudGl0eT4oKTtcblxuICAgIHByaXZhdGUgX3BhZ2luYXRpb246IEJlaGF2aW9yU3ViamVjdDxQYWdpbmF0aW9uTW9kZWw+O1xuICAgIHByaXZhdGUgbGF5b3V0UHJlc2V0cyA9IHt9O1xuICAgIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgICBwcml2YXRlIHJvd01lbnVDYWNoZTogeyBba2V5OiBzdHJpbmddOiBDb250ZW50QWN0aW9uTW9kZWxbXSB9ID0ge307XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRvY3VtZW50TGlzdFNlcnZpY2U6IERvY3VtZW50TGlzdFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBhcHBDb25maWc6IEFwcENvbmZpZ1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBwcmVmZXJlbmNlczogVXNlclByZWZlcmVuY2VzU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGN1c3RvbVJlc291cmNlc1NlcnZpY2U6IEN1c3RvbVJlc291cmNlc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBjb250ZW50U2VydmljZTogQ29udGVudFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSB0aHVtYm5haWxTZXJ2aWNlOiBUaHVtYm5haWxTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgZ2V0Q29udGV4dEFjdGlvbnMobm9kZTogTWluaW1hbE5vZGVFbnRpdHkpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5lbnRyeSkge1xuICAgICAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzLmdldE5vZGVBY3Rpb25zKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGFjdGlvbnMgJiYgYWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbnMubWFwKChjdXJyZW50QWN0aW9uOiBDb250ZW50QWN0aW9uTW9kZWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiBjdXJyZW50QWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3Q6IHRoaXMuY29udGV4dEFjdGlvbkhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKiogQGRlcHJlY2F0ZWQgMi4zLjAgZGVmaW5lIGl0IGluIHBhZ2luYXRpb24gKi9cbiAgICBnZXQgc3VwcG9ydGVkUGFnZVNpemVzKCk6IG51bWJlcltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZmVyZW5jZXMuZ2V0RGVmYXVsdFBhZ2VTaXplcygpO1xuICAgIH1cblxuICAgIGdldCBoYXNDdXN0b21MYXlvdXQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkxpc3QgJiYgdGhpcy5jb2x1bW5MaXN0LmNvbHVtbnMgJiYgdGhpcy5jb2x1bW5MaXN0LmNvbHVtbnMubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldERlZmF1bHRTb3J0aW5nKCk6IERhdGFTb3J0aW5nIHtcbiAgICAgICAgbGV0IGRlZmF1bHRTb3J0aW5nOiBEYXRhU29ydGluZztcbiAgICAgICAgaWYgKHRoaXMuc29ydGluZykge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgZGlyZWN0aW9uXSA9IHRoaXMuc29ydGluZztcbiAgICAgICAgICAgIGRlZmF1bHRTb3J0aW5nID0gbmV3IERhdGFTb3J0aW5nKGtleSwgZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdFNvcnRpbmc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMYXlvdXRQcmVzZXQobmFtZTogc3RyaW5nID0gJ2RlZmF1bHQnKTogRGF0YUNvbHVtbltdIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxheW91dFByZXNldHNbbmFtZV0gfHwgdGhpcy5sYXlvdXRQcmVzZXRzWydkZWZhdWx0J10pLm1hcChjb2wgPT4gbmV3IE9iamVjdERhdGFDb2x1bW4oY29sKSk7XG4gICAgfVxuXG4gICAgZ2V0IHBhZ2luYXRpb24oKTogQmVoYXZpb3JTdWJqZWN0PFBhZ2luYXRpb25Nb2RlbD4ge1xuICAgICAgICBsZXQgbWF4SXRlbXMgPSB0aGlzLnByZWZlcmVuY2VzLnBhZ2luYXRpb25TaXplO1xuXG4gICAgICAgIGlmICghdGhpcy5fcGFnaW5hdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubWF4SXRlbXMpIHtcbiAgICAgICAgICAgICAgICBtYXhJdGVtcyA9IHRoaXMubWF4SXRlbXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBkZWZhdWx0UGFnaW5hdGlvbiA9IDxQYWdpbmF0aW9uTW9kZWw+IHtcbiAgICAgICAgICAgICAgICBtYXhJdGVtczogbWF4SXRlbXMsXG4gICAgICAgICAgICAgICAgc2tpcENvdW50OiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsSXRlbXM6IDAsXG4gICAgICAgICAgICAgICAgaGFzTW9yZUl0ZW1zOiBmYWxzZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fcGFnaW5hdGlvbiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8UGFnaW5hdGlvbk1vZGVsPihkZWZhdWx0UGFnaW5hdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcGFnaW5hdGlvbjtcbiAgICB9XG5cbiAgICBpc0VtcHR5VGVtcGxhdGVEZWZpbmVkKCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5kYXRhVGFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVtcHR5Rm9sZGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaXNOb1Blcm1pc3Npb25UZW1wbGF0ZURlZmluZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFUYWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubm9QZXJtaXNzaW9uVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaXNNb2JpbGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIS9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG5cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGEuZ2V0Um93cygpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5yb3dNZW51Q2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5sb2FkTGF5b3V0UHJlc2V0cygpO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgU2hhcmVEYXRhVGFibGVBZGFwdGVyKHRoaXMuZG9jdW1lbnRMaXN0U2VydmljZSwgdGhpcy50aHVtYm5haWxTZXJ2aWNlLCBudWxsLCB0aGlzLmdldERlZmF1bHRTb3J0aW5nKCksIHRoaXMuc29ydGluZ01vZGUpO1xuICAgICAgICB0aGlzLmRhdGEudGh1bWJuYWlscyA9IHRoaXMudGh1bWJuYWlscztcbiAgICAgICAgdGhpcy5kYXRhLnBlcm1pc3Npb25zU3R5bGUgPSB0aGlzLnBlcm1pc3Npb25zU3R5bGU7XG5cbiAgICAgICAgaWYgKHRoaXMucm93RmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuc2V0RmlsdGVyKHRoaXMucm93RmlsdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmltYWdlUmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zZXRJbWFnZVJlc29sdmVyKHRoaXMuaW1hZ2VSZXNvbHZlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgICAgIHRoaXMuY29udGV4dEFjdGlvbkhhbmRsZXIuc3Vic2NyaWJlKHZhbCA9PiB0aGlzLmNvbnRleHRBY3Rpb25DYWxsYmFjayh2YWwpKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuZW5mb3JjZVNpbmdsZUNsaWNrTmF2aWdhdGlvbkZvck1vYmlsZSgpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGlzdCkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5MaXN0LmNvbHVtbnMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRhYmxlU2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRUYWJsZVNjaGVtYSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0VGFibGVTY2hlbWEoKSB7XG4gICAgICAgIGxldCBzY2hlbWE6IERhdGFDb2x1bW5bXSA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0N1c3RvbUxheW91dCkge1xuICAgICAgICAgICAgc2NoZW1hID0gdGhpcy5jb2x1bW5MaXN0LmNvbHVtbnMubWFwKGMgPT4gPERhdGFDb2x1bW4+IGMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBTaGFyZURhdGFUYWJsZUFkYXB0ZXIodGhpcy5kb2N1bWVudExpc3RTZXJ2aWNlLCB0aGlzLnRodW1ibmFpbFNlcnZpY2UsIHNjaGVtYSwgdGhpcy5nZXREZWZhdWx0U29ydGluZygpLCB0aGlzLnNvcnRpbmdNb2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2hlbWEgJiYgc2NoZW1hLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zZXRDb2x1bW5zKHNjaGVtYSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29sdW1ucyA9IHRoaXMuZGF0YS5nZXRDb2x1bW5zKCk7XG4gICAgICAgIGlmICghY29sdW1ucyB8fCBjb2x1bW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXR1cERlZmF1bHRDb2x1bW5zKHRoaXMuY3VycmVudEZvbGRlcklkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEudGh1bWJuYWlscyA9IHRoaXMudGh1bWJuYWlscztcblxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLnNvcnRpbmdNb2RlICYmICFjaGFuZ2VzLnNvcnRpbmdNb2RlLmZpcnN0Q2hhbmdlICYmIHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnNvcnRpbmdNb2RlID0gY2hhbmdlcy5zb3J0aW5nTW9kZS5jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlcy5zb3J0aW5nICYmICFjaGFuZ2VzLnNvcnRpbmcuZmlyc3RDaGFuZ2UgJiYgdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGNoYW5nZXMuc29ydGluZy5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgJiYgbmV3VmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIGRpcmVjdGlvbl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc2V0U29ydGluZyhuZXcgRGF0YVNvcnRpbmcoa2V5LCBkaXJlY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VzLmZvbGRlck5vZGUgJiYgY2hhbmdlcy5mb2xkZXJOb2RlLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Rm9sZGVySWQgPSBjaGFuZ2VzLmZvbGRlck5vZGUuY3VycmVudFZhbHVlLmlkO1xuICAgICAgICAgICAgdGhpcy5yZXNldE5ld0ZvbGRlclBhZ2luYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMubG9hZEZvbGRlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZXMuY3VycmVudEZvbGRlcklkICYmXG4gICAgICAgICAgICBjaGFuZ2VzLmN1cnJlbnRGb2xkZXJJZC5jdXJyZW50VmFsdWUgJiZcbiAgICAgICAgICAgIGNoYW5nZXMuY3VycmVudEZvbGRlcklkLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5jdXJyZW50Rm9sZGVySWQucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldE5ld0ZvbGRlclBhZ2luYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMubG9hZEZvbGRlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMubm9kZSAmJiBjaGFuZ2VzLm5vZGUuY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmxvYWRQYWdlKGNoYW5nZXMubm9kZS5jdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMub25EYXRhUmVhZHkoY2hhbmdlcy5ub2RlLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZXMucm93RmlsdGVyICYmIGNoYW5nZXMucm93RmlsdGVyLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5yb3dGaWx0ZXIucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zZXRGaWx0ZXIoY2hhbmdlcy5yb3dGaWx0ZXIuY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Rm9sZGVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkRm9sZGVyTm9kZXNCeUZvbGRlck5vZGVJZCh0aGlzLmN1cnJlbnRGb2xkZXJJZCwgdGhpcy5wYWdpbmF0aW9uLmdldFZhbHVlKCkpLmNhdGNoKGVyciA9PiB0aGlzLmVycm9yLmVtaXQoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2VzLmltYWdlUmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc2V0SW1hZ2VSZXNvbHZlcihjaGFuZ2VzLmltYWdlUmVzb2x2ZXIuY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEubG9hZFBhZ2UodGhpcy5ub2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YVJlYWR5KHRoaXMubm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZEZvbGRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb250ZXh0QWN0aW9uQ2FsbGJhY2soYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZUNvbnRlbnRBY3Rpb24oYWN0aW9uLm5vZGUsIGFjdGlvbi5tb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXROb2RlQWN0aW9ucyhub2RlOiBNaW5pbWFsTm9kZUVudGl0eSB8IGFueSk6IENvbnRlbnRBY3Rpb25Nb2RlbFtdIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5lbnRyeSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmVudHJ5LmlzRmlsZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9ICdkb2N1bWVudCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuZW50cnkuaXNGb2xkZXIpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSAnZm9sZGVyJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSB0aGlzLnJvd01lbnVDYWNoZVtub2RlLmVudHJ5LmlkXTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLmZvckVhY2goYWN0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEFjdGlvbihhY3Rpb24sIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGFjdGlvbnNCeVRhcmdldCA9IHRoaXMuYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9ICh0eXBlb2YgZW50cnkudmlzaWJsZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVudHJ5LnZpc2libGUobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGVudHJ5LnZpc2libGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1Zpc2libGUgJiYgZW50cnkudGFyZ2V0LnRvTG93ZXJDYXNlKCkgPT09IHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChhY3Rpb24gPT4gbmV3IENvbnRlbnRBY3Rpb25Nb2RlbChhY3Rpb24pKTtcblxuICAgICAgICAgICAgICAgIGFjdGlvbnNCeVRhcmdldC5mb3JFYWNoKChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQWN0aW9uKGFjdGlvbiwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJvd01lbnVDYWNoZVtub2RlLmVudHJ5LmlkXSA9IGFjdGlvbnNCeVRhcmdldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uc0J5VGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVmcmVzaEFjdGlvbihhY3Rpb246IENvbnRlbnRBY3Rpb25Nb2RlbCwgbm9kZTogTWluaW1hbE5vZGVFbnRpdHkpIHtcbiAgICAgICAgYWN0aW9uLmRpc2FibGVkID0gdGhpcy5pc0FjdGlvbkRpc2FibGVkKGFjdGlvbiwgbm9kZSk7XG4gICAgICAgIGFjdGlvbi52aXNpYmxlID0gdGhpcy5pc0FjdGlvblZpc2libGUoYWN0aW9uLCBub2RlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzQWN0aW9uVmlzaWJsZShhY3Rpb246IENvbnRlbnRBY3Rpb25Nb2RlbCwgbm9kZTogTWluaW1hbE5vZGVFbnRpdHkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24udmlzaWJsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi52aXNpYmxlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjdGlvbi52aXNpYmxlO1xuICAgIH1cblxuICAgIHByaXZhdGUgaXNBY3Rpb25EaXNhYmxlZChhY3Rpb246IENvbnRlbnRBY3Rpb25Nb2RlbCwgbm9kZTogTWluaW1hbE5vZGVFbnRpdHkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24uZGlzYWJsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZGlzYWJsZWQobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uLnBlcm1pc3Npb24gJiYgYWN0aW9uLmRpc2FibGVXaXRoTm9QZXJtaXNzaW9uICYmICF0aGlzLmNvbnRlbnRTZXJ2aWNlLmhhc1Blcm1pc3Npb24obm9kZS5lbnRyeSwgYWN0aW9uLnBlcm1pc3Npb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY3Rpb24uZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY29udGV4dG1lbnUnLCBbJyRldmVudCddKVxuICAgIG9uU2hvd0NvbnRleHRNZW51KGU/OiBFdmVudCkge1xuICAgICAgICBpZiAoZSAmJiB0aGlzLmNvbnRleHRNZW51QWN0aW9ucykge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGVyZm9ybU5hdmlnYXRpb24obm9kZTogTWluaW1hbE5vZGVFbnRpdHkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuTmF2aWdhdGVGb2xkZXIobm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9sZGVyRGF0YShub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwZXJmb3JtQ3VzdG9tU291cmNlTmF2aWdhdGlvbihub2RlOiBNaW5pbWFsTm9kZUVudGl0eSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5jdXN0b21SZXNvdXJjZXNTZXJ2aWNlLmlzQ3VzdG9tU291cmNlKHRoaXMuY3VycmVudEZvbGRlcklkKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb2xkZXJEYXRhKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHVwZGF0ZUZvbGRlckRhdGEobm9kZTogTWluaW1hbE5vZGVFbnRpdHkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZXNldE5ld0ZvbGRlclBhZ2luYXRpb24oKTtcbiAgICAgICAgdGhpcy5jdXJyZW50Rm9sZGVySWQgPSBub2RlLmVudHJ5LmlkO1xuICAgICAgICB0aGlzLnJlbG9hZCgpO1xuICAgICAgICB0aGlzLmZvbGRlckNoYW5nZS5lbWl0KG5ldyBOb2RlRW50cnlFdmVudChub2RlLmVudHJ5KSk7XG4gICAgfVxuXG4gICAgdXBkYXRlQ3VzdG9tU291cmNlRGF0YShub2RlSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmZvbGRlck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRGb2xkZXJJZCA9IG5vZGVJZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gZXhlY3V0aW5nIGNvbnRlbnQgYWN0aW9uIGZvciBhIGRvY3VtZW50IG9yIGZvbGRlci5cbiAgICAgKiBAcGFyYW0gbm9kZSBOb2RlIHRvIGJlIHRoZSBjb250ZXh0IG9mIHRoZSBleGVjdXRpb24uXG4gICAgICogQHBhcmFtIGFjdGlvbiBBY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWdhaW5zdCB0aGUgY29udGV4dC5cbiAgICAgKi9cbiAgICBleGVjdXRlQ29udGVudEFjdGlvbihub2RlOiBNaW5pbWFsTm9kZUVudGl0eSwgYWN0aW9uOiBDb250ZW50QWN0aW9uTW9kZWwpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5lbnRyeSAmJiBhY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyU3ViO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbi5oYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlclN1YiA9IGFjdGlvbi5oYW5kbGVyKG5vZGUsIHRoaXMsIGFjdGlvbi5wZXJtaXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlclN1YiA9IG9mKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbi5leGVjdXRlID09PSAnZnVuY3Rpb24nICYmIGhhbmRsZXJTdWIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyU3ViLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5leGVjdXRlKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZEZvbGRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhZ2luYXRpb24uZ2V0VmFsdWUoKS5tZXJnZSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5oYXNDdXN0b21MYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBEZWZhdWx0Q29sdW1ucyh0aGlzLmN1cnJlbnRGb2xkZXJJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mb2xkZXJOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkRm9sZGVyTm9kZXNCeUZvbGRlck5vZGVJZCh0aGlzLmZvbGRlck5vZGUuaWQsIHRoaXMucGFnaW5hdGlvbi5nZXRWYWx1ZSgpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9hZEZvbGRlckJ5Tm9kZUlkKHRoaXMuY3VycmVudEZvbGRlcklkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvYWRGb2xkZXJCeU5vZGVJZChub2RlSWQ6IHN0cmluZykge1xuICAgICAgICBpZiAodGhpcy5jdXN0b21SZXNvdXJjZXNTZXJ2aWNlLmlzQ3VzdG9tU291cmNlKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VzdG9tU291cmNlRGF0YShub2RlSWQpO1xuICAgICAgICAgICAgdGhpcy5jdXN0b21SZXNvdXJjZXNTZXJ2aWNlLmxvYWRGb2xkZXJCeU5vZGVJZChub2RlSWQsIHRoaXMucGFnaW5hdGlvbi5nZXRWYWx1ZSgpLCB0aGlzLmluY2x1ZGVGaWVsZHMpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocGFnZTogTm9kZVBhZ2luZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUGFnZUxvYWRlZChwYWdlKTtcbiAgICAgICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yLmVtaXQoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRMaXN0U2VydmljZVxuICAgICAgICAgICAgICAgIC5nZXRGb2xkZXJOb2RlKG5vZGVJZCwgdGhpcy5pbmNsdWRlRmllbGRzKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKG5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2xkZXJOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEZvbGRlck5vZGVzQnlGb2xkZXJOb2RlSWQobm9kZS5pZCwgdGhpcy5wYWdpbmF0aW9uLmdldFZhbHVlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZEZvbGRlck5vZGVzQnlGb2xkZXJOb2RlSWQoaWQ6IHN0cmluZywgcGFnaW5hdGlvbjogUGFnaW5hdGlvbk1vZGVsKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudExpc3RTZXJ2aWNlXG4gICAgICAgICAgICAgICAgLmdldEZvbGRlcihudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgIG1heEl0ZW1zOiBwYWdpbmF0aW9uLm1heEl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBza2lwQ291bnQ6IHBhZ2luYXRpb24uc2tpcENvdW50LFxuICAgICAgICAgICAgICAgICAgICByb290Rm9sZGVySWQ6IGlkXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5pbmNsdWRlRmllbGRzKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgICAgICAgIG5vZGVQYWdpbmcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmxvYWRQYWdlKDxOb2RlUGFnaW5nPiBub2RlUGFnaW5nLCB0aGlzLnBhZ2luYXRpb24uZ2V0VmFsdWUoKS5tZXJnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25EYXRhUmVhZHkobm9kZVBhZ2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzZXRTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGF0YVRhYmxlLnJlc2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gW107XG4gICAgICAgIHRoaXMubm9QZXJtaXNzaW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgb25QYWdlTG9hZGVkKG5vZGVQYWdpbmc6IE5vZGVQYWdpbmcpIHtcbiAgICAgICAgaWYgKG5vZGVQYWdpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5sb2FkUGFnZShub2RlUGFnaW5nLCB0aGlzLnBhZ2luYXRpb24uZ2V0VmFsdWUoKS5tZXJnZSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub25EYXRhUmVhZHkobm9kZVBhZ2luZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2V0IG9mIHByZWRlZmluZWQgY29sdW1ucy5cbiAgICAgKi9cbiAgICBzZXR1cERlZmF1bHRDb2x1bW5zKHByZXNldDogc3RyaW5nID0gJ2RlZmF1bHQnKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLmdldExheW91dFByZXNldChwcmVzZXQpO1xuICAgICAgICAgICAgdGhpcy5kYXRhLnNldENvbHVtbnMoY29sdW1ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblByZXZpZXdGaWxlKG5vZGU6IE1pbmltYWxOb2RlRW50aXR5KSB7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXcuZW1pdChuZXcgTm9kZUVudGl0eUV2ZW50KG5vZGUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTm9kZUNsaWNrKG5vZGU6IE1pbmltYWxOb2RlRW50aXR5KSB7XG4gICAgICAgIGNvbnN0IGRvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdub2RlLWNsaWNrJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgc2VuZGVyOiB0aGlzLFxuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5kaXNwYXRjaEV2ZW50KGRvbUV2ZW50KTtcblxuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBOb2RlRW50aXR5RXZlbnQobm9kZSk7XG4gICAgICAgIHRoaXMubm9kZUNsaWNrLmVtaXQoZXZlbnQpO1xuXG4gICAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmF2aWdhdGUgJiYgdGhpcy5uYXZpZ2F0aW9uTW9kZSA9PT0gRG9jdW1lbnRMaXN0Q29tcG9uZW50LlNJTkdMRV9DTElDS19OQVZJR0FUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5lbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5lbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25QcmV2aWV3RmlsZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmVudHJ5LmlzRm9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1OYXZpZ2F0aW9uKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Ob2RlRGJsQ2xpY2sobm9kZTogTWluaW1hbE5vZGVFbnRpdHkpIHtcbiAgICAgICAgY29uc3QgZG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ25vZGUtZGJsY2xpY2snLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBzZW5kZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmRpc3BhdGNoRXZlbnQoZG9tRXZlbnQpO1xuXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5vZGVFbnRpdHlFdmVudChub2RlKTtcbiAgICAgICAgdGhpcy5ub2RlRGJsQ2xpY2suZW1pdChldmVudCk7XG5cbiAgICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYXZpZ2F0ZSAmJiB0aGlzLm5hdmlnYXRpb25Nb2RlID09PSBEb2N1bWVudExpc3RDb21wb25lbnQuRE9VQkxFX0NMSUNLX05BVklHQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLmVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmVudHJ5LmlzRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblByZXZpZXdGaWxlKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZW50cnkuaXNGb2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybU5hdmlnYXRpb24obm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk5vZGVTZWxlY3QoZXZlbnQ6IHsgcm93OiBTaGFyZURhdGFSb3csIHNlbGVjdGlvbjogQXJyYXk8U2hhcmVEYXRhUm93PiB9KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gZXZlbnQuc2VsZWN0aW9uLm1hcChlbnRyeSA9PiBlbnRyeS5ub2RlKTtcbiAgICAgICAgY29uc3QgZG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ25vZGUtc2VsZWN0Jywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgbm9kZTogZXZlbnQucm93Lm5vZGUsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmRpc3BhdGNoRXZlbnQoZG9tRXZlbnQpO1xuICAgIH1cblxuICAgIG9uTm9kZVVuc2VsZWN0KGV2ZW50OiB7IHJvdzogU2hhcmVEYXRhUm93LCBzZWxlY3Rpb246IEFycmF5PFNoYXJlRGF0YVJvdz4gfSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGV2ZW50LnNlbGVjdGlvbi5tYXAoZW50cnkgPT4gZW50cnkubm9kZSk7XG4gICAgICAgIGNvbnN0IGRvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdub2RlLXVuc2VsZWN0Jywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgbm9kZTogZXZlbnQucm93Lm5vZGUsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmRpc3BhdGNoRXZlbnQoZG9tRXZlbnQpO1xuICAgIH1cblxuICAgIG9uU2hvd1Jvd0NvbnRleHRNZW51KGV2ZW50OiBEYXRhQ2VsbEV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRNZW51QWN0aW9ucykge1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBldmVudC52YWx1ZTtcbiAgICAgICAgICAgIGxldCBub2RlID0gKDxTaGFyZURhdGFSb3c+IGFyZ3Mucm93KS5ub2RlO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBhcmdzLmFjdGlvbnMgPSB0aGlzLmdldENvbnRleHRBY3Rpb25zKG5vZGUpIHx8IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25TaG93Um93QWN0aW9uc01lbnUoZXZlbnQ6IERhdGFDZWxsRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudEFjdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCBhcmdzID0gZXZlbnQudmFsdWU7XG4gICAgICAgICAgICBsZXQgbm9kZSA9ICg8U2hhcmVEYXRhUm93PiBhcmdzLnJvdykubm9kZTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgYXJncy5hY3Rpb25zID0gdGhpcy5nZXROb2RlQWN0aW9ucyhub2RlKSB8fCBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRXhlY3V0ZVJvd0FjdGlvbihldmVudDogRGF0YVJvd0FjdGlvbkV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRBY3Rpb25zKSB7XG4gICAgICAgICAgICBsZXQgYXJncyA9IGV2ZW50LnZhbHVlO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAoPFNoYXJlRGF0YVJvdz4gYXJncy5yb3cpLm5vZGU7XG4gICAgICAgICAgICBsZXQgYWN0aW9uID0gKDxDb250ZW50QWN0aW9uTW9kZWw+IGFyZ3MuYWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZUNvbnRlbnRBY3Rpb24obm9kZSwgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZW5mb3JjZVNpbmdsZUNsaWNrTmF2aWdhdGlvbkZvck1vYmlsZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNb2JpbGUoKSkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uTW9kZSA9IERvY3VtZW50TGlzdENvbXBvbmVudC5TSU5HTEVfQ0xJQ0tfTkFWSUdBVElPTjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbk5hdmlnYXRlRm9sZGVyKG5vZGU6IE1pbmltYWxOb2RlRW50aXR5KTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBjYW5OYXZpZ2F0ZUZvbGRlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLmN1c3RvbVJlc291cmNlc1NlcnZpY2UuaXNDdXN0b21Tb3VyY2UodGhpcy5jdXJyZW50Rm9sZGVySWQpKSB7XG4gICAgICAgICAgICBjYW5OYXZpZ2F0ZUZvbGRlciA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgJiYgbm9kZS5lbnRyeSAmJiBub2RlLmVudHJ5LmlzRm9sZGVyKSB7XG4gICAgICAgICAgICBjYW5OYXZpZ2F0ZUZvbGRlciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FuTmF2aWdhdGVGb2xkZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBsb2FkTGF5b3V0UHJlc2V0cygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxTZXR0aW5ncyA9IHRoaXMuYXBwQ29uZmlnLmdldCgnZG9jdW1lbnQtbGlzdC5wcmVzZXRzJywgbnVsbCk7XG5cbiAgICAgICAgaWYgKGV4dGVybmFsU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0UHJlc2V0cyA9IE9iamVjdC5hc3NpZ24oe30sIHByZXNldHNEZWZhdWx0TW9kZWwsIGV4dGVybmFsU2V0dGluZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRQcmVzZXRzID0gcHJlc2V0c0RlZmF1bHRNb2RlbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgb25EYXRhUmVhZHkobm9kZVBhZ2luZzogTm9kZVBhZ2luZykge1xuICAgICAgICB0aGlzLnJlYWR5LmVtaXQobm9kZVBhZ2luZyk7XG5cbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uLm5leHQobm9kZVBhZ2luZy5saXN0LnBhZ2luYXRpb24pO1xuICAgIH1cblxuICAgIHVwZGF0ZVBhZ2luYXRpb24ocGFnaW5hdGlvbjogUGFnaW5hdGlvbk1vZGVsKSB7XG4gICAgICAgIHRoaXMucGFnaW5hdGlvbi5uZXh0KHBhZ2luYXRpb24pO1xuICAgICAgICB0aGlzLnJlbG9hZCgpO1xuICAgIH1cblxuICAgIG5hdmlnYXRlVG8obm9kZUlkOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Rm9sZGVySWQgPSBub2RlSWQ7XG4gICAgICAgIHRoaXMucmVzZXROZXdGb2xkZXJQYWdpbmF0aW9uKCk7XG4gICAgICAgIHRoaXMubG9hZEZvbGRlcigpO1xuICAgICAgICB0aGlzLmZvbGRlckNoYW5nZS5lbWl0KG5ldyBOb2RlRW50cnlFdmVudCh7IGlkOiBub2RlSWQgfSkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVzZXROZXdGb2xkZXJQYWdpbmF0aW9uKCkge1xuICAgICAgICB0aGlzLmZvbGRlck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhZ2luYXRpb24udmFsdWUuc2tpcENvdW50ID0gMDtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2gocyA9PiBzLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUVycm9yKGVycjogYW55KSB7XG4gICAgICAgIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKEpTT04ucGFyc2UoZXJyLm1lc3NhZ2UpLmVycm9yLnN0YXR1c0NvZGUgPT09IDQwMykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubm9QZXJtaXNzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVycm9yLmVtaXQoZXJyKTtcblxuICAgIH1cblxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuIC8qIHRzbGludDpkaXNhYmxlOmNvbXBvbmVudC1zZWxlY3RvciAgKi9cblxuaW1wb3J0IHsgRGF0YUNvbHVtbiB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBMb2dTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEb2N1bWVudExpc3RDb21wb25lbnQgfSBmcm9tICcuLy4uL2RvY3VtZW50LWxpc3QuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdjb250ZW50LWNvbHVtbnMnLFxuICAgIHRlbXBsYXRlOiAnJ1xufSlcbmV4cG9ydCBjbGFzcyBDb250ZW50Q29sdW1uTGlzdENvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRvY3VtZW50TGlzdDogRG9jdW1lbnRMaXN0Q29tcG9uZW50LCBwcml2YXRlIGxvZ1NlcnZpY2U6IExvZ1NlcnZpY2UgKSB7XG4gICAgICAgIHRoaXMubG9nU2VydmljZS5sb2coJ0NvbnRlbnRDb2x1bW5MaXN0Q29tcG9uZW50IGlzIGRlcHJlY2F0ZWQgc3RhcnRpbmcgd2l0aCAxLjcuMCBhbmQgbWF5IGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLiBVc2UgRGF0YUNvbHVtbkxpc3RDb21wb25lbnQgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgY29sdW1uIG1vZGVsIHdpdGhpbiB0aGUgcGFyZW50IGRvY3VtZW50IGxpc3QgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSBjb2x1bW4gQ29sdW1uIGRlZmluaXRpb24gbW9kZWwgdG8gcmVnaXN0ZXIuXG4gICAgICovXG4gICAgcmVnaXN0ZXJDb2x1bW4oY29sdW1uOiBEYXRhQ29sdW1uKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50TGlzdCAmJiBjb2x1bW4pIHtcbiAgICAgICAgICAgIGxldCBjb2x1bW5zID0gdGhpcy5kb2N1bWVudExpc3QuZGF0YS5nZXRDb2x1bW5zKCk7XG4gICAgICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4gLyogdHNsaW50OmRpc2FibGU6Y29tcG9uZW50LXNlbGVjdG9yIG5vLWlucHV0LXJlbmFtZSAgKi9cblxuaW1wb3J0IHsgRGF0YUNvbHVtbiB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBMb2dTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkLCBJbnB1dCwgT25Jbml0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDb250ZW50Q29sdW1uTGlzdENvbXBvbmVudCB9IGZyb20gJy4vY29udGVudC1jb2x1bW4tbGlzdC5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2NvbnRlbnQtY29sdW1uJyxcbiAgICB0ZW1wbGF0ZTogJydcbn0pXG5leHBvcnQgY2xhc3MgQ29udGVudENvbHVtbkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgRGF0YUNvbHVtbiB7XG5cbiAgICBASW5wdXQoKVxuICAgIGtleTogc3RyaW5nO1xuXG4gICAgQElucHV0KClcbiAgICB0eXBlOiBzdHJpbmcgPSAndGV4dCc7XG5cbiAgICBASW5wdXQoKVxuICAgIGZvcm1hdDogc3RyaW5nO1xuXG4gICAgQElucHV0KClcbiAgICBzb3J0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nID0gJyc7XG5cbiAgICBAQ29udGVudENoaWxkKFRlbXBsYXRlUmVmKVxuICAgIHRlbXBsYXRlOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBUaXRsZSB0byBiZSB1c2VkIGZvciBzY3JlZW4gcmVhZGVycy5cbiAgICAgKi9cbiAgICBASW5wdXQoJ3NyLXRpdGxlJylcbiAgICBzclRpdGxlOiBzdHJpbmc7XG5cbiAgICBASW5wdXQoJ2NsYXNzJylcbiAgICBjc3NDbGFzczogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBsaXN0OiBDb250ZW50Q29sdW1uTGlzdENvbXBvbmVudCwgcHJpdmF0ZSBsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMubG9nU2VydmljZS5sb2coJ0NvbnRlbnRDb2x1bW5Db21wb25lbnQgaXMgZGVwcmVjYXRlZCBzdGFydGluZyB3aXRoIDEuNy4wIGFuZCBtYXkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMuIFVzZSBEYXRhQ29sdW1uQ29tcG9uZW50IGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zclRpdGxlICYmIHRoaXMua2V5ID09PSAnJHRodW1ibmFpbCcpIHtcbiAgICAgICAgICAgIHRoaXMuc3JUaXRsZSA9ICdUaHVtYm5haWwnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKCk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXIoKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3QucmVnaXN0ZXJDb2x1bW4odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjbGFzcyBQZXJtaXNzaW9uTW9kZWwge1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBhY3Rpb246IHN0cmluZztcbiAgICBwZXJtaXNzaW9uOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihvYmo/OiBhbnkpIHtcbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gb2JqLnR5cGUgfHwgbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gb2JqLmFjdGlvbiB8fCBudWxsO1xuICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uID0gb2JqLnBlcm1pc3Npb24gfHwgbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudHJ5RW50aXR5LCBNaW5pbWFsTm9kZUVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBBbGZyZXNjb0FwaVNlcnZpY2UsIENvbnRlbnRTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IE1hdERpYWxvZyB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcblxuaW1wb3J0IHsgRG9jdW1lbnRMaXN0U2VydmljZSB9IGZyb20gJy4vZG9jdW1lbnQtbGlzdC5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRlbnROb2RlRGlhbG9nU2VydmljZSB9IGZyb20gJy4uLy4uL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci9jb250ZW50LW5vZGUtZGlhbG9nLnNlcnZpY2UnO1xuaW1wb3J0IHsgTm9kZURvd25sb2FkRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9ub2RlLWRvd25sb2FkLmRpcmVjdGl2ZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOb2RlQWN0aW9uc1NlcnZpY2Uge1xuXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbnRlbnREaWFsb2dTZXJ2aWNlOiBDb250ZW50Tm9kZURpYWxvZ1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHVibGljIGRpYWxvZ1JlZjogTWF0RGlhbG9nLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBjb250ZW50OiBDb250ZW50U2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGRvY3VtZW50TGlzdFNlcnZpY2U/OiBEb2N1bWVudExpc3RTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgYXBpU2VydmljZT86IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGRpYWxvZz86IE1hdERpYWxvZykge31cblxuICAgIGRvd25sb2FkTm9kZShub2RlOiBNaW5pbWFsTm9kZUVudGl0eSkge1xuICAgICAgICBuZXcgTm9kZURvd25sb2FkRGlyZWN0aXZlKHRoaXMuYXBpU2VydmljZSwgdGhpcy5kaWFsb2cpXG4gICAgICAgICAgICAuZG93bmxvYWROb2RlKG5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcHkgY29udGVudCBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udGVudEVudHJ5IG5vZGUgdG8gY29weVxuICAgICAqIEBwYXJhbSBwZXJtaXNzaW9uIHBlcm1pc3Npb24gd2hpY2ggaXMgbmVlZGVkIHRvIGFwcGx5IHRoZSBhY3Rpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgY29weUNvbnRlbnQoY29udGVudEVudHJ5OiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5LCBwZXJtaXNzaW9uPzogc3RyaW5nKTogU3ViamVjdDxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9GaWxlT3BlcmF0aW9uKCdjb3B5JywgJ2NvbnRlbnQnLCBjb250ZW50RW50cnksIHBlcm1pc3Npb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcHkgZm9sZGVyIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZW50RW50cnkgbm9kZSB0byBjb3B5XG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gcGVybWlzc2lvbiB3aGljaCBpcyBuZWVkZWQgdG8gYXBwbHkgdGhlIGFjdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBjb3B5Rm9sZGVyKGNvbnRlbnRFbnRyeTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSwgcGVybWlzc2lvbj86IHN0cmluZyk6IFN1YmplY3Q8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvRmlsZU9wZXJhdGlvbignY29weScsICdmb2xkZXInLCBjb250ZW50RW50cnksIHBlcm1pc3Npb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgY29udGVudCBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udGVudEVudHJ5IG5vZGUgdG8gbW92ZVxuICAgICAqIEBwYXJhbSBwZXJtaXNzaW9uIHBlcm1pc3Npb24gd2hpY2ggaXMgbmVlZGVkIHRvIGFwcGx5IHRoZSBhY3Rpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgbW92ZUNvbnRlbnQoY29udGVudEVudHJ5OiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5LCBwZXJtaXNzaW9uPzogc3RyaW5nKTogU3ViamVjdDxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9GaWxlT3BlcmF0aW9uKCdtb3ZlJywgJ2NvbnRlbnQnLCBjb250ZW50RW50cnksIHBlcm1pc3Npb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgZm9sZGVyIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZW50RW50cnkgbm9kZSB0byBtb3ZlXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gcGVybWlzc2lvbiB3aGljaCBpcyBuZWVkZWQgdG8gYXBwbHkgdGhlIGFjdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBtb3ZlRm9sZGVyKGNvbnRlbnRFbnRyeTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSwgcGVybWlzc2lvbj86IHN0cmluZyk6IFN1YmplY3Q8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvRmlsZU9wZXJhdGlvbignbW92ZScsICdmb2xkZXInLCBjb250ZW50RW50cnksIHBlcm1pc3Npb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYWwgbWV0aG9kIGZvciBwZXJmb3JtaW5nIHRoZSBnaXZlbiBvcGVyYXRpb24gKGNvcHl8bW92ZSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb24gdGhlIGFjdGlvbiB0byBwZXJmb3JtIChjb3B5fG1vdmUpXG4gICAgICogQHBhcmFtIHR5cGUgdHlwZSBvZiB0aGUgY29udGVudCAoY29udGVudHxmb2xkZXIpXG4gICAgICogQHBhcmFtIGNvbnRlbnRFbnRyeSB0aGUgY29udGVudEVudHJ5IHdoaWNoIGhhcyB0byBoYXZlIHRoZSBhY3Rpb24gcGVyZm9ybWVkIG9uXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gcGVybWlzc2lvbiB3aGljaCBpcyBuZWVkZWQgdG8gYXBwbHkgdGhlIGFjdGlvblxuICAgICAqL1xuICAgIHByaXZhdGUgZG9GaWxlT3BlcmF0aW9uKGFjdGlvbjogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIGNvbnRlbnRFbnRyeTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSwgcGVybWlzc2lvbj86IHN0cmluZyk6IFN1YmplY3Q8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IG9ic2VydmFibGU6IFN1YmplY3Q8c3RyaW5nPiA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcblxuICAgICAgICB0aGlzLmNvbnRlbnREaWFsb2dTZXJ2aWNlXG4gICAgICAgICAgICAub3BlbkNvcHlNb3ZlRGlhbG9nKGFjdGlvbiwgY29udGVudEVudHJ5LCBwZXJtaXNzaW9uKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoc2VsZWN0aW9uczogTWluaW1hbE5vZGVFbnRyeUVudGl0eVtdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1swXTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50TGlzdFNlcnZpY2VbYCR7YWN0aW9ufU5vZGVgXS5jYWxsKHRoaXMuZG9jdW1lbnRMaXN0U2VydmljZSwgY29udGVudEVudHJ5LmlkLCBzZWxlY3Rpb24uaWQpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGUubmV4dC5iaW5kKG9ic2VydmFibGUsIGBPUEVSQVRJT04uU1VDQ0VTUy4ke3R5cGUudG9VcHBlckNhc2UoKX0uJHthY3Rpb24udG9VcHBlckNhc2UoKX1gKSxcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2YWJsZS5lcnJvci5iaW5kKG9ic2VydmFibGUpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29udGVudFNlcnZpY2UsIFRyYW5zbGF0aW9uU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBDb250ZW50QWN0aW9uSGFuZGxlciB9IGZyb20gJy4uL21vZGVscy9jb250ZW50LWFjdGlvbi5tb2RlbCc7XG5pbXBvcnQgeyBQZXJtaXNzaW9uTW9kZWwgfSBmcm9tICcuLi9tb2RlbHMvcGVybWlzc2lvbnMubW9kZWwnO1xuaW1wb3J0IHsgRG9jdW1lbnRMaXN0U2VydmljZSB9IGZyb20gJy4vZG9jdW1lbnQtbGlzdC5zZXJ2aWNlJztcbmltcG9ydCB7IE5vZGVBY3Rpb25zU2VydmljZSB9IGZyb20gJy4vbm9kZS1hY3Rpb25zLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udGVudE5vZGVEaWFsb2dTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vY29udGVudC1ub2RlLXNlbGVjdG9yL2NvbnRlbnQtbm9kZS1kaWFsb2cuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEb2N1bWVudEFjdGlvbnNTZXJ2aWNlIHtcblxuICAgIHBlcm1pc3Npb25FdmVudDogU3ViamVjdDxQZXJtaXNzaW9uTW9kZWw+ID0gbmV3IFN1YmplY3Q8UGVybWlzc2lvbk1vZGVsPigpO1xuICAgIGVycm9yOiBTdWJqZWN0PEVycm9yPiA9IG5ldyBTdWJqZWN0PEVycm9yPigpO1xuICAgIHN1Y2Nlc3M6IFN1YmplY3Q8c3RyaW5nPiA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcblxuICAgIHByaXZhdGUgaGFuZGxlcnM6IHsgW2lkOiBzdHJpbmddOiBDb250ZW50QWN0aW9uSGFuZGxlcjsgfSA9IHt9O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBub2RlQWN0aW9uc1NlcnZpY2U6IE5vZGVBY3Rpb25zU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNvbnRlbnROb2RlRGlhbG9nU2VydmljZTogQ29udGVudE5vZGVEaWFsb2dTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGRvY3VtZW50TGlzdFNlcnZpY2U/OiBEb2N1bWVudExpc3RTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY29udGVudFNlcnZpY2U/OiBDb250ZW50U2VydmljZSkge1xuICAgICAgICB0aGlzLnNldHVwQWN0aW9uSGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoYW5kbGVyIGZvciBhbiBhY3Rpb24uXG4gICAgICogQHBhcmFtIGtleSBJZGVudGlmaWVyIG9mIHRoZSBhY3Rpb25cbiAgICAgKiBAcmV0dXJucyBUaGUgaGFuZGxlciBmb3IgdGhlIGFjdGlvblxuICAgICAqL1xuICAgIGdldEhhbmRsZXIoa2V5OiBzdHJpbmcpOiBDb250ZW50QWN0aW9uSGFuZGxlciB7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGxldCBsa2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyc1tsa2V5XSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBuZXcgaGFuZGxlciBmb3IgYW4gYWN0aW9uLlxuICAgICAqIEBwYXJhbSBrZXkgSWRlbnRpZmllciBvZiB0aGUgYWN0aW9uXG4gICAgICogQHBhcmFtIGhhbmRsZXIgSGFuZGxlciBmb3IgdGhlIGFjdGlvblxuICAgICAqIEByZXR1cm5zIEZhbHNlIGlmIHRoZSBrZXkgd2FzIGFuIGVtcHR5L251bGwgc3RyaW5nLCB0cnVlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHNldEhhbmRsZXIoa2V5OiBzdHJpbmcsIGhhbmRsZXI6IENvbnRlbnRBY3Rpb25IYW5kbGVyKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGxldCBsa2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzW2xrZXldID0gaGFuZGxlcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYWN0aW9ucyBjYW4gYmUgZXhlY3V0ZWQgZm9yIGFuIGl0ZW0uXG4gICAgICogQHBhcmFtIG9iaiBJdGVtIHRvIHJlY2VpdmUgYW4gYWN0aW9uXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgYWN0aW9uIGNhbiBiZSBleGVjdXRlZCBvbiB0aGlzIGl0ZW0sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGNhbkV4ZWN1dGVBY3Rpb24ob2JqOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRMaXN0U2VydmljZSAmJiBvYmogJiYgb2JqLmVudHJ5LmlzRmlsZSA9PT0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldHVwQWN0aW9uSGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnNbJ2NvcHknXSA9IHRoaXMuY29weU5vZGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVyc1snbW92ZSddID0gdGhpcy5tb3ZlTm9kZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZXJzWydkZWxldGUnXSA9IHRoaXMuZGVsZXRlTm9kZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZXJzWydkb3dubG9hZCddID0gdGhpcy5kb3dubG9hZE5vZGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVyc1snbG9jayddID0gdGhpcy5sb2NrTm9kZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgbG9ja05vZGUobm9kZTogTWluaW1hbE5vZGVFbnRpdHksIHRhcmdldD86IGFueSwgcGVybWlzc2lvbj86IHN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Tm9kZURpYWxvZ1NlcnZpY2Uub3BlbkxvY2tOb2RlRGlhbG9nKG5vZGUuZW50cnkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZG93bmxvYWROb2RlKG9iajogTWluaW1hbE5vZGVFbnRpdHksIHRhcmdldD86IGFueSwgcGVybWlzc2lvbj86IHN0cmluZykge1xuICAgICAgICB0aGlzLm5vZGVBY3Rpb25zU2VydmljZS5kb3dubG9hZE5vZGUob2JqKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvcHlOb2RlKG5vZGU6IE1pbmltYWxOb2RlRW50aXR5LCB0YXJnZXQ/OiBhbnksIHBlcm1pc3Npb24/OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uT2JzZXJ2YWJsZSA9IHRoaXMubm9kZUFjdGlvbnNTZXJ2aWNlLmNvcHlDb250ZW50KG5vZGUuZW50cnksIHBlcm1pc3Npb24pO1xuICAgICAgICB0aGlzLnByZXBhcmVIYW5kbGVycyhhY3Rpb25PYnNlcnZhYmxlLCAnY29udGVudCcsICdjb3B5JywgdGFyZ2V0LCBwZXJtaXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk9ic2VydmFibGU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb3ZlTm9kZShub2RlOiBNaW5pbWFsTm9kZUVudGl0eSwgdGFyZ2V0PzogYW55LCBwZXJtaXNzaW9uPzogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbk9ic2VydmFibGUgPSB0aGlzLm5vZGVBY3Rpb25zU2VydmljZS5tb3ZlQ29udGVudChub2RlLmVudHJ5LCBwZXJtaXNzaW9uKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlSGFuZGxlcnMoYWN0aW9uT2JzZXJ2YWJsZSwgJ2NvbnRlbnQnLCAnbW92ZScsIHRhcmdldCwgcGVybWlzc2lvbik7XG4gICAgICAgIHJldHVybiBhY3Rpb25PYnNlcnZhYmxlO1xuICAgIH1cblxuICAgIHByaXZhdGUgcHJlcGFyZUhhbmRsZXJzKGFjdGlvbk9ic2VydmFibGUsIHR5cGU6IHN0cmluZywgYWN0aW9uOiBzdHJpbmcsIHRhcmdldD86IGFueSwgcGVybWlzc2lvbj86IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBhY3Rpb25PYnNlcnZhYmxlLnN1YnNjcmliZShcbiAgICAgICAgICAgIChmaWxlT3BlcmF0aW9uTWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VjY2Vzcy5uZXh0KGZpbGVPcGVyYXRpb25NZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLmVycm9yLm5leHQuYmluZCh0aGlzLmVycm9yKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgZGVsZXRlTm9kZShub2RlOiBNaW5pbWFsTm9kZUVudGl0eSwgdGFyZ2V0PzogYW55LCBwZXJtaXNzaW9uPzogc3RyaW5nKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICAgICAgbGV0IGhhbmRsZXJPYnNlcnZhYmxlO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbkV4ZWN1dGVBY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRTZXJ2aWNlLmhhc1Blcm1pc3Npb24obm9kZS5lbnRyeSwgcGVybWlzc2lvbikpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyT2JzZXJ2YWJsZSA9IHRoaXMuZG9jdW1lbnRMaXN0U2VydmljZS5kZWxldGVOb2RlKG5vZGUuZW50cnkuaWQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJPYnNlcnZhYmxlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy50cmFuc2xhdGlvbi5pbnN0YW50KCdDT1JFLkRFTEVURV9OT0RFLlNJTkdVTEFSJywgeyBuYW1lOiBub2RlLmVudHJ5Lm5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VjY2Vzcy5uZXh0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSB0aGlzLnRyYW5zbGF0aW9uLmluc3RhbnQoJ0NPUkUuREVMRVRFX05PREUuRVJST1JfU0lOR1VMQVInLCB7IG5hbWU6IG5vZGUuZW50cnkubmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvci5uZXh0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyT2JzZXJ2YWJsZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uRXZlbnQubmV4dChuZXcgUGVybWlzc2lvbk1vZGVsKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdkZWxldGUnLFxuICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uOiBwZXJtaXNzaW9uXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKG5ldyBFcnJvcignTm8gcGVybWlzc2lvbiB0byBkZWxldGUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb250ZW50U2VydmljZSwgVHJhbnNsYXRpb25TZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1pbmltYWxOb2RlRW50aXR5IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IENvbnRlbnRBY3Rpb25IYW5kbGVyIH0gZnJvbSAnLi4vbW9kZWxzL2NvbnRlbnQtYWN0aW9uLm1vZGVsJztcbmltcG9ydCB7IFBlcm1pc3Npb25Nb2RlbCB9IGZyb20gJy4uL21vZGVscy9wZXJtaXNzaW9ucy5tb2RlbCc7XG5pbXBvcnQgeyBEb2N1bWVudExpc3RTZXJ2aWNlIH0gZnJvbSAnLi9kb2N1bWVudC1saXN0LnNlcnZpY2UnO1xuaW1wb3J0IHsgTm9kZUFjdGlvbnNTZXJ2aWNlIH0gZnJvbSAnLi9ub2RlLWFjdGlvbnMuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGb2xkZXJBY3Rpb25zU2VydmljZSB7XG5cbiAgICBwZXJtaXNzaW9uRXZlbnQ6IFN1YmplY3Q8UGVybWlzc2lvbk1vZGVsPiA9IG5ldyBTdWJqZWN0PFBlcm1pc3Npb25Nb2RlbD4oKTtcbiAgICBlcnJvcjogU3ViamVjdDxFcnJvcj4gPSBuZXcgU3ViamVjdDxFcnJvcj4oKTtcbiAgICBzdWNjZXNzOiBTdWJqZWN0PHN0cmluZz4gPSBuZXcgU3ViamVjdDxzdHJpbmc+KCk7XG5cbiAgICBwcml2YXRlIGhhbmRsZXJzOiB7IFtpZDogc3RyaW5nXTogQ29udGVudEFjdGlvbkhhbmRsZXI7IH0gPSB7fTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbm9kZUFjdGlvbnNTZXJ2aWNlOiBOb2RlQWN0aW9uc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBkb2N1bWVudExpc3RTZXJ2aWNlOiBEb2N1bWVudExpc3RTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY29udGVudFNlcnZpY2U6IENvbnRlbnRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uU2VydmljZSkge1xuICAgICAgICB0aGlzLnNldHVwQWN0aW9uSGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIGZvciBhbiBhY3Rpb24uXG4gICAgICogQHBhcmFtIGtleSBJZGVudGlmaWVyIGZvciB0aGUgYWN0aW9uXG4gICAgICogQHJldHVybnMgVGhlIGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBnZXRIYW5kbGVyKGtleTogc3RyaW5nKTogQ29udGVudEFjdGlvbkhhbmRsZXIge1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBsZXQgbGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnNbbGtleV0gfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IGhhbmRsZXIgZnVuY3Rpb24gZm9yIGFuIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0ga2V5IElkZW50aWZpZXIgZm9yIHRoZSBhY3Rpb25cbiAgICAgKiBAcGFyYW0gaGFuZGxlciBUaGUgbmV3IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXkgd2FzIGEgdmFsaWQgYWN0aW9uIGlkZW50aWZpZXIsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHNldEhhbmRsZXIoa2V5OiBzdHJpbmcsIGhhbmRsZXI6IENvbnRlbnRBY3Rpb25IYW5kbGVyKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGxldCBsa2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzW2xrZXldID0gaGFuZGxlcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYW4gYWN0aW9uIGlzIGF2YWlsYWJsZSBmb3IgYSBwYXJ0aWN1bGFyIGl0ZW0uXG4gICAgICogQHBhcmFtIG9iaiBJdGVtIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgYWN0aW9uIGlzIGF2YWlsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgY2FuRXhlY3V0ZUFjdGlvbihvYmo6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudExpc3RTZXJ2aWNlICYmIG9iaiAmJiBvYmouZW50cnkuaXNGb2xkZXIgPT09IHRydWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXR1cEFjdGlvbkhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzWydjb3B5J10gPSB0aGlzLmNvcHlOb2RlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnNbJ21vdmUnXSA9IHRoaXMubW92ZU5vZGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVyc1snZGVsZXRlJ10gPSB0aGlzLmRlbGV0ZU5vZGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVyc1snZG93bmxvYWQnXSA9IHRoaXMuZG93bmxvYWROb2RlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb3dubG9hZE5vZGUob2JqOiBNaW5pbWFsTm9kZUVudGl0eSwgdGFyZ2V0PzogYW55LCBwZXJtaXNzaW9uPzogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMubm9kZUFjdGlvbnNTZXJ2aWNlLmRvd25sb2FkTm9kZShvYmopO1xuICAgIH1cblxuICAgIHByaXZhdGUgY29weU5vZGUob2JqOiBNaW5pbWFsTm9kZUVudGl0eSwgdGFyZ2V0PzogYW55LCBwZXJtaXNzaW9uPzogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbk9ic2VydmFibGUgPSB0aGlzLm5vZGVBY3Rpb25zU2VydmljZS5jb3B5Rm9sZGVyKG9iai5lbnRyeSwgcGVybWlzc2lvbik7XG4gICAgICAgIHRoaXMucHJlcGFyZUhhbmRsZXJzKGFjdGlvbk9ic2VydmFibGUsICdmb2xkZXInLCAnY29weScsIHRhcmdldCwgcGVybWlzc2lvbik7XG4gICAgICAgIHJldHVybiBhY3Rpb25PYnNlcnZhYmxlO1xuICAgIH1cblxuICAgIHByaXZhdGUgbW92ZU5vZGUob2JqOiBNaW5pbWFsTm9kZUVudGl0eSwgdGFyZ2V0PzogYW55LCBwZXJtaXNzaW9uPzogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbk9ic2VydmFibGUgPSB0aGlzLm5vZGVBY3Rpb25zU2VydmljZS5tb3ZlRm9sZGVyKG9iai5lbnRyeSwgcGVybWlzc2lvbik7XG4gICAgICAgIHRoaXMucHJlcGFyZUhhbmRsZXJzKGFjdGlvbk9ic2VydmFibGUsICdmb2xkZXInLCAnbW92ZScsIHRhcmdldCwgcGVybWlzc2lvbik7XG4gICAgICAgIHJldHVybiBhY3Rpb25PYnNlcnZhYmxlO1xuICAgIH1cblxuICAgIHByaXZhdGUgcHJlcGFyZUhhbmRsZXJzKGFjdGlvbk9ic2VydmFibGUsIHR5cGU6IHN0cmluZywgYWN0aW9uOiBzdHJpbmcsIHRhcmdldD86IGFueSwgcGVybWlzc2lvbj86IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBhY3Rpb25PYnNlcnZhYmxlLnN1YnNjcmliZShcbiAgICAgICAgICAgIChmaWxlT3BlcmF0aW9uTWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldC5yZWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3MubmV4dChmaWxlT3BlcmF0aW9uTWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpcy5lcnJvci5uZXh0LmJpbmQodGhpcy5lcnJvcilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlbGV0ZU5vZGUobm9kZTogTWluaW1hbE5vZGVFbnRpdHksIHRhcmdldD86IGFueSwgcGVybWlzc2lvbj86IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICAgIGxldCBoYW5kbGVyT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxhbnk+O1xuXG4gICAgICAgIGlmICh0aGlzLmNhbkV4ZWN1dGVBY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRTZXJ2aWNlLmhhc1Blcm1pc3Npb24obm9kZS5lbnRyeSwgcGVybWlzc2lvbikpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyT2JzZXJ2YWJsZSA9IHRoaXMuZG9jdW1lbnRMaXN0U2VydmljZS5kZWxldGVOb2RlKG5vZGUuZW50cnkuaWQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJPYnNlcnZhYmxlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldC5yZWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy50cmFuc2xhdGlvbi5pbnN0YW50KCdDT1JFLkRFTEVURV9OT0RFLlNJTkdVTEFSJywgeyBuYW1lOiBub2RlLmVudHJ5Lm5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VjY2Vzcy5uZXh0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSB0aGlzLnRyYW5zbGF0aW9uLmluc3RhbnQoJ0NPUkUuREVMRVRFX05PREUuRVJST1JfU0lOR1VMQVInLCB7IG5hbWU6IG5vZGUuZW50cnkubmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvci5uZXh0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJPYnNlcnZhYmxlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25FdmVudC5uZXh0KG5ldyBQZXJtaXNzaW9uTW9kZWwoe3R5cGU6ICdmb2xkZXInLCBhY3Rpb246ICdkZWxldGUnLCBwZXJtaXNzaW9uOiBwZXJtaXNzaW9ufSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKG5ldyBFcnJvcignTm8gcGVybWlzc2lvbiB0byBkZWxldGUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4gLyogdHNsaW50OmRpc2FibGU6Y29tcG9uZW50LXNlbGVjdG9yICAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29udGVudEFjdGlvbk1vZGVsIH0gZnJvbSAnLi8uLi8uLi9tb2RlbHMvY29udGVudC1hY3Rpb24ubW9kZWwnO1xuaW1wb3J0IHsgRG9jdW1lbnRMaXN0Q29tcG9uZW50IH0gZnJvbSAnLi8uLi9kb2N1bWVudC1saXN0LmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnY29udGVudC1hY3Rpb25zJyxcbiAgICB0ZW1wbGF0ZTogJydcbn0pXG5leHBvcnQgY2xhc3MgQ29udGVudEFjdGlvbkxpc3RDb21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkb2N1bWVudExpc3Q6IERvY3VtZW50TGlzdENvbXBvbmVudCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhY3Rpb24gaGFuZGxlciB3aXRoaW4gdGhlIHBhcmVudCBkb2N1bWVudCBsaXN0IGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0gYWN0aW9uIEFjdGlvbiBtb2RlbCB0byByZWdpc3Rlci5cbiAgICAgKi9cbiAgICByZWdpc3RlckFjdGlvbihhY3Rpb246IENvbnRlbnRBY3Rpb25Nb2RlbCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudExpc3QgJiYgYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50TGlzdC5hY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB1bnJlZ2lzdGVyQWN0aW9uKGFjdGlvbjogQ29udGVudEFjdGlvbk1vZGVsKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50TGlzdCAmJiBhY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZG9jdW1lbnRMaXN0LmFjdGlvbnMuaW5kZXhPZihhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudExpc3QuYWN0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuIC8qIHRzbGludDpkaXNhYmxlOmNvbXBvbmVudC1zZWxlY3RvciAgKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29udGVudEFjdGlvbkhhbmRsZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvY29udGVudC1hY3Rpb24ubW9kZWwnO1xuaW1wb3J0IHsgRG9jdW1lbnRBY3Rpb25zU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2RvY3VtZW50LWFjdGlvbnMuc2VydmljZSc7XG5pbXBvcnQgeyBGb2xkZXJBY3Rpb25zU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2ZvbGRlci1hY3Rpb25zLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udGVudEFjdGlvbk1vZGVsLCBDb250ZW50QWN0aW9uVGFyZ2V0IH0gZnJvbSAnLi8uLi8uLi9tb2RlbHMvY29udGVudC1hY3Rpb24ubW9kZWwnO1xuaW1wb3J0IHsgQ29udGVudEFjdGlvbkxpc3RDb21wb25lbnQgfSBmcm9tICcuL2NvbnRlbnQtYWN0aW9uLWxpc3QuY29tcG9uZW50JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2NvbnRlbnQtYWN0aW9uJyxcbiAgICB0ZW1wbGF0ZTogJycsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIERvY3VtZW50QWN0aW9uc1NlcnZpY2UsXG4gICAgICAgIEZvbGRlckFjdGlvbnNTZXJ2aWNlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBDb250ZW50QWN0aW9uQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG5cbiAgICAvKiogVGhlIHRpdGxlIG9mIHRoZSBhY3Rpb24gYXMgc2hvd24gaW4gdGhlIG1lbnUuICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nID0gJ0FjdGlvbic7XG5cbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGljb24gdG8gZGlzcGxheSBuZXh0IHRvIHRoZSBtZW51IGNvbW1hbmQgKGNhbiBiZSBsZWZ0IGJsYW5rKS4gKi9cbiAgICBASW5wdXQoKVxuICAgIGljb246IHN0cmluZztcblxuICAgIC8qKiBWaXNpYmlsaXR5IHN0YXRlIChzZWUgZXhhbXBsZXMpLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmlzaWJsZTogYm9vbGVhbiB8IEZ1bmN0aW9uID0gdHJ1ZTtcblxuICAgIC8qKiBTeXN0ZW0gYWN0aW9ucy4gQ2FuIGJlIFwiZGVsZXRlXCIsIFwiZG93bmxvYWRcIiwgXCJjb3B5XCIgb3IgXCJtb3ZlXCIuICovXG4gICAgQElucHV0KClcbiAgICBoYW5kbGVyOiBzdHJpbmc7XG5cbiAgICAvKiogVHlwZSBvZiBpdGVtIHRoYXQgdGhlIGFjdGlvbiBhcHBsaWVzIHRvLiBDYW4gYmUgXCJkb2N1bWVudFwiIG9yIFwiZm9sZGVyXCIgKi9cbiAgICBASW5wdXQoKVxuICAgIHRhcmdldDogc3RyaW5nID0gQ29udGVudEFjdGlvblRhcmdldC5BbGw7XG5cbiAgICAvKiogVGhlIHBlcm1pc3Npb24gdHlwZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIHBlcm1pc3Npb246IHN0cmluZztcblxuICAgIC8qKiBTaG91bGQgdGhpcyBhY3Rpb24gYmUgZGlzYWJsZWQgaW4gdGhlIG1lbnUgaWYgdGhlIHVzZXIgZG9lc24ndCBoYXZlIHBlcm1pc3Npb24gZm9yIGl0PyAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZVdpdGhOb1Blcm1pc3Npb246IGJvb2xlYW47XG5cbiAgICAvKiogSXMgdGhlIG1lbnUgaXRlbSBkaXNhYmxlZD8gKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc2FibGVkOiBib29sZWFuIHwgRnVuY3Rpb24gPSBmYWxzZTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyB0aGUgYWN0aW9uIGZyb20gdGhlIG1lbnUuICovXG4gICAgQE91dHB1dCgpXG4gICAgZXhlY3V0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYSBwZXJtaXNzaW9uIGVycm9yIG9jY3VycyAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHBlcm1pc3Npb25FdmVudCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGR1cmluZyB0aGUgYWN0aW9uLlxuICAgICAqIEFwcGxpZXMgdG8gY29weSBhbmQgbW92ZSBhY3Rpb25zLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGVycm9yID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgYWN0aW9uIHN1Y2NlZWRzIHdpdGggdGhlIHN1Y2Nlc3Mgc3RyaW5nIG1lc3NhZ2UuXG4gICAgICogQXBwbGllcyB0byBjb3B5LCBtb3ZlIGFuZCBkZWxldGUgYWN0aW9ucy5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBzdWNjZXNzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgZG9jdW1lbnRBY3Rpb25Nb2RlbDogQ29udGVudEFjdGlvbk1vZGVsO1xuICAgIGZvbGRlckFjdGlvbk1vZGVsOiBDb250ZW50QWN0aW9uTW9kZWw7XG5cbiAgICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBsaXN0OiBDb250ZW50QWN0aW9uTGlzdENvbXBvbmVudCxcbiAgICAgICAgcHJpdmF0ZSBkb2N1bWVudEFjdGlvbnM6IERvY3VtZW50QWN0aW9uc1NlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgZm9sZGVyQWN0aW9uczogRm9sZGVyQWN0aW9uc1NlcnZpY2UpIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSBDb250ZW50QWN0aW9uVGFyZ2V0LkFsbCkge1xuICAgICAgICAgICAgdGhpcy5mb2xkZXJBY3Rpb25Nb2RlbCA9IHRoaXMuZ2VuZXJhdGVBY3Rpb24oQ29udGVudEFjdGlvblRhcmdldC5Gb2xkZXIpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudEFjdGlvbk1vZGVsID0gdGhpcy5nZW5lcmF0ZUFjdGlvbihDb250ZW50QWN0aW9uVGFyZ2V0LkRvY3VtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRBY3Rpb25Nb2RlbCA9IHRoaXMuZ2VuZXJhdGVBY3Rpb24odGhpcy50YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy52aXNpYmxlICYmICFjaGFuZ2VzLnZpc2libGUuZmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvY3VtZW50QWN0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50QWN0aW9uTW9kZWwudmlzaWJsZSA9IGNoYW5nZXMudmlzaWJsZS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mb2xkZXJBY3Rpb25Nb2RlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9sZGVyQWN0aW9uTW9kZWwudmlzaWJsZSA9IGNoYW5nZXMudmlzaWJsZS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlcy5kaXNhYmxlZCAmJiAhY2hhbmdlcy5kaXNhYmxlZC5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRBY3Rpb25Nb2RlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRBY3Rpb25Nb2RlbC5kaXNhYmxlZCA9IGNoYW5nZXMuZGlzYWJsZWQuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9sZGVyQWN0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvbGRlckFjdGlvbk1vZGVsLmRpc2FibGVkID0gY2hhbmdlcy5kaXNhYmxlZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3Vic2NyaXB0aW9uID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRBY3Rpb25Nb2RlbCkge1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKHRoaXMuZG9jdW1lbnRBY3Rpb25Nb2RlbCk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50QWN0aW9uTW9kZWwgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZm9sZGVyQWN0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3Rlcih0aGlzLmZvbGRlckFjdGlvbk1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMuZm9sZGVyQWN0aW9uTW9kZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXIobW9kZWw6IENvbnRlbnRBY3Rpb25Nb2RlbCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5saXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0LnJlZ2lzdGVyQWN0aW9uKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdW5yZWdpc3Rlcihtb2RlbDogQ29udGVudEFjdGlvbk1vZGVsKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3QudW5yZWdpc3RlckFjdGlvbihtb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2VuZXJhdGVBY3Rpb24odGFyZ2V0OiBzdHJpbmcpOiBDb250ZW50QWN0aW9uTW9kZWwge1xuICAgICAgICBjb25zdCBtb2RlbCA9IG5ldyBDb250ZW50QWN0aW9uTW9kZWwoe1xuICAgICAgICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICAgICAgICBpY29uOiB0aGlzLmljb24sXG4gICAgICAgICAgICBwZXJtaXNzaW9uOiB0aGlzLnBlcm1pc3Npb24sXG4gICAgICAgICAgICBkaXNhYmxlV2l0aE5vUGVybWlzc2lvbjogdGhpcy5kaXNhYmxlV2l0aE5vUGVybWlzc2lvbixcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZXIpIHtcbiAgICAgICAgICAgIG1vZGVsLmhhbmRsZXIgPSB0aGlzLmdldFN5c3RlbUhhbmRsZXIodGFyZ2V0LCB0aGlzLmhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZXhlY3V0ZSkge1xuICAgICAgICAgICAgbW9kZWwuZXhlY3V0ZSA9ICh2YWx1ZTogYW55KTogdm9pZCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5leGVjdXRlLmVtaXQoeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZ2lzdGVyKG1vZGVsKTtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH1cblxuICAgIGdldFN5c3RlbUhhbmRsZXIodGFyZ2V0OiBzdHJpbmcsIG5hbWU6IHN0cmluZyk6IENvbnRlbnRBY3Rpb25IYW5kbGVyIHtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IENvbnRlbnRBY3Rpb25UYXJnZXQuRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb2N1bWVudEFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50QWN0aW9ucy5wZXJtaXNzaW9uRXZlbnQuc3Vic2NyaWJlKHBlcm1pc3Npb24gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbkV2ZW50LmVtaXQocGVybWlzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRBY3Rpb25zLmVycm9yLnN1YnNjcmliZShlcnJvcnMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChlcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50QWN0aW9ucy5zdWNjZXNzLnN1YnNjcmliZShtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3MuZW1pdChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRBY3Rpb25zLmdldEhhbmRsZXIobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBDb250ZW50QWN0aW9uVGFyZ2V0LkZvbGRlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvbGRlckFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbGRlckFjdGlvbnMucGVybWlzc2lvbkV2ZW50LnN1YnNjcmliZShwZXJtaXNzaW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25FdmVudC5lbWl0KHBlcm1pc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbGRlckFjdGlvbnMuZXJyb3Iuc3Vic2NyaWJlKGVycm9ycyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvci5lbWl0KGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9sZGVyQWN0aW9ucy5zdWNjZXNzLnN1YnNjcmliZShtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3MuZW1pdChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9sZGVyQWN0aW9ucy5nZXRIYW5kbGVyKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb250ZW50Q2hpbGQsIERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERvY3VtZW50TGlzdENvbXBvbmVudCB9IGZyb20gJy4vLi4vZG9jdW1lbnQtbGlzdC5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2VtcHR5LWZvbGRlci1jb250ZW50J1xufSlcbmV4cG9ydCBjbGFzcyBFbXB0eUZvbGRlckNvbnRlbnREaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcblxuICAgIEBDb250ZW50Q2hpbGQoVGVtcGxhdGVSZWYpXG4gICAgdGVtcGxhdGU6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZG9jdW1lbnRMaXN0OiBEb2N1bWVudExpc3RDb21wb25lbnQpIHtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRMaXN0LmVtcHR5Rm9sZGVyVGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgICAgICB0aGlzLmRvY3VtZW50TGlzdC5kYXRhVGFibGUubm9Db250ZW50VGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbnRlbnRDaGlsZCwgRGlyZWN0aXZlLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRG9jdW1lbnRMaXN0Q29tcG9uZW50IH0gZnJvbSAnLi8uLi9kb2N1bWVudC1saXN0LmNvbXBvbmVudCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnbm8tcGVybWlzc2lvbi1jb250ZW50J1xufSlcbmV4cG9ydCBjbGFzcyBOb1Blcm1pc3Npb25Db250ZW50RGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG5cbiAgICBAQ29udGVudENoaWxkKFRlbXBsYXRlUmVmKVxuICAgIHRlbXBsYXRlOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRvY3VtZW50TGlzdDogRG9jdW1lbnRMaXN0Q29tcG9uZW50KSB7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50TGlzdC5ub1Blcm1pc3Npb25UZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRMaXN0LmRhdGFUYWJsZS5ub1Blcm1pc3Npb25UZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gbm90ZTogY29udGFpbnMgb25seSBsaW1pdGVkIHN1YnNldCBvZiBhdmFpbGFibGUgZmllbGRzXG5cbmltcG9ydCB7IE1pbmltYWxOb2RlRW50aXR5LCBNaW5pbWFsTm9kZUVudHJ5RW50aXR5IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcblxuZXhwb3J0IGNsYXNzIE5vZGVQYWdpbmcge1xuICAgIGxpc3Q6IE5vZGVQYWdpbmdMaXN0O1xufVxuXG5leHBvcnQgY2xhc3MgTm9kZVBhZ2luZ0xpc3Qge1xuICAgIHBhZ2luYXRpb246IFBhZ2luYXRpb247XG4gICAgZW50cmllczogTm9kZU1pbmltYWxFbnRyeVtdO1xufVxuXG5leHBvcnQgY2xhc3MgTm9kZU1pbmltYWxFbnRyeSBpbXBsZW1lbnRzIE1pbmltYWxOb2RlRW50aXR5IHtcbiAgICBlbnRyeTogTm9kZU1pbmltYWw7XG59XG5cbmV4cG9ydCBjbGFzcyBQYWdpbmF0aW9uIHtcbiAgICBjb3VudDogbnVtYmVyO1xuICAgIGhhc01vcmVJdGVtczogYm9vbGVhbjtcbiAgICB0b3RhbEl0ZW1zOiBudW1iZXI7XG4gICAgc2tpcENvdW50OiBudW1iZXI7XG4gICAgbWF4SXRlbXM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIE5vZGVNaW5pbWFsIGltcGxlbWVudHMgTWluaW1hbE5vZGVFbnRyeUVudGl0eSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBwYXJlbnRJZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBub2RlVHlwZTogc3RyaW5nO1xuICAgIGlzRm9sZGVyOiBib29sZWFuO1xuICAgIGlzRmlsZTogYm9vbGVhbjtcbiAgICBtb2RpZmllZEF0OiBEYXRlO1xuICAgIG1vZGlmaWVkQnlVc2VyOiBVc2VySW5mbztcbiAgICBjcmVhdGVkQXQ6IERhdGU7XG4gICAgY3JlYXRlZEJ5VXNlcjogVXNlckluZm87XG4gICAgY29udGVudDogQ29udGVudEluZm87XG4gICAgcGF0aDogUGF0aEluZm9FbnRpdHk7XG4gICAgcHJvcGVydGllczogTm9kZVByb3BlcnRpZXMgPSB7fTtcbiAgICBhc3BlY3ROYW1lczogc3RyaW5nW107XG59XG5cbmV4cG9ydCBjbGFzcyBVc2VySW5mbyB7XG4gICAgZGlzcGxheU5hbWU6IHN0cmluZztcbiAgICBpZDogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ29udGVudEluZm8ge1xuICAgIG1pbWVUeXBlOiBzdHJpbmc7XG4gICAgbWltZVR5cGVOYW1lOiBzdHJpbmc7XG4gICAgc2l6ZUluQnl0ZXM6IG51bWJlcjtcbiAgICBlbmNvZGluZzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgUGF0aEluZm9FbnRpdHkge1xuICAgIGVsZW1lbnRzOiBQYXRoRWxlbWVudEVudGl0eVtdO1xuICAgIGlzQ29tcGxldGU6IGJvb2xlYW47XG4gICAgbmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgUGF0aEVsZW1lbnRFbnRpdHkge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVQcm9wZXJ0aWVzIHtcbiAgICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQZXJtaXNzaW9uc0VudW0gfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvblN0eWxlTW9kZWwge1xuICAgIGNzczogc3RyaW5nO1xuICAgIHBlcm1pc3Npb246IFBlcm1pc3Npb25zRW51bTtcbiAgICBpc0ZvbGRlcjogYm9vbGVhbiA9IHRydWU7XG4gICAgaXNGaWxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKGNzczogc3RyaW5nLCBwZXJtaXNzaW9uOiBQZXJtaXNzaW9uc0VudW0sIGlzRmlsZTogYm9vbGVhbiA9IHRydWUsIGlzRm9sZGVyOiBib29sZWFuID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmNzcyA9IGNzcztcbiAgICAgICAgdGhpcy5wZXJtaXNzaW9uID0gcGVybWlzc2lvbjtcbiAgICAgICAgdGhpcy5pc0ZpbGUgPSBpc0ZpbGU7XG4gICAgICAgIHRoaXMuaXNGb2xkZXIgPSBpc0ZvbGRlcjtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBGaWxlTW9kZWwsIEZpbGVVcGxvYWRTdGF0dXMsIE5vZGVzQXBpU2VydmljZSwgVHJhbnNsYXRpb25TZXJ2aWNlLCBVcGxvYWRTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBJbnB1dCwgT3V0cHV0LCBUZW1wbGF0ZVJlZiwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBmb3JrSm9pbiwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtZmlsZS11cGxvYWRpbmctbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2ZpbGUtdXBsb2FkaW5nLWxpc3QuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2ZpbGUtdXBsb2FkaW5nLWxpc3QuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBGaWxlVXBsb2FkaW5nTGlzdENvbXBvbmVudCB7XG5cbiAgICBGaWxlVXBsb2FkU3RhdHVzID0gRmlsZVVwbG9hZFN0YXR1cztcblxuICAgIEBDb250ZW50Q2hpbGQoVGVtcGxhdGVSZWYpXG4gICAgdGVtcGxhdGU6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgZmlsZXM6IEZpbGVNb2RlbFtdID0gW107XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGEgZmlsZSBpbiB0aGUgbGlzdCBoYXMgYW4gZXJyb3IuICovXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgdXBsb2FkU2VydmljZTogVXBsb2FkU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBub2Rlc0FwaTogTm9kZXNBcGlTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0aW9uU2VydmljZSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbCBmaWxlIHVwbG9hZFxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGUgRmlsZSBtb2RlbCB0byBjYW5jZWwgdXBsb2FkIGZvci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBGaWxlVXBsb2FkaW5nTGlzdENvbXBvbmVudFxuICAgICAqL1xuICAgIGNhbmNlbEZpbGUoZmlsZTogRmlsZU1vZGVsKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBsb2FkU2VydmljZS5jYW5jZWxVcGxvYWQoZmlsZSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlRmlsZShmaWxlOiBGaWxlTW9kZWwpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kZWxldGVOb2RlKGZpbGUpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIGZpbGUuc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5RXJyb3IoZmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy51cGxvYWRTZXJ2aWNlLmNhbmNlbFVwbG9hZChmaWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBmb3IgZWFjaCBmaWxlLCBkZXBlbmRpbmcgb24gc3RhdGVcbiAgICAgKi9cbiAgICBjYW5jZWxBbGxGaWxlcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5nZXRVcGxvYWRpbmdGaWxlcygpXG4gICAgICAgICAgICAuZm9yRWFjaCgoZmlsZSkgPT4gdGhpcy51cGxvYWRTZXJ2aWNlLmNhbmNlbFVwbG9hZChmaWxlKSk7XG5cbiAgICAgICAgY29uc3QgZGVsZXRlZEZpbGVzID0gdGhpcy5maWxlc1xuICAgICAgICAgICAgLmZpbHRlcigoZmlsZSkgPT4gZmlsZS5zdGF0dXMgPT09IEZpbGVVcGxvYWRTdGF0dXMuQ29tcGxldGUpXG4gICAgICAgICAgICAubWFwKChmaWxlKSA9PiB0aGlzLmRlbGV0ZU5vZGUoZmlsZSkpO1xuXG4gICAgICAgIGZvcmtKb2luKC4uLmRlbGV0ZWRGaWxlcylcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGZpbGVzOiBGaWxlTW9kZWxbXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGZpbGVzXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGZpbGUpID0+IGZpbGUuc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLkVycm9yKTtcblxuICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5RXJyb3IoLi4uZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UuY2FuY2VsVXBsb2FkKC4uLmZpbGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhbGwgdGhlIGZpbGVzIGFyZSB1cGxvYWRlZCBmYWxzZSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZmlsZSBpbiBQcm9ncmVzcyB8IFN0YXJ0aW5nIHwgUGVuZGluZ1xuICAgICAqL1xuICAgIGlzVXBsb2FkQ29tcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICAgcmV0dXJuICF0aGlzLmlzVXBsb2FkQ2FuY2VsbGVkKCkgJiZcbiAgICAgICAgICAgIEJvb2xlYW4odGhpcy5maWxlcy5sZW5ndGgpICYmXG4gICAgICAgICAgICAhdGhpcy5maWxlc1xuICAgICAgICAgICAgICAgIC5zb21lKCh7c3RhdHVzfSkgPT5cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLlN0YXJ0aW5nIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9PT0gRmlsZVVwbG9hZFN0YXR1cy5Qcm9ncmVzcyB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPT09IEZpbGVVcGxvYWRTdGF0dXMuUGVuZGluZ1xuICAgICAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYWxsIHRoZSBmaWxlcyBhcmUgQ2FuY2VsbGVkIHwgQWJvcnRlZCB8IEVycm9yLiBmYWxzZSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZmlsZSBpbiB1cGxvYWRpbmcgc3RhdGVzXG4gICAgICovXG4gICAgaXNVcGxvYWRDYW5jZWxsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZmlsZXMubGVuZ3RoICYmXG4gICAgICAgICAgICB0aGlzLmZpbGVzXG4gICAgICAgICAgICAgICAgLmV2ZXJ5KCh7c3RhdHVzfSkgPT5cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLkFib3J0ZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLkNhbmNlbGxlZCB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPT09IEZpbGVVcGxvYWRTdGF0dXMuRGVsZXRlZFxuICAgICAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkZWxldGVOb2RlKGZpbGU6IEZpbGVNb2RlbCk6IE9ic2VydmFibGU8RmlsZU1vZGVsPiB7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IGZpbGUuZGF0YS5lbnRyeTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc0FwaVxuICAgICAgICAgICAgLmRlbGV0ZU5vZGUoaWQsIHsgcGVybWFuZW50OiB0cnVlIH0pXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmaWxlLnN0YXR1cyA9IEZpbGVVcGxvYWRTdGF0dXMuRGVsZXRlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2F0Y2hFcnJvcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUuc3RhdHVzID0gRmlsZVVwbG9hZFN0YXR1cy5FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKGZpbGUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgbm90aWZ5RXJyb3IoLi4uZmlsZXM6IEZpbGVNb2RlbFtdKSB7XG4gICAgICAgIGxldCBtZXNzYWdlRXJyb3I6IHN0cmluZyA9IG51bGw7XG5cbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbWVzc2FnZUVycm9yID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlXG4gICAgICAgICAgICAgICAgLmluc3RhbnQoXG4gICAgICAgICAgICAgICAgICAgICdGSUxFX1VQTE9BRC5NRVNTQUdFUy5SRU1PVkVfRklMRV9FUlJPUicsXG4gICAgICAgICAgICAgICAgICAgIHsgZmlsZU5hbWU6IGZpbGVzWzBdLm5hbWV9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2VFcnJvciA9IHRoaXMudHJhbnNsYXRlU2VydmljZVxuICAgICAgICAgICAgICAgIC5pbnN0YW50KFxuICAgICAgICAgICAgICAgICAgICAnRklMRV9VUExPQUQuTUVTU0FHRVMuUkVNT1ZFX0ZJTEVTX0VSUk9SJyxcbiAgICAgICAgICAgICAgICAgICAgeyB0b3RhbDogZmlsZXMubGVuZ3RoIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lcnJvci5lbWl0KG1lc3NhZ2VFcnJvcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRVcGxvYWRpbmdGaWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEZpbGVVcGxvYWRTdGF0dXMuUGVuZGluZyB8fFxuICAgICAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBGaWxlVXBsb2FkU3RhdHVzLlByb2dyZXNzIHx8XG4gICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEZpbGVVcGxvYWRTdGF0dXMuU3RhcnRpbmdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIEZpbGVNb2RlbCwgRmlsZVVwbG9hZENvbXBsZXRlRXZlbnQsIEZpbGVVcGxvYWREZWxldGVFdmVudCxcbiAgICBGaWxlVXBsb2FkRXJyb3JFdmVudCwgRmlsZVVwbG9hZFN0YXR1cywgVXBsb2FkU2VydmljZVxufSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE9uSW5pdCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIG1lcmdlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBGaWxlVXBsb2FkaW5nTGlzdENvbXBvbmVudCB9IGZyb20gJy4vZmlsZS11cGxvYWRpbmctbGlzdC5jb21wb25lbnQnO1xuXG4vLyBAZGVwcmVjYXRlZCBmaWxlLXVwbG9hZGluZy1kaWFsb2cgVE9ETyByZW1vdmUgaW4gMy4wLjBcbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWZpbGUtdXBsb2FkaW5nLWRpYWxvZywgZmlsZS11cGxvYWRpbmctZGlhbG9nJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmlsZS11cGxvYWRpbmctZGlhbG9nLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9maWxlLXVwbG9hZGluZy1kaWFsb2cuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBGaWxlVXBsb2FkaW5nRGlhbG9nQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIEBWaWV3Q2hpbGQoJ3VwbG9hZExpc3QnKVxuICAgIHVwbG9hZExpc3Q6IEZpbGVVcGxvYWRpbmdMaXN0Q29tcG9uZW50O1xuXG4gICAgLyoqIERpYWxvZyBwb3NpdGlvbi4gQ2FuIGJlICdsZWZ0JyBvciAncmlnaHQnLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgcG9zaXRpb246IHN0cmluZyA9ICdyaWdodCc7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGEgZmlsZSBpbiB0aGUgbGlzdCBoYXMgYW4gZXJyb3IuICovXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgZmlsZXNVcGxvYWRpbmdMaXN0OiBGaWxlTW9kZWxbXSA9IFtdO1xuICAgIGlzRGlhbG9nQWN0aXZlOiBib29sZWFuID0gZmFsc2U7XG4gICAgdG90YWxDb21wbGV0ZWQ6IG51bWJlciA9IDA7XG4gICAgdG90YWxFcnJvcnM6IG51bWJlciA9IDA7XG4gICAgaXNEaWFsb2dNaW5pbWl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBpc0NvbmZpcm1hdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSBsaXN0U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBjb3VudGVyU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBmaWxlVXBsb2FkU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBlcnJvclN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB1cGxvYWRTZXJ2aWNlOiBVcGxvYWRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY2hhbmdlRGV0ZWNvcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5saXN0U3Vic2NyaXB0aW9uID0gdGhpcy51cGxvYWRTZXJ2aWNlXG4gICAgICAgICAgICAucXVldWVDaGFuZ2VkLnN1YnNjcmliZSgoZmlsZUxpc3Q6IEZpbGVNb2RlbFtdKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlc1VwbG9hZGluZ0xpc3QgPSBmaWxlTGlzdDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzVXBsb2FkaW5nTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RpYWxvZ0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jb3VudGVyU3Vic2NyaXB0aW9uID0gbWVyZ2UoXG4gICAgICAgICAgICAgICAgdGhpcy51cGxvYWRTZXJ2aWNlLmZpbGVVcGxvYWRDb21wbGV0ZSxcbiAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UuZmlsZVVwbG9hZERlbGV0ZWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGV2ZW50OiAoRmlsZVVwbG9hZERlbGV0ZUV2ZW50IHwgRmlsZVVwbG9hZENvbXBsZXRlRXZlbnQpKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3RhbENvbXBsZXRlZCA9IGV2ZW50LnRvdGFsQ29tcGxldGU7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY29yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXJyb3JTdWJzY3JpcHRpb24gPSB0aGlzLnVwbG9hZFNlcnZpY2UuZmlsZVVwbG9hZEVycm9yXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChldmVudDogRmlsZVVwbG9hZEVycm9yRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdGFsRXJyb3JzID0gZXZlbnQudG90YWxFcnJvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjb3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5maWxlVXBsb2FkU3Vic2NyaXB0aW9uID0gdGhpcy51cGxvYWRTZXJ2aWNlXG4gICAgICAgICAgICAuZmlsZVVwbG9hZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWNvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UuZmlsZURlbGV0ZWQuc3Vic2NyaWJlKChvYmpJZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsZXNVcGxvYWRpbmdMaXN0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmZpbGVzVXBsb2FkaW5nTGlzdC5maW5kKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmRhdGEuZW50cnkuaWQgPT09IG9iaklkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUuc3RhdHVzID0gRmlsZVVwbG9hZFN0YXR1cy5DYW5jZWxsZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWNvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgY29uZmlybWF0aW9uIG1lc3NhZ2UuXG4gICAgICovXG4gICAgdG9nZ2xlQ29uZmlybWF0aW9uKCkge1xuICAgICAgICB0aGlzLmlzQ29uZmlybWF0aW9uID0gIXRoaXMuaXNDb25maXJtYXRpb247XG5cbiAgICAgICAgaWYgKHRoaXMuaXNEaWFsb2dNaW5pbWl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEaWFsb2dNaW5pbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbCB1cGxvYWRzIGFuZCBoaWRlIGNvbmZpcmFtdGlvblxuICAgICAqL1xuICAgIGNhbmNlbEFsbFVwbG9hZHMoKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlQ29uZmlybWF0aW9uKCk7XG5cbiAgICAgICAgdGhpcy51cGxvYWRMaXN0LmNhbmNlbEFsbEZpbGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIGRpYWxvZyBtaW5pbWl6ZWQgc3RhdGUuXG4gICAgICovXG4gICAgdG9nZ2xlTWluaW1pemVkKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmlzRGlhbG9nTWluaW1pemVkID0gIXRoaXMuaXNEaWFsb2dNaW5pbWl6ZWQ7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWNvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzbWlzcyBkaWFsb2dcbiAgICAgKi9cbiAgICBjbG9zZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pc0NvbmZpcm1hdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvdGFsQ29tcGxldGVkID0gMDtcbiAgICAgICAgdGhpcy50b3RhbEVycm9ycyA9IDA7XG4gICAgICAgIHRoaXMuZmlsZXNVcGxvYWRpbmdMaXN0ID0gW107XG4gICAgICAgIHRoaXMuaXNEaWFsb2dBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0RpYWxvZ01pbmltaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UuY2xlYXJRdWV1ZSgpO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjb3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UuY2xlYXJRdWV1ZSgpO1xuICAgICAgICB0aGlzLmxpc3RTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jb3VudGVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZmlsZVVwbG9hZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmVycm9yU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRmlsZU1vZGVsLCBGaWxlVXBsb2FkU3RhdHVzIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWZpbGUtdXBsb2FkaW5nLWxpc3Qtcm93JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmlsZS11cGxvYWRpbmctbGlzdC1yb3cuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWyAnLi9maWxlLXVwbG9hZGluZy1saXN0LXJvdy5jb21wb25lbnQuc2NzcycgXVxufSlcbmV4cG9ydCBjbGFzcyBGaWxlVXBsb2FkaW5nTGlzdFJvd0NvbXBvbmVudCB7XG4gICAgQElucHV0KClcbiAgICBmaWxlOiBGaWxlTW9kZWw7XG5cbiAgICBAT3V0cHV0KClcbiAgICBjYW5jZWw6IEV2ZW50RW1pdHRlcjxGaWxlTW9kZWw+ID0gbmV3IEV2ZW50RW1pdHRlcjxGaWxlTW9kZWw+KCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICByZW1vdmU6IEV2ZW50RW1pdHRlcjxGaWxlTW9kZWw+ID0gbmV3IEV2ZW50RW1pdHRlcjxGaWxlTW9kZWw+KCk7XG5cbiAgICBGaWxlVXBsb2FkU3RhdHVzID0gRmlsZVVwbG9hZFN0YXR1cztcblxuICAgIG9uQ2FuY2VsKGZpbGU6IEZpbGVNb2RlbCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNhbmNlbC5lbWl0KGZpbGUpO1xuICAgIH1cblxuICAgIG9uUmVtb3ZlKGZpbGU6IEZpbGVNb2RlbCk6IHZvaWQge1xuICAgICAgICB0aGlzLnJlbW92ZS5lbWl0KGZpbGUpO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZpbGVNb2RlbCwgVXBsb2FkU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuZXhwb3J0IGNsYXNzIFVwbG9hZEZpbGVzRXZlbnQge1xuICAgIHByaXZhdGUgaXNEZWZhdWx0UHJldmVudGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBnZXQgZGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkO1xuICAgIH1cblxuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBmaWxlczogQXJyYXk8RmlsZU1vZGVsPixcbiAgICAgICAgcHJpdmF0ZSB1cGxvYWRTZXJ2aWNlOiBVcGxvYWRTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGNhbGxiYWNrOiBFdmVudEVtaXR0ZXI8YW55PlxuICAgICkge31cblxuICAgIHBhdXNlVXBsb2FkKCkge1xuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgcmVzdW1lVXBsb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5maWxlcyAmJiB0aGlzLmZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkU2VydmljZS5hZGRUb1F1ZXVlKC4uLnRoaXMuZmlsZXMpO1xuICAgICAgICAgICAgdGhpcy51cGxvYWRTZXJ2aWNlLnVwbG9hZEZpbGVzSW5UaGVRdWV1ZSh0aGlzLmNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZpbGVNb2RlbCwgRmlsZUluZm8gfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBPbkluaXQsIE9uRGVzdHJveSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGxvYWRTZXJ2aWNlLCBUcmFuc2xhdGlvblNlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBVcGxvYWRGaWxlc0V2ZW50IH0gZnJvbSAnLi4vdXBsb2FkLWZpbGVzLmV2ZW50JztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFVwbG9hZEJhc2UgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKiogU2V0cyBhIGxpbWl0IG9uIHRoZSBtYXhpbXVtIHNpemUgKGluIGJ5dGVzKSBvZiBhIGZpbGUgdG8gYmUgdXBsb2FkZWQuXG4gICAgICogSGFzIG5vIGVmZmVjdCBpZiB1bmRlZmluZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtYXhGaWxlc1NpemU6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgSUQgb2YgdGhlIHJvb3QuIFVzZSB0aGUgbm9kZUlkIGZvclxuICAgICAqIENvbnRlbnQgU2VydmljZXMgb3IgdGhlIHRhc2tJZC9wcm9jZXNzSWQgZm9yIFByb2Nlc3MgU2VydmljZXMuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICByb290Rm9sZGVySWQ6IHN0cmluZyA9ICctcm9vdC0nO1xuXG4gICAgLyoqIFRvZ2dsZXMgY29tcG9uZW50IGRpc2FibGVkIHN0YXRlIChpZiB0aGVyZSBpcyBubyBub2RlIHBlcm1pc3Npb24gY2hlY2tpbmcpLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBGaWx0ZXIgZm9yIGFjY2VwdGVkIGZpbGUgdHlwZXMuICovXG4gICAgQElucHV0KClcbiAgICBhY2NlcHRlZEZpbGVzVHlwZTogc3RyaW5nID0gJyonO1xuXG4gICAgLyoqIFRvZ2dsZXMgdmVyc2lvbmluZy4gKi9cbiAgICBASW5wdXQoKVxuICAgIHZlcnNpb25pbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBtYWpvclZlcnNpb24gYm9vbGVhbiBmaWVsZCB0byB0cnVlIHRvIGluZGljYXRlIGEgbWFqb3IgdmVyc2lvbiBzaG91bGQgYmUgY3JlYXRlZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIG1ham9yVmVyc2lvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIFdoZW4geW91IG92ZXJ3cml0ZSBleGlzdGluZyBjb250ZW50LCB5b3UgY2FuIHVzZSB0aGUgY29tbWVudCBmaWVsZCB0byBhZGQgYSB2ZXJzaW9uIGNvbW1lbnQgdGhhdCBhcHBlYXJzIGluIHRoZSB2ZXJzaW9uIGhpc3RvcnkgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbW1lbnQ6IHN0cmluZztcblxuICAgIC8qKiBDdXN0b20gbm9kZSB0eXBlIGZvciB1cGxvYWRlZCBmaWxlICovXG4gICAgQElucHV0KClcbiAgICBub2RlVHlwZTogc3RyaW5nID0gJ2NtOmNvbnRlbnQnO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgZmlsZSBpcyB1cGxvYWRlZCBzdWNjZXNzZnVsbHkuICovXG4gICAgQE91dHB1dCgpXG4gICAgc3VjY2VzcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhIGZvbGRlciBpcyBjcmVhdGVkLlxuICAgICAqIEBkZXByZWNhdGVkIDIuNC4wIE5vIGxvbmdlciB1c2VkIGJ5IHRoZSBmcmFtZXdvcmtcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBjcmVhdGVGb2xkZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3Vycy4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBlcnJvciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIHVwbG9hZCBiZWdpbnMuICovXG4gICAgQE91dHB1dCgpXG4gICAgYmVnaW5VcGxvYWQgPSBuZXcgRXZlbnRFbWl0dGVyPFVwbG9hZEZpbGVzRXZlbnQ+KCk7XG5cbiAgICBwcm90ZWN0ZWQgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCB1cGxvYWRTZXJ2aWNlOiBVcGxvYWRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCB0cmFuc2xhdGlvblNlcnZpY2U6IFRyYW5zbGF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgbmdab25lOiBOZ1pvbmUpIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UuZmlsZVVwbG9hZEVycm9yLnN1YnNjcmliZSgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yLmVtaXQoZXJyb3IpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWJzY3JpcHRpb24gPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYSBsaXN0IG9mIGZpbGUgaW4gdGhlIHNwZWNpZmllZCBwYXRoXG4gICAgICogQHBhcmFtIGZpbGVzXG4gICAgICogQHBhcmFtIHBhdGhcbiAgICAgKi9cbiAgICB1cGxvYWRGaWxlcyhmaWxlczogRmlsZVtdKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRmlsZXM6IEZpbGVNb2RlbFtdID0gZmlsZXNcbiAgICAgICAgICAgIC5tYXA8RmlsZU1vZGVsPigoZmlsZTogRmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUZpbGVNb2RlbChmaWxlLCB0aGlzLnJvb3RGb2xkZXJJZCwgKGZpbGUud2Via2l0UmVsYXRpdmVQYXRoIHx8ICcnKS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sICcnKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnVwbG9hZFF1ZXVlKGZpbHRlcmVkRmlsZXMpO1xuICAgIH1cblxuICAgIHVwbG9hZEZpbGVzSW5mbyhmaWxlczogRmlsZUluZm9bXSk6IHZvaWQge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZEZpbGVzOiBGaWxlTW9kZWxbXSA9IGZpbGVzXG4gICAgICAgICAgICAubWFwPEZpbGVNb2RlbD4oKGZpbGVJbmZvOiBGaWxlSW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUZpbGVNb2RlbChmaWxlSW5mby5maWxlLCB0aGlzLnJvb3RGb2xkZXJJZCwgZmlsZUluZm8ucmVsYXRpdmVGb2xkZXIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy51cGxvYWRRdWV1ZShmaWx0ZXJlZEZpbGVzKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwbG9hZFF1ZXVlKGZpbGVzOiBGaWxlTW9kZWxbXSkge1xuICAgICAgICBsZXQgZmlsdGVyZWRGaWxlcyA9IGZpbGVzXG4gICAgICAgICAgICAuZmlsdGVyKHRoaXMuaXNGaWxlQWNjZXB0YWJsZS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLmZpbHRlcih0aGlzLmlzRmlsZVNpemVBY2NlcHRhYmxlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBVcGxvYWRGaWxlc0V2ZW50KFxuICAgICAgICAgICAgICAgIFsuLi5maWx0ZXJlZEZpbGVzXSxcbiAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgdGhpcy5zdWNjZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5iZWdpblVwbG9hZC5lbWl0KGV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UuYWRkVG9RdWV1ZSguLi5maWx0ZXJlZEZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGxvYWRTZXJ2aWNlLnVwbG9hZEZpbGVzSW5UaGVRdWV1ZSh0aGlzLnN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBmaWxlIGlzIGFsbG93ZWQgYnkgdGhlIGV4dGVuc2lvbiBmaWx0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZSBGaWxlTW9kZWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaXNGaWxlQWNjZXB0YWJsZShmaWxlOiBGaWxlTW9kZWwpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuYWNjZXB0ZWRGaWxlc1R5cGUgPT09ICcqJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhbGxvd2VkRXh0ZW5zaW9ucyA9IHRoaXMuYWNjZXB0ZWRGaWxlc1R5cGVcbiAgICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgICAubWFwKGV4dCA9PiBleHQucmVwbGFjZSgvXlxcLi8sICcnKSk7XG5cbiAgICAgICAgaWYgKGFsbG93ZWRFeHRlbnNpb25zLmluZGV4T2YoZmlsZS5leHRlbnNpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBGaWxlTW9kZWwgZnJvbSBGaWxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVGaWxlTW9kZWwoZmlsZTogRmlsZSwgcGFyZW50SWQ6IHN0cmluZywgcGF0aDogc3RyaW5nLCBpZD86IHN0cmluZyk6IEZpbGVNb2RlbCB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsZU1vZGVsKGZpbGUsIHtcbiAgICAgICAgICAgIGNvbW1lbnQ6IHRoaXMuY29tbWVudCxcbiAgICAgICAgICAgIG1ham9yVmVyc2lvbjogdGhpcy5tYWpvclZlcnNpb24sXG4gICAgICAgICAgICBuZXdWZXJzaW9uOiB0aGlzLnZlcnNpb25pbmcsXG4gICAgICAgICAgICBwYXJlbnRJZDogcGFyZW50SWQsXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgbm9kZVR5cGU6IHRoaXMubm9kZVR5cGVcbiAgICAgICAgfSwgaWQpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBpc0ZpbGVTaXplQWxsb3dlZChmaWxlOiBGaWxlTW9kZWwpIHtcbiAgICAgICAgbGV0IGlzRmlsZVNpemVBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXhGaWxlU2l6ZURlZmluZWQoKSkge1xuICAgICAgICAgICAgaXNGaWxlU2l6ZUFsbG93ZWQgPSB0aGlzLmlzRmlsZVNpemVDb3JyZWN0KGZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzRmlsZVNpemVBbGxvd2VkO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBpc01heEZpbGVTaXplRGVmaW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RmlsZXNTaXplICE9PSB1bmRlZmluZWQgJiYgdGhpcy5tYXhGaWxlc1NpemUgIT09IG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGlzRmlsZVNpemVDb3JyZWN0KGZpbGU6IEZpbGVNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhGaWxlc1NpemUgPj0gMCAmJiBmaWxlLnNpemUgPD0gdGhpcy5tYXhGaWxlc1NpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBmaWxlIGlzIGFuIGFjY2VwdGFibGUgc2l6ZVxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGUgRmlsZU1vZGVsXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0ZpbGVTaXplQWNjZXB0YWJsZShmaWxlOiBGaWxlTW9kZWwpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGFjY2VwdGFibGVTaXplID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNGaWxlU2l6ZUFsbG93ZWQoZmlsZSkpIHtcbiAgICAgICAgICAgIGFjY2VwdGFibGVTaXplID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLnRyYW5zbGF0aW9uU2VydmljZS5pbnN0YW50KFxuICAgICAgICAgICAgICAgICdGSUxFX1VQTE9BRC5NRVNTQUdFUy5FWENFRURfTUFYX0ZJTEVfU0laRScsXG4gICAgICAgICAgICAgICAgeyBmaWxlTmFtZTogZmlsZS5uYW1lIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY2NlcHRhYmxlU2l6ZTtcbiAgICB9XG5cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgQ29udGVudFNlcnZpY2UsIEVYVEVORElCTEVfQ09NUE9ORU5ULCBGaWxlVXRpbHMsXG4gICAgTG9nU2VydmljZSwgTm9kZVBlcm1pc3Npb25TdWJqZWN0LCBUcmFuc2xhdGlvblNlcnZpY2UsIFVwbG9hZFNlcnZpY2UsIFBlcm1pc3Npb25zRW51bVxufSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSW5wdXQsXG4gICAgT25DaGFuZ2VzLCBPbkluaXQsIE91dHB1dCwgU2ltcGxlQ2hhbmdlcywgVmlld0VuY2Fwc3VsYXRpb24sIE5nWm9uZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1pbmltYWxOb2RlRW50cnlFbnRpdHkgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUGVybWlzc2lvbk1vZGVsIH0gZnJvbSAnLi4vLi4vZG9jdW1lbnQtbGlzdC9tb2RlbHMvcGVybWlzc2lvbnMubW9kZWwnO1xuaW1wb3J0IHsgVXBsb2FkQmFzZSB9IGZyb20gJy4vYmFzZS11cGxvYWQvdXBsb2FkLWJhc2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi11cGxvYWQtYnV0dG9uJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdXBsb2FkLWJ1dHRvbi5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vdXBsb2FkLWJ1dHRvbi5jb21wb25lbnQuc2NzcyddLFxuICAgIHZpZXdQcm92aWRlcnM6IFtcbiAgICAgICAgeyBwcm92aWRlOiBFWFRFTkRJQkxFX0NPTVBPTkVOVCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVXBsb2FkQnV0dG9uQ29tcG9uZW50KSB9XG4gICAgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIFVwbG9hZEJ1dHRvbkNvbXBvbmVudCBleHRlbmRzIFVwbG9hZEJhc2UgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgTm9kZVBlcm1pc3Npb25TdWJqZWN0IHtcblxuICAgIC8qKiBBbGxvd3MvZGlzYWxsb3dzIHVwbG9hZCBmb2xkZXJzIChvbmx5IGZvciBDaHJvbWUpLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdXBsb2FkRm9sZGVyczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEFsbG93cy9kaXNhbGxvd3MgbXVsdGlwbGUgZmlsZXMgKi9cbiAgICBASW5wdXQoKVxuICAgIG11bHRpcGxlRmlsZXM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBEZWZpbmVzIHRoZSB0ZXh0IG9mIHRoZSB1cGxvYWQgYnV0dG9uLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RhdGljVGl0bGU6IHN0cmluZztcblxuICAgIC8qKiBDdXN0b20gdG9vbHRpcCB0ZXh0LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdG9vbHRpcDogc3RyaW5nID0gbnVsbDtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gY3JlYXRlIHBlcm1pc3Npb24gaXMgbWlzc2luZy4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBwZXJtaXNzaW9uRXZlbnQ6IEV2ZW50RW1pdHRlcjxQZXJtaXNzaW9uTW9kZWw+ID0gbmV3IEV2ZW50RW1pdHRlcjxQZXJtaXNzaW9uTW9kZWw+KCk7XG5cbiAgICBwcml2YXRlIGhhc1Blcm1pc3Npb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByb3RlY3RlZCBwZXJtaXNzaW9uVmFsdWU6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHVwbG9hZFNlcnZpY2U6IFVwbG9hZFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBjb250ZW50U2VydmljZTogQ29udGVudFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHRyYW5zbGF0aW9uU2VydmljZTogVHJhbnNsYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBuZ1pvbmU6IE5nWm9uZSkge1xuICAgICAgICBzdXBlcih1cGxvYWRTZXJ2aWNlLCB0cmFuc2xhdGlvblNlcnZpY2UsIG5nWm9uZSk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucGVybWlzc2lvblZhbHVlLnN1YnNjcmliZSgocGVybWlzc2lvbjogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYXNQZXJtaXNzaW9uID0gcGVybWlzc2lvbjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICBsZXQgcm9vdEZvbGRlcklkID0gY2hhbmdlc1sncm9vdEZvbGRlcklkJ107XG4gICAgICAgIGlmIChyb290Rm9sZGVySWQgJiYgcm9vdEZvbGRlcklkLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja1Blcm1pc3Npb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzQnV0dG9uRGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBvbkZpbGVzQWRkZWQoJGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgbGV0IGZpbGVzOiBGaWxlW10gPSBGaWxlVXRpbHMudG9GaWxlQXJyYXkoJGV2ZW50LmN1cnJlbnRUYXJnZXQuZmlsZXMpO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc1Blcm1pc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkRmlsZXMoZmlsZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uRXZlbnQuZW1pdChuZXcgUGVybWlzc2lvbk1vZGVsKHsgdHlwZTogJ2NvbnRlbnQnLCBhY3Rpb246ICd1cGxvYWQnLCBwZXJtaXNzaW9uOiAnY3JlYXRlJyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzZXQgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBmaWxlXG4gICAgICAgICRldmVudC50YXJnZXQudmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBvbkRpcmVjdG9yeUFkZGVkKCRldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmhhc1Blcm1pc3Npb24pIHtcbiAgICAgICAgICAgIGxldCBmaWxlczogRmlsZVtdID0gRmlsZVV0aWxzLnRvRmlsZUFycmF5KCRldmVudC5jdXJyZW50VGFyZ2V0LmZpbGVzKTtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkRmlsZXMoZmlsZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uRXZlbnQuZW1pdChuZXcgUGVybWlzc2lvbk1vZGVsKHsgdHlwZTogJ2NvbnRlbnQnLCBhY3Rpb246ICd1cGxvYWQnLCBwZXJtaXNzaW9uOiAnY3JlYXRlJyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzZXQgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBmaWxlXG4gICAgICAgICRldmVudC50YXJnZXQudmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBjaGVja1Blcm1pc3Npb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3RGb2xkZXJJZCkge1xuICAgICAgICAgICAgbGV0IG9wdHM6IGFueSA9IHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlU291cmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IFsnYWxsb3dhYmxlT3BlcmF0aW9ucyddXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTZXJ2aWNlLmdldE5vZGUodGhpcy5yb290Rm9sZGVySWQsIG9wdHMpLnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICByZXMgPT4gdGhpcy5wZXJtaXNzaW9uVmFsdWUubmV4dCh0aGlzLm5vZGVIYXNQZXJtaXNzaW9uKHJlcy5lbnRyeSwgUGVybWlzc2lvbnNFbnVtLkNSRUFURSkpLFxuICAgICAgICAgICAgICAgIGVycm9yID0+IHRoaXMuZXJyb3IuZW1pdChlcnJvcilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlSGFzUGVybWlzc2lvbihub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5LCBwZXJtaXNzaW9uOiBQZXJtaXNzaW9uc0VudW0gfCBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFNlcnZpY2UuaGFzUGVybWlzc2lvbihub2RlLCBwZXJtaXNzaW9uKTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQZXJtaXNzaW9uc0VudW0gIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5wdXQsIE9uQ2hhbmdlcywgVmlld0VuY2Fwc3VsYXRpb24sIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRyeUVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBVcGxvYWRCdXR0b25Db21wb25lbnQgfSBmcm9tICcuL3VwbG9hZC1idXR0b24uY29tcG9uZW50JztcbmltcG9ydCB7IEZpbGVNb2RlbCwgRVhURU5ESUJMRV9DT01QT05FTlQgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi11cGxvYWQtdmVyc2lvbi1idXR0b24nLFxuICAgIHRlbXBsYXRlVXJsOiAnLi91cGxvYWQtYnV0dG9uLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi91cGxvYWQtYnV0dG9uLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgdmlld1Byb3ZpZGVyczogW1xuICAgICAgICB7IHByb3ZpZGU6IEVYVEVORElCTEVfQ09NUE9ORU5ULCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBVcGxvYWRWZXJzaW9uQnV0dG9uQ29tcG9uZW50KSB9XG4gICAgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIFVwbG9hZFZlcnNpb25CdXR0b25Db21wb25lbnQgZXh0ZW5kcyBVcGxvYWRCdXR0b25Db21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uSW5pdCB7XG5cbiAgICAvKiogKCoqUmVxdWlyZWQqKikgVGhlIG5vZGUgdG8gYmUgdmVyc2lvbmVkLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eTtcblxuICAgIHByb3RlY3RlZCBjcmVhdGVGaWxlTW9kZWwoZmlsZTogRmlsZSk6IEZpbGVNb2RlbCB7XG4gICAgICAgIGNvbnN0IGZpbGVNb2RlbCA9IHN1cGVyLmNyZWF0ZUZpbGVNb2RlbChmaWxlLCB0aGlzLnJvb3RGb2xkZXJJZCwgKGZpbGUud2Via2l0UmVsYXRpdmVQYXRoIHx8ICcnKS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sICcnKSwgdGhpcy5ub2RlLmlkKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNGaWxlQWNjZXB0YWJsZShmaWxlTW9kZWwpKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy50cmFuc2xhdGlvblNlcnZpY2UuaW5zdGFudCgnRklMRV9VUExPQUQuVkVSU0lPTi5NRVNTQUdFUy5JTkNPTVBBVElCTEVfVkVSU0lPTicpO1xuICAgICAgICAgICAgdGhpcy5lcnJvci5lbWl0KG1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbGVNb2RlbDtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgdGhpcy5jaGVja1Blcm1pc3Npb24oKTtcbiAgICB9XG5cbiAgICBjaGVja1Blcm1pc3Npb24oKSB7XG4gICAgICAgIHRoaXMucGVybWlzc2lvblZhbHVlLm5leHQodGhpcy5ub2RlSGFzUGVybWlzc2lvbih0aGlzLm5vZGUsIFBlcm1pc3Npb25zRW51bS5VUERBVEUpKTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIEVYVEVORElCTEVfQ09NUE9ORU5ULCBGaWxlSW5mbywgRmlsZU1vZGVsLCBGaWxlVXRpbHMsIE5vZGVQZXJtaXNzaW9uU3ViamVjdCxcbiAgICBOb3RpZmljYXRpb25TZXJ2aWNlLCBUcmFuc2xhdGlvblNlcnZpY2UsIFVwbG9hZFNlcnZpY2UsIENvbnRlbnRTZXJ2aWNlLCBQZXJtaXNzaW9uc0VudW1cbn0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5wdXQsIFZpZXdFbmNhcHN1bGF0aW9uLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwbG9hZEJhc2UgfSBmcm9tICcuL2Jhc2UtdXBsb2FkL3VwbG9hZC1iYXNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtdXBsb2FkLWRyYWctYXJlYScsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3VwbG9hZC1kcmFnLWFyZWEuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3VwbG9hZC1kcmFnLWFyZWEuY29tcG9uZW50LmNzcyddLFxuICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ2FkZi11cGxvYWQtZHJhZy1hcmVhJyB9LFxuICAgIHZpZXdQcm92aWRlcnM6IFtcbiAgICAgICAgeyBwcm92aWRlOiBFWFRFTkRJQkxFX0NPTVBPTkVOVCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVXBsb2FkRHJhZ0FyZWFDb21wb25lbnQpIH1cbiAgICBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgVXBsb2FkRHJhZ0FyZWFDb21wb25lbnQgZXh0ZW5kcyBVcGxvYWRCYXNlIGltcGxlbWVudHMgTm9kZVBlcm1pc3Npb25TdWJqZWN0IHtcblxuICAgIC8qKlxuICAgICAqIElEIG9mIHBhcmVudCBmb2xkZXIgbm9kZVxuICAgICAqIEBkZXByZWNhdGVkIDIuNC4wIC0gdXNlIHJvb3RGb2xkZXJJZCBJRCBvZiBwYXJlbnQgZm9sZGVyIG5vZGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBwYXJlbnRJZChub2RlSWQ6IHN0cmluZykge1xuICAgICAgICB0aGlzLnJvb3RGb2xkZXJJZCA9IG5vZGVJZDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgdXBsb2FkU2VydmljZTogVXBsb2FkU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgdHJhbnNsYXRpb25TZXJ2aWNlOiBUcmFuc2xhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBub3RpZmljYXRpb25TZXJ2aWNlOiBOb3RpZmljYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY29udGVudFNlcnZpY2U6IENvbnRlbnRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBuZ1pvbmU6IE5nWm9uZSkge1xuICAgICAgICBzdXBlcih1cGxvYWRTZXJ2aWNlLCB0cmFuc2xhdGlvblNlcnZpY2UsIG5nWm9uZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGNhbGxlZCB3aGVuIGZpbGVzIGFyZSBkcm9wcGVkIGluIHRoZSBkcmFnIGFyZWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZXMgLSBmaWxlcyBkcm9wcGVkIGluIHRoZSBkcmFnIGFyZWEuXG4gICAgICovXG4gICAgb25GaWxlc0Ryb3BwZWQoZmlsZXM6IEZpbGVbXSk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZEZpbGVzKGZpbGVzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBmaWxlIGFyZSBkcm9wcGVkIGluIHRoZSBkcmFnIGFyZWEuXG4gICAgICogQGRlcHJlY2F0ZWQgaW4gMi40LjA6IHVzZSBgb25GaWxlc0Ryb3BwZWRgIGluc3RlYWRcbiAgICAgKiBAcGFyYW0gaXRlbSAtIEZpbGVFbnRpdHlcbiAgICAgKi9cbiAgICBvbkZpbGVzRW50aXR5RHJvcHBlZChpdGVtOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBpdGVtLmZpbGUoKGZpbGU6IEZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBmaWxlTW9kZWwgPSB0aGlzLmNyZWF0ZUZpbGVNb2RlbChmaWxlLCB0aGlzLnJvb3RGb2xkZXJJZCwgaXRlbS5mdWxsUGF0aC5yZXBsYWNlKGl0ZW0ubmFtZSwgJycpKTtcblxuICAgICAgICAgICAgICAgIHRoaXMudXBsb2FkRmlsZXMoW2ZpbGVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBmb2xkZXIgYXJlIGRyb3BwZWQgaW4gdGhlIGRyYWcgYXJlYVxuICAgICAqXG4gICAgICogQHBhcmFtIGZvbGRlciAtIG5hbWUgb2YgdGhlIGRyb3BwZWQgZm9sZGVyXG4gICAgICovXG4gICAgb25Gb2xkZXJFbnRpdHlEcm9wcGVkKGZvbGRlcjogYW55KTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiBmb2xkZXIuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgIEZpbGVVdGlscy5mbGF0dGVybihmb2xkZXIpLnRoZW4oZmlsZXNJbmZvID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZEZpbGVzSW5mbyhmaWxlc0luZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IHVuZG8gbm90aWZpY2F0aW9uIGJhci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXRlc3RGaWxlc0FkZGVkIC0gZmlsZXMgaW4gdGhlIHVwbG9hZCBxdWV1ZSBlbnJpY2hlZCB3aXRoIHN0YXR1cyBmbGFnIGFuZCB4aHIgb2JqZWN0LlxuICAgICAqL1xuICAgIHNob3dVbmRvTm90aWZpY2F0aW9uQmFyKGxhdGVzdEZpbGVzQWRkZWQ6IEZpbGVNb2RlbFtdKSB7XG4gICAgICAgIGxldCBtZXNzYWdlVHJhbnNsYXRlOiBhbnksIGFjdGlvblRyYW5zbGF0ZTogYW55O1xuICAgICAgICBtZXNzYWdlVHJhbnNsYXRlID0gdGhpcy50cmFuc2xhdGlvblNlcnZpY2UuZ2V0KCdGSUxFX1VQTE9BRC5NRVNTQUdFUy5QUk9HUkVTUycpO1xuICAgICAgICBhY3Rpb25UcmFuc2xhdGUgPSB0aGlzLnRyYW5zbGF0aW9uU2VydmljZS5nZXQoJ0ZJTEVfVVBMT0FELkFDVElPTi5VTkRPJyk7XG5cbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25TZXJ2aWNlLm9wZW5TbmFja01lc3NhZ2VBY3Rpb24obWVzc2FnZVRyYW5zbGF0ZS52YWx1ZSwgYWN0aW9uVHJhbnNsYXRlLnZhbHVlLCAzMDAwKS5vbkFjdGlvbigpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UuY2FuY2VsVXBsb2FkKC4uLmxhdGVzdEZpbGVzQWRkZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGNvbnNpZGVyaW5nIHRoZSBjb21wb25lbnQgb3B0aW9ucyBhbmQgbm9kZSBwZXJtaXNzaW9ucyAqL1xuICAgIGlzRHJvcHBhYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyAndXBsb2FkLWZpbGVzJyBldmVudHMgcmFpc2VkIGJ5IGNoaWxkIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgRE9NIGV2ZW50XG4gICAgICovXG4gICAgb25VcGxvYWRGaWxlcyhldmVudDogQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCBpc0FsbG93ZWQ6IGJvb2xlYW4gPSB0aGlzLmNvbnRlbnRTZXJ2aWNlLmhhc1Blcm1pc3Npb24oZXZlbnQuZGV0YWlsLmRhdGEub2JqLmVudHJ5LCBQZXJtaXNzaW9uc0VudW0uQ1JFQVRFKTtcbiAgICAgICAgaWYgKGlzQWxsb3dlZCkge1xuICAgICAgICAgICAgbGV0IGZpbGVJbmZvOiBGaWxlSW5mb1tdID0gZXZlbnQuZGV0YWlsLmZpbGVzO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUYXJnZXROb2RlRm9sZGVyKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uRm9sZGVyTmFtZSA9IGV2ZW50LmRldGFpbC5kYXRhLm9iai5lbnRyeS5uYW1lO1xuICAgICAgICAgICAgICAgIGZpbGVJbmZvLm1hcCgoZmlsZSkgPT4gZmlsZS5yZWxhdGl2ZUZvbGRlciA9IGRlc3RpbmF0aW9uRm9sZGVyTmFtZSA/IGRlc3RpbmF0aW9uRm9sZGVyTmFtZS5jb25jYXQoZmlsZS5yZWxhdGl2ZUZvbGRlcikgOiBmaWxlLnJlbGF0aXZlRm9sZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxlSW5mbyAmJiBmaWxlSW5mby5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGxvYWRGaWxlc0luZm8oZmlsZUluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc1RhcmdldE5vZGVGb2xkZXIoZXZlbnQ6IEN1c3RvbUV2ZW50KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBldmVudC5kZXRhaWwuZGF0YS5vYmogJiYgZXZlbnQuZGV0YWlsLmRhdGEub2JqLmVudHJ5LmlzRm9sZGVyO1xuICAgIH1cblxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogdHNsaW50OmRpc2FibGU6bm8taW5wdXQtcmVuYW1lICAqL1xuXG5pbXBvcnQgeyBGaWxlVXRpbHMgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBOZ1pvbmUsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbZmlsZS1kcmFnZ2FibGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBGaWxlRHJhZ2dhYmxlRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgZmlsZXM6IEZpbGUgW107XG5cbiAgICAvKiogRW5hYmxlcy9kaXNhYmxlcyBkcmFnLWFuZC1kcm9wIGZ1bmN0aW9uYWxpdHkuICovXG4gICAgQElucHV0KCdmaWxlLWRyYWdnYWJsZScpXG4gICAgZW5hYmxlZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIG9uZSBvciBtb3JlIGZpbGVzIGFyZSBkcmFnZ2VkIGFuZCBkcm9wcGVkIG9udG8gdGhlIGRyYWdnYWJsZSBlbGVtZW50LiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGZpbGVzRHJvcHBlZDogRXZlbnRFbWl0dGVyPEZpbGVbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPEZpbGVbXT4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBvbmUgb3IgbW9yZSBmaWxlcyBhcmUgZHJhZ2dlZCBhbmQgZHJvcHBlZCBvbnRvIHRoZSBkcmFnZ2FibGUgZWxlbWVudC5cbiAgICAgKiBAZGVwcmVjYXRlZCBpbiAyLjQuMDogdXNlIGBmaWxlc0Ryb3BwZWRgIGluc3RlYWRcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBmaWxlc0VudGl0eURyb3BwZWQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhIGRpcmVjdG9yeSBpcyBkcmFnZ2VkIGFuZCBkcm9wcGVkIG9udG8gdGhlIGRyYWdnYWJsZSBlbGVtZW50LiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGZvbGRlckVudGl0eURyb3BwZWQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgcHJpdmF0ZSBjc3NDbGFzc05hbWU6IHN0cmluZyA9ICdmaWxlLWRyYWdnYWJsZV9faW5wdXQtZm9jdXMnO1xuICAgIHByaXZhdGUgZWxlbWVudDogSFRNTEVsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3RvcihlbDogRWxlbWVudFJlZiwgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbC5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgdGhpcy5vbkRyYWdFbnRlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMub25EcmFnT3Zlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCB0aGlzLm9uRHJhZ0xlYXZlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLm9uRHJvcEZpbGVzLmJpbmQodGhpcykpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIHRoaXMub25EcmFnRW50ZXIpO1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzLm9uRHJhZ092ZXIpO1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgdGhpcy5vbkRyYWdMZWF2ZSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpcy5vbkRyb3BGaWxlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGNhbGxlZCB3aGVuIGZpbGVzIGlzIGRyb3BwZWQgaW4gdGhlIGRyYWcgYW5kIGRyb3AgYXJlYS5cbiAgICAgKiBAcGFyYW0gZXZlbnQgRE9NIGV2ZW50LlxuICAgICAqL1xuICAgIG9uRHJvcEZpbGVzKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdChldmVudCk7XG5cbiAgICAgICAgICAgIC8vIENocm9tZSwgRWRnZSwgRmlyZWZveCwgT3BlcmEgKEZpbGVzICsgRm9sZGVycylcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gZXZlbnQuZGF0YVRyYW5zZmVyLml0ZW1zO1xuICAgICAgICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXM6IEZpbGVbXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbXNbaV0ud2Via2l0R2V0QXNFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldLndlYmtpdEdldEFzRW50cnkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc0ZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGl0ZW1zW2ldLmdldEFzRmlsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9sZGVyRW50aXR5RHJvcHBlZC5lbWl0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGVzRHJvcHBlZC5lbWl0KGZpbGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElFLCBTYWZhcmksIENocm9tZSwgRWRnZSwgRmlyZWZveCwgT3BlcmEgKEZpbGVzIG9ubHkpXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBGaWxlVXRpbHMudG9GaWxlQXJyYXkoZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVzRHJvcHBlZC5lbWl0KGZpbGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jc3NDbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBzdHlsZSBvZiB0aGUgZHJhZyBhcmVhIHdoZW4gYSBmaWxlIGRyYWcgaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBET00gZXZlbnQuXG4gICAgICovXG4gICAgb25EcmFnRW50ZXIoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5jc3NDbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBzdHlsZSBvZiB0aGUgZHJhZyBhcmVhIHdoZW4gYSBmaWxlIGRyYWcgb3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gRE9NIGV2ZW50LlxuICAgICAqL1xuICAgIG9uRHJhZ0xlYXZlKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5lbmFibGVkICYmICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY3NzQ2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgc3R5bGUgb2YgdGhlIGRyYWcgYXJlYSB3aGVuIGEgZmlsZSBpcyBvdmVyIHRoZSBkcmFnIGFyZWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkRyYWdPdmVyKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5lbmFibGVkICYmICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuY3NzQ2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXZlbnQgZGVmYXVsdCBhbmQgc3RvcCBwcm9wYWdhdGlvbiBvZiB0aGUgRE9NIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtICRldmVudCAtIERPTSBldmVudC5cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdChldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IE1hdGVyaWFsTW9kdWxlIH0gZnJvbSAnLi4vbWF0ZXJpYWwubW9kdWxlJztcbmltcG9ydCB7IEZpbGVVcGxvYWRpbmdEaWFsb2dDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZmlsZS11cGxvYWRpbmctZGlhbG9nLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGaWxlVXBsb2FkaW5nTGlzdFJvd0NvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9maWxlLXVwbG9hZGluZy1saXN0LXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlsZVVwbG9hZGluZ0xpc3RDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZmlsZS11cGxvYWRpbmctbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVXBsb2FkQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3VwbG9hZC1idXR0b24uY29tcG9uZW50JztcbmltcG9ydCB7IFVwbG9hZFZlcnNpb25CdXR0b25Db21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvdXBsb2FkLXZlcnNpb24tYnV0dG9uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBVcGxvYWREcmFnQXJlYUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy91cGxvYWQtZHJhZy1hcmVhLmNvbXBvbmVudCc7XG5cbmltcG9ydCB7IENvcmVNb2R1bGUgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgRmlsZURyYWdnYWJsZURpcmVjdGl2ZSB9IGZyb20gJy4vZGlyZWN0aXZlcy9maWxlLWRyYWdnYWJsZS5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29yZU1vZHVsZS5mb3JDaGlsZCgpLFxuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIE1hdGVyaWFsTW9kdWxlXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRmlsZURyYWdnYWJsZURpcmVjdGl2ZSxcbiAgICAgICAgVXBsb2FkRHJhZ0FyZWFDb21wb25lbnQsXG4gICAgICAgIFVwbG9hZEJ1dHRvbkNvbXBvbmVudCxcbiAgICAgICAgVXBsb2FkVmVyc2lvbkJ1dHRvbkNvbXBvbmVudCxcbiAgICAgICAgRmlsZVVwbG9hZGluZ0RpYWxvZ0NvbXBvbmVudCxcbiAgICAgICAgRmlsZVVwbG9hZGluZ0xpc3RDb21wb25lbnQsXG4gICAgICAgIEZpbGVVcGxvYWRpbmdMaXN0Um93Q29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEZpbGVEcmFnZ2FibGVEaXJlY3RpdmUsXG4gICAgICAgIFVwbG9hZERyYWdBcmVhQ29tcG9uZW50LFxuICAgICAgICBVcGxvYWRCdXR0b25Db21wb25lbnQsXG4gICAgICAgIFVwbG9hZFZlcnNpb25CdXR0b25Db21wb25lbnQsXG4gICAgICAgIEZpbGVVcGxvYWRpbmdEaWFsb2dDb21wb25lbnQsXG4gICAgICAgIEZpbGVVcGxvYWRpbmdMaXN0Q29tcG9uZW50LFxuICAgICAgICBGaWxlVXBsb2FkaW5nTGlzdFJvd0NvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgVXBsb2FkTW9kdWxlIHt9XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZsZXhMYXlvdXRNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mbGV4LWxheW91dCc7XG5pbXBvcnQgeyBDb3JlTW9kdWxlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuaW1wb3J0IHsgTWF0ZXJpYWxNb2R1bGUgfSBmcm9tICcuLi9tYXRlcmlhbC5tb2R1bGUnO1xuaW1wb3J0IHsgVXBsb2FkTW9kdWxlIH0gZnJvbSAnLi4vdXBsb2FkL3VwbG9hZC5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDb250ZW50QWN0aW9uTGlzdENvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9jb250ZW50LWFjdGlvbi9jb250ZW50LWFjdGlvbi1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb250ZW50QWN0aW9uQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2NvbnRlbnQtYWN0aW9uL2NvbnRlbnQtYWN0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb250ZW50Q29sdW1uTGlzdENvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9jb250ZW50LWNvbHVtbi9jb250ZW50LWNvbHVtbi1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb250ZW50Q29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2NvbnRlbnQtY29sdW1uL2NvbnRlbnQtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEb2N1bWVudExpc3RDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZG9jdW1lbnQtbGlzdC5jb21wb25lbnQnO1xuXG5pbXBvcnQgeyBFbXB0eUZvbGRlckNvbnRlbnREaXJlY3RpdmUgfSBmcm9tICcuL2NvbXBvbmVudHMvZW1wdHktZm9sZGVyL2VtcHR5LWZvbGRlci1jb250ZW50LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOb1Blcm1pc3Npb25Db250ZW50RGlyZWN0aXZlIH0gZnJvbSAnLi9jb21wb25lbnRzL25vLXBlcm1pc3Npb24vbm8tcGVybWlzc2lvbi1jb250ZW50LmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb3JlTW9kdWxlLmZvckNoaWxkKCksXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRmxleExheW91dE1vZHVsZSxcbiAgICAgICAgTWF0ZXJpYWxNb2R1bGUsXG4gICAgICAgIFVwbG9hZE1vZHVsZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIERvY3VtZW50TGlzdENvbXBvbmVudCxcbiAgICAgICAgQ29udGVudENvbHVtbkNvbXBvbmVudCxcbiAgICAgICAgQ29udGVudENvbHVtbkxpc3RDb21wb25lbnQsXG4gICAgICAgIENvbnRlbnRBY3Rpb25Db21wb25lbnQsXG4gICAgICAgIENvbnRlbnRBY3Rpb25MaXN0Q29tcG9uZW50LFxuICAgICAgICBFbXB0eUZvbGRlckNvbnRlbnREaXJlY3RpdmUsXG4gICAgICAgIE5vUGVybWlzc2lvbkNvbnRlbnREaXJlY3RpdmVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRG9jdW1lbnRMaXN0Q29tcG9uZW50LFxuICAgICAgICBDb250ZW50Q29sdW1uQ29tcG9uZW50LFxuICAgICAgICBDb250ZW50Q29sdW1uTGlzdENvbXBvbmVudCxcbiAgICAgICAgQ29udGVudEFjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgQ29udGVudEFjdGlvbkxpc3RDb21wb25lbnQsXG4gICAgICAgIEVtcHR5Rm9sZGVyQ29udGVudERpcmVjdGl2ZSxcbiAgICAgICAgTm9QZXJtaXNzaW9uQ29udGVudERpcmVjdGl2ZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgRG9jdW1lbnRMaXN0TW9kdWxlIHt9XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBBbGZyZXNjb0FwaVNlcnZpY2UsIEFwcENvbmZpZ1NlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgUXVlcnlCb2R5LCBSZXF1ZXN0RmFjZXRGaWVsZHMsIFJlcXVlc3RGYWNldEZpZWxkLCBSZXF1ZXN0U29ydERlZmluaXRpb25Jbm5lciB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBTZWFyY2hDYXRlZ29yeSB9IGZyb20gJy4vc2VhcmNoLWNhdGVnb3J5LmludGVyZmFjZSc7XG5pbXBvcnQgeyBGaWx0ZXJRdWVyeSB9IGZyb20gJy4vZmlsdGVyLXF1ZXJ5LmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hSYW5nZSB9IGZyb20gJy4vc2VhcmNoLXJhbmdlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hDb25maWd1cmF0aW9uIH0gZnJvbSAnLi9zZWFyY2gtY29uZmlndXJhdGlvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRmFjZXRRdWVyeSB9IGZyb20gJy4vZmFjZXQtcXVlcnkuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaFNvcnRpbmdEZWZpbml0aW9uIH0gZnJvbSAnLi9zZWFyY2gtc29ydGluZy1kZWZpbml0aW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBGYWNldEZpZWxkIH0gZnJvbSAnLi9mYWNldC1maWVsZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRmFjZXRGaWVsZEJ1Y2tldCB9IGZyb20gJy4vZmFjZXQtZmllbGQtYnVja2V0LmludGVyZmFjZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgX3VzZXJRdWVyeSA9ICcnO1xuXG4gICAgdXBkYXRlZDogU3ViamVjdDxRdWVyeUJvZHk+ID0gbmV3IFN1YmplY3QoKTtcbiAgICBleGVjdXRlZDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3QoKTtcblxuICAgIGNhdGVnb3JpZXM6IEFycmF5PFNlYXJjaENhdGVnb3J5PiA9IFtdO1xuICAgIHF1ZXJ5RnJhZ21lbnRzOiB7IFtpZDogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgICBmaWx0ZXJRdWVyaWVzOiBGaWx0ZXJRdWVyeVtdID0gW107XG4gICAgcGFnaW5nOiB7IG1heEl0ZW1zPzogbnVtYmVyOyBza2lwQ291bnQ/OiBudW1iZXIgfSA9IG51bGw7XG4gICAgc29ydGluZzogQXJyYXk8U2VhcmNoU29ydGluZ0RlZmluaXRpb24+ID0gW107XG5cbiAgICBwcm90ZWN0ZWQgdXNlckZhY2V0UXVlcmllczogRmFjZXRRdWVyeVtdID0gW107XG4gICAgcHJvdGVjdGVkIHVzZXJGYWNldEJ1Y2tldHM6IHsgW2tleTogc3RyaW5nXTogQXJyYXk8RmFjZXRGaWVsZEJ1Y2tldD4gfSA9IHt9O1xuXG4gICAgZ2V0IHVzZXJRdWVyeSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlclF1ZXJ5O1xuICAgIH1cblxuICAgIHNldCB1c2VyUXVlcnkodmFsdWU6IHN0cmluZykge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8fCAnJykudHJpbSgpO1xuICAgICAgICB0aGlzLl91c2VyUXVlcnkgPSB2YWx1ZSA/IGAoJHt2YWx1ZX0pYCA6ICcnO1xuICAgIH1cblxuICAgIGNvbmZpZzogU2VhcmNoQ29uZmlndXJhdGlvbjtcblxuICAgIC8vIFRPRE86IHRvIGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgaXRlcmF0aW9uc1xuICAgIHJhbmdlczogeyBbaWQ6IHN0cmluZ106IFNlYXJjaFJhbmdlIH0gPSB7fTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYXBwQ29uZmlnOiBBcHBDb25maWdTZXJ2aWNlLCBwcml2YXRlIGFsZnJlc2NvQXBpU2VydmljZTogQWxmcmVzY29BcGlTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMucmVzZXRUb0RlZmF1bHRzKCk7XG4gICAgfVxuXG4gICAgcmVzZXRUb0RlZmF1bHRzKCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuYXBwQ29uZmlnLmdldDxTZWFyY2hDb25maWd1cmF0aW9uPignc2VhcmNoJyk7XG4gICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlKSk7XG4gICAgICAgICAgICB0aGlzLmNhdGVnb3JpZXMgPSAodGhpcy5jb25maWcuY2F0ZWdvcmllcyB8fCBbXSkuZmlsdGVyKGNhdGVnb3J5ID0+IGNhdGVnb3J5LmVuYWJsZWQpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJRdWVyaWVzID0gdGhpcy5jb25maWcuZmlsdGVyUXVlcmllcyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMudXNlckZhY2V0QnVja2V0cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy51c2VyRmFjZXRRdWVyaWVzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuc29ydGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ydGluZyA9IHRoaXMuY29uZmlnLnNvcnRpbmcuZGVmYXVsdHMgfHwgW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRVc2VyRmFjZXRRdWVyeShxdWVyeTogRmFjZXRRdWVyeSkge1xuICAgICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy51c2VyRmFjZXRRdWVyaWVzLmZpbmQoZmFjZXRRdWVyeSA9PiBmYWNldFF1ZXJ5LmxhYmVsID09PSBxdWVyeS5sYWJlbCk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZy5xdWVyeSA9IHF1ZXJ5LnF1ZXJ5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJGYWNldFF1ZXJpZXMucHVzaCh7IC4uLnF1ZXJ5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlVXNlckZhY2V0UXVlcnkocXVlcnk6IEZhY2V0UXVlcnkpIHtcbiAgICAgICAgaWYgKHF1ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJGYWNldFF1ZXJpZXMgPSB0aGlzLnVzZXJGYWNldFF1ZXJpZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZhY2V0UXVlcnkgPT4gZmFjZXRRdWVyeS5sYWJlbCAhPT0gcXVlcnkubGFiZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkVXNlckZhY2V0QnVja2V0KGZpZWxkOiBGYWNldEZpZWxkLCBidWNrZXQ6IEZhY2V0RmllbGRCdWNrZXQpIHtcbiAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLmZpZWxkICYmIGJ1Y2tldCkge1xuICAgICAgICAgICAgY29uc3QgYnVja2V0cyA9IHRoaXMudXNlckZhY2V0QnVja2V0c1tmaWVsZC5maWVsZF0gfHwgW107XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGJ1Y2tldHMuZmluZChmYWNldEJ1Y2tldCA9PiBmYWNldEJ1Y2tldC5sYWJlbCA9PT0gYnVja2V0LmxhYmVsKTtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICBidWNrZXRzLnB1c2goYnVja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXNlckZhY2V0QnVja2V0c1tmaWVsZC5maWVsZF0gPSBidWNrZXRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VXNlckZhY2V0QnVja2V0cyhmaWVsZDogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJGYWNldEJ1Y2tldHNbZmllbGRdIHx8IFtdO1xuICAgIH1cblxuICAgIHJlbW92ZVVzZXJGYWNldEJ1Y2tldChmaWVsZDogRmFjZXRGaWVsZCwgYnVja2V0OiBGYWNldEZpZWxkQnVja2V0KSB7XG4gICAgICAgIGlmIChmaWVsZCAmJiBmaWVsZC5maWVsZCAmJiBidWNrZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1Y2tldHMgPSB0aGlzLnVzZXJGYWNldEJ1Y2tldHNbZmllbGQuZmllbGRdIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy51c2VyRmFjZXRCdWNrZXRzW2ZpZWxkLmZpZWxkXSA9IGJ1Y2tldHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZhY2V0QnVja2V0ID0+IGZhY2V0QnVja2V0LmxhYmVsICE9PSBidWNrZXQubGFiZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkRmlsdGVyUXVlcnkocXVlcnk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5maWx0ZXJRdWVyaWVzLmZpbmQoZmlsdGVyUXVlcnkgPT4gZmlsdGVyUXVlcnkucXVlcnkgPT09IHF1ZXJ5KTtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlclF1ZXJpZXMucHVzaCh7IHF1ZXJ5OiBxdWVyeSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUZpbHRlclF1ZXJ5KHF1ZXJ5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYgKHF1ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlclF1ZXJpZXMgPSB0aGlzLmZpbHRlclF1ZXJpZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZpbHRlclF1ZXJ5ID0+IGZpbHRlclF1ZXJ5LnF1ZXJ5ICE9PSBxdWVyeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGYWNldFF1ZXJ5KGxhYmVsOiBzdHJpbmcpOiBGYWNldFF1ZXJ5IHtcbiAgICAgICAgaWYgKGxhYmVsICYmIHRoaXMuaGFzRmFjZXRRdWVyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNvbmZpZy5mYWNldFF1ZXJpZXMucXVlcmllcy5maW5kKHF1ZXJ5ID0+IHF1ZXJ5LmxhYmVsID09PSBsYWJlbCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0RmFjZXRGaWVsZChsYWJlbDogc3RyaW5nKTogRmFjZXRGaWVsZCB7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5jb25maWcuZmFjZXRGaWVsZHMuZmllbGRzIHx8IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZmllbGRzLmZpbmQoZmllbGQgPT4gZmllbGQubGFiZWwgPT09IGxhYmVsKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5idWlsZFF1ZXJ5KCk7XG4gICAgICAgIHRoaXMudXBkYXRlZC5uZXh0KHF1ZXJ5KTtcbiAgICB9XG5cbiAgICBhc3luYyBleGVjdXRlKCkge1xuICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXMuYnVpbGRRdWVyeSgpO1xuICAgICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmFsZnJlc2NvQXBpU2VydmljZS5zZWFyY2hBcGkuc2VhcmNoKHF1ZXJ5KTtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZWQubmV4dChkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJ1aWxkUXVlcnkoKTogUXVlcnlCb2R5IHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5nZXRGaW5hbFF1ZXJ5KCk7XG5cbiAgICAgICAgY29uc3QgaW5jbHVkZSA9IHRoaXMuY29uZmlnLmluY2x1ZGUgfHwgW107XG4gICAgICAgIGlmIChpbmNsdWRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaW5jbHVkZS5wdXNoKCdwYXRoJywgJ2FsbG93YWJsZU9wZXJhdGlvbnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChxdWVyeSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBRdWVyeUJvZHkgPSB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogJ2FmdHMnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiBpbmNsdWRlLFxuICAgICAgICAgICAgICAgIHBhZ2luZzogdGhpcy5wYWdpbmcsXG4gICAgICAgICAgICAgICAgZmllbGRzOiB0aGlzLmNvbmZpZy5maWVsZHMsXG4gICAgICAgICAgICAgICAgZmlsdGVyUXVlcmllczogdGhpcy5maWx0ZXJRdWVyaWVzLFxuICAgICAgICAgICAgICAgIGZhY2V0UXVlcmllczogdGhpcy5mYWNldFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgZmFjZXRGaWVsZHM6IHRoaXMuZmFjZXRGaWVsZHMsXG4gICAgICAgICAgICAgICAgc29ydDogdGhpcy5zb3J0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwcmltYXJ5IHNvcnRpbmcgZGVmaW5pdGlvbi5cbiAgICAgKi9cbiAgICBnZXRQcmltYXJ5U29ydGluZygpOiBTZWFyY2hTb3J0aW5nRGVmaW5pdGlvbiB7XG4gICAgICAgIGlmICh0aGlzLnNvcnRpbmcgJiYgdGhpcy5zb3J0aW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvcnRpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgcHJlLWNvbmZpZ3VyZWQgc29ydGluZyBvcHRpb25zIHRoYXQgdXNlcnMgY2FuIGNob29zZSBmcm9tLlxuICAgICAqL1xuICAgIGdldFNvcnRpbmdPcHRpb25zKCk6IFNlYXJjaFNvcnRpbmdEZWZpbml0aW9uW10ge1xuICAgICAgICBpZiAodGhpcy5jb25maWcgJiYgdGhpcy5jb25maWcuc29ydGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNvcnRpbmcub3B0aW9ucyB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgRmFjZXRRdWVyaWVzIGhhcyBiZWVuIGRlZmluZWRcbiAgICAgKi9cbiAgICBnZXQgaGFzRmFjZXRRdWVyaWVzKCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5jb25maWdcbiAgICAgICAgICAgICYmIHRoaXMuY29uZmlnLmZhY2V0UXVlcmllc1xuICAgICAgICAgICAgJiYgdGhpcy5jb25maWcuZmFjZXRRdWVyaWVzLnF1ZXJpZXNcbiAgICAgICAgICAgICYmIHRoaXMuY29uZmlnLmZhY2V0UXVlcmllcy5xdWVyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IHNvcnQoKTogUmVxdWVzdFNvcnREZWZpbml0aW9uSW5uZXJbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRpbmcubWFwKGRlZiA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGRlZi50eXBlLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBkZWYuZmllbGQsXG4gICAgICAgICAgICAgICAgYXNjZW5kaW5nOiBkZWYuYXNjZW5kaW5nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGZhY2V0UXVlcmllcygpOiBGYWNldFF1ZXJ5W10ge1xuICAgICAgICBpZiAodGhpcy5oYXNGYWNldFF1ZXJpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5mYWNldFF1ZXJpZXMucXVlcmllcy5tYXAocXVlcnkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiA8RmFjZXRRdWVyeT4geyAuLi5xdWVyeSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0RmluYWxRdWVyeSgpOiBzdHJpbmcge1xuICAgICAgICBsZXQgcXVlcnkgPSAnJztcblxuICAgICAgICB0aGlzLmNhdGVnb3JpZXMuZm9yRWFjaChmYWNldCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXN0b21RdWVyeSA9IHRoaXMucXVlcnlGcmFnbWVudHNbZmFjZXQuaWRdO1xuICAgICAgICAgICAgaWYgKGN1c3RvbVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgKz0gJyBBTkQgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXVlcnkgKz0gYCgke2N1c3RvbVF1ZXJ5fSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgcmVzdWx0ID0gW3RoaXMudXNlclF1ZXJ5LCBxdWVyeV1cbiAgICAgICAgICAgIC5maWx0ZXIoZW50cnkgPT4gZW50cnkpXG4gICAgICAgICAgICAuam9pbignIEFORCAnKTtcblxuICAgICAgICBpZiAodGhpcy51c2VyRmFjZXRRdWVyaWVzICYmIHRoaXMudXNlckZhY2V0UXVlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZCA9IHRoaXMudXNlckZhY2V0UXVlcmllc1xuICAgICAgICAgICAgICAgIC5tYXAodXNlclF1ZXJ5ID0+IHVzZXJRdWVyeS5xdWVyeSlcbiAgICAgICAgICAgICAgICAuam9pbignIE9SICcpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGAgQU5EICgke2NvbWJpbmVkfSlgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudXNlckZhY2V0QnVja2V0cykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy51c2VyRmFjZXRCdWNrZXRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViUXVlcnkgPSAodGhpcy51c2VyRmFjZXRCdWNrZXRzW2tleV0gfHwgW10pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoYnVja2V0ID0+IGJ1Y2tldC5maWx0ZXJRdWVyeSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyBPUiAnKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyBBTkQgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYCgke3N1YlF1ZXJ5fSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGZhY2V0RmllbGRzKCk6IFJlcXVlc3RGYWNldEZpZWxkcyB7XG4gICAgICAgIGNvbnN0IGZhY2V0RmllbGRzID0gdGhpcy5jb25maWcuZmFjZXRGaWVsZHMgJiYgdGhpcy5jb25maWcuZmFjZXRGaWVsZHMuZmllbGRzO1xuXG4gICAgICAgIGlmIChmYWNldEZpZWxkcyAmJiBmYWNldEZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZhY2V0czogZmFjZXRGaWVsZHMubWFwKGZhY2V0ID0+IDxSZXF1ZXN0RmFjZXRGaWVsZD4ge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmFjZXQuZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIG1pbmNvdW50OiBmYWNldC5taW5jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZhY2V0LmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogZmFjZXQubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogZmFjZXQub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IGZhY2V0LnByZWZpeFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgU2VhcmNoU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBPbkNoYW5nZXMsXG4gICAgT3V0cHV0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZCxcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5vZGVQYWdpbmcsIFF1ZXJ5Qm9keSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXNlYXJjaCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NlYXJjaC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vc2VhcmNoLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgICBleHBvcnRBczogJ3NlYXJjaEF1dG9jb21wbGV0ZScsXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAnYWRmLXNlYXJjaCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcyB7XG5cbiAgICBAVmlld0NoaWxkKCdwYW5lbCcpXG4gICAgcGFuZWw6IEVsZW1lbnRSZWY7XG5cbiAgICBAQ29udGVudENoaWxkKFRlbXBsYXRlUmVmKVxuICAgIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqIEZ1bmN0aW9uIHRoYXQgbWFwcyBhbiBvcHRpb24ncyB2YWx1ZSB0byBpdHMgZGlzcGxheSB2YWx1ZSBpbiB0aGUgdHJpZ2dlci4gKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc3BsYXlXaXRoOiAoKHZhbHVlOiBhbnkpID0+IHN0cmluZykgfCBudWxsID0gbnVsbDtcblxuICAgIC8qKiBNYXhpbXVtIG51bWJlciBvZiByZXN1bHRzIHRvIHNob3cgaW4gdGhlIHNlYXJjaC4gKi9cbiAgICBASW5wdXQoKVxuICAgIG1heFJlc3VsdHM6IG51bWJlciA9IDIwO1xuXG4gICAgLyoqIE51bWJlciBvZiByZXN1bHRzIHRvIHNraXAgZnJvbSB0aGUgcmVzdWx0cyBwYWdpbmF0aW9uLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2tpcFJlc3VsdHM6IG51bWJlciA9IDA7XG5cbiAgICAvKiogQGRlcHJlY2F0ZWQgaW4gMi4xLjAgKi9cbiAgICBASW5wdXQoKVxuICAgIHF1ZXJ5Qm9keTogUXVlcnlCb2R5O1xuXG4gICAgLyoqIFNlYXJjaCB0ZXJtIHRvIHVzZSB3aGVuIGV4ZWN1dGluZyB0aGUgc2VhcmNoLiBVcGRhdGluZyB0aGlzIHZhbHVlIHdpbGxcbiAgICAgKiBydW4gYSBuZXcgc2VhcmNoIGFuZCB1cGRhdGUgdGhlIHJlc3VsdHMuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWFyY2hUZXJtOiBzdHJpbmcgPSAnJztcblxuICAgIC8qKiBDU1MgY2xhc3MgZm9yIGRpc3BsYXkuICovXG4gICAgQElucHV0KCdjbGFzcycpXG4gICAgc2V0IGNsYXNzTGlzdChjbGFzc0xpc3Q6IHN0cmluZykge1xuICAgICAgICBpZiAoY2xhc3NMaXN0ICYmIGNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5zcGxpdCgnICcpLmZvckVhY2goY2xhc3NOYW1lID0+IHRoaXMuX2NsYXNzTGlzdFtjbGFzc05hbWUudHJpbSgpXSA9IHRydWUpO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTmFtZSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBzZWFyY2ggcmVzdWx0cyBoYXZlIGZ1bGx5IGxvYWRlZC4gKi9cbiAgICBAT3V0cHV0KClcbiAgICByZXN1bHRMb2FkZWQ6IEV2ZW50RW1pdHRlcjxOb2RlUGFnaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGVycm9yOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIHNob3dQYW5lbDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHJlc3VsdHM6IE5vZGVQYWdpbmc7XG5cbiAgICBnZXQgaXNPcGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuICYmIHRoaXMuc2hvd1BhbmVsO1xuICAgIH1cblxuICAgIHNldCBpc09wZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5faXNPcGVuID0gdmFsdWU7XG4gICAgfVxuXG4gICAgX2lzT3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAga2V5UHJlc3NlZFN0cmVhbTogU3ViamVjdDxzdHJpbmc+ID0gbmV3IFN1YmplY3QoKTtcblxuICAgIF9jbGFzc0xpc3Q6IHsgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNlYXJjaFNlcnZpY2U6IFNlYXJjaFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLmtleVByZXNzZWRTdHJlYW0uYXNPYnNlcnZhYmxlKClcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIGRlYm91bmNlVGltZSgyMDApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChzZWFyY2hlZFdvcmQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZFNlYXJjaFJlc3VsdHMoc2VhcmNoZWRXb3JkKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHNlYXJjaFNlcnZpY2UuZGF0YUxvYWRlZC5zdWJzY3JpYmUoXG4gICAgICAgICAgICBkYXRhID0+IHRoaXMub25TZWFyY2hEYXRhTG9hZGVkKGRhdGEpLFxuICAgICAgICAgICAgZXJyb3IgPT4gdGhpcy5vblNlYXJjaERhdGFFcnJvcihlcnJvcilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMucXVlcnlCb2R5ICYmXG4gICAgICAgICAgICB0aGlzLmhhc0RpZmZlcmVudFF1ZXJ5Qm9keShjaGFuZ2VzLnF1ZXJ5Qm9keS5wcmV2aW91c1ZhbHVlLCBjaGFuZ2VzLnF1ZXJ5Qm9keS5jdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRTZWFyY2hSZXN1bHRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMuc2VhcmNoVGVybSAmJiBjaGFuZ2VzLnNlYXJjaFRlcm0uY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRTZWFyY2hSZXN1bHRzKGNoYW5nZXMuc2VhcmNoVGVybS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXRSZXN1bHRzKCkge1xuICAgICAgICB0aGlzLmNsZWFuUmVzdWx0cygpO1xuICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoKTtcbiAgICB9XG5cbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHRoaXMubG9hZFNlYXJjaFJlc3VsdHModGhpcy5zZWFyY2hUZXJtKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhc0RpZmZlcmVudFF1ZXJ5Qm9keShwcmV2aW91c1F1ZXJ5Qm9keTogUXVlcnlCb2R5LCBjdXJyZW50UXVlcnlCb2R5OiBRdWVyeUJvZHkpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXZpb3VzUXVlcnlCb2R5KSAhPT0gSlNPTi5zdHJpbmdpZnkoY3VycmVudFF1ZXJ5Qm9keSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjbGVhblJlc3VsdHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cyA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBsb2FkU2VhcmNoUmVzdWx0cyhzZWFyY2hUZXJtPzogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMucmVzZXRSZXN1bHRzKCk7XG4gICAgICAgIGlmIChzZWFyY2hUZXJtKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeUJvZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFNlcnZpY2Uuc2VhcmNoQnlRdWVyeUJvZHkodGhpcy5xdWVyeUJvZHkpLnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0+IHRoaXMub25TZWFyY2hEYXRhTG9hZGVkKHJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIGVyciA9PiB0aGlzLm9uU2VhcmNoRGF0YUVycm9yKGVycilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFNlcnZpY2Uuc2VhcmNoKHNlYXJjaFRlcm0sIHRoaXMubWF4UmVzdWx0cywgdGhpcy5za2lwUmVzdWx0cykuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPT4gdGhpcy5vblNlYXJjaERhdGFMb2FkZWQocmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgZXJyID0+IHRoaXMub25TZWFyY2hEYXRhRXJyb3IoZXJyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFuUmVzdWx0cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25TZWFyY2hEYXRhTG9hZGVkKGRhdGE6IE5vZGVQYWdpbmcpIHtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cyA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdExvYWRlZC5lbWl0KHRoaXMucmVzdWx0cyk7XG4gICAgICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uU2VhcmNoRGF0YUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5zdGF0dXMgIT09IDQwMCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoaWRlUGFuZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydhZGYtc2VhcmNoLXNob3cnXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydhZGYtc2VhcmNoLWhpZGUnXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0VmlzaWJpbGl0eSgpIHtcbiAgICAgICAgdGhpcy5zaG93UGFuZWwgPSAhIXRoaXMucmVzdWx0cyAmJiAhIXRoaXMucmVzdWx0cy5saXN0O1xuICAgICAgICB0aGlzLl9jbGFzc0xpc3RbJ2FkZi1zZWFyY2gtc2hvdyddID0gdGhpcy5zaG93UGFuZWw7XG4gICAgICAgIHRoaXMuX2NsYXNzTGlzdFsnYWRmLXNlYXJjaC1oaWRlJ10gPSAhdGhpcy5zaG93UGFuZWw7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1lbXB0eS1zZWFyY2gtcmVzdWx0JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZW1wdHktc2VhcmNoLXJlc3VsdC5jb21wb25lbnQuaHRtbCcsXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBFbXB0eVNlYXJjaFJlc3VsdENvbXBvbmVudCB7fVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQXV0aGVudGljYXRpb25TZXJ2aWNlLCBUaHVtYm5haWxTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IGFuaW1hdGUsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LFxuICAgICAgICAgUXVlcnlMaXN0LCBWaWV3RW5jYXBzdWxhdGlvbiwgVmlld0NoaWxkLCBWaWV3Q2hpbGRyZW4sIEVsZW1lbnRSZWYsIFRlbXBsYXRlUmVmLCBDb250ZW50Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1pbmltYWxOb2RlRW50aXR5LCBRdWVyeUJvZHkgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU2VhcmNoQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2guY29tcG9uZW50JztcbmltcG9ydCB7IE1hdExpc3RJdGVtIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgRW1wdHlTZWFyY2hSZXN1bHRDb21wb25lbnQgfSBmcm9tICcuL2VtcHR5LXNlYXJjaC1yZXN1bHQuY29tcG9uZW50JztcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1zZWFyY2gtY29udHJvbCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NlYXJjaC1jb250cm9sLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9zZWFyY2gtY29udHJvbC5jb21wb25lbnQuc2NzcyddLFxuICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgdHJpZ2dlcigndHJhbnNpdGlvbk1lc3NhZ2VzJywgW1xuICAgICAgICAgICAgc3RhdGUoJ2FjdGl2ZScsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwJSknLCAnbWFyZ2luLWxlZnQnOiAnMTNweCcgfSkpLFxuICAgICAgICAgICAgc3RhdGUoJ2luYWN0aXZlJywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDgxJSknfSkpLFxuICAgICAgICAgICAgc3RhdGUoJ25vLWFuaW1hdGlvbicsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwJSknLCB3aWR0aDogJzEwMCUnIH0pKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJ2luYWN0aXZlID0+IGFjdGl2ZScsXG4gICAgICAgICAgICAgICAgYW5pbWF0ZSgnMzAwbXMgY3ViaWMtYmV6aWVyKDAuNTUsIDAsIDAuNTUsIDAuMiknKSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCdhY3RpdmUgPT4gaW5hY3RpdmUnLFxuICAgICAgICAgICAgICAgIGFuaW1hdGUoJzMwMG1zIGN1YmljLWJlemllcigwLjU1LCAwLCAwLjU1LCAwLjIpJykpXG4gICAgICAgIF0pXG4gICAgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGhvc3Q6IHsgY2xhc3M6ICdhZGYtc2VhcmNoLWNvbnRyb2wnIH1cbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoQ29udHJvbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIC8qKiBUb2dnbGVzIHdoZXRoZXIgdG8gdXNlIGFuIGV4cGFuZGluZyBzZWFyY2ggY29udHJvbC4gSWYgZmFsc2VcbiAgICAgKiB0aGVuIGEgcmVndWxhciBpbnB1dCBpcyB1c2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXhwYW5kYWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogVG9nZ2xlcyBoaWdobGlnaHRpbmcgb2YgdGhlIHNlYXJjaCB0ZXJtIGluIHRoZSByZXN1bHRzLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlnaGxpZ2h0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogVHlwZSBvZiB0aGUgaW5wdXQgZmllbGQgdG8gcmVuZGVyLCBlLmcuIFwic2VhcmNoXCIgb3IgXCJ0ZXh0XCIgKGRlZmF1bHQpLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW5wdXRUeXBlOiBzdHJpbmcgPSAndGV4dCc7XG5cbiAgICAvKiogVG9nZ2xlcyBhdXRvLWNvbXBsZXRpb24gb2YgdGhlIHNlYXJjaCBpbnB1dCBmaWVsZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIGF1dG9jb21wbGV0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIFRvZ2dsZXMgXCJmaW5kLWFzLXlvdS10eXBlXCIgc3VnZ2VzdGlvbnMgZm9yIHBvc3NpYmxlIG1hdGNoZXMuICovXG4gICAgQElucHV0KClcbiAgICBsaXZlU2VhcmNoRW5hYmxlZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogTWF4aW11bSBudW1iZXIgb2YgcmVzdWx0cyB0byBzaG93IGluIHRoZSBsaXZlIHNlYXJjaC4gKi9cbiAgICBASW5wdXQoKVxuICAgIGxpdmVTZWFyY2hNYXhSZXN1bHRzOiBudW1iZXIgPSA1O1xuXG4gICAgLyoqIEBkZXByZWNhdGVkIGluIDIuMS4wICovXG4gICAgQElucHV0KClcbiAgICBjdXN0b21RdWVyeUJvZHk6IFF1ZXJ5Qm9keTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIHNlYXJjaCBpcyBzdWJtaXR0ZWQgcHJlc3NpbmcgRU5URVIgYnV0dG9uLlxuICAgICAqIFRoZSBzZWFyY2ggdGVybSBpcyBwcm92aWRlZCBhcyB2YWx1ZSBvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgc3VibWl0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIHNlYXJjaCB0ZXJtIGlzIGNoYW5nZWQuIFRoZSBzZWFyY2ggdGVybSBpcyBwcm92aWRlZFxuICAgICAqIGluIHRoZSAndmFsdWUnIHByb3BlcnR5IG9mIHRoZSByZXR1cm5lZCBvYmplY3QuICBJZiB0aGUgdGVybSBpcyBsZXNzXG4gICAgICogdGhhbiB0aHJlZSBjaGFyYWN0ZXJzIGluIGxlbmd0aCB0aGVuIHRoZSB0ZXJtIGlzIHRydW5jYXRlZCB0byBhbiBlbXB0eVxuICAgICAqIHN0cmluZy5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBzZWFyY2hDaGFuZ2U6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhIGZpbGUgaXRlbSBmcm9tIHRoZSBsaXN0IG9mIFwiZmluZC1hcy15b3UtdHlwZVwiIHJlc3VsdHMgaXMgc2VsZWN0ZWQuICovXG4gICAgQE91dHB1dCgpXG4gICAgb3B0aW9uQ2xpY2tlZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBAVmlld0NoaWxkKCdzZWFyY2gnKVxuICAgIHNlYXJjaEF1dG9jb21wbGV0ZTogU2VhcmNoQ29tcG9uZW50O1xuXG4gICAgQFZpZXdDaGlsZCgnc2VhcmNoSW5wdXQnKVxuICAgIHNlYXJjaElucHV0OiBFbGVtZW50UmVmO1xuXG4gICAgQFZpZXdDaGlsZHJlbihNYXRMaXN0SXRlbSlcbiAgICBwcml2YXRlIGxpc3RSZXN1bHRFbGVtZW50OiBRdWVyeUxpc3Q8TWF0TGlzdEl0ZW0+O1xuXG4gICAgQENvbnRlbnRDaGlsZChFbXB0eVNlYXJjaFJlc3VsdENvbXBvbmVudClcbiAgICBlbXB0eVNlYXJjaFRlbXBsYXRlOiBFbXB0eVNlYXJjaFJlc3VsdENvbXBvbmVudDtcblxuICAgIHNlYXJjaFRlcm06IHN0cmluZyA9ICcnO1xuICAgIHN1YnNjcmlwdEFuaW1hdGlvblN0YXRlOiBzdHJpbmc7XG4gICAgbm9TZWFyY2hSZXN1bHRUZW1wbGF0ZTogVGVtcGxhdGVSZWYgPGFueT4gPSBudWxsO1xuXG4gICAgcHJpdmF0ZSB0b2dnbGVTZWFyY2ggPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gICAgcHJpdmF0ZSBmb2N1c1N1YmplY3QgPSBuZXcgU3ViamVjdDxGb2N1c0V2ZW50PigpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGF1dGhTZXJ2aWNlOiBBdXRoZW50aWNhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSB0aHVtYm5haWxTZXJ2aWNlOiBUaHVtYm5haWxTZXJ2aWNlKSB7XG5cbiAgICAgICAgdGhpcy50b2dnbGVTZWFyY2guYXNPYnNlcnZhYmxlKCkucGlwZShkZWJvdW5jZVRpbWUoMjAwKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4cGFuZGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdEFuaW1hdGlvblN0YXRlID0gdGhpcy5zdWJzY3JpcHRBbmltYXRpb25TdGF0ZSA9PT0gJ2luYWN0aXZlJyA/ICdhY3RpdmUnIDogJ2luYWN0aXZlJztcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdEFuaW1hdGlvblN0YXRlID09PSAnaW5hY3RpdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoVGVybSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaEF1dG9jb21wbGV0ZS5yZXNldFJlc3VsdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmlkID09PSB0aGlzLnNlYXJjaElucHV0Lm5hdGl2ZUVsZW1lbnQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQubmF0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFwcGx5U2VhcmNoRm9jdXMoYW5pbWF0aW9uRG9uZUV2ZW50KSB7XG4gICAgICAgIGlmIChhbmltYXRpb25Eb25lRXZlbnQudG9TdGF0ZSA9PT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0QW5pbWF0aW9uU3RhdGUgPSB0aGlzLmV4cGFuZGFibGUgPyAnaW5hY3RpdmUnIDogJ25vLWFuaW1hdGlvbic7XG4gICAgICAgIHRoaXMuc2V0dXBGb2N1c0V2ZW50SGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICBpc05vU2VhcmNoVGVtcGxhdGVQcmVzZW50KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbXB0eVNlYXJjaFRlbXBsYXRlID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5mb2N1c1N1YmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNTdWJqZWN0LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzU3ViamVjdCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50b2dnbGVTZWFyY2gpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlU2VhcmNoLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVNlYXJjaCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0xvZ2dlZEluKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoU2VydmljZS5pc0VjbUxvZ2dlZEluKCk7XG4gICAgfVxuXG4gICAgc2VhcmNoU3VibWl0KGV2ZW50OiBhbnkpIHtcbiAgICAgICAgdGhpcy5zdWJtaXQuZW1pdChldmVudCk7XG4gICAgICAgIHRoaXMudG9nZ2xlU2VhcmNoQmFyKCk7XG4gICAgfVxuXG4gICAgaW5wdXRDaGFuZ2UoZXZlbnQ6IGFueSkge1xuICAgICAgICB0aGlzLnNlYXJjaENoYW5nZS5lbWl0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBnZXRBdXRvQ29tcGxldGUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0b2NvbXBsZXRlID8gJ29uJyA6ICdvZmYnO1xuICAgIH1cblxuICAgIGdldE1pbWVUeXBlSWNvbihub2RlOiBNaW5pbWFsTm9kZUVudGl0eSk6IHN0cmluZyB7XG4gICAgICAgIGxldCBtaW1lVHlwZTtcblxuICAgICAgICBpZiAobm9kZS5lbnRyeS5jb250ZW50ICYmIG5vZGUuZW50cnkuY29udGVudC5taW1lVHlwZSkge1xuICAgICAgICAgICAgbWltZVR5cGUgPSBub2RlLmVudHJ5LmNvbnRlbnQubWltZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZW50cnkuaXNGb2xkZXIpIHtcbiAgICAgICAgICAgIG1pbWVUeXBlID0gJ2ZvbGRlcic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy50aHVtYm5haWxTZXJ2aWNlLmdldE1pbWVUeXBlSWNvbihtaW1lVHlwZSk7XG4gICAgfVxuXG4gICAgaXNTZWFyY2hCYXJBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdEFuaW1hdGlvblN0YXRlID09PSAnYWN0aXZlJyAmJiB0aGlzLmxpdmVTZWFyY2hFbmFibGVkO1xuICAgIH1cblxuICAgIHRvZ2dsZVNlYXJjaEJhcigpIHtcbiAgICAgICAgaWYgKHRoaXMudG9nZ2xlU2VhcmNoKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVNlYXJjaC5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50Q2xpY2tlZChpdGVtOiBhbnkpIHtcbiAgICAgICAgaWYgKGl0ZW0uZW50cnkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uQ2xpY2tlZC5uZXh0KGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy50b2dnbGVTZWFyY2hCYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRm9jdXMoJGV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXNTdWJqZWN0Lm5leHQoJGV2ZW50KTtcbiAgICB9XG5cbiAgICBvbkJsdXIoJGV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXNTdWJqZWN0Lm5leHQoJGV2ZW50KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZVRvb2xiYXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1NlYXJjaEJhckFjdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVNlYXJjaEJhcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0Rmlyc3RSZXN1bHQoKSB7XG4gICAgICAgIGlmICggdGhpcy5saXN0UmVzdWx0RWxlbWVudCAmJiB0aGlzLmxpc3RSZXN1bHRFbGVtZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBmaXJzdEVsZW1lbnQ6IE1hdExpc3RJdGVtID0gPE1hdExpc3RJdGVtPiB0aGlzLmxpc3RSZXN1bHRFbGVtZW50LmZpcnN0O1xuICAgICAgICAgICAgZmlyc3RFbGVtZW50Ll9nZXRIb3N0RWxlbWVudCgpLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblJvd0Fycm93RG93bigkZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgbGV0IG5leHRFbGVtZW50OiBhbnkgPSB0aGlzLmdldE5leHRFbGVtZW50U2libGluZyg8RWxlbWVudD4gJGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGlmIChuZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgbmV4dEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uUm93QXJyb3dVcCgkZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgbGV0IHByZXZpb3VzRWxlbWVudDogYW55ID0gdGhpcy5nZXRQcmV2aW91c0VsZW1lbnRTaWJsaW5nKDxFbGVtZW50PiAkZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKHByZXZpb3VzRWxlbWVudCkge1xuICAgICAgICAgICAgcHJldmlvdXNFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNTdWJqZWN0Lm5leHQobmV3IEZvY3VzRXZlbnQoJ2ZvY3VzJykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXR1cEZvY3VzRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgY29uc3QgZm9jdXNFdmVudHM6IE9ic2VydmFibGU8Rm9jdXNFdmVudD4gPSB0aGlzLmZvY3VzU3ViamVjdFxuICAgICAgICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBkZWJvdW5jZVRpbWUoNTApLFxuICAgICAgICAgICAgICAgIGZpbHRlcigoJGV2ZW50OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTZWFyY2hCYXJBY3RpdmUoKSAmJiAoJGV2ZW50LnR5cGUgPT09ICdibHVyJyB8fCAkZXZlbnQudHlwZSA9PT0gJ2ZvY3Vzb3V0Jyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgZm9jdXNFdmVudHMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlU2VhcmNoQmFyKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0TmV4dEVsZW1lbnRTaWJsaW5nKG5vZGU6IEVsZW1lbnQpOiBFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhub2RlOiBFbGVtZW50KTogRWxlbWVudCB7XG4gICAgICAgIHJldHVybiBub2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuXG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTogbm8taW5wdXQtcmVuYW1lIG5vLXVzZS1iZWZvcmUtZGVjbGFyZSBuby1pbnB1dC1yZW5hbWUgICovXG5cbmltcG9ydCB7IEVOVEVSLCBFU0NBUEUgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBOZ1pvbmUsXG4gICAgT25EZXN0cm95LFxuICAgIE9wdGlvbmFsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgU3Vic2NyaXB0aW9uLCBtZXJnZSwgb2YsIGZyb21FdmVudCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU2VhcmNoQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2guY29tcG9uZW50JztcbmltcG9ydCB7IGZpbHRlciwgc3dpdGNoTWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBjb25zdCBTRUFSQ0hfQVVUT0NPTVBMRVRFX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU2VhcmNoVHJpZ2dlckRpcmVjdGl2ZSksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiBgaW5wdXRbc2VhcmNoQXV0b2NvbXBsZXRlXSwgdGV4dGFyZWFbc2VhcmNoQXV0b2NvbXBsZXRlXWAsXG4gICAgaG9zdDoge1xuICAgICAgICAncm9sZSc6ICdjb21ib2JveCcsXG4gICAgICAgICdbYXR0ci5hdXRvY29tcGxldGVdJzogJ2F1dG9jb21wbGV0ZScsXG4gICAgICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6ICdsaXN0JyxcbiAgICAgICAgJ1thdHRyLmFyaWEtZXhwYW5kZWRdJzogJ3BhbmVsT3Blbi50b1N0cmluZygpJyxcbiAgICAgICAgJyhibHVyKSc6ICdvblRvdWNoZWQoKScsXG4gICAgICAgICcoaW5wdXQpJzogJ2hhbmRsZUlucHV0KCRldmVudCknLFxuICAgICAgICAnKGtleWRvd24pJzogJ2hhbmRsZUtleWRvd24oJGV2ZW50KSdcbiAgICB9LFxuICAgIHByb3ZpZGVyczogW1NFQVJDSF9BVVRPQ09NUExFVEVfVkFMVUVfQUNDRVNTT1JdXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaFRyaWdnZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIG9uRGVzdHJveSQ6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgQElucHV0KCdzZWFyY2hBdXRvY29tcGxldGUnKVxuICAgIHNlYXJjaFBhbmVsOiBTZWFyY2hDb21wb25lbnQ7XG5cbiAgICBASW5wdXQoKVxuICAgIGF1dG9jb21wbGV0ZTogc3RyaW5nID0gJ29mZic7XG5cbiAgICBwcml2YXRlIF9wYW5lbE9wZW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIGNsb3NpbmdBY3Rpb25zU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBlc2NhcGVFdmVudFN0cmVhbSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBvbkNoYW5nZTogKHZhbHVlOiBhbnkpID0+IHZvaWQgPSAoKSA9PiB7IH07XG5cbiAgICBvblRvdWNoZWQgPSAoKSA9PiB7IH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIGRvY3VtZW50OiBhbnkpIHsgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMub25EZXN0cm95JC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLm9uRGVzdHJveSQuY29tcGxldGUoKTtcblxuICAgICAgICBpZiAodGhpcy5lc2NhcGVFdmVudFN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5lc2NhcGVFdmVudFN0cmVhbS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5lc2NhcGVFdmVudFN0cmVhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCB0aGlzLmNsb3NpbmdBY3Rpb25zU3Vic2NyaXB0aW9uICkge1xuICAgICAgICAgICAgdGhpcy5jbG9zaW5nQWN0aW9uc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHBhbmVsT3BlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhbmVsT3BlbiAmJiB0aGlzLnNlYXJjaFBhbmVsLnNob3dQYW5lbDtcbiAgICB9XG5cbiAgICBvcGVuUGFuZWwoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2VhcmNoUGFuZWwuaXNPcGVuID0gdGhpcy5fcGFuZWxPcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbG9zaW5nQWN0aW9uc1N1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaWJlVG9DbG9zaW5nQWN0aW9ucygpO1xuICAgIH1cblxuICAgIGNsb3NlUGFuZWwoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5lbE9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2luZ0FjdGlvbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hQYW5lbC5yZXNldFJlc3VsdHMoKTtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoUGFuZWwuaGlkZVBhbmVsKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBwYW5lbENsb3NpbmdBY3Rpb25zKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICAgIHJldHVybiBtZXJnZShcbiAgICAgICAgICAgIHRoaXMuZXNjYXBlRXZlbnRTdHJlYW0sXG4gICAgICAgICAgICB0aGlzLm91dHNpZGVDbGlja1N0cmVhbVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IG91dHNpZGVDbGlja1N0cmVhbSgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBvZihudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXJnZShcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAnY2xpY2snKSxcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAndG91Y2hlbmQnKVxuICAgICAgICApLnBpcGUoXG4gICAgICAgICAgICBmaWx0ZXIoKGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWNrVGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYW5lbE9wZW4gJiYgY2xpY2tUYXJnZXQgIT09IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oKCkgPT4gdGhpcy5zZXRUcmlnZ2VyVmFsdWUodmFsdWUpKTtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAodmFsdWU6IGFueSkgPT4ge30pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB7fSkge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cblxuICAgIGhhbmRsZUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG5cbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEVTQ0FQRSAmJiB0aGlzLnBhbmVsT3Blbikge1xuICAgICAgICAgICAgdGhpcy5lc2NhcGVFdmVudFN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBFTlRFUikge1xuICAgICAgICAgICAgdGhpcy5lc2NhcGVFdmVudFN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBoYW5kbGVJbnB1dChldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRWYWx1ZTogc3RyaW5nID0gKGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoUGFuZWwua2V5UHJlc3NlZFN0cmVhbS5uZXh0KGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMub3BlblBhbmVsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoUGFuZWwucmVzZXRSZXN1bHRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGlzUGFuZWxPcHRpb25DbGlja2VkKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIGxldCBpc1BhbmVsT3B0aW9uOiBib29sZWFuID0gZmFsc2U7XG4gICAgICAgIGlmICggZXZlbnQgKSB7XG4gICAgICAgICAgICBsZXQgY2xpY2tUYXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBpc1BhbmVsT3B0aW9uID0gIXRoaXMuaXNOb1Jlc3VsdE9wdGlvbihldmVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhIXRoaXMuc2VhcmNoUGFuZWwucGFuZWwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhIXRoaXMuc2VhcmNoUGFuZWwucGFuZWwubmF0aXZlRWxlbWVudC5jb250YWlucyhjbGlja1RhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzUGFuZWxPcHRpb247XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc05vUmVzdWx0T3B0aW9uKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaFBhbmVsLnJlc3VsdHMubGlzdCA/IHRoaXMuc2VhcmNoUGFuZWwucmVzdWx0cy5saXN0LmVudHJpZXMubGVuZ3RoID09PSAwIDogdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN1YnNjcmliZVRvQ2xvc2luZ0FjdGlvbnMoKTogU3Vic2NyaXB0aW9uIHtcbiAgICAgICAgY29uc3QgZmlyc3RTdGFibGUgPSB0aGlzLm5nWm9uZS5vblN0YWJsZS5hc09ic2VydmFibGUoKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uQ2hhbmdlcyA9IHRoaXMuc2VhcmNoUGFuZWwua2V5UHJlc3NlZFN0cmVhbS5hc09ic2VydmFibGUoKTtcblxuICAgICAgICByZXR1cm4gbWVyZ2UoZmlyc3RTdGFibGUsIG9wdGlvbkNoYW5nZXMpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSxcbiAgICAgICAgICAgICAgICBzd2l0Y2hNYXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFBhbmVsLnNldFZpc2liaWxpdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFuZWxDbG9zaW5nQWN0aW9ucztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnN1YnNjcmliZShldmVudCA9PiB0aGlzLnNldFZhbHVlQW5kQ2xvc2UoZXZlbnQpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFRyaWdnZXJWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRvRGlzcGxheSA9IHRoaXMuc2VhcmNoUGFuZWwgJiYgdGhpcy5zZWFyY2hQYW5lbC5kaXNwbGF5V2l0aCA/XG4gICAgICAgICAgICB0aGlzLnNlYXJjaFBhbmVsLmRpc3BsYXlXaXRoKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICBjb25zdCBpbnB1dFZhbHVlID0gdG9EaXNwbGF5ICE9IG51bGwgPyB0b0Rpc3BsYXkgOiAnJztcbiAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQudmFsdWUgPSBpbnB1dFZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0VmFsdWVBbmRDbG9zZShldmVudDogYW55IHwgbnVsbCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pc1BhbmVsT3B0aW9uQ2xpY2tlZChldmVudCkgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VHJpZ2dlclZhbHVlKGV2ZW50LnRhcmdldC50ZXh0Q29udGVudC50cmltKCkpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZShldmVudC50YXJnZXQudGV4dENvbnRlbnQudHJpbSgpKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY29uc3QgREVGQVVMVF9QQUdFX1NJWkUgPSA1O1xuXG5leHBvcnQgY2xhc3MgU2VhcmNoRmlsdGVyTGlzdDxUPiBpbXBsZW1lbnRzIEl0ZXJhYmxlPFQ+IHtcblxuICAgIHByaXZhdGUgZmlsdGVyZWRJdGVtczogVFtdID0gW107XG4gICAgcHJpdmF0ZSBfZmlsdGVyVGV4dDogc3RyaW5nID0gJyc7XG5cbiAgICBpdGVtczogVFtdID0gW107XG4gICAgcGFnZVNpemU6IG51bWJlciA9IERFRkFVTFRfUEFHRV9TSVpFO1xuICAgIGN1cnJlbnRQYWdlU2l6ZTogbnVtYmVyID0gREVGQVVMVF9QQUdFX1NJWkU7XG5cbiAgICBnZXQgZmlsdGVyVGV4dCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyVGV4dDtcbiAgICB9XG5cbiAgICBzZXQgZmlsdGVyVGV4dCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlclRleHQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5hcHBseUZpbHRlcigpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2ZpbHRlcjogKGl0ZW06IFQpID0+IGJvb2xlYW4gPSAoKSA9PiB0cnVlO1xuXG4gICAgZ2V0IGZpbHRlcigpOiAoaXRlbTogVCkgPT4gYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXI7XG4gICAgfVxuXG4gICAgc2V0IGZpbHRlcih2YWx1ZTogKGl0ZW06IFQpID0+IGJvb2xlYW4gKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlciA9IHZhbHVlO1xuICAgICAgICB0aGlzLmFwcGx5RmlsdGVyKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhcHBseUZpbHRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkSXRlbXMgPSB0aGlzLml0ZW1zLmZpbHRlcih0aGlzLmZpbHRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkSXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2VTaXplID0gdGhpcy5wYWdlU2l6ZTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB2aXNpYmxlIHBvcnRpb24gb2YgdGhlIGl0ZW1zLiAgKi9cbiAgICBnZXQgdmlzaWJsZUl0ZW1zKCk6IFRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVkSXRlbXMuc2xpY2UoMCwgdGhpcy5jdXJyZW50UGFnZVNpemUpO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGVudGlyZSBjb2xsZWN0aW9uIGxlbmd0aCBpbmNsdWRpbmcgaXRlbXMgbm90IGRpc3BsYXllZCBvbiB0aGUgcGFnZS4gKi9cbiAgICBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKiogRGV0ZWN0cyB3aGV0aGVyIG1vcmUgaXRlbXMgY2FuIGJlIGRpc3BsYXllZC4gKi9cbiAgICBnZXQgY2FuU2hvd01vcmVJdGVtcygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyZWRJdGVtcy5sZW5ndGggPiB0aGlzLmN1cnJlbnRQYWdlU2l6ZTtcbiAgICB9XG5cbiAgICAvKiogRGV0ZWN0cyB3aGV0aGVyIGxlc3MgaXRlbXMgY2FuIGJlIGRpc3BsYXllZC4gKi9cbiAgICBnZXQgY2FuU2hvd0xlc3NJdGVtcygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBhZ2VTaXplID4gdGhpcy5wYWdlU2l6ZTtcbiAgICB9XG5cbiAgICAvKiogRGV0ZWN0cyB3aGV0aGVyIGNvbnRlbnQgZml0cyBzaW5nbGUgcGFnZS4gKi9cbiAgICBnZXQgZml0c1BhZ2UoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VTaXplID49IHRoaXMuZmlsdGVyZWRJdGVtcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoaXRlbXM6IFRbXSA9IFtdLCBwYWdlU2l6ZT86IG51bWJlcikge1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuZmlsdGVyZWRJdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLnBhZ2VTaXplID0gcGFnZVNpemUgfHwgREVGQVVMVF9QQUdFX1NJWkU7XG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2VTaXplID0gcGFnZVNpemUgfHwgREVGQVVMVF9QQUdFX1NJWkU7XG4gICAgfVxuXG4gICAgLyoqIERpc3BsYXkgbW9yZSBpdGVtcy4gKi9cbiAgICBzaG93TW9yZUl0ZW1zKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5TaG93TW9yZUl0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlU2l6ZSArPSB0aGlzLnBhZ2VTaXplO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIERpc3BsYXkgbGVzcyBpdGVtcy4gKi9cbiAgICBzaG93TGVzc0l0ZW1zKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5TaG93TGVzc0l0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlU2l6ZSAtPSB0aGlzLnBhZ2VTaXplO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFJlc2V0IGVudGlyZSBjb2xsZWN0aW9uIGFuZCBwYWdlIHNldHRpbmdzLiAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlU2l6ZSA9IHRoaXMucGFnZVNpemU7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5maWx0ZXJlZEl0ZW1zID0gW107XG4gICAgICAgIHRoaXMuZmlsdGVyVGV4dCA9ICcnO1xuICAgIH1cblxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhdG9yPFQ+IHtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSAwO1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLnZpc2libGVJdGVtcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dCgpOiBJdGVyYXRvclJlc3VsdDxUPiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50ZXIgPCBpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1zW3BvaW50ZXIrK11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZhY2V0UXVlcnkgfSBmcm9tICcuLi8uLi8uLi9mYWNldC1xdWVyeS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoRmlsdGVyTGlzdCB9IGZyb20gJy4vc2VhcmNoLWZpbHRlci1saXN0Lm1vZGVsJztcblxuZXhwb3J0IGNsYXNzIFJlc3BvbnNlRmFjZXRRdWVyeUxpc3QgZXh0ZW5kcyBTZWFyY2hGaWx0ZXJMaXN0PEZhY2V0UXVlcnk+IHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtczogRmFjZXRRdWVyeVtdID0gW10sIHBhZ2VTaXplOiBudW1iZXIgPSA1KSB7XG4gICAgICAgIHN1cGVyKFxuICAgICAgICAgICAgaXRlbXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5jb3VudCA+IDA7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwYWdlU2l6ZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuZmlsdGVyID0gKHF1ZXJ5OiBGYWNldFF1ZXJ5KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJUZXh0ICYmIHF1ZXJ5LmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9ICh0aGlzLmZpbHRlclRleHQgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBxdWVyeS5sYWJlbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbC5zdGFydHNXaXRoKHBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiwgT25Jbml0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1hdENoZWNrYm94Q2hhbmdlIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgU2VhcmNoU2VydmljZSwgVHJhbnNsYXRpb25TZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IFNlYXJjaFF1ZXJ5QnVpbGRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZWFyY2gtcXVlcnktYnVpbGRlci5zZXJ2aWNlJztcbmltcG9ydCB7IEZhY2V0RmllbGRCdWNrZXQgfSBmcm9tICcuLi8uLi9mYWNldC1maWVsZC1idWNrZXQuaW50ZXJmYWNlJztcbmltcG9ydCB7IFJlc3BvbnNlRmFjZXRRdWVyeUxpc3QgfSBmcm9tICcuL21vZGVscy9yZXNwb25zZS1mYWNldC1xdWVyeS1saXN0Lm1vZGVsJztcbmltcG9ydCB7IEZhY2V0UXVlcnkgfSBmcm9tICcuLi8uLi9mYWNldC1xdWVyeS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRmFjZXRGaWVsZCB9IGZyb20gJy4uLy4uL2ZhY2V0LWZpZWxkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hGaWx0ZXJMaXN0IH0gZnJvbSAnLi9tb2RlbHMvc2VhcmNoLWZpbHRlci1saXN0Lm1vZGVsJztcbmltcG9ydCB7IHRha2VXaGlsZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtc2VhcmNoLWZpbHRlcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NlYXJjaC1maWx0ZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3NlYXJjaC1maWx0ZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGhvc3Q6IHsgY2xhc3M6ICdhZGYtc2VhcmNoLWZpbHRlcicgfVxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hGaWx0ZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBwcml2YXRlIERFRkFVTFRfUEFHRV9TSVpFID0gNTtcblxuICAgIGlzQWxpdmUgPSB0cnVlO1xuICAgIHJlc3BvbnNlRmFjZXRRdWVyaWVzOiBSZXNwb25zZUZhY2V0UXVlcnlMaXN0ID0gbnVsbDtcbiAgICByZXNwb25zZUZhY2V0RmllbGRzOiBGYWNldEZpZWxkW10gPSBudWxsO1xuXG4gICAgcHJpdmF0ZSBmYWNldFF1ZXJpZXNQYWdlU2l6ZSA9IHRoaXMuREVGQVVMVF9QQUdFX1NJWkU7XG4gICAgZmFjZXRRdWVyaWVzTGFiZWw6IHN0cmluZyA9ICdGYWNldCBRdWVyaWVzJztcbiAgICBmYWNldFF1ZXJpZXNFeHBhbmRlZCA9IGZhbHNlO1xuICAgIGZhY2V0RmllbGRzRXhwYW5kZWQgPSBmYWxzZTtcbiAgICBjYW5SZXNldFNlbGVjdGVkUXVlcmllcyA9IGZhbHNlO1xuXG4gICAgc2VsZWN0ZWRGYWNldFF1ZXJpZXM6IEFycmF5PEZhY2V0UXVlcnk+ID0gW107XG4gICAgc2VsZWN0ZWRCdWNrZXRzOiBBcnJheTx7IGZpZWxkOiBGYWNldEZpZWxkLCBidWNrZXQ6IEZhY2V0RmllbGRCdWNrZXQgfT4gPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBxdWVyeUJ1aWxkZXI6IFNlYXJjaFF1ZXJ5QnVpbGRlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBzZWFyY2hTZXJ2aWNlOiBTZWFyY2hTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdHJhbnNsYXRpb25TZXJ2aWNlOiBUcmFuc2xhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgaWYgKHF1ZXJ5QnVpbGRlci5jb25maWcgJiYgcXVlcnlCdWlsZGVyLmNvbmZpZy5mYWNldFF1ZXJpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZmFjZXRRdWVyaWVzTGFiZWwgPSBxdWVyeUJ1aWxkZXIuY29uZmlnLmZhY2V0UXVlcmllcy5sYWJlbCB8fCAnRmFjZXQgUXVlcmllcyc7XG4gICAgICAgICAgICB0aGlzLmZhY2V0UXVlcmllc1BhZ2VTaXplID0gcXVlcnlCdWlsZGVyLmNvbmZpZy5mYWNldFF1ZXJpZXMucGFnZVNpemUgfHwgdGhpcy5ERUZBVUxUX1BBR0VfU0laRTtcbiAgICAgICAgICAgIHRoaXMuZmFjZXRRdWVyaWVzRXhwYW5kZWQgPSBxdWVyeUJ1aWxkZXIuY29uZmlnLmZhY2V0UXVlcmllcy5leHBhbmRlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnlCdWlsZGVyLmNvbmZpZyAmJiBxdWVyeUJ1aWxkZXIuY29uZmlnLmZhY2V0RmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLmZhY2V0RmllbGRzRXhwYW5kZWQgPSBxdWVyeUJ1aWxkZXIuY29uZmlnLmZhY2V0RmllbGRzLmV4cGFuZGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5xdWVyeUJ1aWxkZXIudXBkYXRlZC5waXBlKFxuICAgICAgICAgICAgdGFrZVdoaWxlKCgpID0+IHRoaXMuaXNBbGl2ZSlcbiAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5xdWVyeUJ1aWxkZXIuZXhlY3V0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucXVlcnlCdWlsZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5QnVpbGRlci5leGVjdXRlZC5waXBlKFxuICAgICAgICAgICAgICAgIHRha2VXaGlsZSgoKSA9PiB0aGlzLmlzQWxpdmUpXG4gICAgICAgICAgICApLnN1YnNjcmliZSgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25EYXRhTG9hZGVkKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoU2VydmljZS5kYXRhTG9hZGVkLm5leHQoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmlzQWxpdmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBvblRvZ2dsZUZhY2V0UXVlcnkoZXZlbnQ6IE1hdENoZWNrYm94Q2hhbmdlLCBmYWNldFF1ZXJ5OiBGYWNldFF1ZXJ5KSB7XG4gICAgICAgIGlmIChldmVudCAmJiBmYWNldFF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0RmFjZXRRdWVyeShmYWNldFF1ZXJ5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnNlbGVjdEZhY2V0UXVlcnkoZmFjZXRRdWVyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RGYWNldFF1ZXJ5KHF1ZXJ5OiBGYWNldFF1ZXJ5KSB7XG4gICAgICAgIGlmIChxdWVyeSkge1xuICAgICAgICAgICAgcXVlcnkuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5QnVpbGRlci5hZGRVc2VyRmFjZXRRdWVyeShxdWVyeSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkRmllbGRzKCk7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5QnVpbGRlci51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuc2VsZWN0RmFjZXRRdWVyeShxdWVyeTogRmFjZXRRdWVyeSkge1xuICAgICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgICAgIHF1ZXJ5LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucXVlcnlCdWlsZGVyLnJlbW92ZVVzZXJGYWNldFF1ZXJ5KHF1ZXJ5KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRGaWVsZHMoKTtcbiAgICAgICAgICAgIHRoaXMucXVlcnlCdWlsZGVyLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVTZWxlY3RlZEJ1Y2tldHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlRmFjZXRGaWVsZHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRCdWNrZXRzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBmaWVsZCBvZiB0aGlzLnJlc3BvbnNlRmFjZXRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQuYnVja2V0cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQnVja2V0cy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5xdWVyeUJ1aWxkZXIuZ2V0VXNlckZhY2V0QnVja2V0cyhmaWVsZC5maWVsZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGJ1Y2tldCA9PiBidWNrZXQuY2hlY2tlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGJ1Y2tldCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZpZWxkLCBidWNrZXQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRCdWNrZXRzID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVNlbGVjdGVkRmllbGRzKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNwb25zZUZhY2V0UXVlcmllcykge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEZhY2V0UXVlcmllcyA9IHRoaXMucmVzcG9uc2VGYWNldFF1ZXJpZXMuaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5jaGVja2VkKTtcbiAgICAgICAgICAgIHRoaXMuY2FuUmVzZXRTZWxlY3RlZFF1ZXJpZXMgPSB0aGlzLnNlbGVjdGVkRmFjZXRRdWVyaWVzLmxlbmd0aCA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRmFjZXRRdWVyaWVzID0gW107XG4gICAgICAgICAgICB0aGlzLmNhblJlc2V0U2VsZWN0ZWRRdWVyaWVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblRvZ2dsZUJ1Y2tldChldmVudDogTWF0Q2hlY2tib3hDaGFuZ2UsIGZpZWxkOiBGYWNldEZpZWxkLCBidWNrZXQ6IEZhY2V0RmllbGRCdWNrZXQpIHtcbiAgICAgICAgaWYgKGV2ZW50ICYmIGJ1Y2tldCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEZhY2V0QnVja2V0KGZpZWxkLCBidWNrZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc2VsZWN0RmFjZXRCdWNrZXQoZmllbGQsIGJ1Y2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RGYWNldEJ1Y2tldChmaWVsZDogRmFjZXRGaWVsZCwgYnVja2V0OiBGYWNldEZpZWxkQnVja2V0KSB7XG4gICAgICAgIGlmIChidWNrZXQpIHtcbiAgICAgICAgICAgIGJ1Y2tldC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucXVlcnlCdWlsZGVyLmFkZFVzZXJGYWNldEJ1Y2tldChmaWVsZCwgYnVja2V0KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRCdWNrZXRzKCk7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5QnVpbGRlci51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuc2VsZWN0RmFjZXRCdWNrZXQoZmllbGQ6IEZhY2V0RmllbGQsIGJ1Y2tldDogRmFjZXRGaWVsZEJ1Y2tldCkge1xuICAgICAgICBpZiAoYnVja2V0KSB7XG4gICAgICAgICAgICBidWNrZXQuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5xdWVyeUJ1aWxkZXIucmVtb3ZlVXNlckZhY2V0QnVja2V0KGZpZWxkLCBidWNrZXQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZEJ1Y2tldHMoKTtcbiAgICAgICAgICAgIHRoaXMucXVlcnlCdWlsZGVyLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXRTZWxlY3RlZFF1ZXJpZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhblJlc2V0U2VsZWN0ZWRRdWVyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBxdWVyeSBvZiB0aGlzLnJlc3BvbnNlRmFjZXRRdWVyaWVzLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucXVlcnlCdWlsZGVyLnJlbW92ZVVzZXJGYWNldFF1ZXJ5KHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRGYWNldFF1ZXJpZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2FuUmVzZXRTZWxlY3RlZFF1ZXJpZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucXVlcnlCdWlsZGVyLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FuUmVzZXRTZWxlY3RlZEJ1Y2tldHMoZmllbGQ6IEZhY2V0RmllbGQpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLmJ1Y2tldHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZC5idWNrZXRzLml0ZW1zLnNvbWUoYnVja2V0ID0+IGJ1Y2tldC5jaGVja2VkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzZXRTZWxlY3RlZEJ1Y2tldHMoZmllbGQ6IEZhY2V0RmllbGQpIHtcbiAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLmJ1Y2tldHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGJ1Y2tldCBvZiBmaWVsZC5idWNrZXRzLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgYnVja2V0LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5QnVpbGRlci5yZW1vdmVVc2VyRmFjZXRCdWNrZXQoZmllbGQsIGJ1Y2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkQnVja2V0cygpO1xuICAgICAgICAgICAgdGhpcy5xdWVyeUJ1aWxkZXIudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkRhdGFMb2FkZWQoZGF0YTogYW55KSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBkYXRhLmxpc3QuY29udGV4dDtcblxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUZhY2V0RmllbGRzKGNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZUZhY2V0UXVlcmllcyhjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VGYWNldFF1ZXJpZXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZUZhY2V0RmllbGRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGFyc2VGYWNldEZpZWxkcyhjb250ZXh0OiBhbnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlc3BvbnNlRmFjZXRGaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ0ZhY2V0RmllbGRzID0gdGhpcy5xdWVyeUJ1aWxkZXIuY29uZmlnLmZhY2V0RmllbGRzICYmIHRoaXMucXVlcnlCdWlsZGVyLmNvbmZpZy5mYWNldEZpZWxkcy5maWVsZHMgfHwgW107XG5cbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VGYWNldEZpZWxkcyA9IGNvbmZpZ0ZhY2V0RmllbGRzLm1hcChmaWVsZCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VGaWVsZCA9IChjb250ZXh0LmZhY2V0c0ZpZWxkcyB8fCBbXSkuZmluZChyZXNwb25zZSA9PiByZXNwb25zZS5sYWJlbCA9PT0gZmllbGQubGFiZWwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1Y2tldHM6IEZhY2V0RmllbGRCdWNrZXRbXSA9ICgocmVzcG9uc2VGaWVsZCAmJiByZXNwb25zZUZpZWxkLmJ1Y2tldHMpIHx8IFtdKS5tYXAoYnVja2V0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRCdWNrZXQgPSB0aGlzLnNlbGVjdGVkQnVja2V0cy5maW5kKGZhY2V0QnVja2V0ID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNldEJ1Y2tldC5idWNrZXQubGFiZWwgPT09IGJ1Y2tldC5sYWJlbCAmJiBmYWNldEJ1Y2tldC5maWVsZC5maWVsZCA9PT0gZmllbGQuZmllbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA8RmFjZXRGaWVsZEJ1Y2tldD4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYnVja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogISFzZWxlY3RlZEJ1Y2tldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHRoaXMudHJhbnNsYXRpb25TZXJ2aWNlLmluc3RhbnQoYnVja2V0LmRpc3BsYXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMudHJhbnNsYXRpb25TZXJ2aWNlLmluc3RhbnQoYnVja2V0LmxhYmVsKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1Y2tldExpc3QgPSBuZXcgU2VhcmNoRmlsdGVyTGlzdDxGYWNldEZpZWxkQnVja2V0PihidWNrZXRzLCBmaWVsZC5wYWdlU2l6ZSk7XG4gICAgICAgICAgICAgICAgYnVja2V0TGlzdC5maWx0ZXIgPSAoYnVja2V0OiBGYWNldEZpZWxkQnVja2V0KTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWNrZXQgJiYgYnVja2V0TGlzdC5maWx0ZXJUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gKGJ1Y2tldExpc3QuZmlsdGVyVGV4dCB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gKGJ1Y2tldC5kaXNwbGF5IHx8IGJ1Y2tldC5sYWJlbCB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbC5zdGFydHNXaXRoKHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLnRyYW5zbGF0aW9uU2VydmljZS5pbnN0YW50KGZpZWxkLmxhYmVsKSxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNpemU6IGZpZWxkLnBhZ2VTaXplIHwgdGhpcy5ERUZBVUxUX1BBR0VfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhZ2VTaXplOiBmaWVsZC5wYWdlU2l6ZSB8IHRoaXMuREVGQVVMVF9QQUdFX1NJWkUsXG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldHM6IGJ1Y2tldExpc3RcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZUZhY2V0RmllbGRzID0gdGhpcy5yZXNwb25zZUZhY2V0RmllbGRzXG4gICAgICAgICAgICAgICAgLm1hcChmaWVsZCA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlRmllbGQgPSAoY29udGV4dC5mYWNldHNGaWVsZHMgfHwgW10pLmZpbmQocmVzcG9uc2UgPT4gcmVzcG9uc2UubGFiZWwgPT09IGZpZWxkLmxhYmVsKTtcblxuICAgICAgICAgICAgICAgICAgICAoZmllbGQgJiYgZmllbGQuYnVja2V0cyAmJiBmaWVsZC5idWNrZXRzLml0ZW1zIHx8IFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChidWNrZXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQnVja2V0ID0gKChyZXNwb25zZUZpZWxkICYmIHJlc3BvbnNlRmllbGQuYnVja2V0cykgfHwgW10pLmZpbmQocmVzcEJ1Y2tldCA9PiByZXNwQnVja2V0LmxhYmVsID09PSBidWNrZXQubGFiZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0LmNvdW50ID0gcmVzcG9uc2VCdWNrZXQgPyByZXNwb25zZUJ1Y2tldC5jb3VudCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1Y2tldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGFyc2VGYWNldFF1ZXJpZXMoY29udGV4dDogYW55KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlUXVlcmllcyA9IHRoaXMuZ2V0RmFjZXRRdWVyeU1hcChjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMucXVlcnlCdWlsZGVyLmNvbmZpZy5mYWNldFF1ZXJpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJrcFJlc3BvbnNlRmFjZXRRdWVyaWVzID0gIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucmVzcG9uc2VGYWNldFF1ZXJpZXMpO1xuICAgICAgICAgICAgY29uc3QgZmFjZXRRdWVyaWVzID0gKHRoaXMucXVlcnlCdWlsZGVyLmNvbmZpZy5mYWNldFF1ZXJpZXMucXVlcmllcyB8fCBbXSlcbiAgICAgICAgICAgICAgICAubWFwKHF1ZXJ5ID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBxdWVyeVJlc3VsdCA9IHJlc3BvbnNlUXVlcmllc1txdWVyeS5sYWJlbF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJrcFF1ZXJ5ID0gKGJrcFJlc3BvbnNlRmFjZXRRdWVyaWVzLml0ZW1zIHx8IFtdKS5maW5kKGl0ZW0gPT4gaXRlbS5sYWJlbCA9PT0gcXVlcnkubGFiZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChia3BRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmtwUXVlcnkuY291bnQgPSBxdWVyeVJlc3VsdC5jb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBia3BRdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gPEZhY2V0UXVlcnk+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMudHJhbnNsYXRpb25TZXJ2aWNlLmluc3RhbnQocXVlcnkubGFiZWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IHF1ZXJ5UmVzdWx0LmNvdW50XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChmYWNldFF1ZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3BvbnNlRmFjZXRRdWVyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2VGYWNldFF1ZXJpZXMuaXRlbXMgPSBmYWNldFF1ZXJpZXM7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlRmFjZXRRdWVyaWVzID0gbmV3IFJlc3BvbnNlRmFjZXRRdWVyeUxpc3QoZmFjZXRRdWVyaWVzLCB0aGlzLmZhY2V0UXVlcmllc1BhZ2VTaXplKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZUZhY2V0UXVlcmllcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEZhY2V0UXVlcnlNYXAoY29udGV4dDogYW55KTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIChjb250ZXh0LmZhY2V0UXVlcmllcyB8fCBbXSkuZm9yRWFjaChxdWVyeSA9PiB7XG4gICAgICAgICAgICByZXN1bHRbcXVlcnkubGFiZWxdID0gcXVlcnk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiwgT25Jbml0LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VhcmNoV2lkZ2V0IH0gZnJvbSAnLi4vLi4vc2VhcmNoLXdpZGdldC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoV2lkZ2V0U2V0dGluZ3MgfSBmcm9tICcuLi8uLi9zZWFyY2gtd2lkZ2V0LXNldHRpbmdzLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VhcmNoLXF1ZXJ5LWJ1aWxkZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXNlYXJjaC10ZXh0JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2VhcmNoLXRleHQuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3NlYXJjaC10ZXh0LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7IGNsYXNzOiAnYWRmLXNlYXJjaC10ZXh0JyB9XG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaFRleHRDb21wb25lbnQgaW1wbGVtZW50cyBTZWFyY2hXaWRnZXQsIE9uSW5pdCB7XG5cbiAgICAvKiogVGhlIGNvbnRlbnQgb2YgdGhlIHRleHQgYm94LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWUgPSAnJztcblxuICAgIGlkOiBzdHJpbmc7XG4gICAgc2V0dGluZ3M6IFNlYXJjaFdpZGdldFNldHRpbmdzO1xuICAgIGNvbnRleHQ6IFNlYXJjaFF1ZXJ5QnVpbGRlclNlcnZpY2U7XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dCAmJiB0aGlzLnNldHRpbmdzICYmIHRoaXMuc2V0dGluZ3MucGF0dGVybikge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAodGhpcy5zZXR0aW5ncy5wYXR0ZXJuLCAnZycpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5jb250ZXh0LnF1ZXJ5RnJhZ21lbnRzW3RoaXMuaWRdIHx8ICcnKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KG51bGwpO1xuICAgIH1cblxuICAgIG9uQ2hhbmdlZEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVRdWVyeSh0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVF1ZXJ5KHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dCAmJiB0aGlzLnNldHRpbmdzICYmIHRoaXMuc2V0dGluZ3MuZmllbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5xdWVyeUZyYWdtZW50c1t0aGlzLmlkXSA9IHZhbHVlID8gYCR7dGhpcy5zZXR0aW5ncy5maWVsZH06JyR7dmFsdWV9J2AgOiAnJztcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiwgT25Jbml0LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0UmFkaW9DaGFuZ2UgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5cbmltcG9ydCB7IFNlYXJjaFdpZGdldCB9IGZyb20gJy4uLy4uL3NlYXJjaC13aWRnZXQuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaFdpZGdldFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vc2VhcmNoLXdpZGdldC1zZXR0aW5ncy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoUXVlcnlCdWlsZGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NlYXJjaC1xdWVyeS1idWlsZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2VhcmNoRmlsdGVyTGlzdCB9IGZyb20gJy4uL3NlYXJjaC1maWx0ZXIvbW9kZWxzL3NlYXJjaC1maWx0ZXItbGlzdC5tb2RlbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoUmFkaW9PcHRpb24ge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1zZWFyY2gtcmFkaW8nLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zZWFyY2gtcmFkaW8uY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3NlYXJjaC1yYWRpby5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgaG9zdDogeyBjbGFzczogJ2FkZi1zZWFyY2gtcmFkaW8nIH1cbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoUmFkaW9Db21wb25lbnQgaW1wbGVtZW50cyBTZWFyY2hXaWRnZXQsIE9uSW5pdCB7XG5cbiAgICAvKiogVGhlIHZhbHVlIG9mIHRoZSBzZWxlY3RlZCByYWRpbyBidXR0b24uICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogc3RyaW5nO1xuXG4gICAgaWQ6IHN0cmluZztcbiAgICBzZXR0aW5nczogU2VhcmNoV2lkZ2V0U2V0dGluZ3M7XG4gICAgY29udGV4dDogU2VhcmNoUXVlcnlCdWlsZGVyU2VydmljZTtcbiAgICBvcHRpb25zOiBTZWFyY2hGaWx0ZXJMaXN0PFNlYXJjaFJhZGlvT3B0aW9uPjtcbiAgICBwYWdlU2l6ZSA9IDU7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbmV3IFNlYXJjaEZpbHRlckxpc3Q8U2VhcmNoUmFkaW9PcHRpb24+KCk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2VTaXplID0gdGhpcy5zZXR0aW5ncy5wYWdlU2l6ZSB8fCA1O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5vcHRpb25zICYmIHRoaXMuc2V0dGluZ3Mub3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gbmV3IFNlYXJjaEZpbHRlckxpc3Q8U2VhcmNoUmFkaW9PcHRpb24+KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm9wdGlvbnMsIHRoaXMucGFnZVNpemVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRWYWx1ZShcbiAgICAgICAgICAgIHRoaXMuZ2V0U2VsZWN0ZWRWYWx1ZSgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRTZWxlY3RlZFZhbHVlKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IGFueVtdID0gdGhpcy5zZXR0aW5nc1snb3B0aW9ucyddIHx8IFtdO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZCA9IG9wdGlvbnMuZmluZChvcHQgPT4gb3B0LmRlZmF1bHQpO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gb3B0aW9uc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFZhbHVlKG5ld1ZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmNvbnRleHQucXVlcnlGcmFnbWVudHNbdGhpcy5pZF0gPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGNoYW5nZUhhbmRsZXIoZXZlbnQ6IE1hdFJhZGlvQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUoZXZlbnQudmFsdWUpO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb24sIE9uSW5pdCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNlYXJjaFdpZGdldCB9IGZyb20gJy4uLy4uL3NlYXJjaC13aWRnZXQuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaFdpZGdldFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vc2VhcmNoLXdpZGdldC1zZXR0aW5ncy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoUXVlcnlCdWlsZGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NlYXJjaC1xdWVyeS1idWlsZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWF0U2xpZGVyQ2hhbmdlIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1zZWFyY2gtc2xpZGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2VhcmNoLXNsaWRlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vc2VhcmNoLXNsaWRlci5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgaG9zdDogeyBjbGFzczogJ2FkZi1zZWFyY2gtc2xpZGVyJyB9XG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaFNsaWRlckNvbXBvbmVudCBpbXBsZW1lbnRzIFNlYXJjaFdpZGdldCwgT25Jbml0IHtcblxuICAgIGlkOiBzdHJpbmc7XG4gICAgc2V0dGluZ3M6IFNlYXJjaFdpZGdldFNldHRpbmdzO1xuICAgIGNvbnRleHQ6IFNlYXJjaFF1ZXJ5QnVpbGRlclNlcnZpY2U7XG4gICAgc3RlcDogbnVtYmVyO1xuICAgIG1pbjogbnVtYmVyO1xuICAgIG1heDogbnVtYmVyO1xuICAgIHRodW1iTGFiZWwgPSBmYWxzZTtcblxuICAgIC8qKiBUaGUgbnVtZXJpYyB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc2xpZGVyLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IG51bWJlciB8IG51bGw7XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmhhc093blByb3BlcnR5KCdtaW4nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluID0gdGhpcy5zZXR0aW5nc1snbWluJ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmhhc093blByb3BlcnR5KCdtYXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpcy5zZXR0aW5nc1snbWF4J107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmhhc093blByb3BlcnR5KCdzdGVwJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXAgPSB0aGlzLnNldHRpbmdzWydzdGVwJ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudGh1bWJMYWJlbCA9IHRoaXMuc2V0dGluZ3NbJ3RodW1iTGFiZWwnXSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5taW4gfHwgMDtcbiAgICAgICAgdGhpcy51cGRhdGVRdWVyeShudWxsKTtcbiAgICB9XG5cbiAgICBvbkNoYW5nZWRIYW5kbGVyKGV2ZW50OiBNYXRTbGlkZXJDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGV2ZW50LnZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlUXVlcnkodmFsdWU6IG51bWJlciB8IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaWQgJiYgdGhpcy5jb250ZXh0ICYmIHRoaXMuc2V0dGluZ3MgJiYgdGhpcy5zZXR0aW5ncy5maWVsZCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnF1ZXJ5RnJhZ21lbnRzW3RoaXMuaWRdID0gJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5xdWVyeUZyYWdtZW50c1t0aGlzLmlkXSA9IGAke3RoaXMuc2V0dGluZ3MuZmllbGR9OlswIFRPICR7dmFsdWV9XWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEVycm9yU3RhdGVNYXRjaGVyIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIEZvcm1Hcm91cERpcmVjdGl2ZSwgTmdGb3JtIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5leHBvcnQgY2xhc3MgTGl2ZUVycm9yU3RhdGVNYXRjaGVyIGltcGxlbWVudHMgRXJyb3JTdGF0ZU1hdGNoZXIge1xuXG4gICAgaXNFcnJvclN0YXRlKGNvbnRyb2w6IEZvcm1Db250cm9sIHwgbnVsbCwgZm9ybTogRm9ybUdyb3VwRGlyZWN0aXZlIHwgTmdGb3JtIHwgbnVsbCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBpc1N1Ym1pdHRlZCA9IGZvcm0gJiYgZm9ybS5zdWJtaXR0ZWQ7XG4gICAgICAgIHJldHVybiAhIShjb250cm9sICYmIGNvbnRyb2wuaW52YWxpZCAmJiAoY29udHJvbC5kaXJ0eSB8fCBjb250cm9sLnRvdWNoZWQgfHwgKCFjb250cm9sLnByaXN0aW5lICYmIGlzU3VibWl0dGVkKSkpO1xuICAgIH1cblxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgT25Jbml0LCBDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgVmFsaWRhdG9ycywgRm9ybUdyb3VwIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU2VhcmNoV2lkZ2V0IH0gZnJvbSAnLi4vLi4vc2VhcmNoLXdpZGdldC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoV2lkZ2V0U2V0dGluZ3MgfSBmcm9tICcuLi8uLi9zZWFyY2gtd2lkZ2V0LXNldHRpbmdzLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VhcmNoLXF1ZXJ5LWJ1aWxkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBMaXZlRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICcuLi8uLi9mb3Jtcy9saXZlLWVycm9yLXN0YXRlLW1hdGNoZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1zZWFyY2gtbnVtYmVyLXJhbmdlJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2VhcmNoLW51bWJlci1yYW5nZS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vc2VhcmNoLW51bWJlci1yYW5nZS5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgaG9zdDogeyBjbGFzczogJ2FkZi1zZWFyY2gtbnVtYmVyLXJhbmdlJyB9XG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaE51bWJlclJhbmdlQ29tcG9uZW50IGltcGxlbWVudHMgU2VhcmNoV2lkZ2V0LCBPbkluaXQge1xuXG4gICAgZnJvbTogRm9ybUNvbnRyb2w7XG4gICAgdG86IEZvcm1Db250cm9sO1xuXG4gICAgZm9ybTogRm9ybUdyb3VwO1xuICAgIG1hdGNoZXIgPSBuZXcgTGl2ZUVycm9yU3RhdGVNYXRjaGVyKCk7XG5cbiAgICBpZDogc3RyaW5nO1xuICAgIHNldHRpbmdzPzogU2VhcmNoV2lkZ2V0U2V0dGluZ3M7XG4gICAgY29udGV4dD86IFNlYXJjaFF1ZXJ5QnVpbGRlclNlcnZpY2U7XG5cbiAgICBmaWVsZDogc3RyaW5nO1xuICAgIGZvcm1hdCA9ICdbe0ZST019IFRPIHtUT31dJztcblxuICAgIHZhbGlkYXRvcnM6IFZhbGlkYXRvcnM7XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5maWVsZCA9IHRoaXMuc2V0dGluZ3MuZmllbGQ7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdCA9IHRoaXMuc2V0dGluZ3MuZm9ybWF0IHx8ICdbe0ZST019IFRPIHtUT31dJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmFsaWRhdG9ycyA9IFZhbGlkYXRvcnMuY29tcG9zZShbXG4gICAgICAgICAgICBWYWxpZGF0b3JzLnJlcXVpcmVkLFxuICAgICAgICAgICAgVmFsaWRhdG9ycy5wYXR0ZXJuKC9eLT8oMHxbMS05XVxcZCopPyQvKSxcbiAgICAgICAgICAgIFZhbGlkYXRvcnMubWluKDApXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHRoaXMuZnJvbSA9IG5ldyBGb3JtQ29udHJvbCgnJywgdGhpcy52YWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy50byA9IG5ldyBGb3JtQ29udHJvbCgnJywgdGhpcy52YWxpZGF0b3JzKTtcblxuICAgICAgICB0aGlzLmZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvXG4gICAgICAgIH0sIHRoaXMuZm9ybVZhbGlkYXRvcik7XG4gICAgfVxuXG4gICAgZm9ybVZhbGlkYXRvcihmb3JtR3JvdXA6IEZvcm1Hcm91cCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoZm9ybUdyb3VwLmdldCgnZnJvbScpLnZhbHVlLCAxMCkgPCBwYXJzZUludChmb3JtR3JvdXAuZ2V0KCd0bycpLnZhbHVlLCAxMCkgPyBudWxsIDogeydtaXNtYXRjaCc6IHRydWV9O1xuICAgIH1cblxuICAgIGFwcGx5KG1vZGVsOiB7IGZyb206IHN0cmluZywgdG86IHN0cmluZyB9LCBpc1ZhbGlkOiBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkICYmIHRoaXMuaWQgJiYgdGhpcy5jb250ZXh0ICYmIHRoaXMuZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgICAgICAgICBtYXAuc2V0KCdGUk9NJywgbW9kZWwuZnJvbSk7XG4gICAgICAgICAgICBtYXAuc2V0KCdUTycsIG1vZGVsLnRvKTtcblxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmZvcm1hdFN0cmluZyh0aGlzLmZvcm1hdCwgbWFwKTtcblxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnF1ZXJ5RnJhZ21lbnRzW3RoaXMuaWRdID0gYCR7dGhpcy5maWVsZH06JHt2YWx1ZX1gO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmb3JtYXRTdHJpbmcoc3RyOiBzdHJpbmcsIG1hcDogTWFwPHN0cmluZywgc3RyaW5nPik6IHN0cmluZyB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzdHI7XG5cbiAgICAgICAgbWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSBuZXcgUmVnRXhwKCd7JyArIGtleSArICd9JywgJ2dtJyk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShleHByLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZm9ybS5yZXNldCh7XG4gICAgICAgICAgICBmcm9tOiAnJyxcbiAgICAgICAgICAgIHRvOiAnJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5pZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5xdWVyeUZyYWdtZW50c1t0aGlzLmlkXSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXRDaGVja2JveENoYW5nZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCB7IFNlYXJjaFdpZGdldCB9IGZyb20gJy4uLy4uL3NlYXJjaC13aWRnZXQuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaFdpZGdldFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vc2VhcmNoLXdpZGdldC1zZXR0aW5ncy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoUXVlcnlCdWlsZGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NlYXJjaC1xdWVyeS1idWlsZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2VhcmNoRmlsdGVyTGlzdCB9IGZyb20gJy4uL3NlYXJjaC1maWx0ZXIvbW9kZWxzL3NlYXJjaC1maWx0ZXItbGlzdC5tb2RlbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoTGlzdE9wdGlvbiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgY2hlY2tlZDogYm9vbGVhbjtcbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtc2VhcmNoLWNoZWNrLWxpc3QnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zZWFyY2gtY2hlY2stbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vc2VhcmNoLWNoZWNrLWxpc3QuY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGhvc3Q6IHsgY2xhc3M6ICdhZGYtc2VhcmNoLWNoZWNrLWxpc3QnIH1cbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoQ2hlY2tMaXN0Q29tcG9uZW50IGltcGxlbWVudHMgU2VhcmNoV2lkZ2V0LCBPbkluaXQge1xuXG4gICAgaWQ6IHN0cmluZztcbiAgICBzZXR0aW5ncz86IFNlYXJjaFdpZGdldFNldHRpbmdzO1xuICAgIGNvbnRleHQ/OiBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlO1xuICAgIG9wdGlvbnM6IFNlYXJjaEZpbHRlckxpc3Q8U2VhcmNoTGlzdE9wdGlvbj47XG4gICAgb3BlcmF0b3I6IHN0cmluZyA9ICdPUic7XG4gICAgcGFnZVNpemUgPSA1O1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBTZWFyY2hGaWx0ZXJMaXN0PFNlYXJjaExpc3RPcHRpb24+KCk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gdGhpcy5zZXR0aW5ncy5vcGVyYXRvciB8fCAnT1InO1xuICAgICAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHRoaXMuc2V0dGluZ3MucGFnZVNpemUgfHwgNTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mub3B0aW9ucyAmJiB0aGlzLnNldHRpbmdzLm9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBTZWFyY2hGaWx0ZXJMaXN0KHRoaXMuc2V0dGluZ3Mub3B0aW9ucywgdGhpcy5wYWdlU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLml0ZW1zLmZvckVhY2gob3B0ID0+IHtcbiAgICAgICAgICAgIG9wdC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmlkICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnF1ZXJ5RnJhZ21lbnRzW3RoaXMuaWRdID0gJyc7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGFuZ2VIYW5kbGVyKGV2ZW50OiBNYXRDaGVja2JveENoYW5nZSwgb3B0aW9uOiBhbnkpIHtcbiAgICAgICAgb3B0aW9uLmNoZWNrZWQgPSBldmVudC5jaGVja2VkO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuXG4gICAgZmx1c2goKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRWYWx1ZXMgPSB0aGlzLm9wdGlvbnMuaXRlbXNcbiAgICAgICAgICAgIC5maWx0ZXIob3B0aW9uID0+IG9wdGlvbi5jaGVja2VkKVxuICAgICAgICAgICAgLm1hcChvcHRpb24gPT4gb3B0aW9uLnZhbHVlKTtcblxuICAgICAgICBjb25zdCBxdWVyeSA9IGNoZWNrZWRWYWx1ZXMuam9pbihgICR7dGhpcy5vcGVyYXRvcn0gYCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaWQgJiYgdGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucXVlcnlGcmFnbWVudHNbdGhpcy5pZF0gPSBxdWVyeTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IE9uSW5pdCwgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIFZhbGlkYXRvcnMsIEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IERhdGVBZGFwdGVyLCBNQVRfREFURV9GT1JNQVRTLCBNQVRfREFURV9MT0NBTEUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9jb3JlJztcbmltcG9ydCB7IE1vbWVudERhdGVBZGFwdGVyLCBNT01FTlRfREFURV9GT1JNQVRTIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuaW1wb3J0IHsgU2VhcmNoV2lkZ2V0IH0gZnJvbSAnLi4vLi4vc2VhcmNoLXdpZGdldC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoV2lkZ2V0U2V0dGluZ3MgfSBmcm9tICcuLi8uLi9zZWFyY2gtd2lkZ2V0LXNldHRpbmdzLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VhcmNoLXF1ZXJ5LWJ1aWxkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBMaXZlRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICcuLi8uLi9mb3Jtcy9saXZlLWVycm9yLXN0YXRlLW1hdGNoZXInO1xuaW1wb3J0IHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB7IFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UsIFVzZXJQcmVmZXJlbmNlVmFsdWVzIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuZGVjbGFyZSBsZXQgbW9tZW50OiBhbnk7XG5cbmNvbnN0IERFRkFVTFRfRk9STUFUX0RBVEU6IHN0cmluZyA9ICdERC9NTS9ZWVlZJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtc2VhcmNoLWRhdGUtcmFuZ2UnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zZWFyY2gtZGF0ZS1yYW5nZS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vc2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50LnNjc3MnXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge3Byb3ZpZGU6IERhdGVBZGFwdGVyLCB1c2VDbGFzczogTW9tZW50RGF0ZUFkYXB0ZXIsIGRlcHM6IFtNQVRfREFURV9MT0NBTEVdfSxcbiAgICAgICAge3Byb3ZpZGU6IE1BVF9EQVRFX0ZPUk1BVFMsIHVzZVZhbHVlOiBNT01FTlRfREFURV9GT1JNQVRTfVxuICAgIF0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7IGNsYXNzOiAnYWRmLXNlYXJjaC1kYXRlLXJhbmdlJyB9XG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaERhdGVSYW5nZUNvbXBvbmVudCBpbXBsZW1lbnRzIFNlYXJjaFdpZGdldCwgT25Jbml0IHtcblxuICAgIGZyb206IEZvcm1Db250cm9sO1xuICAgIHRvOiBGb3JtQ29udHJvbDtcblxuICAgIGZvcm06IEZvcm1Hcm91cDtcbiAgICBtYXRjaGVyID0gbmV3IExpdmVFcnJvclN0YXRlTWF0Y2hlcigpO1xuXG4gICAgaWQ6IHN0cmluZztcbiAgICBzZXR0aW5ncz86IFNlYXJjaFdpZGdldFNldHRpbmdzO1xuICAgIGNvbnRleHQ/OiBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlO1xuICAgIG1heERhdGU6IGFueTtcbiAgICBkYXRlUGlja2VyRGF0ZUZvcm1hdCA9IERFRkFVTFRfRk9STUFUX0RBVEU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcjxNb21lbnQ+LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdXNlclByZWZlcmVuY2VzU2VydmljZTogVXNlclByZWZlcmVuY2VzU2VydmljZSkge1xuICAgIH1cblxuICAgIGdldEZyb21WYWxpZGF0aW9uTWVzc2FnZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tLmhhc0Vycm9yKCdpbnZhbGlkT25DaGFuZ2UnKSB8fCB0aGlzLmhhc1BhcnNlRXJyb3IodGhpcy5mcm9tKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uSU5WQUxJRC1EQVRFJyA6XG4gICAgICAgICAgICB0aGlzLmZyb20uaGFzRXJyb3IoJ21hdERhdGVwaWNrZXJNYXgnKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uQkVZT05ELU1BWC1EQVRFJyA6XG4gICAgICAgICAgICB0aGlzLmZyb20uaGFzRXJyb3IoJ3JlcXVpcmVkJykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLlJFUVVJUkVELVZBTFVFJyA6XG4gICAgICAgICAgICAnJztcbiAgICB9XG5cbiAgICBnZXRUb1ZhbGlkYXRpb25NZXNzYWdlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvLmhhc0Vycm9yKCdpbnZhbGlkT25DaGFuZ2UnKSB8fCB0aGlzLmhhc1BhcnNlRXJyb3IodGhpcy50bykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLklOVkFMSUQtREFURScgOlxuICAgICAgICAgICAgdGhpcy50by5oYXNFcnJvcignbWF0RGF0ZXBpY2tlck1pbicpID8gJ1NFQVJDSC5GSUxURVIuVkFMSURBVElPTi5OTy1EQVlTJyA6XG4gICAgICAgICAgICB0aGlzLnRvLmhhc0Vycm9yKCdtYXREYXRlcGlja2VyTWF4JykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLkJFWU9ORC1NQVgtREFURScgOlxuICAgICAgICAgICAgdGhpcy50by5oYXNFcnJvcigncmVxdWlyZWQnKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uUkVRVUlSRUQtVkFMVUUnIDpcbiAgICAgICAgICAgICcnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5kYXRlUGlja2VyRGF0ZUZvcm1hdCA9IHRoaXMuc2V0dGluZ3MuZGF0ZUZvcm1hdCB8fCBERUZBVUxUX0ZPUk1BVF9EQVRFO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRoZUN1c3RvbURhdGVBZGFwdGVyID0gPE1vbWVudERhdGVBZGFwdGVyPiA8YW55PiB0aGlzLmRhdGVBZGFwdGVyO1xuICAgICAgICB0aGVDdXN0b21EYXRlQWRhcHRlci5vdmVycmlkZURpc3BseWFGb3JtYXQgPSB0aGlzLmRhdGVQaWNrZXJEYXRlRm9ybWF0O1xuXG4gICAgICAgIHRoaXMudXNlclByZWZlcmVuY2VzU2VydmljZS5zZWxlY3QoVXNlclByZWZlcmVuY2VWYWx1ZXMuTG9jYWxlKS5zdWJzY3JpYmUoKGxvY2FsZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRMb2NhbGUobG9jYWxlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdmFsaWRhdG9ycyA9IFZhbGlkYXRvcnMuY29tcG9zZShbXG4gICAgICAgICAgICBWYWxpZGF0b3JzLnJlcXVpcmVkXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHRoaXMuZnJvbSA9IG5ldyBGb3JtQ29udHJvbCgnJywgdmFsaWRhdG9ycyk7XG4gICAgICAgIHRoaXMudG8gPSBuZXcgRm9ybUNvbnRyb2woJycsIHZhbGlkYXRvcnMpO1xuXG4gICAgICAgIHRoaXMuZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICAgICAgdG86IHRoaXMudG9cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYXhEYXRlID0gdGhpcy5kYXRlQWRhcHRlci50b2RheSgpLnN0YXJ0T2YoJ2RheScpO1xuICAgIH1cblxuICAgIGFwcGx5KG1vZGVsOiB7IGZyb206IHN0cmluZywgdG86IHN0cmluZyB9LCBpc1ZhbGlkOiBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkICYmIHRoaXMuaWQgJiYgdGhpcy5jb250ZXh0ICYmIHRoaXMuc2V0dGluZ3MgJiYgdGhpcy5zZXR0aW5ncy5maWVsZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBtb21lbnQobW9kZWwuZnJvbSkuc3RhcnRPZignZGF5JykuZm9ybWF0KCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBtb21lbnQobW9kZWwudG8pLmVuZE9mKCdkYXknKS5mb3JtYXQoKTtcblxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnF1ZXJ5RnJhZ21lbnRzW3RoaXMuaWRdID0gYCR7dGhpcy5zZXR0aW5ncy5maWVsZH06Wycke3N0YXJ0fScgVE8gJyR7ZW5kfSddYDtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmZvcm0ucmVzZXQoe1xuICAgICAgICAgICAgZnJvbTogJycsXG4gICAgICAgICAgICB0bzogJydcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmlkICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnF1ZXJ5RnJhZ21lbnRzW3RoaXMuaWRdID0gJyc7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNoYW5nZWRIYW5kbGVyKGV2ZW50OiBhbnksIGZvcm1Db250cm9sOiBGb3JtQ29udHJvbCkge1xuICAgICAgICBjb25zdCBpbnB1dFZhbHVlID0gZXZlbnQuc3JjRWxlbWVudC52YWx1ZTtcblxuICAgICAgICBjb25zdCBmb3JtYXREYXRlID0gdGhpcy5kYXRlQWRhcHRlci5wYXJzZShpbnB1dFZhbHVlLCB0aGlzLmRhdGVQaWNrZXJEYXRlRm9ybWF0KTtcbiAgICAgICAgaWYgKGZvcm1hdERhdGUgJiYgZm9ybWF0RGF0ZS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIGZvcm1Db250cm9sLnNldFZhbHVlKGZvcm1hdERhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdERhdGUpIHtcbiAgICAgICAgICAgIGZvcm1Db250cm9sLnNldEVycm9ycyh7XG4gICAgICAgICAgICAgICAgJ2ludmFsaWRPbkNoYW5nZSc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybUNvbnRyb2wuc2V0RXJyb3JzKHtcbiAgICAgICAgICAgICAgICAncmVxdWlyZWQnOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICAgICAgdGhpcy5kYXRlQWRhcHRlci5zZXRMb2NhbGUobG9jYWxlKTtcbiAgICAgICAgbW9tZW50LmxvY2FsZShsb2NhbGUpO1xuICAgIH1cblxuICAgIGhhc1BhcnNlRXJyb3IoZm9ybUNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1Db250cm9sLmhhc0Vycm9yKCdtYXREYXRlcGlja2VyUGFyc2UnKSAmJiBmb3JtQ29udHJvbC5nZXRFcnJvcignbWF0RGF0ZXBpY2tlclBhcnNlJykudGV4dDtcbiAgICB9XG5cbiAgICBmb3JjZVBsYWNlaG9sZGVyKGV2ZW50OiBhbnkpIHtcbiAgICAgICAgZXZlbnQuc3JjRWxlbWVudC5jbGljaygpO1xuICAgIH1cblxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VhcmNoVGV4dENvbXBvbmVudCB9IGZyb20gJy4uL3NlYXJjaC10ZXh0L3NlYXJjaC10ZXh0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hSYWRpb0NvbXBvbmVudCB9IGZyb20gJy4uL3NlYXJjaC1yYWRpby9zZWFyY2gtcmFkaW8uY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaFNsaWRlckNvbXBvbmVudCB9IGZyb20gJy4uL3NlYXJjaC1zbGlkZXIvc2VhcmNoLXNsaWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoTnVtYmVyUmFuZ2VDb21wb25lbnQgfSBmcm9tICcuLi9zZWFyY2gtbnVtYmVyLXJhbmdlL3NlYXJjaC1udW1iZXItcmFuZ2UuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaENoZWNrTGlzdENvbXBvbmVudCB9IGZyb20gJy4uL3NlYXJjaC1jaGVjay1saXN0L3NlYXJjaC1jaGVjay1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hEYXRlUmFuZ2VDb21wb25lbnQgfSBmcm9tICcuLi9zZWFyY2gtZGF0ZS1yYW5nZS9zZWFyY2gtZGF0ZS1yYW5nZS5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2VhcmNoRmlsdGVyU2VydmljZSB7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWlucyBzdHJpbmctdG8tdHlwZSBtYXBwaW5ncyBmb3IgcmVnaXN0ZXJlZCB3aWRnZXRzLlxuICAgICAqL1xuICAgIHdpZGdldHM6IHsgW2lkOiBzdHJpbmddOiBUeXBlPHt9PiB9ID0ge1xuICAgICAgICAndGV4dCc6IFNlYXJjaFRleHRDb21wb25lbnQsXG4gICAgICAgICdyYWRpbyc6IFNlYXJjaFJhZGlvQ29tcG9uZW50LFxuICAgICAgICAnc2xpZGVyJzogU2VhcmNoU2xpZGVyQ29tcG9uZW50LFxuICAgICAgICAnbnVtYmVyLXJhbmdlJzogU2VhcmNoTnVtYmVyUmFuZ2VDb21wb25lbnQsXG4gICAgICAgICdjaGVjay1saXN0JzogU2VhcmNoQ2hlY2tMaXN0Q29tcG9uZW50LFxuICAgICAgICAnZGF0ZS1yYW5nZSc6IFNlYXJjaERhdGVSYW5nZUNvbXBvbmVudFxuICAgIH07XG5cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb24sIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTZWFyY2hGaWx0ZXJDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3NlYXJjaC1maWx0ZXIvc2VhcmNoLWZpbHRlci5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1zZWFyY2gtY2hpcC1saXN0JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2VhcmNoLWNoaXAtbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7IGNsYXNzOiAnYWRmLXNlYXJjaC1jaGlwLWxpc3QnIH1cbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoQ2hpcExpc3RDb21wb25lbnQge1xuXG4gICAgLyoqIFNlYXJjaCBmaWx0ZXIgdG8gc3VwcGx5IHRoZSBkYXRhIGZvciB0aGUgY2hpcHMuICovXG4gICAgQElucHV0KClcbiAgICBzZWFyY2hGaWx0ZXI6IFNlYXJjaEZpbHRlckNvbXBvbmVudDtcbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VhcmNoUXVlcnlCdWlsZGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NlYXJjaC1xdWVyeS1idWlsZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2VhcmNoU29ydGluZ0RlZmluaXRpb24gfSBmcm9tICcuLi8uLi9zZWFyY2gtc29ydGluZy1kZWZpbml0aW9uLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXNlYXJjaC1zb3J0aW5nLXBpY2tlcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NlYXJjaC1zb3J0aW5nLXBpY2tlci5jb21wb25lbnQuaHRtbCcsXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7IGNsYXNzOiAnYWRmLXNlYXJjaC1zb3J0aW5nLXBpY2tlcicgfVxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hTb3J0aW5nUGlja2VyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIG9wdGlvbnM6IFNlYXJjaFNvcnRpbmdEZWZpbml0aW9uW10gPSBbXTtcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGFzY2VuZGluZzogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcXVlcnlCdWlsZGVyOiBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlKSB7fVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMucXVlcnlCdWlsZGVyLmdldFNvcnRpbmdPcHRpb25zKCk7XG5cbiAgICAgICAgY29uc3QgcHJpbWFyeSA9IHRoaXMucXVlcnlCdWlsZGVyLmdldFByaW1hcnlTb3J0aW5nKCk7XG4gICAgICAgIGlmIChwcmltYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gcHJpbWFyeS5rZXk7XG4gICAgICAgICAgICB0aGlzLmFzY2VuZGluZyA9IHByaW1hcnkuYXNjZW5kaW5nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DaGFuZ2VkKHNvcnRpbmc6IHsga2V5OiBzdHJpbmcsIGFzY2VuZGluZzogYm9vbGVhbiB9KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBzb3J0aW5nLmtleTtcbiAgICAgICAgdGhpcy5hc2NlbmRpbmcgPSBzb3J0aW5nLmFzY2VuZGluZztcbiAgICAgICAgdGhpcy5hcHBseVNvcnRpbmcoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGZpbmRPcHRpb25CeUtleShrZXk6IHN0cmluZyk6IFNlYXJjaFNvcnRpbmdEZWZpbml0aW9uIHtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maW5kKG9wdCA9PiBvcHQua2V5ID09PSBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXBwbHlTb3J0aW5nKCkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSB0aGlzLmZpbmRPcHRpb25CeUtleSh0aGlzLnZhbHVlKTtcbiAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5xdWVyeUJ1aWxkZXIuc29ydGluZyA9IFt7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9uLFxuICAgICAgICAgICAgICAgIGFzY2VuZGluZzogdGhpcy5hc2NlbmRpbmdcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgdGhpcy5xdWVyeUJ1aWxkZXIudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIFZpZXdDaGlsZCwgVmlld0NvbnRhaW5lclJlZiwgT25Jbml0LCBPbkRlc3Ryb3ksIENvbXBvbmVudFJlZiwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VhcmNoLXF1ZXJ5LWJ1aWxkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBTZWFyY2hGaWx0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VhcmNoLWZpbHRlci9zZWFyY2gtZmlsdGVyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1zZWFyY2gtd2lkZ2V0LWNvbnRhaW5lcicsXG4gICAgdGVtcGxhdGU6ICc8ZGl2ICNjb250ZW50PjwvZGl2Pidcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoV2lkZ2V0Q29udGFpbmVyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQFZpZXdDaGlsZCgnY29udGVudCcsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9KVxuICAgIGNvbnRlbnQ6IFZpZXdDb250YWluZXJSZWY7XG5cbiAgICBASW5wdXQoKVxuICAgIGlkOiBzdHJpbmc7XG5cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdG9yOiBzdHJpbmc7XG5cbiAgICBASW5wdXQoKVxuICAgIHNldHRpbmdzOiBhbnk7XG5cbiAgICBASW5wdXQoKVxuICAgIGNvbmZpZzogYW55O1xuXG4gICAgcHJpdmF0ZSBjb21wb25lbnRSZWY6IENvbXBvbmVudFJlZjxhbnk+O1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgc2VhcmNoRmlsdGVyU2VydmljZTogU2VhcmNoRmlsdGVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBxdWVyeUJ1aWxkZXI6IFNlYXJjaFF1ZXJ5QnVpbGRlclNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgY29tcG9uZW50RmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50VHlwZSA9IHRoaXMuc2VhcmNoRmlsdGVyU2VydmljZS53aWRnZXRzW3RoaXMuc2VsZWN0b3JdO1xuICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgaWYgKGZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudFJlZiA9IHRoaXMuY29udGVudC5jcmVhdGVDb21wb25lbnQoZmFjdG9yeSwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cFdpZGdldCh0aGlzLmNvbXBvbmVudFJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldHVwV2lkZ2V0KHJlZjogQ29tcG9uZW50UmVmPGFueT4pIHtcbiAgICAgICAgaWYgKHJlZiAmJiByZWYuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJlZi5pbnN0YW5jZS5pZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgICByZWYuaW5zdGFuY2Uuc2V0dGluZ3MgPSB7IC4uLnRoaXMuc2V0dGluZ3MgfTtcbiAgICAgICAgICAgIHJlZi5pbnN0YW5jZS5jb250ZXh0ID0gdGhpcy5xdWVyeUJ1aWxkZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFJlZi5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBNYXRlcmlhbE1vZHVsZSB9IGZyb20gJy4uL21hdGVyaWFsLm1vZHVsZSc7XG5cbmltcG9ydCB7IENvcmVNb2R1bGUgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5pbXBvcnQgeyBTZWFyY2hUcmlnZ2VyRGlyZWN0aXZlIH0gZnJvbSAnLi9jb21wb25lbnRzL3NlYXJjaC10cmlnZ2VyLmRpcmVjdGl2ZSc7XG5cbmltcG9ydCB7IFNlYXJjaENvbnRyb2xDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2VhcmNoLWNvbnRyb2wuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaENvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zZWFyY2guY29tcG9uZW50JztcbmltcG9ydCB7IEVtcHR5U2VhcmNoUmVzdWx0Q29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2VtcHR5LXNlYXJjaC1yZXN1bHQuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaFdpZGdldENvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zZWFyY2gtd2lkZ2V0LWNvbnRhaW5lci9zZWFyY2gtd2lkZ2V0LWNvbnRhaW5lci5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoRmlsdGVyQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3NlYXJjaC1maWx0ZXIvc2VhcmNoLWZpbHRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoQ2hpcExpc3RDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2VhcmNoLWNoaXAtbGlzdC9zZWFyY2gtY2hpcC1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hUZXh0Q29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3NlYXJjaC10ZXh0L3NlYXJjaC10ZXh0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hSYWRpb0NvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zZWFyY2gtcmFkaW8vc2VhcmNoLXJhZGlvLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hTbGlkZXJDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2VhcmNoLXNsaWRlci9zZWFyY2gtc2xpZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hOdW1iZXJSYW5nZUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zZWFyY2gtbnVtYmVyLXJhbmdlL3NlYXJjaC1udW1iZXItcmFuZ2UuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaENoZWNrTGlzdENvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zZWFyY2gtY2hlY2stbGlzdC9zZWFyY2gtY2hlY2stbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3NlYXJjaC1kYXRlLXJhbmdlL3NlYXJjaC1kYXRlLXJhbmdlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hTb3J0aW5nUGlja2VyQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3NlYXJjaC1zb3J0aW5nLXBpY2tlci9zZWFyY2gtc29ydGluZy1waWNrZXIuY29tcG9uZW50JztcblxuZXhwb3J0IGNvbnN0IEFMRlJFU0NPX1NFQVJDSF9ESVJFQ1RJVkVTOiBhbnlbXSA9IFtcbiAgICBTZWFyY2hDb21wb25lbnQsXG4gICAgU2VhcmNoQ29udHJvbENvbXBvbmVudCxcbiAgICBTZWFyY2hUcmlnZ2VyRGlyZWN0aXZlLFxuICAgIEVtcHR5U2VhcmNoUmVzdWx0Q29tcG9uZW50LFxuICAgIFNlYXJjaEZpbHRlckNvbXBvbmVudCxcbiAgICBTZWFyY2hDaGlwTGlzdENvbXBvbmVudFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIE1hdGVyaWFsTW9kdWxlLFxuICAgICAgICBDb3JlTW9kdWxlLmZvckNoaWxkKClcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAuLi5BTEZSRVNDT19TRUFSQ0hfRElSRUNUSVZFUyxcbiAgICAgICAgU2VhcmNoV2lkZ2V0Q29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICBTZWFyY2hUZXh0Q29tcG9uZW50LFxuICAgICAgICBTZWFyY2hSYWRpb0NvbXBvbmVudCxcbiAgICAgICAgU2VhcmNoU2xpZGVyQ29tcG9uZW50LFxuICAgICAgICBTZWFyY2hOdW1iZXJSYW5nZUNvbXBvbmVudCxcbiAgICAgICAgU2VhcmNoQ2hlY2tMaXN0Q29tcG9uZW50LFxuICAgICAgICBTZWFyY2hEYXRlUmFuZ2VDb21wb25lbnQsXG4gICAgICAgIFNlYXJjaFNvcnRpbmdQaWNrZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgLi4uQUxGUkVTQ09fU0VBUkNIX0RJUkVDVElWRVMsXG4gICAgICAgIFNlYXJjaFdpZGdldENvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgU2VhcmNoVGV4dENvbXBvbmVudCxcbiAgICAgICAgU2VhcmNoUmFkaW9Db21wb25lbnQsXG4gICAgICAgIFNlYXJjaFNsaWRlckNvbXBvbmVudCxcbiAgICAgICAgU2VhcmNoTnVtYmVyUmFuZ2VDb21wb25lbnQsXG4gICAgICAgIFNlYXJjaENoZWNrTGlzdENvbXBvbmVudCxcbiAgICAgICAgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50LFxuICAgICAgICBTZWFyY2hTb3J0aW5nUGlja2VyQ29tcG9uZW50XG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgU2VhcmNoV2lkZ2V0Q29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICBTZWFyY2hUZXh0Q29tcG9uZW50LFxuICAgICAgICBTZWFyY2hSYWRpb0NvbXBvbmVudCxcbiAgICAgICAgU2VhcmNoU2xpZGVyQ29tcG9uZW50LFxuICAgICAgICBTZWFyY2hOdW1iZXJSYW5nZUNvbXBvbmVudCxcbiAgICAgICAgU2VhcmNoQ2hlY2tMaXN0Q29tcG9uZW50LFxuICAgICAgICBTZWFyY2hEYXRlUmFuZ2VDb21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaE1vZHVsZSB7fVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNpdGVzU2VydmljZSwgTG9nU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBTaXRlUGFnaW5nLCBTaXRlRW50cnkgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuXG5leHBvcnQgZW51bSBSZWxhdGlvbnMge1xuICAgIE1lbWJlcnMgPSAnbWVtYmVycycsXG4gICAgQ29udGFpbmVycyA9ICdjb250YWluZXJzJ1xufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1zaXRlcy1kcm9wZG93bicsXG4gICAgc3R5bGVVcmxzOiBbJy4vc2l0ZXMtZHJvcGRvd24uY29tcG9uZW50LnNjc3MnXSxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2l0ZXMtZHJvcGRvd24uY29tcG9uZW50Lmh0bWwnLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgaG9zdDogeyAnY2xhc3MnOiAnYWRmLXNpdGVzLWRyb3Bkb3duJyB9XG59KVxuZXhwb3J0IGNsYXNzIERyb3Bkb3duU2l0ZXNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgLyoqIEhpZGUgdGhlIFwiTXkgRmlsZXNcIiBvcHRpb24uICovXG4gICAgQElucHV0KClcbiAgICBoaWRlTXlGaWxlczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEEgY3VzdG9tIGxpc3Qgb2Ygc2l0ZXMgdG8gYmUgZGlzcGxheWVkIGJ5IHRoZSBkcm9wZG93bi4gSWYgbm8gdmFsdWVcbiAgICAgKiBpcyBnaXZlbiwgdGhlIHNpdGVzIG9mIHRoZSBjdXJyZW50IHVzZXIgYXJlIGRpc3BsYXllZCBieSBkZWZhdWx0LiBBXG4gICAgICogbGlzdCBvZiBvYmplY3RzIG9ubHkgd2l0aCBwcm9wZXJ0aWVzICd0aXRsZScgYW5kICdndWlkJyBpcyBlbm91Z2ggdG9cbiAgICAgKiBiZSBhYmxlIHRvIGRpc3BsYXkgdGhlIGRyb3Bkb3duLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2l0ZUxpc3Q6IFNpdGVQYWdpbmcgPSBudWxsO1xuXG4gICAgLyoqIElkIG9mIHRoZSBzZWxlY3RlZCBzaXRlICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogc3RyaW5nID0gbnVsbDtcblxuICAgIC8qKiBUZXh0IG9yIGEgdHJhbnNsYXRpb24ga2V5IHRvIGFjdCBhcyBhIHBsYWNlaG9sZGVyLiBEZWZhdWx0IHZhbHVlIGlzIHRoZVxuICAgICAqIGtleSBcIkRST1BET1dOLlBMQUNFSE9MREVSX0xBQkVMXCIuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwbGFjZWhvbGRlcjogc3RyaW5nID0gJ0RST1BET1dOLlBMQUNFSE9MREVSX0xBQkVMJztcblxuICAgIC8qKiBGaWx0ZXIgZm9yIHRoZSByZXN1bHRzIG9mIHRoZSBzaXRlcyBxdWVyeS4gUG9zc2libGUgdmFsdWVzIGFyZVxuICAgICAqIFwibWVtYmVyc1wiIGFuZCBcImNvbnRhaW5lcnNcIi4gV2hlbiBcIm1lbWJlcnNcIiBpcyB1c2VkLCB0aGUgc2l0ZSBsaXN0XG4gICAgICogd2lsbCBiZSByZXN0cmljdGVkIHRvIHRoZSBzaXRlcyB0aGF0IHRoZSB1c2VyIGlzIGEgbWVtYmVyIG9mLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcmVsYXRpb25zOiBzdHJpbmc7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBzaXRlLiBXaGVuIHRoZSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZCxcbiAgICAgKiBhbiBlbXB0eSBtb2RlbCBpcyBlbWl0dGVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGNoYW5nZTogRXZlbnRFbWl0dGVyPFNpdGVFbnRyeT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBzZWxlY3RlZDogU2l0ZUVudHJ5ID0gbnVsbDtcblxuICAgIHB1YmxpYyBNWV9GSUxFU19WQUxVRSA9ICctbXktJztcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgc2l0ZXNTZXJ2aWNlOiBTaXRlc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zaXRlTGlzdCkge1xuICAgICAgICAgICAgdGhpcy5zZXREZWZhdWx0U2l0ZUxpc3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdGVkU2l0ZShldmVudDogYW55KSB7XG4gICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoZXZlbnQudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0RGVmYXVsdFNpdGVMaXN0KCkge1xuICAgICAgICBsZXQgZXh0ZW5kZWRPcHRpb25zID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucmVsYXRpb25zKSB7XG4gICAgICAgICAgICBleHRlbmRlZE9wdGlvbnMgPSB7IHJlbGF0aW9uczogW3RoaXMucmVsYXRpb25zXSB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l0ZXNTZXJ2aWNlLmdldFNpdGVzKGV4dGVuZGVkT3B0aW9ucykuc3Vic2NyaWJlKChyZXN1bHQpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5zaXRlTGlzdCA9IHRoaXMucmVsYXRpb25zID09PSBSZWxhdGlvbnMuTWVtYmVycyA/IHRoaXMuZmlsdGVyZWRSZXN1bHRzQnlNZW1iZXIocmVzdWx0KSA6IHJlc3VsdDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmhpZGVNeUZpbGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG15SXRlbSA9IHsgZW50cnk6IHsgaWQ6ICctbXktJywgZ3VpZDogJy1teS0nLCB0aXRsZTogJ0RST1BET1dOLk1ZX0ZJTEVTX09QVElPTicgfSB9O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zaXRlTGlzdC5saXN0LmVudHJpZXMudW5zaGlmdChteUl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSAnLW15LSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zaXRlTGlzdC5saXN0LmVudHJpZXMuZmluZChzaXRlID0+IHNpdGUuZW50cnkuaWQgPT09IHRoaXMudmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nU2VydmljZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZmlsdGVyZWRSZXN1bHRzQnlNZW1iZXIoc2l0ZXM6IFNpdGVQYWdpbmcpOiBTaXRlUGFnaW5nIHtcbiAgICAgICAgY29uc3QgbG9nZ2VkVXNlck5hbWUgPSB0aGlzLnNpdGVzU2VydmljZS5nZXRFY21DdXJyZW50TG9nZ2VkVXNlck5hbWUoKTtcbiAgICAgICAgc2l0ZXMubGlzdC5lbnRyaWVzID0gc2l0ZXMubGlzdC5lbnRyaWVzLmZpbHRlciggKHNpdGUpID0+IHRoaXMuaXNDdXJyZW50VXNlck1lbWJlcihzaXRlLCBsb2dnZWRVc2VyTmFtZSkpO1xuICAgICAgICByZXR1cm4gc2l0ZXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0N1cnJlbnRVc2VyTWVtYmVyKHNpdGUsIGxvZ2dlZFVzZXJOYW1lKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBzaXRlLmVudHJ5LnZpc2liaWxpdHkgPT09ICdQVUJMSUMnIHx8XG4gICAgICAgICAgICAhIXNpdGUucmVsYXRpb25zLm1lbWJlcnMubGlzdC5lbnRyaWVzLmZpbmQoKG1lbWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZW1iZXIuZW50cnkuaWQudG9Mb3dlckNhc2UoKSA9PT0gbG9nZ2VkVXNlck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXRlcmlhbE1vZHVsZSB9IGZyb20gJy4uL21hdGVyaWFsLm1vZHVsZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgRHJvcGRvd25TaXRlc0NvbXBvbmVudCB9IGZyb20gJy4vc2l0ZXMtZHJvcGRvd24uY29tcG9uZW50JztcbmltcG9ydCB7IENvcmVNb2R1bGUgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBNYXRlcmlhbE1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIENvcmVNb2R1bGUuZm9yQ2hpbGQoKVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBEcm9wZG93blNpdGVzQ29tcG9uZW50XG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRHJvcGRvd25TaXRlc0NvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgU2l0ZXNEcm9wZG93bk1vZHVsZSB7fVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE9uSW5pdCwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzLCBWaWV3Q2hpbGQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXRTZWxlY3QgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudHJ5RW50aXR5LCBQYXRoRWxlbWVudEVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBEb2N1bWVudExpc3RDb21wb25lbnQgfSBmcm9tICcuLi9kb2N1bWVudC1saXN0JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtYnJlYWRjcnVtYicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2JyZWFkY3J1bWIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2JyZWFkY3J1bWIuY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ2FkZi1icmVhZGNydW1iJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgQnJlYWRjcnVtYkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcblxuICAgIC8qKiBBY3RpdmUgbm9kZSwgYnVpbGRzIFVJIGJhc2VkIG9uIGZvbGRlck5vZGUucGF0aC5lbGVtZW50cyBjb2xsZWN0aW9uLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZm9sZGVyTm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSA9IG51bGw7XG5cbiAgICAvKiogKG9wdGlvbmFsKSBOYW1lIG9mIHRoZSByb290IGVsZW1lbnQgb2YgdGhlIGJyZWFkY3J1bWIuIFlvdSBjYW4gdXNlXG4gICAgICogdGhpcyBwcm9wZXJ0eSB0byByZW5hbWUgXCJDb21wYW55IEhvbWVcIiB0byBcIlBlcnNvbmFsIEZpbGVzXCIgZm9yXG4gICAgICogZXhhbXBsZS4gWW91IGNhbiB1c2UgYW4gaTE4biByZXNvdXJjZSBrZXkgZm9yIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJvb3Q6IHN0cmluZyA9IG51bGw7XG5cbiAgICAvKiogKG9wdGlvbmFsKSBUaGUgaWQgb2YgdGhlIHJvb3QgZWxlbWVudC4gWW91IGNhbiB1c2UgdGhpcyBwcm9wZXJ0eVxuICAgICAqIHRvIHNldCBhIGN1c3RvbSBlbGVtZW50IHRoZSBicmVhZGNydW1iIHNob3VsZCBzdGFydCB3aXRoLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcm9vdElkOiBzdHJpbmcgPSBudWxsO1xuXG4gICAgLyoqIChvcHRpb25hbCkgRG9jdW1lbnQgTGlzdCBjb21wb25lbnQgdG8gb3BlcmF0ZSB3aXRoLiBUaGUgbGlzdCB3aWxsXG4gICAgICogdXBkYXRlIHdoZW4gdGhlIGJyZWFkY3J1bWIgaXMgY2xpY2tlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRhcmdldDogRG9jdW1lbnRMaXN0Q29tcG9uZW50O1xuXG4gICAgLyoqIFRyYW5zZm9ybWF0aW9uIHRvIGJlIHBlcmZvcm1lZCBvbiB0aGUgY2hvc2VuL2ZvbGRlciBub2RlIGJlZm9yZSBidWlsZGluZ1xuICAgICAqIHRoZSBicmVhZGNydW1iIFVJLiBDYW4gYmUgdXNlZnVsIHdoZW4gY3VzdG9tIGZvcm1hdHRpbmcgaXMgbmVlZGVkIGZvciB0aGVcbiAgICAgKiBicmVhZGNydW1iLiBZb3UgY2FuIGNoYW5nZSB0aGUgcGF0aCBlbGVtZW50cyBmcm9tIHRoZSBub2RlIHRoYXQgYXJlIHVzZWQgdG9cbiAgICAgKiBidWlsZCB0aGUgYnJlYWRjcnVtYiB1c2luZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHJhbnNmb3JtOiAobm9kZSkgPT4gYW55O1xuXG4gICAgQFZpZXdDaGlsZCgnZHJvcGRvd24nKVxuICAgIGRyb3Bkb3duOiBNYXRTZWxlY3Q7XG5cbiAgICAvKiogTWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgdG8gZGlzcGxheSBiZWZvcmUgd3JhcHBpbmcgdGhlbSB3aXRoIGEgZHJvcGRvd24gZWxlbWVudC4gICovXG4gICAgQElucHV0KClcbiAgICBtYXhJdGVtczogbnVtYmVyO1xuXG4gICAgcHJldmlvdXNOb2RlczogUGF0aEVsZW1lbnRFbnRpdHlbXTtcbiAgICBsYXN0Tm9kZXM6IFBhdGhFbGVtZW50RW50aXR5W107XG5cbiAgICByb3V0ZTogUGF0aEVsZW1lbnRFbnRpdHlbXSA9IFtdO1xuXG4gICAgZ2V0IGhhc1Jvb3QoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucm9vdDtcbiAgICB9XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhIGJyZWFkY3J1bWIuICovXG4gICAgQE91dHB1dCgpXG4gICAgbmF2aWdhdGUgPSBuZXcgRXZlbnRFbWl0dGVyPFBhdGhFbGVtZW50RW50aXR5PigpO1xuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0gPyB0aGlzLnRyYW5zZm9ybSA6IG51bGw7XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICBpZiAoY2hhbmdlcy5mb2xkZXJOb2RlKSB7XG4gICAgICAgICAgICBsZXQgbm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSA9IG51bGw7XG4gICAgICAgICAgICBub2RlID0gdGhpcy50cmFuc2Zvcm0gPyB0aGlzLnRyYW5zZm9ybShjaGFuZ2VzLmZvbGRlck5vZGUuY3VycmVudFZhbHVlKSA6IGNoYW5nZXMuZm9sZGVyTm9kZS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJvdXRlID0gdGhpcy5wYXJzZVJvdXRlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMudHJhbnNmb3JtID8gdGhpcy50cmFuc2Zvcm0odGhpcy5mb2xkZXJOb2RlKSA6IHRoaXMuZm9sZGVyTm9kZTtcbiAgICAgICAgICAgIHRoaXMucm91dGUgPSB0aGlzLnBhcnNlUm91dGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZU5vZGVzKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHJlY2FsY3VsYXRlTm9kZXMoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm1heEl0ZW1zICYmIHRoaXMucm91dGUubGVuZ3RoID4gdGhpcy5tYXhJdGVtcykge1xuICAgICAgICAgICAgdGhpcy5sYXN0Tm9kZXMgPSB0aGlzLnJvdXRlLnNsaWNlKHRoaXMucm91dGUubGVuZ3RoIC0gdGhpcy5tYXhJdGVtcyk7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzTm9kZXMgPSB0aGlzLnJvdXRlLnNsaWNlKDAsIHRoaXMucm91dGUubGVuZ3RoIC0gdGhpcy5tYXhJdGVtcyk7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzTm9kZXMucmV2ZXJzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXN0Tm9kZXMgPSB0aGlzLnJvdXRlO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c05vZGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW4oKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRyb3Bkb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhc1ByZXZpb3VzTm9kZXMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzTm9kZXMgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuXG4gICAgcGFyc2VSb3V0ZShub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KTogUGF0aEVsZW1lbnRFbnRpdHlbXSB7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUucGF0aCkge1xuICAgICAgICAgICAgY29uc3Qgcm91dGUgPSA8UGF0aEVsZW1lbnRFbnRpdHlbXT4gKG5vZGUucGF0aC5lbGVtZW50cyB8fCBbXSkuc2xpY2UoKTtcblxuICAgICAgICAgICAgcm91dGUucHVzaCg8UGF0aEVsZW1lbnRFbnRpdHk+IHtcbiAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByb290UG9zID0gdGhpcy5nZXRFbGVtZW50UG9zaXRpb24ocm91dGUsIHRoaXMucm9vdElkKTtcbiAgICAgICAgICAgIGlmIChyb290UG9zID4gMCkge1xuICAgICAgICAgICAgICAgIHJvdXRlLnNwbGljZSgwLCByb290UG9zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJvb3RQb3MgPT09IC0xICYmIHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICAgICAgcm91dGVbMF0uaWQgPSB0aGlzLnJvb3RJZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgICAgIHJvdXRlWzBdLm5hbWUgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByb3V0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEVsZW1lbnRQb3NpdGlvbihyb3V0ZTogUGF0aEVsZW1lbnRFbnRpdHlbXSwgbm9kZUlkOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICBsZXQgcmVzdWx0OiBudW1iZXIgPSAtMTtcblxuICAgICAgICBpZiAocm91dGUgJiYgcm91dGUubGVuZ3RoID4gMCAmJiBub2RlSWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJvdXRlLmZpbmRJbmRleChlbCA9PiBlbC5pZCA9PT0gbm9kZUlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgb25Sb3V0ZVBhdGhDbGljayhyb3V0ZTogUGF0aEVsZW1lbnRFbnRpdHksIGV2ZW50PzogRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlLmVtaXQocm91dGUpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5uYXZpZ2F0ZVRvKHJvdXRlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLCBWaWV3Q2hpbGQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXRTZWxlY3QgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgeyBQYXRoRWxlbWVudEVudGl0eSwgTWluaW1hbE5vZGVFbnRyeUVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBCcmVhZGNydW1iQ29tcG9uZW50IH0gZnJvbSAnLi9icmVhZGNydW1iLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWRyb3Bkb3duLWJyZWFkY3J1bWInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9kcm9wZG93bi1icmVhZGNydW1iLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9kcm9wZG93bi1icmVhZGNydW1iLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7XG4gICAgICAgICdjbGFzcyc6ICdhZGYtZHJvcGRvd24tYnJlYWRjcnVtYidcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIERyb3Bkb3duQnJlYWRjcnVtYkNvbXBvbmVudCBleHRlbmRzIEJyZWFkY3J1bWJDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuXG4gICAgQFZpZXdDaGlsZCgnZHJvcGRvd24nKVxuICAgIGRyb3Bkb3duOiBNYXRTZWxlY3Q7XG5cbiAgICBjdXJyZW50Tm9kZTogUGF0aEVsZW1lbnRFbnRpdHk7XG4gICAgcHJldmlvdXNOb2RlczogUGF0aEVsZW1lbnRFbnRpdHlbXTtcblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZm9sZGVyTm9kZSkge1xuICAgICAgICAgICAgbGV0IG5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkgPSBudWxsO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMudHJhbnNmb3JtID8gdGhpcy50cmFuc2Zvcm0oY2hhbmdlcy5mb2xkZXJOb2RlLmN1cnJlbnRWYWx1ZSkgOiBjaGFuZ2VzLmZvbGRlck5vZGUuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5yb3V0ZSA9IHRoaXMucGFyc2VSb3V0ZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VzLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnRyYW5zZm9ybSA/IHRoaXMudHJhbnNmb3JtKHRoaXMuZm9sZGVyTm9kZSkgOiB0aGlzLmZvbGRlck5vZGU7XG4gICAgICAgICAgICB0aGlzLnJvdXRlID0gdGhpcy5wYXJzZVJvdXRlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjYWxjdWxhdGVOb2RlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY3VycmVudCBhbmQgcHJldmlvdXMgbm9kZXMgZnJvbSB0aGUgcm91dGUgYXJyYXlcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVjYWxjdWxhdGVOb2RlcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMucm91dGVbdGhpcy5yb3V0ZS5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5wcmV2aW91c05vZGVzID0gdGhpcy5yb3V0ZS5zbGljZSgwLCB0aGlzLnJvdXRlLmxlbmd0aCAtIDEpLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgbm9kZSBwaWNrZXIgbWVudVxuICAgICAqL1xuICAgIG9wZW4oKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRyb3Bkb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBpZiByb3V0ZSBoYXMgbW9yZSB0aGFuIG9uZSBlbGVtZW50IChtZWFuczogd2UgYXJlIG5vdCBpbiB0aGUgcm9vdCBkaXJlY3RvcnkpXG4gICAgICovXG4gICAgaGFzUHJldmlvdXNOb2RlcygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNOb2Rlcy5sZW5ndGggPiAwO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0ZXJpYWxNb2R1bGUgfSBmcm9tICcuLi9tYXRlcmlhbC5tb2R1bGUnO1xuXG5pbXBvcnQgeyBCcmVhZGNydW1iQ29tcG9uZW50IH0gZnJvbSAnLi9icmVhZGNydW1iLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEcm9wZG93bkJyZWFkY3J1bWJDb21wb25lbnQgfSBmcm9tICcuL2Ryb3Bkb3duLWJyZWFkY3J1bWIuY29tcG9uZW50JztcbmltcG9ydCB7IENvcmVNb2R1bGUgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBNYXRlcmlhbE1vZHVsZSxcbiAgICAgICAgQ29yZU1vZHVsZS5mb3JDaGlsZCgpXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEJyZWFkY3J1bWJDb21wb25lbnQsXG4gICAgICAgIERyb3Bkb3duQnJlYWRjcnVtYkNvbXBvbmVudFxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEJyZWFkY3J1bWJDb21wb25lbnQsXG4gICAgICAgIERyb3Bkb3duQnJlYWRjcnVtYkNvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQnJlYWRjcnVtYk1vZHVsZSB7fVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBJbmplY3QsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNQVRfRElBTE9HX0RBVEEgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWNvbmZpcm0tZGlhbG9nJyxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8aDEgbWF0LWRpYWxvZy10aXRsZT57eyB0aXRsZSB8IHRyYW5zbGF0ZSB9fTwvaDE+XG4gICAgICAgIDxtYXQtZGlhbG9nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8cD57eyBtZXNzYWdlIHwgdHJhbnNsYXRlIH19PC9wPlxuICAgICAgICA8L21hdC1kaWFsb2ctY29udGVudD5cbiAgICAgICAgPG1hdC1kaWFsb2ctYWN0aW9ucz5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3BhY2VyXCI+PC9zcGFuPlxuICAgICAgICAgICAgPGJ1dHRvbiBpZD1cImFkZi1jb25maXJtLWFjY2VwdFwiIG1hdC1idXR0b24gY29sb3I9XCJwcmltYXJ5XCIgW21hdC1kaWFsb2ctY2xvc2VdPVwidHJ1ZVwiPnt7IHllc0xhYmVsIHwgdHJhbnNsYXRlIH19PC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIGlkPVwiYWRmLWNvbmZpcm0tY2FuY2VsXCIgbWF0LWJ1dHRvbiBbbWF0LWRpYWxvZy1jbG9zZV09XCJmYWxzZVwiIGNka0ZvY3VzSW5pdGlhbD57eyBub0xhYmVsIHwgdHJhbnNsYXRlIH19PC9idXR0b24+XG4gICAgICAgIDwvbWF0LWRpYWxvZy1hY3Rpb25zPlxuICAgIGAsXG4gICAgc3R5bGVzOiBbYFxuICAgICAgICAuc3BhY2VyIHsgZmxleDogMSAxIGF1dG87IH1cblxuICAgICAgICAuYWRmLWNvbmZpcm0tZGlhbG9nIC5tYXQtZGlhbG9nLWFjdGlvbnMgLm1hdC1idXR0b24td3JhcHBlciB7XG4gICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgICAgICB9XG4gICAgYF0sXG4gICAgaG9zdDogeyAnY2xhc3MnOiAnYWRmLWNvbmZpcm0tZGlhbG9nJyB9LFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgQ29uZmlybURpYWxvZ0NvbXBvbmVudCB7XG5cbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICB5ZXNMYWJlbDogc3RyaW5nO1xuICAgIG5vTGFiZWw6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoTUFUX0RJQUxPR19EQVRBKSBkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICB0aGlzLnRpdGxlID0gZGF0YS50aXRsZSB8fCAnQURGX0NPTkZJUk1fRElBTE9HLkNPTkZJUk0nO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBkYXRhLm1lc3NhZ2UgfHwgJ0FERl9DT05GSVJNX0RJQUxPRy5NRVNTQUdFJztcbiAgICAgICAgdGhpcy55ZXNMYWJlbCA9IGRhdGEueWVzTGFiZWwgfHwgJ0FERl9DT05GSVJNX0RJQUxPRy5ZRVNfTEFCRUwnO1xuICAgICAgICB0aGlzLm5vTGFiZWwgPSBkYXRhLm5vTGFiZWwgfHwgJ0FERl9DT05GSVJNX0RJQUxPRy5OT19MQUJFTCc7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlLCBDb250ZW50U2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPbkNoYW5nZXMsIFZpZXdFbmNhcHN1bGF0aW9uLCBFdmVudEVtaXR0ZXIsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVmVyc2lvbnNBcGksIE1pbmltYWxOb2RlRW50cnlFbnRpdHksIFZlcnNpb25FbnRyeSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBNYXREaWFsb2cgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgeyBDb25maXJtRGlhbG9nQ29tcG9uZW50IH0gZnJvbSAnLi4vZGlhbG9ncy9jb25maXJtLmRpYWxvZyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXZlcnNpb24tbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3ZlcnNpb24tbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vdmVyc2lvbi1saXN0LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7XG4gICAgICAgICdjbGFzcyc6ICdhZGYtdmVyc2lvbi1saXN0J1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgVmVyc2lvbkxpc3RDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuXG4gICAgcHJpdmF0ZSB2ZXJzaW9uc0FwaTogVmVyc2lvbnNBcGk7XG4gICAgdmVyc2lvbnM6IFZlcnNpb25FbnRyeVtdID0gW107XG4gICAgaXNMb2FkaW5nID0gdHJ1ZTtcblxuICAgIC8qKiBAZGVwcmVjYXRlZCBpbiAyLjMuMCAqL1xuICAgIEBJbnB1dCgpXG4gICAgaWQ6IHN0cmluZztcblxuICAgIC8qKiBUaGUgdGFyZ2V0IG5vZGUuICovXG4gICAgQElucHV0KClcbiAgICBub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5O1xuXG4gICAgLyoqIFRvZ2dsZXMgc2hvd2luZy9oaWRpbmcgb2YgY29tbWVudHMgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dDb21tZW50cyA9IHRydWU7XG5cbiAgICAvKiogRW5hYmxlL2Rpc2FibGUgZG93bmxvYWRpbmcgYSB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IG5vZGUuICovXG4gICAgQElucHV0KClcbiAgICBhbGxvd0Rvd25sb2FkID0gdHJ1ZTtcblxuICAgIC8qKiBUb2dnbGVzIHNob3dpbmcvaGlkaW5nIG9mIHZlcnNpb24gYWN0aW9ucyAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0FjdGlvbnMgPSB0cnVlO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhIHZlcnNpb24gaXMgcmVzdG9yZWQgKi9cbiAgICBAT3V0cHV0KClcbiAgICByZXN0b3JlZDogRXZlbnRFbWl0dGVyPE1pbmltYWxOb2RlRW50cnlFbnRpdHk+ID0gbmV3IEV2ZW50RW1pdHRlcjxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhIHZlcnNpb24gaXMgZGVsZXRlZCAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGRlbGV0ZWQ6IEV2ZW50RW1pdHRlcjxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiA9IG5ldyBFdmVudEVtaXR0ZXI8TWluaW1hbE5vZGVFbnRyeUVudGl0eT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYWxmcmVzY29BcGk6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNvbnRlbnRTZXJ2aWNlOiBDb250ZW50U2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGRpYWxvZzogTWF0RGlhbG9nKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbnNBcGkgPSB0aGlzLmFsZnJlc2NvQXBpLnZlcnNpb25zQXBpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLmxvYWRWZXJzaW9uSGlzdG9yeSgpO1xuICAgIH1cblxuICAgIGNhblVwZGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFNlcnZpY2UuaGFzUGVybWlzc2lvbih0aGlzLm5vZGUsICd1cGRhdGUnKSAmJiB0aGlzLnZlcnNpb25zLmxlbmd0aCA+IDE7XG4gICAgfVxuXG4gICAgY2FuRGVsZXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50U2VydmljZS5oYXNQZXJtaXNzaW9uKHRoaXMubm9kZSwgJ2RlbGV0ZScpICYmIHRoaXMudmVyc2lvbnMubGVuZ3RoID4gMTtcbiAgICB9XG5cbiAgICByZXN0b3JlKHZlcnNpb25JZCkge1xuICAgICAgICBpZiAodGhpcy5jYW5VcGRhdGUoKSkge1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uc0FwaVxuICAgICAgICAgICAgICAgIC5yZXZlcnRWZXJzaW9uKHRoaXMubm9kZS5pZCwgdmVyc2lvbklkLCB7IG1ham9yVmVyc2lvbjogdHJ1ZSwgY29tbWVudDogJycgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLm9uVmVyc2lvblJlc3RvcmVkKHRoaXMubm9kZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZFZlcnNpb25IaXN0b3J5KCkge1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudmVyc2lvbnNBcGkubGlzdFZlcnNpb25IaXN0b3J5KHRoaXMubm9kZS5pZCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9ucyA9IGRhdGEubGlzdC5lbnRyaWVzO1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZG93bmxvYWRWZXJzaW9uKHZlcnNpb25JZDogc3RyaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93RG93bmxvYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb25Eb3dubG9hZFVybCA9IHRoaXMuZ2V0VmVyc2lvbkNvbnRlbnRVcmwodGhpcy5ub2RlLmlkLCB2ZXJzaW9uSWQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5kb3dubG9hZENvbnRlbnQodmVyc2lvbkRvd25sb2FkVXJsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZVZlcnNpb24odmVyc2lvbklkOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuVXBkYXRlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpYWxvZ1JlZiA9IHRoaXMuZGlhbG9nLm9wZW4oQ29uZmlybURpYWxvZ0NvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdBREZfVkVSU0lPTl9MSVNULkNPTkZJUk1fREVMRVRFLlRJVExFJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0FERl9WRVJTSU9OX0xJU1QuQ09ORklSTV9ERUxFVEUuTUVTU0FHRScsXG4gICAgICAgICAgICAgICAgICAgIHllc0xhYmVsOiAnQURGX1ZFUlNJT05fTElTVC5DT05GSVJNX0RFTEVURS5ZRVNfTEFCRUwnLFxuICAgICAgICAgICAgICAgICAgICBub0xhYmVsOiAnQURGX1ZFUlNJT05fTElTVC5DT05GSVJNX0RFTEVURS5OT19MQUJFTCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiAnMjUwcHgnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGlhbG9nUmVmLmFmdGVyQ2xvc2VkKCkuc3Vic2NyaWJlKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsZnJlc2NvQXBpLnZlcnNpb25zQXBpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVsZXRlVmVyc2lvbih0aGlzLm5vZGUuaWQsIHZlcnNpb25JZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMub25WZXJzaW9uRGVsZXRlZCh0aGlzLm5vZGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uVmVyc2lvbkRlbGV0ZWQobm9kZTogYW55KSB7XG4gICAgICAgIHRoaXMubG9hZFZlcnNpb25IaXN0b3J5KCk7XG4gICAgICAgIHRoaXMuZGVsZXRlZC5lbWl0KG5vZGUpO1xuICAgIH1cblxuICAgIG9uVmVyc2lvblJlc3RvcmVkKG5vZGU6IGFueSkge1xuICAgICAgICB0aGlzLmxvYWRWZXJzaW9uSGlzdG9yeSgpO1xuICAgICAgICB0aGlzLnJlc3RvcmVkLmVtaXQobm9kZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRWZXJzaW9uQ29udGVudFVybChub2RlSWQ6IHN0cmluZywgdmVyc2lvbklkOiBzdHJpbmcsIGF0dGFjaG1lbnQ/OiBib29sZWFuKSB7XG4gICAgICAgIGNvbnN0IG5vZGVEb3dubG9hZFVybCA9IHRoaXMuYWxmcmVzY29BcGkuY29udGVudEFwaS5nZXRDb250ZW50VXJsKG5vZGVJZCwgYXR0YWNobWVudCk7XG4gICAgICAgIHJldHVybiBub2RlRG93bmxvYWRVcmwucmVwbGFjZSgnL2NvbnRlbnQnLCAnL3ZlcnNpb25zLycgKyB2ZXJzaW9uSWQgKyAnL2NvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBkb3dubG9hZENvbnRlbnQodXJsOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICAgICAgICAgICAgbGluay5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgbGluay5ocmVmID0gdXJsO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xuICAgICAgICAgICAgbGluay5jbGljaygpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIFZpZXdFbmNhcHN1bGF0aW9uLCBWaWV3Q2hpbGQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudHJ5RW50aXR5IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IFZlcnNpb25MaXN0Q29tcG9uZW50IH0gZnJvbSAnLi92ZXJzaW9uLWxpc3QuY29tcG9uZW50JztcbmltcG9ydCB7IEFwcENvbmZpZ1NlcnZpY2UsIENvbnRlbnRTZXJ2aWNlLCBBbGZyZXNjb0FwaVNlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgdHJpZ2dlciwgc3RhdGUsIHN0eWxlLCBhbmltYXRlLCB0cmFuc2l0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXZlcnNpb24tbWFuYWdlcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3ZlcnNpb24tbWFuYWdlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vdmVyc2lvbi1tYW5hZ2VyLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgYW5pbWF0aW9uczogW1xuICAgICAgICB0cmlnZ2VyKCd1cGxvYWRUb2dnbGUnLCBbXG4gICAgICAgICAgICBzdGF0ZSgnb3BlbicsIHN0eWxlKHsgaGVpZ2h0OiAnMTc1cHgnLCBvcGFjaXR5OiAxLCB2aXNpYmlsaXR5OiAndmlzaWJsZScgfSkpLFxuICAgICAgICAgICAgc3RhdGUoJ2Nsb3NlJywgc3R5bGUoeyBoZWlnaHQ6ICcwJScsIG9wYWNpdHk6IDAsIHZpc2liaWxpdHk6ICdoaWRkZW4nIH0pKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJ29wZW4gPT4gY2xvc2UnLCBbXG4gICAgICAgICAgICAgICAgc3R5bGUoeyB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9KSxcbiAgICAgICAgICAgICAgICBhbmltYXRlKCcwLjRzIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpJylcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdHJhbnNpdGlvbignY2xvc2UgPT4gb3BlbicsIFtcbiAgICAgICAgICAgICAgICBzdHlsZSh7IHZpc2liaWxpdHk6ICd2aXNpYmxlJyB9KSxcbiAgICAgICAgICAgICAgICBhbmltYXRlKCcwLjRzIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpJylcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIFZlcnNpb25NYW5hZ2VyQ29tcG9uZW50IHtcblxuICAgIC8qKiBUYXJnZXQgbm9kZSB0byBtYW5hZ2UgdmVyc2lvbiBoaXN0b3J5LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eTtcblxuICAgIC8qKiBUb2dnbGVzIHNob3dpbmcvaGlkaW5nIG9mIGNvbW1lbnRzLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0NvbW1lbnRzID0gdHJ1ZTtcblxuICAgIC8qKiBFbmFibGUvZGlzYWJsZSBkb3dubG9hZGluZyBhIHZlcnNpb24gb2YgdGhlIGN1cnJlbnQgbm9kZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIGFsbG93RG93bmxvYWQgPSB0cnVlO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhIGZpbGUgaXMgdXBsb2FkZWQgc3VjY2Vzc2Z1bGx5LiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHVwbG9hZFN1Y2Nlc3M6IEV2ZW50RW1pdHRlcjxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiA9IG5ldyBFdmVudEVtaXR0ZXI8TWluaW1hbE5vZGVFbnRyeUVudGl0eT4oKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGR1cmluZyB1cGxvYWQuICovXG4gICAgQE91dHB1dCgpXG4gICAgdXBsb2FkRXJyb3I6IEV2ZW50RW1pdHRlcjxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiA9IG5ldyBFdmVudEVtaXR0ZXI8TWluaW1hbE5vZGVFbnRyeUVudGl0eT4oKTtcblxuICAgIEBWaWV3Q2hpbGQoJ3ZlcnNpb25MaXN0JylcbiAgICB2ZXJzaW9uTGlzdENvbXBvbmVudDogVmVyc2lvbkxpc3RDb21wb25lbnQ7XG5cbiAgICB1cGxvYWRTdGF0ZTogc3RyaW5nID0gJ2Nsb3NlJztcblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogQXBwQ29uZmlnU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNvbnRlbnRTZXJ2aWNlOiBDb250ZW50U2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGFsZnJlc2NvQXBpU2VydmljZTogQWxmcmVzY29BcGlTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgcmVmcmVzaChub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KSB7XG4gICAgICAgIHRoaXMuYWxmcmVzY29BcGlTZXJ2aWNlLm5vZGVVcGRhdGVkLm5leHQobm9kZSk7XG4gICAgICAgIHRoaXMudmVyc2lvbkxpc3RDb21wb25lbnQubG9hZFZlcnNpb25IaXN0b3J5KCk7XG4gICAgICAgIHRoaXMudXBsb2FkU3VjY2Vzcy5lbWl0KG5vZGUpO1xuICAgICAgICB0aGlzLnVwbG9hZFN0YXRlID0gJ2Nsb3NlJztcbiAgICB9XG5cbiAgICBvblVwbG9hZFN1Y2Nlc3MoZXZlbnQ6IGFueSkge1xuICAgICAgICB0aGlzLmFsZnJlc2NvQXBpU2VydmljZS5ub2RlVXBkYXRlZC5uZXh0KGV2ZW50LnZhbHVlLmVudHJ5KTtcbiAgICAgICAgdGhpcy52ZXJzaW9uTGlzdENvbXBvbmVudC5sb2FkVmVyc2lvbkhpc3RvcnkoKTtcbiAgICAgICAgdGhpcy51cGxvYWRTdWNjZXNzLmVtaXQoZXZlbnQudmFsdWUuZW50cnkpO1xuICAgICAgICB0aGlzLnVwbG9hZFN0YXRlID0gJ2Nsb3NlJztcbiAgICB9XG5cbiAgICBvblVwbG9hZEVycm9yKGV2ZW50OiBhbnkpIHtcbiAgICAgICAgdGhpcy51cGxvYWRFcnJvci5lbWl0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBvblVwbG9hZENhbmNlbCgpIHtcbiAgICAgICAgdGhpcy51cGxvYWRTdGF0ZSA9ICdjbG9zZSc7XG4gICAgfVxuXG4gICAgdG9nZ2xlTmV3VmVyc2lvbigpIHtcbiAgICAgICAgdGhpcy51cGxvYWRTdGF0ZSA9IHRoaXMudXBsb2FkU3RhdGUgPT09ICdvcGVuJyA/ICdjbG9zZScgOiAnb3Blbic7XG4gICAgfVxuXG4gICAgY2FuVXBkYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50U2VydmljZS5oYXNQZXJtaXNzaW9uKHRoaXMubm9kZSwgJ3VwZGF0ZScpO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIFZpZXdFbmNhcHN1bGF0aW9uLCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRyeUVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBDb250ZW50U2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXZlcnNpb24tdXBsb2FkJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdmVyc2lvbi11cGxvYWQuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3ZlcnNpb24tdXBsb2FkLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7ICdjbGFzcyc6ICdhZGYtdmVyc2lvbi11cGxvYWQnIH1cbn0pXG5leHBvcnQgY2xhc3MgVmVyc2lvblVwbG9hZENvbXBvbmVudCB7XG5cbiAgICBzZW1hbnRpY1ZlcnNpb246IHN0cmluZyA9ICdtaW5vcic7XG4gICAgY29tbWVudDogc3RyaW5nO1xuICAgIHVwbG9hZFZlcnNpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpXG4gICAgbm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eTtcblxuICAgIEBPdXRwdXQoKVxuICAgIHN1Y2Nlc3MgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBlcnJvciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIGNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY29udGVudFNlcnZpY2U6IENvbnRlbnRTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgY2FuVXBsb2FkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50U2VydmljZS5oYXNQZXJtaXNzaW9uKHRoaXMubm9kZSwgJ3VwZGF0ZScpO1xuICAgIH1cblxuICAgIGlzTWFqb3JWZXJzaW9uKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW1hbnRpY1ZlcnNpb24gPT09ICdtaW5vcicgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuXG4gICAgY2FuY2VsVXBsb2FkKCkge1xuICAgICAgICB0aGlzLmNhbmNlbC5lbWl0KCk7XG4gICAgfVxuXG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0ZXJpYWxNb2R1bGUgfSBmcm9tICcuLi9tYXRlcmlhbC5tb2R1bGUnO1xuXG5pbXBvcnQgeyBWZXJzaW9uVXBsb2FkQ29tcG9uZW50IH0gZnJvbSAnLi92ZXJzaW9uLXVwbG9hZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVmVyc2lvbk1hbmFnZXJDb21wb25lbnQgfSBmcm9tICcuL3ZlcnNpb24tbWFuYWdlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgVmVyc2lvbkxpc3RDb21wb25lbnQgfSBmcm9tICcuL3ZlcnNpb24tbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVXBsb2FkTW9kdWxlIH0gZnJvbSAnLi4vdXBsb2FkL3VwbG9hZC5tb2R1bGUnO1xuaW1wb3J0IHsgQ29yZU1vZHVsZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIE1hdGVyaWFsTW9kdWxlLFxuICAgICAgICBDb3JlTW9kdWxlLmZvckNoaWxkKCksXG4gICAgICAgIFVwbG9hZE1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgVmVyc2lvblVwbG9hZENvbXBvbmVudCxcbiAgICAgICAgVmVyc2lvbk1hbmFnZXJDb21wb25lbnQsXG4gICAgICAgIFZlcnNpb25MaXN0Q29tcG9uZW50LFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFZlcnNpb25VcGxvYWRDb21wb25lbnQsXG4gICAgICAgIFZlcnNpb25NYW5hZ2VyQ29tcG9uZW50LFxuICAgICAgICBWZXJzaW9uTGlzdENvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgVmVyc2lvbk1hbmFnZXJNb2R1bGUge31cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IElucHV0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBPbkluaXQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRhUm93IH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtbmFtZS1sb2NhdGlvbi1jZWxsJyxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiYWRmLW5hbWUtbG9jYXRpb24tY2VsbC1uYW1lXCI+e3sgbmFtZSB9fTwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYWRmLW5hbWUtbG9jYXRpb24tY2VsbC1sb2NhdGlvblwiIFt0aXRsZV09XCJwYXRoXCI+e3sgcGF0aCB9fTwvZGl2PlxuICAgIGAsXG4gICAgc3R5bGVVcmxzOiBbJy4vbmFtZS1sb2NhdGlvbi1jZWxsLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBob3N0OiB7IGNsYXNzOiAnYWRmLW5hbWUtbG9jYXRpb24tY2VsbCcgfVxufSlcbmV4cG9ydCBjbGFzcyBOYW1lTG9jYXRpb25DZWxsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIG5hbWU6IHN0cmluZyA9ICcnO1xuICAgIHBhdGg6IHN0cmluZyA9ICcnO1xuXG4gICAgQElucHV0KClcbiAgICByb3c6IERhdGFSb3c7XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm93KSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLnJvdy5nZXRWYWx1ZSgnbmFtZScpO1xuXG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHRoaXMucm93LmdldFZhbHVlKCdwYXRoJyk7XG4gICAgICAgICAgICBpZiAoZnVsbFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBmdWxsUGF0aC5uYW1lIHx8ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgU2VhcmNoU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOb2RlUGFnaW5nIH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcblxuLyoqXG4gKiBJbnRlcm5hbCBzZXJ2aWNlIHVzZWQgYnkgQ29udGVudE5vZGVTZWxlY3RvciBjb21wb25lbnQuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb250ZW50Tm9kZVNlbGVjdG9yU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNlYXJjaFNlcnZpY2U6IFNlYXJjaFNlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHNlYXJjaCBmb3IgY29udGVudCBub2RlIHNlbGVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHNlYXJjaFRlcm0gICAgVGhlIHRlcm0gdG8gc2VhcmNoIGZvclxuICAgICAqIEBwYXJhbSByb290Tm9kZUlkICAgIFRoZSByb290IGlzIHRvIHN0YXJ0IHRoZSBzZWFyY2ggZnJvbVxuICAgICAqIEBwYXJhbSBza2lwQ291bnQgICAgIEZyb20gd2hlcmUgdG8gc3RhcnQgdGhlIGxvYWRpbmdcbiAgICAgKiBAcGFyYW0gbWF4SXRlbXMgICAgICBIb3cgbWFueSBpdGVtcyB0byBsb2FkXG4gICAgICogQHBhcmFtIFtleHRyYU5vZGVJZHNdICBMaXN0IG9mIGV4dHJhIG5vZGUgaWRzIHRvIHNlYXJjaCBmcm9tLiBUaGlzIGxhc3QgcGFyYW1ldGVyIGlzIG5lY2Vzc2FyeSB3aGVuXG4gICAgICogdGhlIHJvb3ROb2RlSWQgaXMgb25lIG9mIHRoZSBzdXBwb3J0ZWQgYWxpYXNlcyAoZS5nLiAnLW15LScsICctcm9vdC0nLCAnLW15c2l0ZXMtJywgZXRjLilcbiAgICAgKiBhbmQgc2VhcmNoIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoYXQgYWxpYXMsIGJ1dCBjYW4gYmUgcGVyZm9ybWVkIG9uIGl0cyBjb3JyZXNwb25kaW5nIG5vZGVzLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZWFyY2goc2VhcmNoVGVybTogc3RyaW5nLCByb290Tm9kZUlkOiBzdHJpbmcgPSBudWxsLCBza2lwQ291bnQ6IG51bWJlciA9IDAsIG1heEl0ZW1zOiBudW1iZXIgPSAyNSwgZXh0cmFOb2RlSWRzPzogc3RyaW5nW10pOiBPYnNlcnZhYmxlPE5vZGVQYWdpbmc+IHtcblxuICAgICAgICBsZXQgZXh0cmFQYXJlbnRGaWx0ZXJpbmcgPSAnJztcblxuICAgICAgICBpZiAoZXh0cmFOb2RlSWRzICYmIGV4dHJhTm9kZUlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGV4dHJhTm9kZUlkc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoaWQgPT4gaWQgIT09IHJvb3ROb2RlSWQpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZXh0cmFJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhUGFyZW50RmlsdGVyaW5nICs9IGAgT1IgQU5DRVNUT1I6J3dvcmtzcGFjZTovL1NwYWNlc1N0b3JlLyR7ZXh0cmFJZH0nYDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcmVudEZpbHRlcmluZyA9IHJvb3ROb2RlSWQgPyBbeyBxdWVyeTogYEFOQ0VTVE9SOid3b3Jrc3BhY2U6Ly9TcGFjZXNTdG9yZS8ke3Jvb3ROb2RlSWR9JyR7ZXh0cmFQYXJlbnRGaWx0ZXJpbmd9YCB9XSA6IFtdO1xuXG4gICAgICAgIGxldCBkZWZhdWx0U2VhcmNoTm9kZTogYW55ID0ge1xuICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICBxdWVyeTogYCR7c2VhcmNoVGVybX0qIE9SIG5hbWU6JHtzZWFyY2hUZXJtfSpgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5jbHVkZTogWydwYXRoJywgJ2FsbG93YWJsZU9wZXJhdGlvbnMnXSxcbiAgICAgICAgICAgIHBhZ2luZzoge1xuICAgICAgICAgICAgICAgIG1heEl0ZW1zOiBtYXhJdGVtcyxcbiAgICAgICAgICAgICAgICBza2lwQ291bnQ6IHNraXBDb3VudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbHRlclF1ZXJpZXM6IFtcbiAgICAgICAgICAgICAgICB7IHF1ZXJ5OiBcIlRZUEU6J2NtOmZvbGRlcidcIiB9LFxuICAgICAgICAgICAgICAgIHsgcXVlcnk6ICdOT1QgY206Y3JlYXRvcjpTeXN0ZW0nIH0sXG4gICAgICAgICAgICAgICAgLi4ucGFyZW50RmlsdGVyaW5nXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbnM6IFsnbm9kZXMnXVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaFNlcnZpY2Uuc2VhcmNoQnlRdWVyeUJvZHkoZGVmYXVsdFNlYXJjaE5vZGUpO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQsIFZpZXdDaGlsZCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgQWxmcmVzY29BcGlTZXJ2aWNlLCBIaWdobGlnaHREaXJlY3RpdmUsIFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UsXG4gICAgUGFnaW5hdGVkQ29tcG9uZW50LCBQYWdpbmF0aW9uTW9kZWxcbn0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRyeUVudGl0eSwgTm9kZVBhZ2luZywgUGFnaW5hdGlvbiwgU2l0ZUVudHJ5LCBTaXRlUGFnaW5nIH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IERvY3VtZW50TGlzdENvbXBvbmVudCwgUGFnaW5hdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi4vZG9jdW1lbnQtbGlzdC9jb21wb25lbnRzL2RvY3VtZW50LWxpc3QuY29tcG9uZW50JztcbmltcG9ydCB7IFJvd0ZpbHRlciB9IGZyb20gJy4uL2RvY3VtZW50LWxpc3QvZGF0YS9yb3ctZmlsdGVyLm1vZGVsJztcbmltcG9ydCB7IEltYWdlUmVzb2x2ZXIgfSBmcm9tICcuLi9kb2N1bWVudC1saXN0L2RhdGEvaW1hZ2UtcmVzb2x2ZXIubW9kZWwnO1xuaW1wb3J0IHsgQ29udGVudE5vZGVTZWxlY3RvclNlcnZpY2UgfSBmcm9tICcuL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci5zZXJ2aWNlJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQ3VzdG9tUmVzb3VyY2VzU2VydmljZSB9IGZyb20gJy4uL2RvY3VtZW50LWxpc3Qvc2VydmljZXMvY3VzdG9tLXJlc291cmNlcy5zZXJ2aWNlJztcblxuZXhwb3J0IHR5cGUgVmFsaWRhdGlvbkZ1bmN0aW9uID0gKGVudHJ5OiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KSA9PiBib29sZWFuO1xuXG5jb25zdCBkZWZhdWx0VmFsaWRhdGlvbiA9ICgpID0+IHRydWU7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWNvbnRlbnQtbm9kZS1zZWxlY3Rvci1wYW5lbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vY29udGVudC1ub2RlLXNlbGVjdG9yLXBhbmVsLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci1wYW5lbC5jb21wb25lbnQuaHRtbCcsXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7ICdjbGFzcyc6ICdhZGYtY29udGVudC1ub2RlLXNlbGVjdG9yLXBhbmVsJyB9XG59KVxuZXhwb3J0IGNsYXNzIENvbnRlbnROb2RlU2VsZWN0b3JQYW5lbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgUGFnaW5hdGVkQ29tcG9uZW50IHtcblxuICAgIC8qKiBOb2RlIElEIG9mIHRoZSBmb2xkZXIgY3VycmVudGx5IGxpc3RlZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIGN1cnJlbnRGb2xkZXJJZDogc3RyaW5nID0gbnVsbDtcblxuICAgIC8qKiBIaWRlIHRoZSBcIk15IEZpbGVzXCIgb3B0aW9uIGFkZGVkIHRvIHRoZSBzaXRlIGxpc3QgYnkgZGVmYXVsdC5cbiAgICAgKiBTZWUgdGhlIFtTaXRlcyBEcm9wZG93biBjb21wb25lbnRdKHNpdGVzLWRyb3Bkb3duLmNvbXBvbmVudC5tZClcbiAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRyb3Bkb3duSGlkZU15RmlsZXM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBDdXN0b20gc2l0ZSBmb3Igc2l0ZSBkcm9wZG93biBzYW1lIGFzIHNpdGVMaXN0LiBTZWUgdGhlXG4gICAgICogW1NpdGVzIERyb3Bkb3duIGNvbXBvbmVudF0oc2l0ZXMtZHJvcGRvd24uY29tcG9uZW50Lm1kKVxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZHJvcGRvd25TaXRlTGlzdDogU2l0ZVBhZ2luZyA9IG51bGw7XG5cbiAgICAvKiogQ3VzdG9tIHJvdyBmaWx0ZXIgZnVuY3Rpb24uIFNlZSB0aGVcbiAgICAgKiBbRG9jdW1lbnQgTGlzdCBjb21wb25lbnRdKGRvY3VtZW50LWxpc3QuY29tcG9uZW50Lm1kI2N1c3RvbS1yb3ctZmlsdGVyKVxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcm93RmlsdGVyOiBSb3dGaWx0ZXIgPSBudWxsO1xuXG4gICAgLyoqIEN1c3RvbSBpbWFnZSByZXNvbHZlciBmdW5jdGlvbi4gU2VlIHRoZVxuICAgICAqIFtEb2N1bWVudCBMaXN0IGNvbXBvbmVudF0oZG9jdW1lbnQtbGlzdC5jb21wb25lbnQubWQjY3VzdG9tLXJvdy1maWx0ZXIpXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpbWFnZVJlc29sdmVyOiBJbWFnZVJlc29sdmVyID0gbnVsbDtcblxuICAgIC8qKiBOdW1iZXIgb2YgaXRlbXMgc2hvd24gcGVyIHBhZ2UgaW4gdGhlIGxpc3QuICovXG4gICAgQElucHV0KClcbiAgICBwYWdlU2l6ZTogbnVtYmVyO1xuXG4gICAgLyoqIEZ1bmN0aW9uIHVzZWQgdG8gZGVjaWRlIGlmIHRoZSBzZWxlY3RlZCBub2RlIGhhcyBwZXJtaXNzaW9uIHRvIGJlIHNlbGVjdGVkLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIHRydWUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpc1NlbGVjdGlvblZhbGlkOiBWYWxpZGF0aW9uRnVuY3Rpb24gPSBkZWZhdWx0VmFsaWRhdGlvbjtcblxuICAgIC8qKiBUcmFuc2Zvcm1hdGlvbiB0byBiZSBwZXJmb3JtZWQgb24gdGhlIGNob3Nlbi9mb2xkZXIgbm9kZSBiZWZvcmUgYnVpbGRpbmcgdGhlXG4gICAgICogYnJlYWRjcnVtYiBVSS4gQ2FuIGJlIHVzZWZ1bCB3aGVuIGN1c3RvbSBmb3JtYXR0aW5nIGlzIG5lZWRlZCBmb3IgdGhlIGJyZWFkY3J1bWIuXG4gICAgICogWW91IGNhbiBjaGFuZ2UgdGhlIHBhdGggZWxlbWVudHMgZnJvbSB0aGUgbm9kZSB0aGF0IGFyZSB1c2VkIHRvIGJ1aWxkIHRoZVxuICAgICAqIGJyZWFkY3J1bWIgdXNpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJyZWFkY3J1bWJUcmFuc2Zvcm06IChub2RlKSA9PiBhbnk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSB1c2VyIGhhcyBjaG9zZW4gYW4gaXRlbS4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBzZWxlY3Q6IEV2ZW50RW1pdHRlcjxNaW5pbWFsTm9kZUVudHJ5RW50aXR5W10+ID0gbmV3IEV2ZW50RW1pdHRlcjxNaW5pbWFsTm9kZUVudHJ5RW50aXR5W10+KCk7XG5cbiAgICBAVmlld0NoaWxkKCdkb2N1bWVudExpc3QnKVxuICAgIGRvY3VtZW50TGlzdDogRG9jdW1lbnRMaXN0Q29tcG9uZW50O1xuXG4gICAgQFZpZXdDaGlsZChIaWdobGlnaHREaXJlY3RpdmUpXG4gICAgaGlnaGxpZ2h0ZXI6IEhpZ2hsaWdodERpcmVjdGl2ZTtcblxuICAgIG5vZGVzOiBOb2RlUGFnaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgc2l0ZUlkOiBudWxsIHwgc3RyaW5nO1xuICAgIHNlYXJjaFRlcm06IHN0cmluZyA9ICcnO1xuICAgIHNob3dpbmdTZWFyY2hSZXN1bHRzOiBib29sZWFuID0gZmFsc2U7XG4gICAgbG9hZGluZ1NlYXJjaFJlc3VsdHM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBpbkRpYWxvZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIF9jaG9zZW5Ob2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5ID0gbnVsbDtcbiAgICBmb2xkZXJJZFRvU2hvdzogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgcGFnaW5hdGlvblN0cmF0ZWd5OiBQYWdpbmF0aW9uU3RyYXRlZ3kgPSBQYWdpbmF0aW9uU3RyYXRlZ3kuSW5maW5pdGU7XG4gICAgcGFnaW5hdGlvbjogQmVoYXZpb3JTdWJqZWN0PFBhZ2luYXRpb25Nb2RlbD47XG5cbiAgICBza2lwQ291bnQ6IG51bWJlciA9IDA7XG4gICAgaW5maW5pdGVTY3JvbGw6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBkZWJvdW5jZVNlYXJjaDogbnVtYmVyID0gMjAwO1xuICAgIHNlYXJjaElucHV0OiBGb3JtQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBjb250ZW50Tm9kZVNlbGVjdG9yU2VydmljZTogQ29udGVudE5vZGVTZWxlY3RvclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBjdXN0b21SZXNvdXJjZXNTZXJ2aWNlOiBDdXN0b21SZXNvdXJjZXNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgcHJlZmVyZW5jZXM6IFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC52YWx1ZUNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIGRlYm91bmNlVGltZSh0aGlzLmRlYm91bmNlU2VhcmNoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoc2VhcmNoVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaChzZWFyY2hWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHRoaXMucHJlZmVyZW5jZXMucGFnaW5hdGlvblNpemU7XG5cbiAgICAgICAgbGV0IGRlZmF1bHRQYWdpbmF0aW9uID0gPFBhZ2luYXRpb25Nb2RlbD4ge1xuICAgICAgICAgICAgbWF4SXRlbXM6IHRoaXMucGFnZVNpemUsXG4gICAgICAgICAgICBza2lwQ291bnQ6IDAsXG4gICAgICAgICAgICB0b3RhbEl0ZW1zOiAwLFxuICAgICAgICAgICAgaGFzTW9yZUl0ZW1zOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhZ2luYXRpb24gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFBhZ2luYXRpb25Nb2RlbD4oZGVmYXVsdFBhZ2luYXRpb24pO1xuICAgIH1cblxuICAgIHNldCBjaG9zZW5Ob2RlKHZhbHVlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KSB7XG4gICAgICAgIHRoaXMuX2Nob3Nlbk5vZGUgPSB2YWx1ZTtcbiAgICAgICAgbGV0IHZhbHVlc0FycmF5ID0gbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZXNBcnJheSA9IFt2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3QubmV4dCh2YWx1ZXNBcnJheSk7XG4gICAgfVxuXG4gICAgZ2V0IGNob3Nlbk5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaG9zZW5Ob2RlO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmZvbGRlcklkVG9TaG93ID0gdGhpcy5jdXJyZW50Rm9sZGVySWQ7XG5cbiAgICAgICAgdGhpcy5icmVhZGNydW1iVHJhbnNmb3JtID0gdGhpcy5icmVhZGNydW1iVHJhbnNmb3JtID8gdGhpcy5icmVhZGNydW1iVHJhbnNmb3JtIDogbnVsbDtcbiAgICAgICAgdGhpcy5pc1NlbGVjdGlvblZhbGlkID0gdGhpcy5pc1NlbGVjdGlvblZhbGlkID8gdGhpcy5pc1NlbGVjdGlvblZhbGlkIDogZGVmYXVsdFZhbGlkYXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgc2l0ZSBhdHRyaWJ1dGUgYW5kIHN0YXJ0cyBhIG5ldyBzZWFyY2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaG9zZW5TaXRlIFNpdGVFbnRyeSB0byBzZWFyY2ggd2l0aGluXG4gICAgICovXG4gICAgc2l0ZUNoYW5nZWQoY2hvc2VuU2l0ZTogU2l0ZUVudHJ5KTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2l0ZUlkID0gY2hvc2VuU2l0ZS5lbnRyeS5ndWlkO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlc3VsdHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzZWFyY2hUZXJtIGF0dHJpYnV0ZSBhbmQgc3RhcnRzIGEgbmV3IHNlYXJjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHNlYXJjaFRlcm0gc3RyaW5nIHZhbHVlIHRvIHNlYXJjaCBhZ2FpbnN0XG4gICAgICovXG4gICAgc2VhcmNoKHNlYXJjaFRlcm06IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLnNlYXJjaFRlcm0gPSBzZWFyY2hUZXJtO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlc3VsdHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3R1YWxseSBzZWxlY3RlZHxlbnRlcmVkIGZvbGRlciBub2RlIG9yIG51bGwgaW4gY2FzZSBvZiBzZWFyY2hpbmcgZm9yIHRoZSBicmVhZGNydW1iXG4gICAgICovXG4gICAgZ2V0IGJyZWFkY3J1bWJGb2xkZXJOb2RlKCk6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkgfCBudWxsIHtcbiAgICAgICAgbGV0IGZvbGRlck5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd2luZ1NlYXJjaFJlc3VsdHMgJiYgdGhpcy5jaG9zZW5Ob2RlKSB7XG4gICAgICAgICAgICBmb2xkZXJOb2RlID0gdGhpcy5jaG9zZW5Ob2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9sZGVyTm9kZSA9IHRoaXMuZG9jdW1lbnRMaXN0LmZvbGRlck5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9sZGVyTm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgc2VhcmNoIGlucHV0IGFuZCByZXNldCB0byBsYXN0IGZvbGRlciBub2RlIGluIHdoaWNoIHNlYXJjaCB3YXMgcGVyZm9ybWVkXG4gICAgICovXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2xlYXJTZWFyY2goKTtcbiAgICAgICAgdGhpcy5mb2xkZXJJZFRvU2hvdyA9IHRoaXMuc2l0ZUlkIHx8IHRoaXMuY3VycmVudEZvbGRlcklkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBzZWFyY2ggaW5wdXQgYW5kIHNlYXJjaCByZWxhdGVkIGRhdGFcbiAgICAgKi9cbiAgICBjbGVhclNlYXJjaCgpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hUZXJtID0gJyc7XG4gICAgICAgIHRoaXMubm9kZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnNraXBDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuY2hvc2VuTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hvd2luZ1NlYXJjaFJlc3VsdHMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHJlc3VsdCBsaXN0IGRlcGVuZGluZyBvbiB0aGUgY3JpdGVyaWFzXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVSZXN1bHRzKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zZWFyY2hUZXJtLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydE5ld1NlYXJjaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgZmlyc3QgcGFnZSBvZiBhIG5ldyBzZWFyY2ggcmVzdWx0XG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGFydE5ld1NlYXJjaCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2tpcENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5jaG9zZW5Ob2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2xkZXJJZFRvU2hvdyA9IG51bGw7XG4gICAgICAgIHRoaXMucXVlcnlTZWFyY2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgbmV4dCBiYXRjaCBvZiBzZWFyY2ggcmVzdWx0c1xuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IFBhZ2luYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgdXBkYXRlUGFnaW5hdGlvbihwYWdpbmF0aW9uOiBQYWdpbmF0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5maW5pdGVTY3JvbGwgPSB0cnVlO1xuICAgICAgICB0aGlzLnNraXBDb3VudCA9IHBhZ2luYXRpb24uc2tpcENvdW50O1xuXG4gICAgICAgIGlmICh0aGlzLnNlYXJjaFRlcm0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeVNlYXJjaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSB0aGUgY2FsbCB0byBzZWFyY2hTZXJ2aWNlIHdpdGggdGhlIHByb3BlciBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgcHJpdmF0ZSBxdWVyeVNlYXJjaCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nU2VhcmNoUmVzdWx0cyA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tUmVzb3VyY2VzU2VydmljZS5oYXNDb3JyZXNwb25kaW5nTm9kZUlkcyh0aGlzLnNpdGVJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tUmVzb3VyY2VzU2VydmljZS5nZXRDb3JyZXNwb25kaW5nTm9kZUlkcyh0aGlzLnNpdGVJZClcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKG5vZGVJZHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50Tm9kZVNlbGVjdG9yU2VydmljZS5zZWFyY2godGhpcy5zZWFyY2hUZXJtLCB0aGlzLnNpdGVJZCwgdGhpcy5za2lwQ291bnQsIHRoaXMucGFnZVNpemUsIG5vZGVJZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLnNob3dTZWFyY2hSZXN1bHRzLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dTZWFyY2hSZXN1bHRzKHsgbGlzdDogeyBlbnRyaWVzOiBbXSB9IH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudE5vZGVTZWxlY3RvclNlcnZpY2Uuc2VhcmNoKHRoaXMuc2VhcmNoVGVybSwgdGhpcy5zaXRlSWQsIHRoaXMuc2tpcENvdW50LCB0aGlzLnBhZ2VTaXplKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5zaG93U2VhcmNoUmVzdWx0cy5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIHJlc3VsdHMgb2YgdGhlIHNlYXJjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc3VsdHMgU2VhcmNoIHJlc3VsdHNcbiAgICAgKi9cbiAgICBwcml2YXRlIHNob3dTZWFyY2hSZXN1bHRzKG5vZGVQYWdpbmc6IE5vZGVQYWdpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zaG93aW5nU2VhcmNoUmVzdWx0cyA9IHRydWU7XG4gICAgICAgIHRoaXMubG9hZGluZ1NlYXJjaFJlc3VsdHMgPSBmYWxzZTtcblxuICAgICAgICAvLyBEb2N1bWVudGxpc3QgaGFjaywgc2luY2UgZGF0YSBkaXNwbGF5aW5nIGZvciBwcmVsb2FkZWQgbm9kZXMgaXMgYSBsaXR0bGUgYml0IG1lc3N5IHRoZXJlXG4gICAgICAgIGlmICghdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVQYWdpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50TGlzdC5kYXRhLmxvYWRQYWdlKG5vZGVQYWdpbmcsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uLm5leHQobm9kZVBhZ2luZy5saXN0LnBhZ2luYXRpb24pO1xuICAgICAgICB0aGlzLmhpZ2hsaWdodCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZ2h0bGlnaHQgdGhlIGFjdHVhbCBzZWFyY2h0ZXJtIGluIHRoZSBuZXh0IGZyYW1lXG4gICAgICovXG4gICAgaGlnaGxpZ2h0KCk6IHZvaWQge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZXIuaGlnaGxpZ2h0KHRoaXMuc2VhcmNoVGVybSk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgc2hvd2luZ1NlYXJjaFJlc3VsdHMgc3RhdGUgdG8gYmUgYWJsZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gc2VhcmNoIHJlc3VsdHMgb3IgZm9sZGVyIHJlc3VsdHNcbiAgICAgKi9cbiAgICBvbkZvbGRlckNoYW5nZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zaG93aW5nU2VhcmNoUmVzdWx0cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluZmluaXRlU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xlYXJTZWFyY2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBzZXQgdGhlIGN1cnJlbnRseSBsb2FkZWQgbm9kZVxuICAgICAqL1xuICAgIG9uRm9sZGVyTG9hZGVkKG5vZGVQYWdpbmc6IE5vZGVQYWdpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnNob3dpbmdTZWFyY2hSZXN1bHRzKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGVtcHROb2RlU2VsZWN0aW9uKHRoaXMuZG9jdW1lbnRMaXN0LmZvbGRlck5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGJyZWFkY3J1bWIgaGFzIHRvIGJlIHNob3duIG9yIG5vdFxuICAgICAqL1xuICAgIHNob3dCcmVhZGNydW1icygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnNob3dpbmdTZWFyY2hSZXN1bHRzIHx8IHRoaXMuY2hvc2VuTm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgbmV4dCBiYXRjaCBvZiBzZWFyY2ggcmVzdWx0c1xuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IFBhZ2luYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgZ2V0TmV4dFBhZ2VPZlNlYXJjaChldmVudDogUGFnaW5hdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmluZmluaXRlU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5za2lwQ291bnQgPSBldmVudC5za2lwQ291bnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuc2VhcmNoVGVybS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5U2VhcmNoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIG5vZGUgYXMgY2hvc2VuIGlmIGl0IGhhcyB0aGUgcmlnaHQgcGVybWlzc2lvbiwgY2xlYXJzIHRoZSBzZWxlY3Rpb24gb3RoZXJ3aXNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50cnlcbiAgICAgKi9cbiAgICBwcml2YXRlIGF0dGVtcHROb2RlU2VsZWN0aW9uKGVudHJ5OiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0aW9uVmFsaWQoZW50cnkpKSB7XG4gICAgICAgICAgICB0aGlzLmNob3Nlbk5vZGUgPSBlbnRyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRDaG9zZW5Ob2RlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNob3NlbiBub2RlXG4gICAgICovXG4gICAgcmVzZXRDaG9zZW5Ob2RlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNob3Nlbk5vZGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB1c2VyIHNlbGVjdHMgYSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgQ3VzdG9tRXZlbnQgZm9yIG5vZGUtc2VsZWN0XG4gICAgICovXG4gICAgb25Ob2RlU2VsZWN0KGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hdHRlbXB0Tm9kZVNlbGVjdGlvbihldmVudC5kZXRhaWwubm9kZS5lbnRyeSk7XG4gICAgfVxuXG4gICAgb25Ob2RlRG91YmxlQ2xpY2soZTogQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgY29uc3Qgbm9kZTogYW55ID0gZS5kZXRhaWwubm9kZS5lbnRyeTtcblxuICAgICAgICBpZiAobm9kZSAmJiBub2RlLmd1aWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWF4SXRlbXM6IHRoaXMucGFnZVNpemUsXG4gICAgICAgICAgICAgICAgc2tpcENvdW50OiB0aGlzLnNraXBDb3VudCxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiBbJ3BhdGgnLCAncHJvcGVydGllcycsICdhbGxvd2FibGVPcGVyYXRpb25zJ11cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuYXBpU2VydmljZS5ub2Rlc0FwaS5nZXROb2RlKG5vZGUuZ3VpZCwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAudGhlbihkb2N1bWVudExpYnJhcnkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50TGlzdC5wZXJmb3JtQ3VzdG9tU291cmNlTmF2aWdhdGlvbihkb2N1bWVudExpYnJhcnkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE1hdGVyaWFsTW9kdWxlIH0gZnJvbSAnLi4vbWF0ZXJpYWwubW9kdWxlJztcblxuaW1wb3J0IHsgQ29udGVudE5vZGVTZWxlY3RvclBhbmVsQ29tcG9uZW50IH0gZnJvbSAnLi9jb250ZW50LW5vZGUtc2VsZWN0b3ItcGFuZWwuY29tcG9uZW50JztcbmltcG9ydCB7IENvbnRlbnROb2RlU2VsZWN0b3JDb21wb25lbnQgfSBmcm9tICcuL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2l0ZXNEcm9wZG93bk1vZHVsZSB9IGZyb20gJy4uL3NpdGUtZHJvcGRvd24vc2l0ZXMtZHJvcGRvd24ubW9kdWxlJztcbmltcG9ydCB7IEJyZWFkY3J1bWJNb2R1bGUgfSBmcm9tICcuLi9icmVhZGNydW1iL2JyZWFkY3J1bWIubW9kdWxlJztcbmltcG9ydCB7IENvcmVNb2R1bGUgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgRG9jdW1lbnRMaXN0TW9kdWxlIH0gZnJvbSAnLi4vZG9jdW1lbnQtbGlzdC9kb2N1bWVudC1saXN0Lm1vZHVsZSc7XG5pbXBvcnQgeyBOYW1lTG9jYXRpb25DZWxsQ29tcG9uZW50IH0gZnJvbSAnLi9uYW1lLWxvY2F0aW9uLWNlbGwvbmFtZS1sb2NhdGlvbi1jZWxsLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQ29yZU1vZHVsZS5mb3JDaGlsZCgpLFxuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIE1hdGVyaWFsTW9kdWxlLFxuICAgICAgICBTaXRlc0Ryb3Bkb3duTW9kdWxlLFxuICAgICAgICBCcmVhZGNydW1iTW9kdWxlLFxuICAgICAgICBEb2N1bWVudExpc3RNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ29udGVudE5vZGVTZWxlY3RvclBhbmVsQ29tcG9uZW50LFxuICAgICAgICBOYW1lTG9jYXRpb25DZWxsQ29tcG9uZW50LFxuICAgICAgICBDb250ZW50Tm9kZVNlbGVjdG9yQ29tcG9uZW50XG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgQ29udGVudE5vZGVTZWxlY3RvclBhbmVsQ29tcG9uZW50LFxuICAgICAgICBDb250ZW50Tm9kZVNlbGVjdG9yQ29tcG9uZW50XG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ29udGVudE5vZGVTZWxlY3RvclBhbmVsQ29tcG9uZW50LFxuICAgICAgICBOYW1lTG9jYXRpb25DZWxsQ29tcG9uZW50LFxuICAgICAgICBDb250ZW50Tm9kZVNlbGVjdG9yQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBDb250ZW50Tm9kZVNlbGVjdG9yTW9kdWxlIHt9XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBGb3JtQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuY29uc3QgSTE4Tl9FUlJPUlNfUEFUSCA9ICdDT1JFLkZPTERFUl9ESUFMT0cuRk9MREVSX05BTUUuRVJST1JTJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZvcmJpZFNwZWNpYWxDaGFyYWN0ZXJzKHsgdmFsdWUgfTogRm9ybUNvbnRyb2wpIHtcbiAgICBjb25zdCBzcGVjaWFsQ2hhcmFjdGVyczogUmVnRXhwID0gLyhbXFwqXFxcIlxcPFxcPlxcXFxcXC9cXD9cXDpcXHxdKS87XG4gICAgY29uc3QgaXNWYWxpZDogYm9vbGVhbiA9ICFzcGVjaWFsQ2hhcmFjdGVycy50ZXN0KHZhbHVlKTtcblxuICAgIHJldHVybiAoaXNWYWxpZCkgPyBudWxsIDoge1xuICAgICAgICBtZXNzYWdlOiBgJHtJMThOX0VSUk9SU19QQVRIfS5TUEVDSUFMX0NIQVJBQ1RFUlNgXG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcmJpZEVuZGluZ0RvdCh7IHZhbHVlIH06IEZvcm1Db250cm9sKSB7XG4gICAgY29uc3QgaXNWYWxpZDogYm9vbGVhbiA9ICgodmFsdWUgfHwgJycpLnRyaW0oKS5zcGxpdCgnJykucG9wKCkgIT09ICcuJyk7XG5cbiAgICByZXR1cm4gaXNWYWxpZCA/IG51bGwgOiB7XG4gICAgICAgIG1lc3NhZ2U6IGAke0kxOE5fRVJST1JTX1BBVEh9LkVORElOR19ET1RgXG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcmJpZE9ubHlTcGFjZXMoeyB2YWx1ZSB9OiBGb3JtQ29udHJvbCkge1xuICAgIGNvbnN0IGlzVmFsaWQ6IGJvb2xlYW4gPSAhISgodmFsdWUgfHwgJycpKS50cmltKCk7XG5cbiAgICByZXR1cm4gaXNWYWxpZCA/IG51bGwgOiB7XG4gICAgICAgIG1lc3NhZ2U6IGAke0kxOE5fRVJST1JTX1BBVEh9Lk9OTFlfU1BBQ0VTYFxuICAgIH07XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5qZWN0LCBPbkluaXQsIE9wdGlvbmFsLCBFdmVudEVtaXR0ZXIsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUJ1aWxkZXIsIEZvcm1Hcm91cCwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE1BVF9ESUFMT0dfREFUQSwgTWF0RGlhbG9nUmVmIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuXG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudHJ5RW50aXR5IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IE5vZGVzQXBpU2VydmljZSwgVHJhbnNsYXRpb25TZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuaW1wb3J0IHsgZm9yYmlkRW5kaW5nRG90LCBmb3JiaWRPbmx5U3BhY2VzLCBmb3JiaWRTcGVjaWFsQ2hhcmFjdGVycyB9IGZyb20gJy4vZm9sZGVyLW5hbWUudmFsaWRhdG9ycyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWZvbGRlci1kaWFsb2cnLFxuICAgIHN0eWxlVXJsczogWycuL2ZvbGRlci5kaWFsb2cuc2NzcyddLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9mb2xkZXIuZGlhbG9nLmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIEZvbGRlckRpYWxvZ0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICBmb3JtOiBGb3JtR3JvdXA7XG5cbiAgICBmb2xkZXI6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkgPSBudWxsO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgZWRpdC9jcmVhdGUgZm9sZGVyIGdpdmUgZXJyb3IgZm9yIGV4YW1wbGUgYSBmb2xkZXIgd2l0aCBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGVycm9yOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgZWRpdC9jcmVhdGUgZm9sZGVyIGlzIHN1Y2Nlc3NmdWxseSBjcmVhdGVkL21tb2RpZmllZFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHN1Y2Nlc3M6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PigpO1xuXG4gICAgZWRpdFRpdGxlID0gJ0NPUkUuRk9MREVSX0RJQUxPRy5FRElUX0ZPTERFUl9USVRMRSc7XG4gICAgY3JlYXRlVGl0bGUgPSAnQ09SRS5GT0xERVJfRElBTE9HLkNSRUFURV9GT0xERVJfVElUTEUnO1xuICAgIG5vZGVUeXBlID0gJ2NtOmZvbGRlcic7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBmb3JtQnVpbGRlcjogRm9ybUJ1aWxkZXIsXG4gICAgICAgIHByaXZhdGUgZGlhbG9nOiBNYXREaWFsb2dSZWY8Rm9sZGVyRGlhbG9nQ29tcG9uZW50PixcbiAgICAgICAgcHJpdmF0ZSBub2Rlc0FwaTogTm9kZXNBcGlTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHRyYW5zbGF0aW9uOiBUcmFuc2xhdGlvblNlcnZpY2UsXG4gICAgICAgIEBPcHRpb25hbCgpXG4gICAgICAgIEBJbmplY3QoTUFUX0RJQUxPR19EQVRBKVxuICAgICAgICBwdWJsaWMgZGF0YTogYW55XG4gICAgKSB7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRUaXRsZSA9IGRhdGEuZWRpdFRpdGxlIHx8IHRoaXMuZWRpdFRpdGxlO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVUaXRsZSA9IGRhdGEuY3JlYXRlVGl0bGUgfHwgdGhpcy5jcmVhdGVUaXRsZTtcbiAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPSBkYXRhLm5vZGVUeXBlIHx8IHRoaXMubm9kZVR5cGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZWRpdGluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5kYXRhLmZvbGRlcjtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgY29uc3QgeyBmb2xkZXIgfSA9IHRoaXMuZGF0YTtcbiAgICAgICAgbGV0IG5hbWUgPSAnJztcbiAgICAgICAgbGV0IGRlc2NyaXB0aW9uID0gJyc7XG5cbiAgICAgICAgaWYgKGZvbGRlcikge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBmb2xkZXI7XG5cbiAgICAgICAgICAgIG5hbWUgPSBmb2xkZXIubmFtZSB8fCAnJztcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gcHJvcGVydGllcyA/IHByb3BlcnRpZXNbJ2NtOmRlc2NyaXB0aW9uJ10gOiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRvcnMgPSB7XG4gICAgICAgICAgICBuYW1lOiBbXG4gICAgICAgICAgICAgICAgVmFsaWRhdG9ycy5yZXF1aXJlZCxcbiAgICAgICAgICAgICAgICBmb3JiaWRTcGVjaWFsQ2hhcmFjdGVycyxcbiAgICAgICAgICAgICAgICBmb3JiaWRFbmRpbmdEb3QsXG4gICAgICAgICAgICAgICAgZm9yYmlkT25seVNwYWNlc1xuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZm9ybSA9IHRoaXMuZm9ybUJ1aWxkZXIuZ3JvdXAoe1xuICAgICAgICAgICAgbmFtZTogWyBuYW1lLCB2YWxpZGF0b3JzLm5hbWUgXSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBbIGRlc2NyaXB0aW9uIF1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHsgbmFtZSB9ID0gdGhpcy5mb3JtLnZhbHVlO1xuXG4gICAgICAgIHJldHVybiAobmFtZSB8fCAnJykudHJpbSgpO1xuICAgIH1cblxuICAgIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuICAgICAgICBsZXQgeyBkZXNjcmlwdGlvbiB9ID0gdGhpcy5mb3JtLnZhbHVlO1xuXG4gICAgICAgIHJldHVybiAoZGVzY3JpcHRpb24gfHwgJycpLnRyaW0oKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBwcm9wZXJ0aWVzKCk6IGFueSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZTogdGl0bGUsIGRlc2NyaXB0aW9uIH0gPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnY206dGl0bGUnOiB0aXRsZSxcbiAgICAgICAgICAgICdjbTpkZXNjcmlwdGlvbic6IGRlc2NyaXB0aW9uXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGUoKTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgcHJvcGVydGllcywgbm9kZVR5cGUsIG5vZGVzQXBpLCBkYXRhOiB7IHBhcmVudE5vZGVJZH0gfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBub2Rlc0FwaS5jcmVhdGVGb2xkZXIocGFyZW50Tm9kZUlkLCB7IG5hbWUsIHByb3BlcnRpZXMsIG5vZGVUeXBlIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZWRpdCgpOiBPYnNlcnZhYmxlPE1pbmltYWxOb2RlRW50cnlFbnRpdHk+IHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBwcm9wZXJ0aWVzLCBub2Rlc0FwaSwgZGF0YTogeyBmb2xkZXI6IHsgaWQ6IG5vZGVJZCB9fSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5vZGVzQXBpLnVwZGF0ZU5vZGUobm9kZUlkLCB7IG5hbWUsIHByb3BlcnRpZXMgfSk7XG4gICAgfVxuXG4gICAgc3VibWl0KCkge1xuICAgICAgICBjb25zdCB7IGZvcm0sIGRpYWxvZywgZWRpdGluZyB9ID0gdGhpcztcblxuICAgICAgICBpZiAoIWZvcm0udmFsaWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgKGVkaXRpbmcgPyB0aGlzLmVkaXQoKSA6IHRoaXMuY3JlYXRlKCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgIChmb2xkZXI6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWNjZXNzLmVtaXQoZm9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKGZvbGRlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoZXJyb3IpID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIGhhbmRsZUVycm9yKGVycm9yOiBhbnkpOiBhbnkge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ0NPUkUuTUVTU0FHRVMuRVJST1JTLkdFTkVSSUMnO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGVycm9yOiB7IHN0YXR1c0NvZGUgfSB9ID0gSlNPTi5wYXJzZShlcnJvci5tZXNzYWdlKTtcblxuICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDQwOSkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdDT1JFLk1FU1NBR0VTLkVSUk9SUy5FWElTVEVOVF9GT0xERVInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHsgLyogRG8gbm90aGluZywga2VlcCB0aGUgb3JpZ2luYWwgbWVzc2FnZSAqLyB9XG5cbiAgICAgICAgdGhpcy5lcnJvci5lbWl0KHRoaXMudHJhbnNsYXRpb24uaW5zdGFudChlcnJvck1lc3NhZ2UpKTtcblxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IENvcmVNb2R1bGUgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5pbXBvcnQgeyBNYXRlcmlhbE1vZHVsZSB9IGZyb20gJy4uL21hdGVyaWFsLm1vZHVsZSc7XG5pbXBvcnQgeyBEb3dubG9hZFppcERpYWxvZ0NvbXBvbmVudCB9IGZyb20gJy4vZG93bmxvYWQtemlwLmRpYWxvZyc7XG5pbXBvcnQgeyBGb2xkZXJEaWFsb2dDb21wb25lbnQgfSBmcm9tICcuL2ZvbGRlci5kaWFsb2cnO1xuaW1wb3J0IHsgTm9kZUxvY2tEaWFsb2dDb21wb25lbnQgfSBmcm9tICcuL25vZGUtbG9jay5kaWFsb2cnO1xuaW1wb3J0IHsgQ29uZmlybURpYWxvZ0NvbXBvbmVudCB9IGZyb20gJy4vY29uZmlybS5kaWFsb2cnO1xuaW1wb3J0IHsgTWF0RGF0ZXRpbWVwaWNrZXJNb2R1bGUgfSBmcm9tICdAbWF0LWRhdGV0aW1lcGlja2VyL2NvcmUnO1xuaW1wb3J0IHsgTWF0TW9tZW50RGF0ZXRpbWVNb2R1bGUgfSBmcm9tICdAbWF0LWRhdGV0aW1lcGlja2VyL21vbWVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIE1hdGVyaWFsTW9kdWxlLFxuICAgICAgICBDb3JlTW9kdWxlLmZvckNoaWxkKCksXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBNYXRNb21lbnREYXRldGltZU1vZHVsZSxcbiAgICAgICAgTWF0RGF0ZXRpbWVwaWNrZXJNb2R1bGVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBEb3dubG9hZFppcERpYWxvZ0NvbXBvbmVudCxcbiAgICAgICAgRm9sZGVyRGlhbG9nQ29tcG9uZW50LFxuICAgICAgICBOb2RlTG9ja0RpYWxvZ0NvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybURpYWxvZ0NvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBEb3dubG9hZFppcERpYWxvZ0NvbXBvbmVudCxcbiAgICAgICAgRm9sZGVyRGlhbG9nQ29tcG9uZW50LFxuICAgICAgICBOb2RlTG9ja0RpYWxvZ0NvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybURpYWxvZ0NvbXBvbmVudFxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIERvd25sb2FkWmlwRGlhbG9nQ29tcG9uZW50LFxuICAgICAgICBGb2xkZXJEaWFsb2dDb21wb25lbnQsXG4gICAgICAgIE5vZGVMb2NrRGlhbG9nQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtRGlhbG9nQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBEaWFsb2dNb2R1bGUge31cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIHRzbGludDpkaXNhYmxlOm5vLWlucHV0LXJlbmFtZSAgKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0RGlhbG9nLCBNYXREaWFsb2dDb25maWcgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudHJ5RW50aXR5IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IEZvbGRlckRpYWxvZ0NvbXBvbmVudCB9IGZyb20gJy4uL2RpYWxvZ3MvZm9sZGVyLmRpYWxvZyc7XG5pbXBvcnQgeyBDb250ZW50U2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5cbmNvbnN0IERFRkFVTFRfRk9MREVSX1BBUkVOVF9JRCA9ICctbXktJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbYWRmLWNyZWF0ZS1mb2xkZXJdJ1xufSlcbmV4cG9ydCBjbGFzcyBGb2xkZXJDcmVhdGVEaXJlY3RpdmUge1xuICAgIHN0YXRpYyBESUFMT0dfV0lEVEg6IG51bWJlciA9IDQwMDtcblxuICAgIC8qKiBQYXJlbnQgZm9sZGVyIHdoZXJlIHRoZSBuZXcgZm9sZGVyIHdpbGwgYmUgbG9jYXRlZCBhZnRlciBjcmVhdGlvbi4gKi9cbiAgICBASW5wdXQoJ2FkZi1jcmVhdGUtZm9sZGVyJylcbiAgICBwYXJlbnROb2RlSWQ6IHN0cmluZyA9IERFRkFVTFRfRk9MREVSX1BBUkVOVF9JRDtcblxuICAgIC8qKiBUaXRsZSBvZiBmb2xkZXIgY3JlYXRpb24gZGlhbG9nLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZyA9IG51bGw7XG5cbiAgICAvKiogVHlwZSBvZiBub2RlIHRvIGNyZWF0ZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIG5vZGVUeXBlID0gJ2NtOmZvbGRlcic7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3VycyAoZWcsIGEgZm9sZGVyIHdpdGggc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzKS4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBlcnJvcjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIGZvbGRlciBpcyBjcmVhdGVkIHN1Y2Nlc3NmdWxseS4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBzdWNjZXNzOiBFdmVudEVtaXR0ZXI8TWluaW1hbE5vZGVFbnRyeUVudGl0eT4gPSBuZXcgRXZlbnRFbWl0dGVyPE1pbmltYWxOb2RlRW50cnlFbnRpdHk+KCk7XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsgJyRldmVudCcgXSlcbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMub3BlbkRpYWxvZygpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgZGlhbG9nUmVmOiBNYXREaWFsb2csXG4gICAgICAgIHB1YmxpYyBjb250ZW50OiBDb250ZW50U2VydmljZVxuICAgICkge31cblxuICAgIHByaXZhdGUgZ2V0IGRpYWxvZ0NvbmZpZygpOiBNYXREaWFsb2dDb25maWcge1xuICAgICAgICBjb25zdCB7IERJQUxPR19XSURUSDogd2lkdGggfSA9IEZvbGRlckNyZWF0ZURpcmVjdGl2ZTtcbiAgICAgICAgY29uc3QgeyBwYXJlbnROb2RlSWQsIHRpdGxlOiBjcmVhdGVUaXRsZSwgbm9kZVR5cGUgfSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHsgcGFyZW50Tm9kZUlkLCBjcmVhdGVUaXRsZSwgbm9kZVR5cGUgfSxcbiAgICAgICAgICAgIHdpZHRoOiBgJHt3aWR0aH1weGBcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9wZW5EaWFsb2coKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHsgZGlhbG9nUmVmLCBkaWFsb2dDb25maWcsIGNvbnRlbnQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGRpYWxvZ0luc3RhbmNlID0gZGlhbG9nUmVmLm9wZW4oRm9sZGVyRGlhbG9nQ29tcG9uZW50LCBkaWFsb2dDb25maWcpO1xuXG4gICAgICAgIGRpYWxvZ0luc3RhbmNlLmNvbXBvbmVudEluc3RhbmNlLmVycm9yLnN1YnNjcmliZSgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChlcnJvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpYWxvZ0luc3RhbmNlLmNvbXBvbmVudEluc3RhbmNlLnN1Y2Nlc3Muc3Vic2NyaWJlKChub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1Y2Nlc3MuZW1pdChub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGlhbG9nSW5zdGFuY2UuYWZ0ZXJDbG9zZWQoKS5zdWJzY3JpYmUoKG5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5mb2xkZXJDcmVhdGUubmV4dChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogdHNsaW50OmRpc2FibGU6bm8taW5wdXQtcmVuYW1lICAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXREaWFsb2csIE1hdERpYWxvZ0NvbmZpZyB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcblxuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRyeUVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5cbmltcG9ydCB7IEZvbGRlckRpYWxvZ0NvbXBvbmVudCB9IGZyb20gJy4uL2RpYWxvZ3MvZm9sZGVyLmRpYWxvZyc7XG5pbXBvcnQgeyBDb250ZW50U2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2FkZi1lZGl0LWZvbGRlcl0nXG59KVxuZXhwb3J0IGNsYXNzIEZvbGRlckVkaXREaXJlY3RpdmUge1xuICAgIHN0YXRpYyBESUFMT0dfV0lEVEg6IG51bWJlciA9IDQwMDtcblxuICAgIC8qKiBGb2xkZXIgbm9kZSB0byBlZGl0LiAqL1xuICAgIEBJbnB1dCgnYWRmLWVkaXQtZm9sZGVyJylcbiAgICBmb2xkZXI6IE1pbmltYWxOb2RlRW50cnlFbnRpdHk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3VycyAoZWcsIGEgZm9sZGVyIHdpdGggc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzKS4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBlcnJvcjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKiBUaXRsZSBvZiBmb2xkZXIgZWRpdCBkaWFsb2cuICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nID0gbnVsbDtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIGZvbGRlciBoYXMgYmVlbiBlZGl0ZWQgc3VjY2Vzc2Z1bGx5LiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHN1Y2Nlc3M6IEV2ZW50RW1pdHRlcjxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiA9IG5ldyBFdmVudEVtaXR0ZXI8TWluaW1hbE5vZGVFbnRyeUVudGl0eT4oKTtcblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyAnJGV2ZW50JyBdKVxuICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuZm9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5EaWFsb2coKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgZGlhbG9nUmVmOiBNYXREaWFsb2csXG4gICAgICAgIHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwdWJsaWMgY29udGVudDogQ29udGVudFNlcnZpY2VcbiAgICApIHt9XG5cbiAgICBwcml2YXRlIGdldCBkaWFsb2dDb25maWcoKTogTWF0RGlhbG9nQ29uZmlnIHtcbiAgICAgICAgY29uc3QgeyBESUFMT0dfV0lEVEg6IHdpZHRoIH0gPSBGb2xkZXJFZGl0RGlyZWN0aXZlO1xuICAgICAgICBjb25zdCB7IGZvbGRlciB9ID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGZvbGRlcixcbiAgICAgICAgICAgICAgICBlZGl0VGl0bGU6IHRoaXMudGl0bGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aWR0aDogYCR7d2lkdGh9cHhgXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvcGVuRGlhbG9nKCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IGRpYWxvZ1JlZiwgZGlhbG9nQ29uZmlnLCBjb250ZW50IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBkaWFsb2dJbnN0YW5jZSA9IGRpYWxvZ1JlZi5vcGVuKEZvbGRlckRpYWxvZ0NvbXBvbmVudCwgZGlhbG9nQ29uZmlnKTtcblxuICAgICAgICBkaWFsb2dJbnN0YW5jZS5jb21wb25lbnRJbnN0YW5jZS5lcnJvci5zdWJzY3JpYmUoKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVycm9yLmVtaXQoZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICBkaWFsb2dJbnN0YW5jZS5jb21wb25lbnRJbnN0YW5jZS5zdWNjZXNzLnN1YnNjcmliZSgobm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWNjZXNzLmVtaXQobm9kZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpYWxvZ0luc3RhbmNlLmFmdGVyQ2xvc2VkKCkuc3Vic2NyaWJlKChub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQuZm9sZGVyRWRpdC5uZXh0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1hdGVyaWFsTW9kdWxlIH0gZnJvbSAnLi4vbWF0ZXJpYWwubW9kdWxlJztcblxuaW1wb3J0IHsgRm9sZGVyQ3JlYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi9mb2xkZXItY3JlYXRlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBGb2xkZXJFZGl0RGlyZWN0aXZlIH0gZnJvbSAnLi9mb2xkZXItZWRpdC5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBNYXRlcmlhbE1vZHVsZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEZvbGRlckNyZWF0ZURpcmVjdGl2ZSxcbiAgICAgICAgRm9sZGVyRWRpdERpcmVjdGl2ZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBGb2xkZXJDcmVhdGVEaXJlY3RpdmUsXG4gICAgICAgIEZvbGRlckVkaXREaXJlY3RpdmVcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEZvbGRlckRpcmVjdGl2ZU1vZHVsZSB7fVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1pbmltYWxOb2RlRW50cnlFbnRpdHkgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgQ29udGVudFNlcnZpY2UsIFBlcm1pc3Npb25zRW51bSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWNvbnRlbnQtbWV0YWRhdGEtY2FyZCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NvbnRlbnQtbWV0YWRhdGEtY2FyZC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vY29udGVudC1tZXRhZGF0YS1jYXJkLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7ICdjbGFzcyc6ICdhZGYtY29udGVudC1tZXRhZGF0YS1jYXJkJyB9XG59KVxuZXhwb3J0IGNsYXNzIENvbnRlbnRNZXRhZGF0YUNhcmRDb21wb25lbnQge1xuICAgIC8qKiAocmVxdWlyZWQpIFRoZSBub2RlIGVudGl0eSB0byBmZXRjaCBtZXRhZGF0YSBhYm91dCAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eTtcblxuICAgIC8qKiAob3B0aW9uYWwpIFRoaXMgZmxhZyBkaXNwbGF5cy9oaWRlcyBlbXB0eSBtZXRhZGF0YVxuICAgICAqIGZpZWxkcy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc3BsYXlFbXB0eTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIChyZXF1aXJlZCkgTmFtZSBvZiB0aGUgbWV0YWRhdGEgcHJlc2V0LCB3aGljaCBkZWZpbmVzIGFzcGVjdHNcbiAgICAgKiBhbmQgdGhlaXIgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHByZXNldDogc3RyaW5nO1xuXG4gICAgLyoqIChvcHRpb25hbCkgVGhpcyBmbGFnIHNldHMgdGhlIG1ldGFkYXRhIGluIHJlYWQgb25seSBtb2RlXG4gICAgICogcHJldmVudGluZyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcmVhZE9ubHkgPSBmYWxzZTtcblxuICAgIC8qKiAob3B0aW9uYWwpIFRoaXMgZmxhZyBhbGxvd3MgdGhlIGNvbXBvbmVudCB0byBkaXNwbGF5IG1vcmVcbiAgICAgKiB0aGFuIG9uZSBhY2NvcmRpb24gYXQgYSB0aW1lLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbXVsdGkgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX2Rpc3BsYXlEZWZhdWx0UHJvcGVydGllczogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogKG9wdGlvbmFsKSBUaGlzIGZsYWcgZGlzcGxheXMvaGlkZXMgdGhlIG1ldGFkYXRhXG4gICAgICogcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBkaXNwbGF5RGVmYXVsdFByb3BlcnRpZXModmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZGlzcGxheURlZmF1bHRQcm9wZXJ0aWVzID0gdmFsdWU7XG4gICAgICAgIHRoaXMub25EaXNwbGF5RGVmYXVsdFByb3BlcnRpZXNDaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBnZXQgZGlzcGxheURlZmF1bHRQcm9wZXJ0aWVzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGxheURlZmF1bHRQcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIGVkaXRhYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBleHBhbmRlZDogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY29udGVudFNlcnZpY2U6IENvbnRlbnRTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgb25EaXNwbGF5RGVmYXVsdFByb3BlcnRpZXNDaGFuZ2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5fZGlzcGxheURlZmF1bHRQcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIHRvZ2dsZUVkaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSAhdGhpcy5lZGl0YWJsZTtcbiAgICB9XG5cbiAgICB0b2dnbGVFeHBhbmRlZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgIH1cblxuICAgIGhhc1Blcm1pc3Npb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRTZXJ2aWNlLmhhc1Blcm1pc3Npb24odGhpcy5ub2RlLCBQZXJtaXNzaW9uc0VudW0uVVBEQVRFKTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudHJ5RW50aXR5IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IENhcmRWaWV3RGF0ZUl0ZW1Nb2RlbCwgQ2FyZFZpZXdUZXh0SXRlbU1vZGVsLCBGaWxlU2l6ZVBpcGUgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQmFzaWNQcm9wZXJ0aWVzU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZpbGVTaXplUGlwZTogRmlsZVNpemVQaXBlKSB7XG4gICAgfVxuXG4gICAgZ2V0UHJvcGVydGllcyhub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KSB7XG5cbiAgICAgICAgY29uc3Qgc2l6ZUluQnl0ZXMgPSBub2RlLmNvbnRlbnQgPyBub2RlLmNvbnRlbnQuc2l6ZUluQnl0ZXMgOiAnJyxcbiAgICAgICAgICAgIG1pbWVUeXBlTmFtZSA9IG5vZGUuY29udGVudCA/IG5vZGUuY29udGVudC5taW1lVHlwZU5hbWUgOiAnJyxcbiAgICAgICAgICAgIGF1dGhvciA9IG5vZGUucHJvcGVydGllcyA/IG5vZGUucHJvcGVydGllc1snY206YXV0aG9yJ10gOiAnJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gbm9kZS5wcm9wZXJ0aWVzID8gbm9kZS5wcm9wZXJ0aWVzWydjbTpkZXNjcmlwdGlvbiddIDogJycsXG4gICAgICAgICAgICB0aXRsZSA9IG5vZGUucHJvcGVydGllcyA/IG5vZGUucHJvcGVydGllc1snY206dGl0bGUnXSA6ICcnO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgQ2FyZFZpZXdUZXh0SXRlbU1vZGVsKHtcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0NPUkUuTUVUQURBVEEuQkFTSUMuTkFNRScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgICAgICBrZXk6ICduYW1lJyxcbiAgICAgICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXcgQ2FyZFZpZXdUZXh0SXRlbU1vZGVsKHtcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0NPUkUuTUVUQURBVEEuQkFTSUMuVElUTEUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aXRsZSxcbiAgICAgICAgICAgICAgICBrZXk6ICdwcm9wZXJ0aWVzLmNtOnRpdGxlJyxcbiAgICAgICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXcgQ2FyZFZpZXdUZXh0SXRlbU1vZGVsKHtcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0NPUkUuTUVUQURBVEEuQkFTSUMuQ1JFQVRPUicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5vZGUuY3JlYXRlZEJ5VXNlci5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgICBrZXk6ICdjcmVhdGVkQnlVc2VyLmRpc3BsYXlOYW1lJyxcbiAgICAgICAgICAgICAgICBlZGl0YWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbmV3IENhcmRWaWV3RGF0ZUl0ZW1Nb2RlbCh7XG4gICAgICAgICAgICAgICAgbGFiZWw6ICdDT1JFLk1FVEFEQVRBLkJBU0lDLkNSRUFURURfREFURScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5vZGUuY3JlYXRlZEF0LFxuICAgICAgICAgICAgICAgIGtleTogJ2NyZWF0ZWRBdCcsXG4gICAgICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG5ldyBDYXJkVmlld1RleHRJdGVtTW9kZWwoe1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnQ09SRS5NRVRBREFUQS5CQVNJQy5TSVpFJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2l6ZUluQnl0ZXMsXG4gICAgICAgICAgICAgICAga2V5OiAnY29udGVudC5zaXplSW5CeXRlcycsXG4gICAgICAgICAgICAgICAgcGlwZXM6IFt7IHBpcGU6IHRoaXMuZmlsZVNpemVQaXBlIH1dLFxuICAgICAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXcgQ2FyZFZpZXdUZXh0SXRlbU1vZGVsKHtcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0NPUkUuTUVUQURBVEEuQkFTSUMuTU9ESUZJRVInLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBub2RlLm1vZGlmaWVkQnlVc2VyLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgICAgIGtleTogJ21vZGlmaWVkQnlVc2VyLmRpc3BsYXlOYW1lJyxcbiAgICAgICAgICAgICAgICBlZGl0YWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbmV3IENhcmRWaWV3RGF0ZUl0ZW1Nb2RlbCh7XG4gICAgICAgICAgICAgICAgbGFiZWw6ICdDT1JFLk1FVEFEQVRBLkJBU0lDLk1PRElGSUVEX0RBVEUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBub2RlLm1vZGlmaWVkQXQsXG4gICAgICAgICAgICAgICAga2V5OiAnbW9kaWZpZWRBdCcsXG4gICAgICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG5ldyBDYXJkVmlld1RleHRJdGVtTW9kZWwoe1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnQ09SRS5NRVRBREFUQS5CQVNJQy5NSU1FVFlQRScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1pbWVUeXBlTmFtZSxcbiAgICAgICAgICAgICAgICBrZXk6ICdjb250ZW50Lm1pbWVUeXBlTmFtZScsXG4gICAgICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG5ldyBDYXJkVmlld1RleHRJdGVtTW9kZWwoe1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnQ09SRS5NRVRBREFUQS5CQVNJQy5BVVRIT1InLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhdXRob3IsXG4gICAgICAgICAgICAgICAga2V5OiAncHJvcGVydGllcy5jbTphdXRob3InLFxuICAgICAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG5ldyBDYXJkVmlld1RleHRJdGVtTW9kZWwoe1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnQ09SRS5NRVRBREFUQS5CQVNJQy5ERVNDUklQVElPTicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIGtleTogJ3Byb3BlcnRpZXMuY206ZGVzY3JpcHRpb24nLFxuICAgICAgICAgICAgICAgIG11bHRpbGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIENhcmRWaWV3SXRlbVByb3BlcnRpZXMsXG4gICAgQ2FyZFZpZXdJdGVtLFxuICAgIENhcmRWaWV3VGV4dEl0ZW1Nb2RlbCxcbiAgICBDYXJkVmlld0Jvb2xJdGVtTW9kZWwsXG4gICAgQ2FyZFZpZXdEYXRlSXRlbU1vZGVsLFxuICAgIENhcmRWaWV3RGF0ZXRpbWVJdGVtTW9kZWwsXG4gICAgQ2FyZFZpZXdJbnRJdGVtTW9kZWwsXG4gICAgQ2FyZFZpZXdGbG9hdEl0ZW1Nb2RlbCxcbiAgICBMb2dTZXJ2aWNlXG59IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBQcm9wZXJ0eSwgQ2FyZFZpZXdHcm91cCwgT3JnYW5pc2VkUHJvcGVydHlHcm91cCB9IGZyb20gJy4uL2ludGVyZmFjZXMvY29udGVudC1tZXRhZGF0YS5pbnRlcmZhY2VzJztcblxuY29uc3QgRF9URVhUID0gJ2Q6dGV4dCc7XG5jb25zdCBEX01MVEVYVCA9ICdkOm1sdGV4dCc7XG5jb25zdCBEX0RBVEUgPSAnZDpkYXRlJztcbmNvbnN0IERfREFURVRJTUUgPSAnZDpkYXRldGltZSc7XG5jb25zdCBEX0lOVCA9ICdkOmludCc7XG5jb25zdCBEX0xPTkcgPSAnZDpsb25nJztcbmNvbnN0IERfRkxPQVQgPSAnZDpmbG9hdCc7XG5jb25zdCBEX0RPVUJMRSA9ICdkOmRvdWJsZSc7XG5jb25zdCBEX0JPT0xFQU4gPSAnZDpib29sZWFuJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFByb3BlcnR5R3JvdXBUcmFuc2xhdG9yU2VydmljZSB7XG5cbiAgICBzdGF0aWMgcmVhZG9ubHkgUkVDT0dOSVNFRF9FQ01fVFlQRVMgPSBbIERfVEVYVCwgRF9NTFRFWFQsIERfREFURSwgRF9EQVRFVElNRSwgRF9JTlQsIERfTE9ORyAsIERfRkxPQVQsIERfRE9VQkxFLCBEX0JPT0xFQU4gXTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbG9nU2VydmljZTogTG9nU2VydmljZSkge31cblxuICAgIHB1YmxpYyB0cmFuc2xhdGVUb0NhcmRWaWV3R3JvdXBzKHByb3BlcnR5R3JvdXBzOiBPcmdhbmlzZWRQcm9wZXJ0eUdyb3VwW10sIHByb3BlcnR5VmFsdWVzKTogQ2FyZFZpZXdHcm91cFtdIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5R3JvdXBzLm1hcChwcm9wZXJ0eUdyb3VwID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZWRQcm9wZXJ0eUdyb3VwOiBhbnkgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wZXJ0eUdyb3VwKTtcbiAgICAgICAgICAgIHRyYW5zbGF0ZWRQcm9wZXJ0eUdyb3VwLnByb3BlcnRpZXMgPSB0aGlzLnRyYW5zbGF0ZUFycmF5KHByb3BlcnR5R3JvdXAucHJvcGVydGllcywgcHJvcGVydHlWYWx1ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZWRQcm9wZXJ0eUdyb3VwO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRyYW5zbGF0ZUFycmF5KHByb3BlcnRpZXM6IFByb3BlcnR5W10sIHByb3BlcnR5VmFsdWVzOiBhbnkpOiBDYXJkVmlld0l0ZW1bXSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzLm1hcChwcm9wZXJ0eSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUocHJvcGVydHksIHByb3BlcnR5VmFsdWVzW3Byb3BlcnR5Lm5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0cmFuc2xhdGUocHJvcGVydHk6IFByb3BlcnR5LCBwcm9wZXJ0eVZhbHVlOiBhbnkpOiBDYXJkVmlld0l0ZW0ge1xuICAgICAgICB0aGlzLmNoZWNrRUNNVHlwZVZhbGlkaXR5KHByb3BlcnR5LmRhdGFUeXBlKTtcblxuICAgICAgICBjb25zdCBwcmVmaXggPSAncHJvcGVydGllcy4nO1xuXG4gICAgICAgIGxldCBwcm9wZXJ0eURlZmluaXRpb246IENhcmRWaWV3SXRlbVByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBsYWJlbDogcHJvcGVydHkudGl0bGUsXG4gICAgICAgICAgICB2YWx1ZTogcHJvcGVydHlWYWx1ZSxcbiAgICAgICAgICAgIGtleTogYCR7cHJlZml4fSR7cHJvcGVydHkubmFtZX1gLFxuICAgICAgICAgICAgZGVmYXVsdDogcHJvcGVydHkuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgZWRpdGFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhcmRWaWV3SXRlbVByb3BlcnR5O1xuXG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkuZGF0YVR5cGUpIHtcblxuICAgICAgICAgICAgY2FzZSBEX01MVEVYVDpcbiAgICAgICAgICAgICAgICBjYXJkVmlld0l0ZW1Qcm9wZXJ0eSA9IG5ldyBDYXJkVmlld1RleHRJdGVtTW9kZWwoT2JqZWN0LmFzc2lnbihwcm9wZXJ0eURlZmluaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlsaW5lOiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIERfSU5UOlxuICAgICAgICAgICAgY2FzZSBEX0xPTkc6XG4gICAgICAgICAgICAgICAgY2FyZFZpZXdJdGVtUHJvcGVydHkgPSBuZXcgQ2FyZFZpZXdJbnRJdGVtTW9kZWwocHJvcGVydHlEZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBEX0ZMT0FUOlxuICAgICAgICAgICAgY2FzZSBEX0RPVUJMRTpcbiAgICAgICAgICAgICAgICBjYXJkVmlld0l0ZW1Qcm9wZXJ0eSA9IG5ldyBDYXJkVmlld0Zsb2F0SXRlbU1vZGVsKHByb3BlcnR5RGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRF9EQVRFOlxuICAgICAgICAgICAgICAgIGNhcmRWaWV3SXRlbVByb3BlcnR5ID0gbmV3IENhcmRWaWV3RGF0ZUl0ZW1Nb2RlbChwcm9wZXJ0eURlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIERfREFURVRJTUU6XG4gICAgICAgICAgICAgICAgY2FyZFZpZXdJdGVtUHJvcGVydHkgPSBuZXcgQ2FyZFZpZXdEYXRldGltZUl0ZW1Nb2RlbChwcm9wZXJ0eURlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIERfQk9PTEVBTjpcbiAgICAgICAgICAgICAgICBjYXJkVmlld0l0ZW1Qcm9wZXJ0eSA9IG5ldyBDYXJkVmlld0Jvb2xJdGVtTW9kZWwocHJvcGVydHlEZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBEX1RFWFQ6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNhcmRWaWV3SXRlbVByb3BlcnR5ID0gbmV3IENhcmRWaWV3VGV4dEl0ZW1Nb2RlbChPYmplY3QuYXNzaWduKHByb3BlcnR5RGVmaW5pdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhcmRWaWV3SXRlbVByb3BlcnR5O1xuICAgIH1cblxuICAgIHByaXZhdGUgY2hlY2tFQ01UeXBlVmFsaWRpdHkoZWNtUHJvcGVydHlUeXBlKSB7XG4gICAgICAgIGlmIChQcm9wZXJ0eUdyb3VwVHJhbnNsYXRvclNlcnZpY2UuUkVDT0dOSVNFRF9FQ01fVFlQRVMuaW5kZXhPZihlY21Qcm9wZXJ0eVR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5sb2dTZXJ2aWNlLmVycm9yKGBVbmtub3duIHR5cGUgZm9yIG1hcHBpbmc6ICR7ZWNtUHJvcGVydHlUeXBlfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUHJvcGVydHlHcm91cCwgUHJvcGVydHksIFByb3BlcnR5R3JvdXBDb250YWluZXIgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2NvbnRlbnQtbWV0YWRhdGEuaW50ZXJmYWNlcyc7XG5cbmNvbnN0IGVtcHR5R3JvdXAgPSB7XG4gICAgcHJvcGVydGllczoge31cbn07XG5cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3RUb0FycmF5KG9iamVjdDogYW55KTogUHJvcGVydHlbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubWFwKGtleSA9PiBvYmplY3Rba2V5XSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHcm91cChwcm9wZXJ0eUdyb3VwczogUHJvcGVydHlHcm91cENvbnRhaW5lciwgZ3JvdXBOYW1lOiBzdHJpbmcpOiBQcm9wZXJ0eUdyb3VwIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gcHJvcGVydHlHcm91cHNbZ3JvdXBOYW1lXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BlcnR5KHByb3BlcnR5R3JvdXBzOiBQcm9wZXJ0eUdyb3VwQ29udGFpbmVyLCBncm91cE5hbWU6IHN0cmluZywgcHJvcGVydHlOYW1lOiBzdHJpbmcpOiBQcm9wZXJ0eSB8IFByb3BlcnR5W10gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGdyb3VwRGVmaW5pdGlvbiA9IGdldEdyb3VwKHByb3BlcnR5R3JvdXBzLCBncm91cE5hbWUpIHx8IGVtcHR5R3JvdXA7XG4gICAgbGV0IHByb3BlcnR5RGVmaW5pdGlvbnM7XG5cbiAgICBpZiAocHJvcGVydHlOYW1lID09PSAnKicpIHtcbiAgICAgICAgcHJvcGVydHlEZWZpbml0aW9ucyA9IGNvbnZlcnRPYmplY3RUb0FycmF5KGdyb3VwRGVmaW5pdGlvbi5wcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wZXJ0eURlZmluaXRpb25zID0gZ3JvdXBEZWZpbml0aW9uLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcGVydHlEZWZpbml0aW9ucztcbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbnRlbnRNZXRhZGF0YUNvbmZpZywgT3JnYW5pc2VkUHJvcGVydHlHcm91cCwgUHJvcGVydHlHcm91cENvbnRhaW5lciB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvY29udGVudC1tZXRhZGF0YS5pbnRlcmZhY2VzJztcbmltcG9ydCB7IGdldEdyb3VwLCBnZXRQcm9wZXJ0eSB9IGZyb20gJy4vcHJvcGVydHktZ3JvdXAtcmVhZGVyJztcblxuZXhwb3J0IGNsYXNzIEFzcGVjdE9yaWVudGVkQ29uZmlnU2VydmljZSBpbXBsZW1lbnRzIENvbnRlbnRNZXRhZGF0YUNvbmZpZyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbmZpZzogYW55KSB7fVxuXG4gICAgcHVibGljIGlzR3JvdXBBbGxvd2VkKGdyb3VwTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGdyb3VwTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbmZpZyk7XG4gICAgICAgIHJldHVybiBncm91cE5hbWVzLmluZGV4T2YoZ3JvdXBOYW1lKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgcHVibGljIHJlb3JnYW5pc2VCeUNvbmZpZyhwcm9wZXJ0eUdyb3VwczogUHJvcGVydHlHcm91cENvbnRhaW5lcik6IE9yZ2FuaXNlZFByb3BlcnR5R3JvdXBbXSB7XG4gICAgICAgIGNvbnN0IGFzcGVjdHMgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIGFzcGVjdE5hbWVzID0gT2JqZWN0LmtleXMoYXNwZWN0cyk7XG5cbiAgICAgICAgcmV0dXJuIGFzcGVjdE5hbWVzXG4gICAgICAgICAgICAucmVkdWNlKChncm91cEFjY3VtdWxhdG9yLCBhc3BlY3ROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3R3JvdXAgPSB0aGlzLmdldE9yZ2FuaXNlZFByb3BlcnR5R3JvdXAocHJvcGVydHlHcm91cHMsIGFzcGVjdE5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBncm91cEFjY3VtdWxhdG9yLmNvbmNhdChuZXdHcm91cCk7XG4gICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIob3JnYW5pc2VkUHJvcGVydHlHcm91cCA9PiBvcmdhbmlzZWRQcm9wZXJ0eUdyb3VwLnByb3BlcnRpZXMubGVuZ3RoID4gMCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRPcmdhbmlzZWRQcm9wZXJ0eUdyb3VwKHByb3BlcnR5R3JvdXBzLCBhc3BlY3ROYW1lKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gZ2V0R3JvdXAocHJvcGVydHlHcm91cHMsIGFzcGVjdE5hbWUpO1xuICAgICAgICBsZXQgbmV3R3JvdXAgPSBbXTtcblxuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGNvbnN0IGFzcGVjdFByb3BlcnRpZXMgPSB0aGlzLmNvbmZpZ1thc3BlY3ROYW1lXTtcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0aWVzO1xuXG4gICAgICAgICAgICBpZiAoYXNwZWN0UHJvcGVydGllcyA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IGdldFByb3BlcnR5KHByb3BlcnR5R3JvdXBzLCBhc3BlY3ROYW1lLCBhc3BlY3RQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyA9ICg8c3RyaW5nW10+IGFzcGVjdFByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHByb3BlcnR5TmFtZSkgPT4gZ2V0UHJvcGVydHkocHJvcGVydHlHcm91cHMsIGFzcGVjdE5hbWUsIHByb3BlcnR5TmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIocHJvcHMgPT4gcHJvcHMgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld0dyb3VwID0gWyB7IHRpdGxlOiBncm91cC50aXRsZSwgcHJvcGVydGllcyB9IF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3R3JvdXA7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29udGVudE1ldGFkYXRhQ29uZmlnLCBPcmdhbmlzZWRQcm9wZXJ0eUdyb3VwLFxuICAgIFByb3BlcnR5R3JvdXBDb250YWluZXJcbn0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9jb250ZW50LW1ldGFkYXRhLmludGVyZmFjZXMnO1xuXG5leHBvcnQgY2xhc3MgSW5kaWZmZXJlbnRDb25maWdTZXJ2aWNlIGltcGxlbWVudHMgQ29udGVudE1ldGFkYXRhQ29uZmlnIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogYW55KSB7fVxuXG4gICAgcHVibGljIGlzR3JvdXBBbGxvd2VkKGdyb3VwTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW9yZ2FuaXNlQnlDb25maWcocHJvcGVydHlHcm91cHM6IFByb3BlcnR5R3JvdXBDb250YWluZXIpOiBPcmdhbmlzZWRQcm9wZXJ0eUdyb3VwW10ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocHJvcGVydHlHcm91cHMpXG4gICAgICAgICAgICAubWFwKChncm91cE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cHNbZ3JvdXBOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnR5R3JvdXAucHJvcGVydGllcztcblxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwcm9wZXJ0eUdyb3VwLCB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLm1hcChwcm9wZXJ0eU5hbWUgPT4gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgICBDb250ZW50TWV0YWRhdGFDb25maWcsXG4gICAgTGF5b3V0T3JpZW50ZWRDb25maWdJdGVtLFxuICAgIE9yZ2FuaXNlZFByb3BlcnR5R3JvdXAsXG4gICAgUHJvcGVydHlHcm91cENvbnRhaW5lclxufSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2NvbnRlbnQtbWV0YWRhdGEuaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBnZXRQcm9wZXJ0eSB9IGZyb20gJy4vcHJvcGVydHktZ3JvdXAtcmVhZGVyJztcblxuZXhwb3J0IGNsYXNzIExheW91dE9yaWVudGVkQ29uZmlnU2VydmljZSBpbXBsZW1lbnRzIENvbnRlbnRNZXRhZGF0YUNvbmZpZyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbmZpZzogYW55KSB7fVxuXG4gICAgcHVibGljIGlzR3JvdXBBbGxvd2VkKGdyb3VwTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nR3JvdXBzKGdyb3VwTmFtZSkubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVvcmdhbmlzZUJ5Q29uZmlnKHByb3BlcnR5R3JvdXBzOiBQcm9wZXJ0eUdyb3VwQ29udGFpbmVyKTogT3JnYW5pc2VkUHJvcGVydHlHcm91cFtdIHtcbiAgICAgICAgY29uc3QgbGF5b3V0QmxvY2tzID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgcmV0dXJuIGxheW91dEJsb2Nrcy5tYXAoKGxheW91dEJsb2NrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbGF0dGVuZWRJdGVtcyA9IHRoaXMuZmxhdHRlbkl0ZW1zKGxheW91dEJsb2NrLml0ZW1zKSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gZmxhdHRlbmVkSXRlbXMucmVkdWNlKChwcm9wcywgZXhwbG9kZWRJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gZ2V0UHJvcGVydHkocHJvcGVydHlHcm91cHMsIGV4cGxvZGVkSXRlbS5ncm91cE5hbWUsIGV4cGxvZGVkSXRlbS5wcm9wZXJ0eU5hbWUpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuY29uY2F0KHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGxheW91dEJsb2NrLnRpdGxlLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZmxhdHRlbkl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gQXJyYXkuaXNBcnJheShpdGVtLnByb3BlcnRpZXMpID8gaXRlbS5wcm9wZXJ0aWVzIDogW2l0ZW0ucHJvcGVydGllc107XG4gICAgICAgICAgICBjb25zdCBmbGF0dGVuZWRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5tYXAocHJvcGVydHlOYW1lID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBncm91cE5hbWU6IGl0ZW0uYXNwZWN0IHx8IGl0ZW0udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IuY29uY2F0KGZsYXR0ZW5lZFByb3BlcnRpZXMpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRNYXRjaGluZ0dyb3Vwcyhncm91cE5hbWU6IHN0cmluZyk6IExheW91dE9yaWVudGVkQ29uZmlnSXRlbVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnXG4gICAgICAgICAgICAubWFwKGxheW91dEJsb2NrID0+IGxheW91dEJsb2NrLml0ZW1zKVxuICAgICAgICAgICAgLnJlZHVjZSgoYWNjdW11bGF0b3IsIGl0ZW1zKSA9PiBhY2N1bXVsYXRvci5jb25jYXQoaXRlbXMpLCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYXNwZWN0ID09PSBncm91cE5hbWUgfHwgaXRlbS50eXBlID09PSBncm91cE5hbWUpO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFwcENvbmZpZ1NlcnZpY2UsIExvZ1NlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgQXNwZWN0T3JpZW50ZWRDb25maWdTZXJ2aWNlIH0gZnJvbSAnLi9hc3BlY3Qtb3JpZW50ZWQtY29uZmlnLnNlcnZpY2UnO1xuaW1wb3J0IHsgSW5kaWZmZXJlbnRDb25maWdTZXJ2aWNlIH0gZnJvbSAnLi9pbmRpZmZlcmVudC1jb25maWcuc2VydmljZSc7XG5pbXBvcnQgeyBMYXlvdXRPcmllbnRlZENvbmZpZ1NlcnZpY2UgfSBmcm9tICcuL2xheW91dC1vcmllbnRlZC1jb25maWcuc2VydmljZSc7XG5pbXBvcnQge1xuICAgIFByZXNldENvbmZpZyxcbiAgICBDb250ZW50TWV0YWRhdGFDb25maWcsXG4gICAgQXNwZWN0T3JpZW50ZWRDb25maWcsXG4gICAgSW5EaWZmZXJlbnRDb25maWcsXG4gICAgTGF5b3V0T3JpZW50ZWRDb25maWdcbn0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9jb250ZW50LW1ldGFkYXRhLmludGVyZmFjZXMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29udGVudE1ldGFkYXRhQ29uZmlnRmFjdG9yeSB7XG5cbiAgICBzdGF0aWMgcmVhZG9ubHkgSU5ESUZGRVJFTlRfUFJFU0VUID0gJyonO1xuICAgIHN0YXRpYyByZWFkb25seSBERUZBVUxUX1BSRVNFVF9OQU1FID0gJ2RlZmF1bHQnO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcHBDb25maWdTZXJ2aWNlOiBBcHBDb25maWdTZXJ2aWNlLCBwcml2YXRlIGxvZ1NlcnZpY2U6IExvZ1NlcnZpY2UpIHt9XG5cbiAgICBwdWJsaWMgZ2V0KHByZXNldE5hbWU6IHN0cmluZyA9ICdkZWZhdWx0Jyk6IENvbnRlbnRNZXRhZGF0YUNvbmZpZyB7XG4gICAgICAgIGxldCBwcmVzZXRDb25maWc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcmVzZXRDb25maWcgPSB0aGlzLmFwcENvbmZpZ1NlcnZpY2UuY29uZmlnWydjb250ZW50LW1ldGFkYXRhJ10ucHJlc2V0c1twcmVzZXROYW1lXTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBpZiAocHJlc2V0TmFtZSAhPT0gQ29udGVudE1ldGFkYXRhQ29uZmlnRmFjdG9yeS5ERUZBVUxUX1BSRVNFVF9OQU1FKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dTZXJ2aWNlLmVycm9yKGBObyBjb250ZW50LW1ldGFkYXRhIHByZXNldCBmb3I6ICR7cHJlc2V0TmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXNldENvbmZpZyA9IENvbnRlbnRNZXRhZGF0YUNvbmZpZ0ZhY3RvcnkuSU5ESUZGRVJFTlRfUFJFU0VUO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29uZmlnKHByZXNldENvbmZpZyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDb25maWcocHJlc2V0Q29uZmlnOiBQcmVzZXRDb25maWcpOiBDb250ZW50TWV0YWRhdGFDb25maWcge1xuICAgICAgICBsZXQgY29uZmlnOiBDb250ZW50TWV0YWRhdGFDb25maWc7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNMYXlvdXRPcmllbnRlZFByZXNldChwcmVzZXRDb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcgPSBuZXcgTGF5b3V0T3JpZW50ZWRDb25maWdTZXJ2aWNlKDxMYXlvdXRPcmllbnRlZENvbmZpZz4gcHJlc2V0Q29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzQXNwZWN0T3JpZW50ZWRQcmVzZXQocHJlc2V0Q29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnID0gbmV3IEFzcGVjdE9yaWVudGVkQ29uZmlnU2VydmljZSg8QXNwZWN0T3JpZW50ZWRDb25maWc+IHByZXNldENvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcgPSBuZXcgSW5kaWZmZXJlbnRDb25maWdTZXJ2aWNlKDxJbkRpZmZlcmVudENvbmZpZz4gcHJlc2V0Q29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5mcmVlemUoY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzQXNwZWN0T3JpZW50ZWRQcmVzZXQocHJlc2V0Q29uZmlnOiBQcmVzZXRDb25maWcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPYmplY3QocHJlc2V0Q29uZmlnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzTGF5b3V0T3JpZW50ZWRQcmVzZXQocHJlc2V0Q29uZmlnOiBQcmVzZXRDb25maWcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocHJlc2V0Q29uZmlnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzT2JqZWN0KHgpIHtcbiAgICAgICAgcmV0dXJuIHggIT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCc7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIGRlZmVyLCBmb3JrSm9pbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUHJvcGVydHlHcm91cCwgUHJvcGVydHlHcm91cENvbnRhaW5lciB9IGZyb20gJy4uL2ludGVyZmFjZXMvY29udGVudC1tZXRhZGF0YS5pbnRlcmZhY2VzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFByb3BlcnR5RGVzY3JpcHRvcnNTZXJ2aWNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYWxmcmVzY29BcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UpIHt9XG5cbiAgICBsb2FkKGdyb3VwTmFtZXM6IHN0cmluZ1tdKTogT2JzZXJ2YWJsZTxQcm9wZXJ0eUdyb3VwQ29udGFpbmVyPiB7XG4gICAgICAgIGNvbnN0IGdyb3VwRmV0Y2hTdHJlYW1zID0gZ3JvdXBOYW1lc1xuICAgICAgICAgICAgLm1hcChncm91cE5hbWUgPT4gZ3JvdXBOYW1lLnJlcGxhY2UoJzonLCAnXycpKVxuICAgICAgICAgICAgLm1hcChncm91cE5hbWUgPT4gZGVmZXIoICgpID0+IHRoaXMuYWxmcmVzY29BcGlTZXJ2aWNlLmNsYXNzZXNBcGkuZ2V0Q2xhc3MoZ3JvdXBOYW1lKSkgKTtcblxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oZ3JvdXBGZXRjaFN0cmVhbXMpLnBpcGUoXG4gICAgICAgICAgICBtYXAodGhpcy5jb252ZXJ0VG9PYmplY3QpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb252ZXJ0VG9PYmplY3QocHJvcGVydHlHcm91cHNBcnJheTogUHJvcGVydHlHcm91cFtdKTogUHJvcGVydHlHcm91cENvbnRhaW5lciB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3Vwc0FycmF5LnJlZHVjZSgocHJvcGVydHlHcm91cHMsIHByb3BlcnR5R3JvdXApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwcm9wZXJ0eUdyb3Vwcywge1xuICAgICAgICAgICAgICAgIFtwcm9wZXJ0eUdyb3VwLm5hbWVdOiBwcm9wZXJ0eUdyb3VwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1pbmltYWxOb2RlRW50cnlFbnRpdHkgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgQmFzaWNQcm9wZXJ0aWVzU2VydmljZSB9IGZyb20gJy4vYmFzaWMtcHJvcGVydGllcy5zZXJ2aWNlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUdyb3VwVHJhbnNsYXRvclNlcnZpY2UgfSBmcm9tICcuL3Byb3BlcnR5LWdyb3Vwcy10cmFuc2xhdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2FyZFZpZXdJdGVtIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IENhcmRWaWV3R3JvdXAgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2NvbnRlbnQtbWV0YWRhdGEuaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBDb250ZW50TWV0YWRhdGFDb25maWdGYWN0b3J5IH0gZnJvbSAnLi9jb25maWcvY29udGVudC1tZXRhZGF0YS1jb25maWcuZmFjdG9yeSc7XG5pbXBvcnQgeyBQcm9wZXJ0eURlc2NyaXB0b3JzU2VydmljZSB9IGZyb20gJy4vcHJvcGVydHktZGVzY3JpcHRvcnMuc2VydmljZSc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb250ZW50TWV0YWRhdGFTZXJ2aWNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYmFzaWNQcm9wZXJ0aWVzU2VydmljZTogQmFzaWNQcm9wZXJ0aWVzU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNvbnRlbnRNZXRhZGF0YUNvbmZpZ0ZhY3Rvcnk6IENvbnRlbnRNZXRhZGF0YUNvbmZpZ0ZhY3RvcnksXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBwcm9wZXJ0eUdyb3VwVHJhbnNsYXRvclNlcnZpY2U6IFByb3BlcnR5R3JvdXBUcmFuc2xhdG9yU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHByb3BlcnR5RGVzY3JpcHRvcnNTZXJ2aWNlOiBQcm9wZXJ0eURlc2NyaXB0b3JzU2VydmljZSkge1xuICAgIH1cblxuICAgIGdldEJhc2ljUHJvcGVydGllcyhub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KTogT2JzZXJ2YWJsZTxDYXJkVmlld0l0ZW1bXT4ge1xuICAgICAgICByZXR1cm4gb2YodGhpcy5iYXNpY1Byb3BlcnRpZXNTZXJ2aWNlLmdldFByb3BlcnRpZXMobm9kZSkpO1xuICAgIH1cblxuICAgIGdldEdyb3VwZWRQcm9wZXJ0aWVzKG5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHksIHByZXNldE5hbWU6IHN0cmluZyA9ICdkZWZhdWx0Jyk6IE9ic2VydmFibGU8Q2FyZFZpZXdHcm91cFtdPiB7XG4gICAgICAgIGxldCBncm91cGVkUHJvcGVydGllcyA9IG9mKFtdKTtcblxuICAgICAgICBpZiAobm9kZS5hc3BlY3ROYW1lcykge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb250ZW50TWV0YWRhdGFDb25maWdGYWN0b3J5LmdldChwcmVzZXROYW1lKSxcbiAgICAgICAgICAgICAgICBncm91cE5hbWVzID0gbm9kZS5hc3BlY3ROYW1lc1xuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG5vZGUubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZ3JvdXBOYW1lID0+IGNvbmZpZy5pc0dyb3VwQWxsb3dlZChncm91cE5hbWUpKTtcblxuICAgICAgICAgICAgaWYgKGdyb3VwTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdyb3VwZWRQcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0eURlc2NyaXB0b3JzU2VydmljZS5sb2FkKGdyb3VwTmFtZXMpLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgIG1hcChncm91cHMgPT4gY29uZmlnLnJlb3JnYW5pc2VCeUNvbmZpZyhncm91cHMpKSxcbiAgICAgICAgICAgICAgICAgICAgbWFwKGdyb3VwcyA9PiB0aGlzLnByb3BlcnR5R3JvdXBUcmFuc2xhdG9yU2VydmljZS50cmFuc2xhdGVUb0NhcmRWaWV3R3JvdXBzKGdyb3Vwcywgbm9kZS5wcm9wZXJ0aWVzKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwZWRQcm9wZXJ0aWVzO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIFNpbXBsZUNoYW5nZXMsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudHJ5RW50aXR5IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQ2FyZFZpZXdJdGVtLCBOb2Rlc0FwaVNlcnZpY2UsIExvZ1NlcnZpY2UsIENhcmRWaWV3VXBkYXRlU2VydmljZSwgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IENvbnRlbnRNZXRhZGF0YVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb250ZW50LW1ldGFkYXRhLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2FyZFZpZXdHcm91cCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvY29udGVudC1tZXRhZGF0YS5pbnRlcmZhY2VzJztcbmltcG9ydCB7IHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtY29udGVudC1tZXRhZGF0YScsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NvbnRlbnQtbWV0YWRhdGEuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2NvbnRlbnQtbWV0YWRhdGEuY29tcG9uZW50LnNjc3MnXSxcbiAgICBob3N0OiB7ICdjbGFzcyc6ICdhZGYtY29udGVudC1tZXRhZGF0YScgfSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIENvbnRlbnRNZXRhZGF0YUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKiAocmVxdWlyZWQpIFRoZSBub2RlIGVudGl0eSB0byBmZXRjaCBtZXRhZGF0YSBhYm91dCAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eTtcblxuICAgIC8qKiBUb2dnbGVzIHdoZXRoZXIgdGhlIGVkaXQgYnV0dG9uIHNob3VsZCBiZSBzaG93biAqL1xuICAgIEBJbnB1dCgpXG4gICAgZWRpdGFibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBUb2dnbGVzIHdoZXRoZXIgdG8gZGlzcGxheSBlbXB0eSB2YWx1ZXMgaW4gdGhlIGNhcmQgdmlldyAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzcGxheUVtcHR5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogVG9nZ2xlcyBiZXR3ZWVuIGV4cGFuZGVkIChpZSwgZnVsbCBpbmZvcm1hdGlvbikgYW5kIGNvbGxhcHNlZFxuICAgICAqIChpZSwgcmVkdWNlZCBpbmZvcm1hdGlvbikgaW4gdGhlIGRpc3BsYXlcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogVGhlIG11bHRpIHBhcmFtZXRlciBvZiB0aGUgdW5kZXJseWluZyBtYXRlcmlhbCBleHBhbnNpb24gcGFuZWwsIHNldCB0byB0cnVlIHRvIGFsbG93IG11bHRpIGFjY29yZGlvbiB0byBiZSBleHBhbmRlZCBhdCB0aGUgc2FtZSB0aW1lICovXG4gICAgQElucHV0KClcbiAgICBtdWx0aSA9IGZhbHNlO1xuXG4gICAgLyoqIE5hbWUgb2YgdGhlIG1ldGFkYXRhIHByZXNldCwgd2hpY2ggZGVmaW5lcyBhc3BlY3RzIGFuZCB0aGVpciBwcm9wZXJ0aWVzICovXG4gICAgQElucHV0KClcbiAgICBwcmVzZXQ6IHN0cmluZztcblxuICAgIC8qKiBUb2dnbGVzIHdoZXRoZXIgdGhlIG1ldGFkYXRhIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNob3duICovXG4gICAgQElucHV0KClcbiAgICBkaXNwbGF5RGVmYXVsdFByb3BlcnRpZXM6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgYmFzaWNQcm9wZXJ0aWVzJDogT2JzZXJ2YWJsZTxDYXJkVmlld0l0ZW1bXT47XG4gICAgZ3JvdXBlZFByb3BlcnRpZXMkOiBPYnNlcnZhYmxlPENhcmRWaWV3R3JvdXBbXT47XG4gICAgZGlzcG9zYWJsZU5vZGVVcGRhdGU6IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGNvbnRlbnRNZXRhZGF0YVNlcnZpY2U6IENvbnRlbnRNZXRhZGF0YVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgY2FyZFZpZXdVcGRhdGVTZXJ2aWNlOiBDYXJkVmlld1VwZGF0ZVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgbm9kZXNBcGlTZXJ2aWNlOiBOb2Rlc0FwaVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgbG9nU2VydmljZTogTG9nU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBhbGZyZXNjb0FwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZVxuICAgICkge31cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGVOb2RlVXBkYXRlID0gIHRoaXMuY2FyZFZpZXdVcGRhdGVTZXJ2aWNlLml0ZW1VcGRhdGVkJFxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgc3dpdGNoTWFwKHRoaXMuc2F2ZU5vZGUuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgICAgdXBkYXRlZE5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMubm9kZSwgdXBkYXRlZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsZnJlc2NvQXBpU2VydmljZS5ub2RlVXBkYXRlZC5uZXh0KHRoaXMubm9kZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvciA9PiB0aGlzLmxvZ1NlcnZpY2UuZXJyb3IoZXJyb3IpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHRoaXMubG9hZFByb3BlcnRpZXModGhpcy5ub2RlKTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLm5vZGUgJiYgIWNoYW5nZXMubm9kZS5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkUHJvcGVydGllcyhjaGFuZ2VzLm5vZGUuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgbG9hZFByb3BlcnRpZXMobm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSkge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNpY1Byb3BlcnRpZXMkID0gdGhpcy5jb250ZW50TWV0YWRhdGFTZXJ2aWNlLmdldEJhc2ljUHJvcGVydGllcyhub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBlZFByb3BlcnRpZXMkID0gdGhpcy5jb250ZW50TWV0YWRhdGFTZXJ2aWNlLmdldEdyb3VwZWRQcm9wZXJ0aWVzKG5vZGUsIHRoaXMucHJlc2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2F2ZU5vZGUoeyBjaGFuZ2VkOiBub2RlQm9keSB9KTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzQXBpU2VydmljZS51cGRhdGVOb2RlKHRoaXMubm9kZS5pZCwgbm9kZUJvZHkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGVOb2RlVXBkYXRlLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRmxleExheW91dE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2ZsZXgtbGF5b3V0JztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXRlcmlhbE1vZHVsZSB9IGZyb20gJy4uL21hdGVyaWFsLm1vZHVsZSc7XG5pbXBvcnQgeyBDb3JlTW9kdWxlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IENvbnRlbnRNZXRhZGF0YUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9jb250ZW50LW1ldGFkYXRhL2NvbnRlbnQtbWV0YWRhdGEuY29tcG9uZW50JztcbmltcG9ydCB7IENvbnRlbnRNZXRhZGF0YUNhcmRDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvY29udGVudC1tZXRhZGF0YS1jYXJkL2NvbnRlbnQtbWV0YWRhdGEtY2FyZC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBNYXRlcmlhbE1vZHVsZSxcbiAgICAgICAgRmxleExheW91dE1vZHVsZSxcbiAgICAgICAgQ29yZU1vZHVsZS5mb3JDaGlsZCgpXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIENvbnRlbnRNZXRhZGF0YUNvbXBvbmVudCxcbiAgICAgICAgQ29udGVudE1ldGFkYXRhQ2FyZENvbXBvbmVudFxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIENvbnRlbnRNZXRhZGF0YUNvbXBvbmVudCxcbiAgICAgICAgQ29udGVudE1ldGFkYXRhQ2FyZENvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQ29udGVudE1ldGFkYXRhTW9kdWxlIHt9XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBQZXJtaXNzaW9uRWxlbWVudCB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5cbmV4cG9ydCBjbGFzcyBQZXJtaXNzaW9uRGlzcGxheU1vZGVsIGltcGxlbWVudHMgUGVybWlzc2lvbkVsZW1lbnQge1xuXG4gICAgYXV0aG9yaXR5SWQ/OiBzdHJpbmc7XG4gICAgbmFtZT86IHN0cmluZztcbiAgICBhY2Nlc3NTdGF0dXM/OiBQZXJtaXNzaW9uRWxlbWVudC5BY2Nlc3NTdGF0dXNFbnVtO1xuICAgIGlzSW5oZXJpdGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgaWNvbjogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3Iob2JqPzogYW55KSB7XG4gICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5SWQgPSBvYmouYXV0aG9yaXR5SWQ7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBvYmoubmFtZTtcbiAgICAgICAgICAgIHRoaXMuYWNjZXNzU3RhdHVzID0gb2JqLmFjY2Vzc1N0YXR1cztcbiAgICAgICAgICAgIHRoaXMuaXNJbmhlcml0ZWQgPSBvYmouaXNJbmhlcml0ZWQgIT09IG51bGwgJiYgb2JqLmlzSW5oZXJpdGVkICE9PSB1bmRlZmluZWQgPyBvYmouaXNJbmhlcml0ZWQgOiBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaWNvbiA9IG9iai5pY29uID8gb2JqLmljb24gOiAndnBuX2tleSc7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiwgZnJvbSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlLCBTZWFyY2hTZXJ2aWNlLCBOb2Rlc0FwaVNlcnZpY2UsIFRyYW5zbGF0aW9uU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBRdWVyeUJvZHksIE1pbmltYWxOb2RlRW50cnlFbnRpdHksIE1pbmltYWxOb2RlRW50aXR5LCBQYXRoRWxlbWVudCwgR3JvdXBNZW1iZXJFbnRyeSwgR3JvdXBzUGFnaW5nLCBHcm91cE1lbWJlclBhZ2luZywgUGVybWlzc2lvbkVsZW1lbnQgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgc3dpdGNoTWFwLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOb2RlUGVybWlzc2lvblNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBzZWFyY2hBcGlTZXJ2aWNlOiBTZWFyY2hTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgbm9kZVNlcnZpY2U6IE5vZGVzQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHRyYW5zbGF0aW9uOiBUcmFuc2xhdGlvblNlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiByb2xlcyBmb3IgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgcm9sZXNcbiAgICAgKi9cbiAgICBnZXROb2RlUm9sZXMobm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSk6IE9ic2VydmFibGU8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3QgcmV0cmlldmVTaXRlUXVlcnlCb2R5OiBRdWVyeUJvZHkgPSB0aGlzLmJ1aWxkUmV0cmlldmVTaXRlUXVlcnlCb2R5KG5vZGUucGF0aC5lbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaEFwaVNlcnZpY2Uuc2VhcmNoQnlRdWVyeUJvZHkocmV0cmlldmVTaXRlUXVlcnlCb2R5KVxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgc3dpdGNoTWFwKChzaXRlTm9kZUxpc3Q6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHNpdGVOb2RlTGlzdC5saXN0LmVudHJpZXMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXRlTmFtZSA9IHNpdGVOb2RlTGlzdC5saXN0LmVudHJpZXNbMF0uZW50cnkubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEdyb3VwTWVtYmVyc0J5U2l0ZU5hbWUoc2l0ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKG5vZGUucGVybWlzc2lvbnMuc2V0dGFibGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcGVybWlzc2lvbiByb2xlIGZvciBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGUgVGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0gdXBkYXRlZFBlcm1pc3Npb25Sb2xlIFBlcm1pc3Npb24gcm9sZSB0byB1cGRhdGUgb3IgYWRkXG4gICAgICogQHJldHVybnMgTm9kZSB3aXRoIHVwZGF0ZWQgcGVybWlzc2lvblxuICAgICAqL1xuICAgIHVwZGF0ZVBlcm1pc3Npb25Sb2xlKG5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHksIHVwZGF0ZWRQZXJtaXNzaW9uUm9sZTogUGVybWlzc2lvbkVsZW1lbnQpOiBPYnNlcnZhYmxlPE1pbmltYWxOb2RlRW50cnlFbnRpdHk+IHtcbiAgICAgICAgbGV0IHBlcm1pc3Npb25Cb2R5ID0geyBwZXJtaXNzaW9uczogeyBsb2NhbGx5U2V0OiBbXX0gfTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBub2RlLnBlcm1pc3Npb25zLmxvY2FsbHlTZXQubWFwKChwZXJtaXNzaW9uKSA9PiBwZXJtaXNzaW9uLmF1dGhvcml0eUlkKS5pbmRleE9mKHVwZGF0ZWRQZXJtaXNzaW9uUm9sZS5hdXRob3JpdHlJZCk7XG4gICAgICAgIHBlcm1pc3Npb25Cb2R5LnBlcm1pc3Npb25zLmxvY2FsbHlTZXQgPSBwZXJtaXNzaW9uQm9keS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0LmNvbmNhdChub2RlLnBlcm1pc3Npb25zLmxvY2FsbHlTZXQpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBwZXJtaXNzaW9uQm9keS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0W2luZGV4XSA9IHVwZGF0ZWRQZXJtaXNzaW9uUm9sZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcm1pc3Npb25Cb2R5LnBlcm1pc3Npb25zLmxvY2FsbHlTZXQucHVzaCh1cGRhdGVkUGVybWlzc2lvblJvbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVTZXJ2aWNlLnVwZGF0ZU5vZGUobm9kZS5pZCwgcGVybWlzc2lvbkJvZHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwZXJtaXNzaW9ucyBmb3IgYSBub2RlLlxuICAgICAqIEBwYXJhbSBub2RlSWQgSUQgb2YgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb25MaXN0IE5ldyBwZXJtaXNzaW9uIHNldHRpbmdzXG4gICAgICogQHJldHVybnMgTm9kZSB3aXRoIHVwZGF0ZWQgcGVybWlzc2lvbnNcbiAgICAgKi9cbiAgICB1cGRhdGVOb2RlUGVybWlzc2lvbnMobm9kZUlkOiBzdHJpbmcsIHBlcm1pc3Npb25MaXN0OiBNaW5pbWFsTm9kZUVudGl0eVtdKTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiB7XG4gICAgICAgcmV0dXJuIHRoaXMubm9kZVNlcnZpY2UuZ2V0Tm9kZShub2RlSWQpLnBpcGUoXG4gICAgICAgICAgIHN3aXRjaE1hcChub2RlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROb2RlUm9sZXMobm9kZSkucGlwZShcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoTWFwKChub2RlUm9sZXMpID0+IG9mKHtub2RlLCBub2RlUm9sZXN9KSApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc3dpdGNoTWFwKCh7bm9kZSwgbm9kZVJvbGVzfSkgPT4gdGhpcy51cGRhdGVMb2NhbGx5U2V0UGVybWlzc2lvbnMobm9kZSwgcGVybWlzc2lvbkxpc3QsIG5vZGVSb2xlcykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbG9jYWxseSBzZXQgcGVybWlzc2lvbnMgZm9yIGEgbm9kZS5cbiAgICAgKiBAcGFyYW0gbm9kZSBJRCBvZiB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZXMgUGVybWlzc2lvbiBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSBub2RlUm9sZSBQZXJtaXNzaW9uIHJvbGVcbiAgICAgKiBAcmV0dXJucyBOb2RlIHdpdGggdXBkYXRlZCBwZXJtaXNzaW9uc1xuICAgICAqL1xuICAgIHVwZGF0ZUxvY2FsbHlTZXRQZXJtaXNzaW9ucyhub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5LCBub2RlczogTWluaW1hbE5vZGVFbnRpdHlbXSwgbm9kZVJvbGU6IHN0cmluZ1tdKTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiB7XG4gICAgICAgIGxldCBwZXJtaXNzaW9uQm9keSA9IHsgcGVybWlzc2lvbnM6IHsgbG9jYWxseVNldDogW119IH07XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25MaXN0ID0gdGhpcy50cmFuc2Zvcm1Ob2RlVG9QZXJtaXNzaW9uRWxlbWVudChub2Rlcywgbm9kZVJvbGVbMF0pO1xuICAgICAgICBjb25zdCBkdXBsaWNhdGVkUGVybWlzc2lvbnMgPSB0aGlzLmdldER1cGxpY2F0ZWRQZXJtaXNzaW9ucyhub2RlLnBlcm1pc3Npb25zLmxvY2FsbHlTZXQsIHBlcm1pc3Npb25MaXN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZWRQZXJtaXNzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gZHVwbGljYXRlZFBlcm1pc3Npb25zLm1hcCgocGVybWlzc2lvbikgPT4gJ2F1dGhvcml0eSAtPiAnICsgcGVybWlzc2lvbi5hdXRob3JpdHlJZCArICcgLyByb2xlIC0+ICcgKyBwZXJtaXNzaW9uLm5hbWUpLmpvaW4oJywgJyk7XG4gICAgICAgICAgICBjb25zdCBkdXBsaWNhdGVQZXJtaXNzaW9uTWVzc2FnZTogc3RyaW5nID0gdGhpcy50cmFuc2xhdGlvbi5pbnN0YW50KCdQRVJNSVNTSU9OX01BTkFHRVIuRVJST1IuRFVQTElDQVRFLVBFUk1JU1NJT04nLCAge2xpc3R9KTtcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGR1cGxpY2F0ZVBlcm1pc3Npb25NZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBwZXJtaXNzaW9uQm9keS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0ID0gbm9kZS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0ID8gbm9kZS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0LmNvbmNhdChwZXJtaXNzaW9uTGlzdCkgOiBwZXJtaXNzaW9uTGlzdDtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZVNlcnZpY2UudXBkYXRlTm9kZShub2RlLmlkLCBwZXJtaXNzaW9uQm9keSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXREdXBsaWNhdGVkUGVybWlzc2lvbnMobm9kZUxvY2FsbHlTZXQ6IFBlcm1pc3Npb25FbGVtZW50W10sIHBlcm1pc3Npb25MaXN0QWRkZWQ6IFBlcm1pc3Npb25FbGVtZW50W10pOiBQZXJtaXNzaW9uRWxlbWVudFtdIHtcbiAgICAgICAgbGV0IGR1cGxpY2F0ZVBlcm1pc3Npb25zOiBQZXJtaXNzaW9uRWxlbWVudFtdID0gW107XG4gICAgICAgIGlmIChub2RlTG9jYWxseVNldCkge1xuICAgICAgICAgICAgcGVybWlzc2lvbkxpc3RBZGRlZC5mb3JFYWNoKChwZXJtaXNzaW9uOiBQZXJtaXNzaW9uRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IG5vZGVMb2NhbGx5U2V0LmZpbmQoKGxvY2FsUGVybWlzc2lvbikgPT4gdGhpcy5pc0VxdWFsUGVybWlzc2lvbihsb2NhbFBlcm1pc3Npb24sIHBlcm1pc3Npb24pKTtcbiAgICAgICAgICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZVBlcm1pc3Npb25zLnB1c2goZHVwbGljYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHVwbGljYXRlUGVybWlzc2lvbnM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0VxdWFsUGVybWlzc2lvbihvbGRQZXJtaXNzaW9uOiBQZXJtaXNzaW9uRWxlbWVudCwgbmV3UGVybWlzc2lvbjogUGVybWlzc2lvbkVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIG9sZFBlcm1pc3Npb24uYWNjZXNzU3RhdHVzID09PSBuZXdQZXJtaXNzaW9uLmFjY2Vzc1N0YXR1cyAmJlxuICAgICAgICAgICAgICAgb2xkUGVybWlzc2lvbi5hdXRob3JpdHlJZCA9PT0gbmV3UGVybWlzc2lvbi5hdXRob3JpdHlJZCAmJlxuICAgICAgICAgICAgICAgb2xkUGVybWlzc2lvbi5uYW1lID09PSBuZXdQZXJtaXNzaW9uLm5hbWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0cmFuc2Zvcm1Ob2RlVG9QZXJtaXNzaW9uRWxlbWVudChub2RlczogTWluaW1hbE5vZGVFbnRpdHlbXSwgbm9kZVJvbGU6IGFueSk6IFBlcm1pc3Npb25FbGVtZW50W10ge1xuICAgICAgICByZXR1cm4gbm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3UGVybWlzc2lvbkVsZW1lbnQ6IFBlcm1pc3Npb25FbGVtZW50ID0gPFBlcm1pc3Npb25FbGVtZW50PiB7XG4gICAgICAgICAgICAgICAgJ2F1dGhvcml0eUlkJzogbm9kZS5lbnRyeS5wcm9wZXJ0aWVzWydjbTphdXRob3JpdHlOYW1lJ10gP1xuICAgICAgICAgICAgICAgICAgICBub2RlLmVudHJ5LnByb3BlcnRpZXNbJ2NtOmF1dGhvcml0eU5hbWUnXSA6XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZW50cnkucHJvcGVydGllc1snY206dXNlck5hbWUnXSxcbiAgICAgICAgICAgICAgICAnbmFtZSc6IG5vZGVSb2xlLFxuICAgICAgICAgICAgICAgICdhY2Nlc3NTdGF0dXMnOiAnQUxMT1dFRCdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3UGVybWlzc2lvbkVsZW1lbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBwZXJtaXNzaW9uIHNldHRpbmcgZnJvbSBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGUgSUQgb2YgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb25Ub1JlbW92ZSBQZXJtaXNzaW9uIHNldHRpbmcgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybnMgTm9kZSB3aXRoIG1vZGlmaWVkIHBlcm1pc3Npb25zXG4gICAgICovXG4gICAgcmVtb3ZlUGVybWlzc2lvbihub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5LCBwZXJtaXNzaW9uVG9SZW1vdmU6IFBlcm1pc3Npb25FbGVtZW50KTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiB7XG4gICAgICAgIGxldCBwZXJtaXNzaW9uQm9keSA9IHsgcGVybWlzc2lvbnM6IHsgbG9jYWxseVNldDogW10gfSB9O1xuICAgICAgICBjb25zdCBpbmRleCA9IG5vZGUucGVybWlzc2lvbnMubG9jYWxseVNldC5tYXAoKHBlcm1pc3Npb24pID0+IHBlcm1pc3Npb24uYXV0aG9yaXR5SWQpLmluZGV4T2YocGVybWlzc2lvblRvUmVtb3ZlLmF1dGhvcml0eUlkKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgbm9kZS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBwZXJtaXNzaW9uQm9keS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0ID0gbm9kZS5wZXJtaXNzaW9ucy5sb2NhbGx5U2V0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZVNlcnZpY2UudXBkYXRlTm9kZShub2RlLmlkLCBwZXJtaXNzaW9uQm9keSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEdyb3VwTWVtYmVyc0J5U2l0ZU5hbWUoc2l0ZU5hbWU6IHN0cmluZyk6IE9ic2VydmFibGU8c3RyaW5nW10+IHtcbiAgICAgICAgY29uc3QgZ3JvdXBOYW1lID0gJ0dST1VQX3NpdGVfJyArIHNpdGVOYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcm91cE1lbWViZXJCeUdyb3VwTmFtZShncm91cE5hbWUpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKHJlczogR3JvdXBzUGFnaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXNwbGF5UmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXMubGlzdC5lbnRyaWVzLmZvckVhY2goKG1lbWJlcjogR3JvdXBNZW1iZXJFbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheVJlc3VsdC5wdXNoKHRoaXMuZm9ybWF0dGVkUm9sZU5hbWUobWVtYmVyLmVudHJ5LmRpc3BsYXlOYW1lLCAnc2l0ZV8nICsgc2l0ZU5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXNwbGF5UmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIG1lbWJlcnMgcmVsYXRlZCB0byBhIGdyb3VwIG5hbWUuXG4gICAgICogQHBhcmFtIGdyb3VwTmFtZSBOYW1lIG9mIGdyb3VwIHRvIGxvb2sgZm9yIG1lbWJlcnNcbiAgICAgKiBAcGFyYW0gb3B0cyBFeHRyYSBvcHRpb25zIHN1cHBvcnRlZCBieSBKU0FQSVxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgbWVtYmVyc1xuICAgICAqL1xuICAgIGdldEdyb3VwTWVtZWJlckJ5R3JvdXBOYW1lKGdyb3VwTmFtZTogc3RyaW5nLCBvcHRzPzogYW55KTogT2JzZXJ2YWJsZTxHcm91cE1lbWJlclBhZ2luZz4ge1xuICAgICAgICByZXR1cm4gZnJvbTxHcm91cE1lbWJlclBhZ2luZz4odGhpcy5hcGlTZXJ2aWNlLmdyb3Vwc0FwaS5nZXRHcm91cE1lbWJlcnMoZ3JvdXBOYW1lLCBvcHRzKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmb3JtYXR0ZWRSb2xlTmFtZShkaXNwbGF5TmFtZSwgc2l0ZU5hbWUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gZGlzcGxheU5hbWUucmVwbGFjZShzaXRlTmFtZSArICdfJywgJycpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYnVpbGRSZXRyaWV2ZVNpdGVRdWVyeUJvZHkobm9kZVBhdGg6IFBhdGhFbGVtZW50W10pOiBRdWVyeUJvZHkge1xuICAgICAgICBjb25zdCBwYXRoTmFtZXMgPSBub2RlUGF0aC5tYXAoKG5vZGU6IFBhdGhFbGVtZW50KSA9PiAnbmFtZTogXCInICsgbm9kZS5uYW1lICsgJ1wiJyk7XG4gICAgICAgIGNvbnN0IGJ1aWxkZWRQYXRoTmFtZXMgPSBwYXRoTmFtZXMuam9pbignIE9SICcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3F1ZXJ5Jzoge1xuICAgICAgICAgICAgICAgICdxdWVyeSc6IGJ1aWxkZWRQYXRoTmFtZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncGFnaW5nJzoge1xuICAgICAgICAgICAgICAgICdtYXhJdGVtcyc6IDEwMCxcbiAgICAgICAgICAgICAgICAnc2tpcENvdW50JzogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdpbmNsdWRlJzogWydhc3BlY3ROYW1lcycsICdwcm9wZXJ0aWVzJ10sXG4gICAgICAgICAgICAnZmlsdGVyUXVlcmllcyc6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICdxdWVyeSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlRZUEU6J3N0OnNpdGUnXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuXG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9uLCBJbnB1dCwgT25Jbml0LCBFdmVudEVtaXR0ZXIsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTm9kZXNBcGlTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IE1pbmltYWxOb2RlRW50cnlFbnRpdHksIFBlcm1pc3Npb25FbGVtZW50IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IFBlcm1pc3Npb25EaXNwbGF5TW9kZWwgfSBmcm9tICcuLi8uLi9tb2RlbHMvcGVybWlzc2lvbi5tb2RlbCc7XG5pbXBvcnQgeyBOb2RlUGVybWlzc2lvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9ub2RlLXBlcm1pc3Npb24uc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXBlcm1pc3Npb24tbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3Blcm1pc3Npb24tbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vcGVybWlzc2lvbi1saXN0LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBQZXJtaXNzaW9uTGlzdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvKiogSUQgb2YgdGhlIG5vZGUgd2hvc2UgcGVybWlzc2lvbnMgeW91IHdhbnQgdG8gc2hvdy4gKi9cbiAgICBASW5wdXQoKVxuICAgIG5vZGVJZDogc3RyaW5nID0gJyc7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSBwZXJtaXNzaW9uIGlzIHVwZGF0ZWQuICovXG4gICAgQE91dHB1dCgpXG4gICAgdXBkYXRlOiBFdmVudEVtaXR0ZXI8UGVybWlzc2lvbkVsZW1lbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMuICovXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgcGVybWlzc2lvbkxpc3Q6IFBlcm1pc3Npb25EaXNwbGF5TW9kZWxbXTtcbiAgICBzZXR0YWJsZVJvbGVzOiBhbnlbXTtcbiAgICBhY3R1YWxOb2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBub2RlU2VydmljZTogTm9kZXNBcGlTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgbm9kZVBlcm1pc3Npb25TZXJ2aWNlOiBOb2RlUGVybWlzc2lvblNlcnZpY2UpIHtcblxuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmZldGNoTm9kZVBlcm1pc3Npb25zKCk7XG4gICAgfVxuXG4gICAgcmVsb2FkKCkge1xuICAgICAgICB0aGlzLmZldGNoTm9kZVBlcm1pc3Npb25zKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmZXRjaE5vZGVQZXJtaXNzaW9ucygpIHtcbiAgICAgICAgdGhpcy5ub2RlU2VydmljZS5nZXROb2RlKHRoaXMubm9kZUlkKS5zdWJzY3JpYmUoKG5vZGU6IE1pbmltYWxOb2RlRW50cnlFbnRpdHkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0dWFsTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25MaXN0ID0gdGhpcy5nZXRQZXJtaXNzaW9uTGlzdChub2RlKTtcbiAgICAgICAgICAgIHRoaXMubm9kZVBlcm1pc3Npb25TZXJ2aWNlLmdldE5vZGVSb2xlcyhub2RlKS5zdWJzY3JpYmUoKHNldHRhYmxlTGlzdDogc3RyaW5nW10pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRhYmxlUm9sZXMgPSAgc2V0dGFibGVMaXN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0UGVybWlzc2lvbkxpc3Qobm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSk6IFBlcm1pc3Npb25EaXNwbGF5TW9kZWxbXSB7XG4gICAgICAgIGxldCBhbGxQZXJtaXNzaW9uczogUGVybWlzc2lvbkRpc3BsYXlNb2RlbFtdID0gW107XG4gICAgICAgIGlmIChub2RlLnBlcm1pc3Npb25zLmxvY2FsbHlTZXQpIHtcbiAgICAgICAgICAgIG5vZGUucGVybWlzc2lvbnMubG9jYWxseVNldC5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcGVybWlzc2lvbiA9IG5ldyBQZXJtaXNzaW9uRGlzcGxheU1vZGVsKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGFsbFBlcm1pc3Npb25zLnB1c2gocGVybWlzc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5wZXJtaXNzaW9ucy5pbmhlcml0ZWQpIHtcbiAgICAgICAgICAgIG5vZGUucGVybWlzc2lvbnMuaW5oZXJpdGVkLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwZXJtaXNzaW9uSW5oZXJpdGVkID0gbmV3IFBlcm1pc3Npb25EaXNwbGF5TW9kZWwoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbkluaGVyaXRlZC5pc0luaGVyaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWxsUGVybWlzc2lvbnMucHVzaChwZXJtaXNzaW9uSW5oZXJpdGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxQZXJtaXNzaW9ucztcbiAgICB9XG5cbiAgICBzYXZlTmV3Um9sZShldmVudDogYW55LCBwZXJtaXNzaW9uUm93OiBQZXJtaXNzaW9uRGlzcGxheU1vZGVsKSB7XG4gICAgICAgIGxldCB1cGRhdGVkUGVybWlzc2lvblJvbGU6IFBlcm1pc3Npb25FbGVtZW50ID0gdGhpcy5idWlsZFVwZGF0ZWRQZXJtaXNzaW9uKGV2ZW50LnZhbHVlLCBwZXJtaXNzaW9uUm93KTtcbiAgICAgICAgdGhpcy5ub2RlUGVybWlzc2lvblNlcnZpY2UudXBkYXRlUGVybWlzc2lvblJvbGUodGhpcy5hY3R1YWxOb2RlLCB1cGRhdGVkUGVybWlzc2lvblJvbGUpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChub2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUuZW1pdCh1cGRhdGVkUGVybWlzc2lvblJvbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBidWlsZFVwZGF0ZWRQZXJtaXNzaW9uKG5ld1JvbGU6IHN0cmluZywgcGVybWlzc2lvblJvdzogUGVybWlzc2lvbkRpc3BsYXlNb2RlbCk6IFBlcm1pc3Npb25FbGVtZW50IHtcbiAgICAgICAgbGV0IHBlcm1pc3Npb25Sb2xlOiBQZXJtaXNzaW9uRWxlbWVudCA9IHt9O1xuICAgICAgICBwZXJtaXNzaW9uUm9sZS5hY2Nlc3NTdGF0dXMgPSBwZXJtaXNzaW9uUm93LmFjY2Vzc1N0YXR1cztcbiAgICAgICAgcGVybWlzc2lvblJvbGUubmFtZSA9IG5ld1JvbGU7XG4gICAgICAgIHBlcm1pc3Npb25Sb2xlLmF1dGhvcml0eUlkID0gcGVybWlzc2lvblJvdy5hdXRob3JpdHlJZDtcbiAgICAgICAgcmV0dXJuIHBlcm1pc3Npb25Sb2xlO1xuICAgIH1cblxuICAgIHJlbW92ZVBlcm1pc3Npb24ocGVybWlzc2lvblJvdzogUGVybWlzc2lvbkRpc3BsYXlNb2RlbCkge1xuICAgICAgICB0aGlzLm5vZGVQZXJtaXNzaW9uU2VydmljZS5yZW1vdmVQZXJtaXNzaW9uKHRoaXMuYWN0dWFsTm9kZSwgcGVybWlzc2lvblJvdykuc3Vic2NyaWJlKChub2RlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5vZGUpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHRoaXMuZXJyb3IuZW1pdChlcnJvcikpO1xuICAgIH1cblxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogdHNsaW50OmRpc2FibGU6bm8taW5wdXQtcmVuYW1lICAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtbm8tcGVybWlzc2lvbi10ZW1wbGF0ZScsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBOb1Blcm1pc3Npb25UZW1wbGF0ZUNvbXBvbmVudCB7fVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogdHNsaW50OmRpc2FibGU6bm8taW5wdXQtcmVuYW1lICAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5vZGVzQXBpU2VydmljZSwgQ29udGVudFNlcnZpY2UsIFBlcm1pc3Npb25zRW51bSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudHJ5RW50aXR5IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdidXR0b25bYWRmLWluaGVyaXQtcGVybWlzc2lvbl0sIG1hdC1idXR0b24tdG9nZ2xlW2FkZi1pbmhlcml0LXBlcm1pc3Npb25dJyxcbiAgICBob3N0OiB7XG4gICAgICAgICdyb2xlJzogJ2J1dHRvbicsXG4gICAgICAgICcoY2xpY2spJzogJ29uSW5oZXJpdFBlcm1pc3Npb25DbGlja2VkKCknXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBJbmhlcml0UGVybWlzc2lvbkRpcmVjdGl2ZSB7XG5cbiAgICAvKiogSUQgb2YgdGhlIG5vZGUgdG8gYWRkL3JlbW92ZSBpbmhlcml0ZWQgcGVybWlzc2lvbnMuICovXG4gICAgQElucHV0KClcbiAgICBub2RlSWQ6IHN0cmluZztcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIG5vZGUgaXMgdXBkYXRlZC4gKi9cbiAgICBAT3V0cHV0KClcbiAgICB1cGRhdGVkOiBFdmVudEVtaXR0ZXI8TWluaW1hbE5vZGVFbnRyeUVudGl0eT4gPSBuZXcgRXZlbnRFbWl0dGVyPE1pbmltYWxOb2RlRW50cnlFbnRpdHk+KCk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3Vycy4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBlcnJvcjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbm9kZVNlcnZpY2U6IE5vZGVzQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNvbnRlbnRTZXJ2aWNlOiBDb250ZW50U2VydmljZSkge1xuICAgIH1cblxuICAgIG9uSW5oZXJpdFBlcm1pc3Npb25DbGlja2VkKCkge1xuICAgICAgICB0aGlzLm5vZGVTZXJ2aWNlLmdldE5vZGUodGhpcy5ub2RlSWQpLnN1YnNjcmliZSgobm9kZTogTWluaW1hbE5vZGVFbnRyeUVudGl0eSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudFNlcnZpY2UuaGFzUGVybWlzc2lvbihub2RlLCBQZXJtaXNzaW9uc0VudW0uVVBEQVRFUEVSTUlTU0lPTlMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUJvZHkgPSB7IHBlcm1pc3Npb25zOiB7IGlzSW5oZXJpdGFuY2VFbmFibGVkOiAhbm9kZS5wZXJtaXNzaW9ucy5pc0luaGVyaXRhbmNlRW5hYmxlZCB9IH07XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU2VydmljZS51cGRhdGVOb2RlKHRoaXMubm9kZUlkLCBub2RlQm9keSwgeyBpbmNsdWRlOiBbJ3Blcm1pc3Npb25zJ10gfSkuc3Vic2NyaWJlKChub2RlVXBkYXRlZDogTWluaW1hbE5vZGVFbnRyeUVudGl0eSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZWQuZW1pdChub2RlVXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB0aGlzLmVycm9yLmVtaXQoZXJyb3IpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvci5lbWl0KCdQRVJNSVNTSU9OX01BTkFHRVIuRVJST1IuTk9ULUFMTE9XRUQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9uLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1pbmltYWxOb2RlRW50aXR5LCBNaW5pbWFsTm9kZUVudHJ5RW50aXR5IH0gZnJvbSAnYWxmcmVzY28tanMtYXBpJztcbmltcG9ydCB7IE5vZGVQZXJtaXNzaW9uU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL25vZGUtcGVybWlzc2lvbi5zZXJ2aWNlJztcbmltcG9ydCB7IE5vZGVzQXBpU2VydmljZSwgQ29udGVudFNlcnZpY2UsIFBlcm1pc3Npb25zRW51bSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWFkZC1wZXJtaXNzaW9uJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vYWRkLXBlcm1pc3Npb24uY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2FkZC1wZXJtaXNzaW9uLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBBZGRQZXJtaXNzaW9uQ29tcG9uZW50IHtcblxuICAgIC8qKiBJRCBvZiB0aGUgdGFyZ2V0IG5vZGUuICovXG4gICAgQElucHV0KClcbiAgICBub2RlSWQ6IHN0cmluZztcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIG5vZGUgaXMgdXBkYXRlZCBzdWNjZXNzZnVsbHkuICovXG4gICAgQE91dHB1dCgpXG4gICAgc3VjY2VzczogRXZlbnRFbWl0dGVyPE1pbmltYWxOb2RlRW50cnlFbnRpdHk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIHRoZSB1cGRhdGUuICovXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgc2VsZWN0ZWRJdGVtczogTWluaW1hbE5vZGVFbnRpdHlbXSA9IFtdO1xuICAgIGN1cnJlbnROb2RlOiBNaW5pbWFsTm9kZUVudHJ5RW50aXR5O1xuICAgIGN1cnJlbnROb2RlUm9sZXM6IHN0cmluZ1tdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBub2RlUGVybWlzc2lvblNlcnZpY2U6IE5vZGVQZXJtaXNzaW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIG5vZGVBcGlTZXJ2aWNlOiBOb2Rlc0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBjb250ZW50U2VydmljZTogQ29udGVudFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5ub2RlQXBpU2VydmljZS5nZXROb2RlKHRoaXMubm9kZUlkKS5zdWJzY3JpYmUoKG5vZGUpID0+IHRoaXMuY3VycmVudE5vZGUgPSBub2RlKTtcbiAgICB9XG5cbiAgICBvblNlbGVjdChzZWxlY3Rpb246IE1pbmltYWxOb2RlRW50aXR5W10pIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zID0gc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIGlzQWRkRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFNlcnZpY2UuaGFzUGVybWlzc2lvbih0aGlzLmN1cnJlbnROb2RlLCBQZXJtaXNzaW9uc0VudW0uVVBEQVRFUEVSTUlTU0lPTlMpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aCAhPT0gMDtcbiAgICB9XG5cbiAgICBhcHBseVNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudFNlcnZpY2UuaGFzUGVybWlzc2lvbih0aGlzLmN1cnJlbnROb2RlLCBQZXJtaXNzaW9uc0VudW0uVVBEQVRFUEVSTUlTU0lPTlMpKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVQZXJtaXNzaW9uU2VydmljZS51cGRhdGVOb2RlUGVybWlzc2lvbnModGhpcy5ub2RlSWQsIHRoaXMuc2VsZWN0ZWRJdGVtcylcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgICAgICAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWNjZXNzLmVtaXQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvci5lbWl0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb24sIEluamVjdCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNQVRfRElBTE9HX0RBVEEgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBBZGRQZXJtaXNzaW9uRGlhbG9nRGF0YSB9IGZyb20gJy4vYWRkLXBlcm1pc3Npb24tZGlhbG9nLWRhdGEuaW50ZXJmYWNlJztcbmltcG9ydCB7IEFkZFBlcm1pc3Npb25Db21wb25lbnQgfSBmcm9tICcuLi9hZGQtcGVybWlzc2lvbi9hZGQtcGVybWlzc2lvbi5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1hZGQtcGVybWlzc2lvbi1kaWFsb2cnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9hZGQtcGVybWlzc2lvbi1kaWFsb2cuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2FkZC1wZXJtaXNzaW9uLWRpYWxvZy5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgQWRkUGVybWlzc2lvbkRpYWxvZ0NvbXBvbmVudCB7XG5cbiAgICBAVmlld0NoaWxkKCdhZGRQZXJtaXNzaW9uJylcbiAgICBhZGRQZXJtaXNzaW9uQ29tcG9uZW50OiBBZGRQZXJtaXNzaW9uQ29tcG9uZW50O1xuXG4gICAgY3VycmVudFNlbGVjdGlvbjogTWluaW1hbE5vZGVFbnRpdHlbXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IoQEluamVjdChNQVRfRElBTE9HX0RBVEEpIHB1YmxpYyBkYXRhOiBBZGRQZXJtaXNzaW9uRGlhbG9nRGF0YSkge1xuICAgIH1cblxuICAgIG9uU2VsZWN0KGl0ZW1zOiBNaW5pbWFsTm9kZUVudGl0eVtdKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbiA9IGl0ZW1zO1xuICAgIH1cblxuICAgIG9uQWRkQ2xpY2tlZCgpIHtcbiAgICAgICAgdGhpcy5kYXRhLmNvbmZpcm0ubmV4dCh0aGlzLmN1cnJlbnRTZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLmRhdGEuY29uZmlybS5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IE1hdERpYWxvZyB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QsIE9ic2VydmFibGUsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEFkZFBlcm1pc3Npb25EaWFsb2dDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnRzL2FkZC1wZXJtaXNzaW9uL2FkZC1wZXJtaXNzaW9uLWRpYWxvZy5jb21wb25lbnQnO1xuaW1wb3J0IHsgQWRkUGVybWlzc2lvbkRpYWxvZ0RhdGEgfSBmcm9tICcuLi9jb21wb25lbnRzL2FkZC1wZXJtaXNzaW9uL2FkZC1wZXJtaXNzaW9uLWRpYWxvZy1kYXRhLmludGVyZmFjZSc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudGl0eSwgTWluaW1hbE5vZGVFbnRyeUVudGl0eSwgTm9kZSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBOb2RlUGVybWlzc2lvblNlcnZpY2UgfSBmcm9tICcuL25vZGUtcGVybWlzc2lvbi5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRlbnRTZXJ2aWNlLCBQZXJtaXNzaW9uc0VudW0gfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTm9kZVBlcm1pc3Npb25EaWFsb2dTZXJ2aWNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGlhbG9nOiBNYXREaWFsb2csXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBub2RlUGVybWlzc2lvblNlcnZpY2U6IE5vZGVQZXJtaXNzaW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNvbnRlbnRTZXJ2aWNlOiBDb250ZW50U2VydmljZSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgZGlhbG9nIHRvIGFkZCBwZXJtaXNzaW9ucyB0byBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGUgSUQgb2YgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIHRpdGxlIERpYWxvZyB0aXRsZVxuICAgICAqIEByZXR1cm5zIE5vZGUgd2l0aCB1cGRhdGVkIHBlcm1pc3Npb25zXG4gICAgICovXG4gICAgb3BlbkFkZFBlcm1pc3Npb25EaWFsb2cobm9kZTogTm9kZSwgdGl0bGU/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPE1pbmltYWxOb2RlRW50aXR5W10+IHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudFNlcnZpY2UuaGFzUGVybWlzc2lvbihub2RlLCBQZXJtaXNzaW9uc0VudW0uVVBEQVRFUEVSTUlTU0lPTlMpKSB7XG4gICAgICAgICAgICBjb25zdCBjb25maXJtID0gbmV3IFN1YmplY3Q8TWluaW1hbE5vZGVFbnRpdHlbXT4oKTtcblxuICAgICAgICAgICAgY29uZmlybS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiB0aGlzLmNsb3NlLmJpbmQodGhpcylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBkYXRhOiBBZGRQZXJtaXNzaW9uRGlhbG9nRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBub2RlSWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgIGNvbmZpcm06IGNvbmZpcm1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMub3BlbkRpYWxvZyhkYXRhLCAnYWRmLWFkZC1wZXJtaXNzaW9uLWRpYWxvZycsICc2MzBweCcpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZXJyb3JzID0gbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6IHsgc3RhdHVzQ29kZTogNDAzIH0gfSkpO1xuICAgICAgICAgICAgZXJyb3JzLm1lc3NhZ2UgPSAnUEVSTUlTU0lPTl9NQU5BR0VSLkVSUk9SLk5PVC1BTExPV0VEJztcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9wZW5EaWFsb2coZGF0YTogYW55LCBjdXJyZW50UGFuZWxDbGFzczogc3RyaW5nLCBjaG9zZW5XaWR0aDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuZGlhbG9nLm9wZW4oQWRkUGVybWlzc2lvbkRpYWxvZ0NvbXBvbmVudCwgeyBkYXRhLCBwYW5lbENsYXNzOiBjdXJyZW50UGFuZWxDbGFzcywgd2lkdGg6IGNob3NlbldpZHRoIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgY3VycmVudGx5LW9wZW4gZGlhbG9nLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmRpYWxvZy5jbG9zZUFsbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgZGlhbG9nIHRvIHVwZGF0ZSBwZXJtaXNzaW9ucyBmb3IgYSBub2RlLlxuICAgICAqIEBwYXJhbSBub2RlSWQgSUQgb2YgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIHRpdGxlIERpYWxvZyB0aXRsZVxuICAgICAqIEByZXR1cm5zIE5vZGUgd2l0aCB1cGRhdGVkIHBlcm1pc3Npb25zXG4gICAgICovXG4gICAgdXBkYXRlTm9kZVBlcm1pc3Npb25CeURpYWxvZyhub2RlSWQ/OiBzdHJpbmcsIHRpdGxlPzogc3RyaW5nKTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRTZXJ2aWNlLmdldE5vZGUobm9kZUlkLCB7IGluY2x1ZGU6IFsnYWxsb3dhYmxlT3BlcmF0aW9ucyddIH0pXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBzd2l0Y2hNYXAobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW5BZGRQZXJtaXNzaW9uRGlhbG9nKG5vZGUuZW50cnksIHRpdGxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoTWFwKHNlbGVjdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVQZXJtaXNzaW9uU2VydmljZS51cGRhdGVOb2RlUGVybWlzc2lvbnMobm9kZUlkLCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFF1ZXJ5Qm9keSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBTZWFyY2hDb25maWd1cmF0aW9uSW50ZXJmYWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuZXhwb3J0IGNsYXNzIFNlYXJjaFBlcm1pc3Npb25Db25maWd1cmF0aW9uU2VydmljZSBpbXBsZW1lbnRzIFNlYXJjaENvbmZpZ3VyYXRpb25JbnRlcmZhY2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgfVxuXG4gICAgcHVibGljIGdlbmVyYXRlUXVlcnlCb2R5KHNlYXJjaFRlcm06IHN0cmluZywgbWF4UmVzdWx0czogbnVtYmVyLCBza2lwQ291bnQ6IG51bWJlcik6IFF1ZXJ5Qm9keSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRRdWVyeUJvZHk6IFF1ZXJ5Qm9keSA9IHtcbiAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IHNlYXJjaFRlcm0gPyBgYXV0aG9yaXR5TmFtZToqJHtzZWFyY2hUZXJtfSogT1IgdXNlck5hbWU6KiR7c2VhcmNoVGVybX0qYCA6IHNlYXJjaFRlcm1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmNsdWRlOiBbJ3Byb3BlcnRpZXMnLCAnYXNwZWN0TmFtZXMnXSxcbiAgICAgICAgICAgIHBhZ2luZzoge1xuICAgICAgICAgICAgICAgIG1heEl0ZW1zOiBtYXhSZXN1bHRzLFxuICAgICAgICAgICAgICAgIHNraXBDb3VudDogc2tpcENvdW50XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsdGVyUXVlcmllczogW1xuICAgICAgICAgICAgICAgIC8qdHNsaW50OmRpc2FibGUtbmV4dC1saW5lICovXG4gICAgICAgICAgICAgICAgeyBxdWVyeTogXCJUWVBFOidjbTphdXRob3JpdHknXCIgfV1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZGVmYXVsdFF1ZXJ5Qm9keTtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9uLCBFdmVudEVtaXR0ZXIsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTZWFyY2hQZXJtaXNzaW9uQ29uZmlndXJhdGlvblNlcnZpY2UgfSBmcm9tICcuL3NlYXJjaC1jb25maWctcGVybWlzc2lvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFNlYXJjaFNlcnZpY2UsIFNlYXJjaENvbmZpZ3VyYXRpb25TZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IFNlYXJjaENvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uL3NlYXJjaC9jb21wb25lbnRzL3NlYXJjaC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWFkZC1wZXJtaXNzaW9uLXBhbmVsJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vYWRkLXBlcm1pc3Npb24tcGFuZWwuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2FkZC1wZXJtaXNzaW9uLXBhbmVsLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgeyBwcm92aWRlOiBTZWFyY2hDb25maWd1cmF0aW9uU2VydmljZSwgdXNlQ2xhc3M6IFNlYXJjaFBlcm1pc3Npb25Db25maWd1cmF0aW9uU2VydmljZSB9LFxuICAgICAgICBTZWFyY2hTZXJ2aWNlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBZGRQZXJtaXNzaW9uUGFuZWxDb21wb25lbnQge1xuXG4gICAgQFZpZXdDaGlsZCgnc2VhcmNoJylcbiAgICBzZWFyY2g6IFNlYXJjaENvbXBvbmVudDtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYSBwZXJtaXNzaW9uIGxpc3QgaXRlbSBpcyBzZWxlY3RlZC4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBzZWxlY3Q6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgc2VhcmNoSW5wdXQ6IEZvcm1Db250cm9sID0gbmV3IEZvcm1Db250cm9sKCk7XG4gICAgc2VhcmNoZWRXb3JkID0gJyc7XG4gICAgZGVib3VuY2VTZWFyY2g6IG51bWJlciA9IDIwMDtcblxuICAgIHNlbGVjdGVkSXRlbXM6IE1pbmltYWxOb2RlRW50aXR5W10gPSBbXTtcblxuICAgIEVWRVJZT05FOiBNaW5pbWFsTm9kZUVudGl0eSA9IHsgZW50cnk6IHsgcHJvcGVydGllczogeydjbTphdXRob3JpdHlOYW1lJzogJ0dST1VQX0VWRVJZT05FJ319fTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNlYXJjaElucHV0LnZhbHVlQ2hhbmdlc1xuICAgICAgICAucGlwZShcbiAgICAgICAgICAgIGRlYm91bmNlVGltZSh0aGlzLmRlYm91bmNlU2VhcmNoKVxuICAgICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUoKHNlYXJjaFZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaGVkV29yZCA9IHNlYXJjaFZhbHVlO1xuICAgICAgICAgICAgaWYgKCFzZWFyY2hWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnJlc2V0UmVzdWx0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBlbGVtZW50Q2xpY2tlZChpdGVtOiBNaW5pbWFsTm9kZUVudGl0eSkge1xuICAgICAgICBpZiAodGhpcy5pc0FscmVhZHlTZWxlY3RlZChpdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zLnNwbGljZSh0aGlzLnNlbGVjdGVkSXRlbXMuaW5kZXhPZihpdGVtKSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMuc2VsZWN0ZWRJdGVtcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0FscmVhZHlTZWxlY3RlZChpdGVtOiBNaW5pbWFsTm9kZUVudGl0eSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEl0ZW1zLmluZGV4T2YoaXRlbSkgPj0gMDtcbiAgICB9XG5cbiAgICBjbGVhclNlYXJjaCgpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hlZFdvcmQgPSAnJztcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zLnNwbGljZSgwLCB0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zZWFyY2gucmVzZXRSZXN1bHRzKCk7XG4gICAgfVxuXG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTWF0ZXJpYWxNb2R1bGUgfSBmcm9tICcuLi9tYXRlcmlhbC5tb2R1bGUnO1xuaW1wb3J0IHsgUGVybWlzc2lvbkxpc3RDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvcGVybWlzc2lvbi1saXN0L3Blcm1pc3Npb24tbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgQWRkUGVybWlzc2lvbkNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9hZGQtcGVybWlzc2lvbi9hZGQtcGVybWlzc2lvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgQWRkUGVybWlzc2lvbkRpYWxvZ0NvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9hZGQtcGVybWlzc2lvbi9hZGQtcGVybWlzc2lvbi1kaWFsb2cuY29tcG9uZW50JztcbmltcG9ydCB7IENvcmVNb2R1bGUgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgSW5oZXJpdFBlcm1pc3Npb25EaXJlY3RpdmUgfSBmcm9tICcuL2NvbXBvbmVudHMvaW5oZXJpdGVkLWJ1dHRvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTm9QZXJtaXNzaW9uVGVtcGxhdGVDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvcGVybWlzc2lvbi1saXN0L25vLXBlcm1pc3Npb24uY29tcG9uZW50JztcbmltcG9ydCB7IEFkZFBlcm1pc3Npb25QYW5lbENvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9hZGQtcGVybWlzc2lvbi9hZGQtcGVybWlzc2lvbi1wYW5lbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoTW9kdWxlIH0gZnJvbSAnLi4vc2VhcmNoL3NlYXJjaC5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29yZU1vZHVsZS5mb3JDaGlsZCgpLFxuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBNYXRlcmlhbE1vZHVsZSxcbiAgICAgICAgU2VhcmNoTW9kdWxlXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUGVybWlzc2lvbkxpc3RDb21wb25lbnQsXG4gICAgICAgIE5vUGVybWlzc2lvblRlbXBsYXRlQ29tcG9uZW50LFxuICAgICAgICBBZGRQZXJtaXNzaW9uUGFuZWxDb21wb25lbnQsXG4gICAgICAgIEluaGVyaXRQZXJtaXNzaW9uRGlyZWN0aXZlLFxuICAgICAgICBBZGRQZXJtaXNzaW9uQ29tcG9uZW50LFxuICAgICAgICBBZGRQZXJtaXNzaW9uRGlhbG9nQ29tcG9uZW50XG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgQWRkUGVybWlzc2lvblBhbmVsQ29tcG9uZW50LFxuICAgICAgICBBZGRQZXJtaXNzaW9uQ29tcG9uZW50LFxuICAgICAgICBBZGRQZXJtaXNzaW9uRGlhbG9nQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFBlcm1pc3Npb25MaXN0Q29tcG9uZW50LFxuICAgICAgICBOb1Blcm1pc3Npb25UZW1wbGF0ZUNvbXBvbmVudCxcbiAgICAgICAgQWRkUGVybWlzc2lvblBhbmVsQ29tcG9uZW50LFxuICAgICAgICBJbmhlcml0UGVybWlzc2lvbkRpcmVjdGl2ZSxcbiAgICAgICAgQWRkUGVybWlzc2lvbkNvbXBvbmVudCxcbiAgICAgICAgQWRkUGVybWlzc2lvbkRpYWxvZ0NvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbk1hbmFnZXJNb2R1bGUge31cbiIsIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEluamVjdCxcbiAgICBPbkluaXQsXG4gICAgVmlld0VuY2Fwc3VsYXRpb24sXG4gICAgVmlld0NoaWxkLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgT25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTUFUX0RJQUxPR19EQVRBLCBNYXREaWFsb2dSZWYsICBNYXREaWFsb2cgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgeyBGb3JtR3JvdXAsIEZvcm1Db250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YXAsIHNraXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICAgIFNoYXJlZExpbmtzQXBpU2VydmljZSxcbiAgICBOb2Rlc0FwaVNlcnZpY2UsXG4gICAgQ29udGVudFNlcnZpY2Vcbn0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IFNoYXJlZExpbmtFbnRyeSwgTWluaW1hbE5vZGVFbnRyeUVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBDb25maXJtRGlhbG9nQ29tcG9uZW50IH0gZnJvbSAnLi4vZGlhbG9ncy9jb25maXJtLmRpYWxvZyc7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudC1lczYnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1zaGFyZS1kaWFsb2cnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9jb250ZW50LW5vZGUtc2hhcmUuZGlhbG9nLmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2NvbnRlbnQtbm9kZS1zaGFyZS5kaWFsb2cuc2NzcyddLFxuICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ2FkZi1zaGFyZS1kaWFsb2cnIH0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBTaGFyZURpYWxvZ0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgICBtaW5EYXRlID0gbW9tZW50KCkuYWRkKDEsICdkJyk7XG4gICAgc2hhcmVkSWQ6IHN0cmluZztcbiAgICBmaWxlTmFtZTogc3RyaW5nO1xuICAgIGJhc2VTaGFyZVVybDogc3RyaW5nO1xuICAgIGlzRmlsZVNoYXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGlzRGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBmb3JtOiBGb3JtR3JvdXAgPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgICAgJ3NoYXJlZFVybCc6IG5ldyBGb3JtQ29udHJvbCgnJyksXG4gICAgICAgICd0aW1lJzogbmV3IEZvcm1Db250cm9sKHt2YWx1ZTogJycsIGRpc2FibGVkOiBmYWxzZX0pXG4gICAgfSk7XG5cbiAgICBAVmlld0NoaWxkKCdzaGFyZWRMaW5rSW5wdXQnKSBzaGFyZWRMaW5rSW5wdXQ6IEVsZW1lbnRSZWY7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBzaGFyZWRMaW5rc0FwaVNlcnZpY2U6IFNoYXJlZExpbmtzQXBpU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBkaWFsb2dSZWY6IE1hdERpYWxvZ1JlZjxTaGFyZURpYWxvZ0NvbXBvbmVudD4sXG4gICAgICAgIHByaXZhdGUgZGlhbG9nOiBNYXREaWFsb2csXG4gICAgICAgIHByaXZhdGUgbm9kZXNBcGlTZXJ2aWNlOiBOb2Rlc0FwaVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgY29udGVudFNlcnZpY2U6IENvbnRlbnRTZXJ2aWNlLFxuICAgICAgICBASW5qZWN0KE1BVF9ESUFMT0dfREFUQSkgcHVibGljIGRhdGE6IGFueSkge1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuXG4gICAgICAgIGlmICghdGhpcy5jYW5VcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybS5jb250cm9sc1sndGltZSddLmRpc2FibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgICAgICAgdGhpcy5mb3JtLnZhbHVlQ2hhbmdlc1xuICAgICAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgICAgICBza2lwKDEpLFxuICAgICAgICAgICAgICAgICAgICB0YXAoKHVwZGF0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTm9kZSh1cGRhdGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgodXBkYXRlcykgPT4gdGhpcy51cGRhdGVFbnRyeUV4cGlyeURhdGUodXBkYXRlcykpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5ub2RlICYmIHRoaXMuZGF0YS5ub2RlLmVudHJ5KSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVOYW1lID0gdGhpcy5kYXRhLm5vZGUuZW50cnkubmFtZTtcbiAgICAgICAgICAgIHRoaXMuYmFzZVNoYXJlVXJsID0gdGhpcy5kYXRhLmJhc2VTaGFyZVVybDtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLmRhdGEubm9kZS5lbnRyeS5wcm9wZXJ0aWVzO1xuXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcyAmJiAhcHJvcGVydGllc1sncXNoYXJlOnNoYXJlZElkJ10pIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlU2hhcmVkTGlua3ModGhpcy5kYXRhLm5vZGUuZW50cnkuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXJlZElkID0gcHJvcGVydGllc1sncXNoYXJlOnNoYXJlZElkJ107XG4gICAgICAgICAgICAgICAgdGhpcy5pc0ZpbGVTaGFyZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YnNjcmlwdGlvbikgPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKTtcbiAgICB9XG5cbiAgICByZW1vdmVTaGFyZSgpIHtcbiAgICAgICAgdGhpcy5kZWxldGVTaGFyZWRMaW5rKHRoaXMuc2hhcmVkSWQpO1xuICAgIH1cblxuICAgIG9uU2xpZGVTaGFyZUNoYW5nZShldmVudDogYW55KSB7XG4gICAgICAgIGlmIChldmVudC5jaGVja2VkKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVNoYXJlZExpbmtzKHRoaXMuZGF0YS5ub2RlLmVudHJ5LmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkNvbmZpcm1hdGlvbkRpYWxvZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGNhblVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFNlcnZpY2UuaGFzUGVybWlzc2lvbih0aGlzLmRhdGEubm9kZS5lbnRyeSwgJ3VwZGF0ZScpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb3BlbkNvbmZpcm1hdGlvbkRpYWxvZygpIHtcbiAgICAgICAgdGhpcy5pc0ZpbGVTaGFyZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmRpYWxvZ1xuICAgICAgICAgICAgLm9wZW4oQ29uZmlybURpYWxvZ0NvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdTSEFSRS5DT05GSVJNQVRJT04uRElBTE9HLVRJVExFJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1NIQVJFLkNPTkZJUk1BVElPTi5NRVNTQUdFJyxcbiAgICAgICAgICAgICAgICAgICAgeWVzTGFiZWw6ICdTSEFSRS5DT05GSVJNQVRJT04uUkVNT1ZFJyxcbiAgICAgICAgICAgICAgICAgICAgbm9MYWJlbDogJ1NIQVJFLkNPTkZJUk1BVElPTi5DQU5DRUwnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogJzI1MHB4JyxcbiAgICAgICAgICAgICAgICBjbG9zZU9uTmF2aWdhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5iZWZvcmVDbG9zZSgpLnN1YnNjcmliZShkZWxldGVTaGFyZWRMaW5rID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlU2hhcmVkTGluaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZVNoYXJlZExpbmsodGhpcy5zaGFyZWRJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0ZpbGVTaGFyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlU2hhcmVkTGlua3Mobm9kZUlkOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnNoYXJlZExpbmtzQXBpU2VydmljZS5jcmVhdGVTaGFyZWRMaW5rcyhub2RlSWQpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChzaGFyZWRMaW5rOiBTaGFyZWRMaW5rRW50cnkpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmIChzaGFyZWRMaW5rLmVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkSWQgPSBzaGFyZWRMaW5rLmVudHJ5LmlkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEubm9kZS5lbnRyeS5wcm9wZXJ0aWVzWydxc2hhcmU6c2hhcmVkSWQnXSA9IHRoaXMuc2hhcmVkSWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRmlsZVNoYXJlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRmlsZVNoYXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkZWxldGVTaGFyZWRMaW5rKHNoYXJlZElkOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnNoYXJlZExpbmtzQXBpU2VydmljZS5kZWxldGVTaGFyZWRMaW5rKHNoYXJlZElkKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5ub2RlLmVudHJ5LnByb3BlcnRpZXNbJ3FzaGFyZTpzaGFyZWRJZCddID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEubm9kZS5lbnRyeS5wcm9wZXJ0aWVzWydxc2hhcmU6ZXhwaXJ5RGF0ZSddID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZ1JlZi5jbG9zZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNGaWxlU2hhcmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUZvcm0oKSB7XG4gICAgICAgIGNvbnN0IHsgZW50cnkgfSA9IHRoaXMuZGF0YS5ub2RlO1xuICAgICAgICBjb25zdCBleHBpcnlEYXRlID0gZW50cnkucHJvcGVydGllc1sncXNoYXJlOmV4cGlyeURhdGUnXTtcblxuICAgICAgICB0aGlzLmZvcm0uc2V0VmFsdWUoe1xuICAgICAgICAgICAgJ3NoYXJlZFVybCc6IGAke3RoaXMuYmFzZVNoYXJlVXJsfSR7dGhpcy5zaGFyZWRJZH1gLFxuICAgICAgICAgICAgJ3RpbWUnOiBleHBpcnlEYXRlID8gZXhwaXJ5RGF0ZSA6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVOb2RlKHVwZGF0ZXMpOiBPYnNlcnZhYmxlPE1pbmltYWxOb2RlRW50cnlFbnRpdHk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNBcGlTZXJ2aWNlLnVwZGF0ZU5vZGUoXG4gICAgICAgICAgICB0aGlzLmRhdGEubm9kZS5lbnRyeS5pZCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICdxc2hhcmU6ZXhwaXJ5RGF0ZSc6IHVwZGF0ZXMudGltZSA/IHVwZGF0ZXMudGltZS51dGMoKS5mb3JtYXQoKSA6IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVFbnRyeUV4cGlyeURhdGUodXBkYXRlcykge1xuICAgICAgICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IHRoaXMuZGF0YS5ub2RlLmVudHJ5O1xuXG4gICAgICAgIHByb3BlcnRpZXNbJ3FzaGFyZTpleHBpcnlEYXRlJ10gPSB1cGRhdGVzLnRpbWVcbiAgICAgICAgICAgID8gdXBkYXRlcy50aW1lLmxvY2FsKClcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBIb3N0TGlzdGVuZXIsIE9uQ2hhbmdlcywgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXREaWFsb2cgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgeyBNaW5pbWFsTm9kZUVudGl0eSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5cbmltcG9ydCB7IFNoYXJlRGlhbG9nQ29tcG9uZW50IH0gZnJvbSAnLi9jb250ZW50LW5vZGUtc2hhcmUuZGlhbG9nJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbYWRmLXNoYXJlXScsXG4gICAgZXhwb3J0QXM6ICdhZGZTaGFyZSdcbn0pXG5leHBvcnQgY2xhc3MgTm9kZVNoYXJlZERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG5cbiAgICBpc0ZpbGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBpc1NoYXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIE5vZGUgdG8gc2hhcmUuICovXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWlucHV0LXJlbmFtZVxuICAgIEBJbnB1dCgnYWRmLXNoYXJlJylcbiAgICBub2RlOiBNaW5pbWFsTm9kZUVudGl0eTtcblxuICAgIEBJbnB1dCgpXG4gICAgYmFzZVNoYXJlVXJsOiBzdHJpbmc7XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gICAgb25DbGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgICAgICAgdGhpcy5zaGFyZU5vZGUodGhpcy5ub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGlhbG9nOiBNYXREaWFsb2csIHByaXZhdGUgem9uZTogTmdab25lKSB7fVxuXG4gICAgc2hhcmVOb2RlKG5vZGU6IE1pbmltYWxOb2RlRW50aXR5KSB7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUuZW50cnkgJiYgbm9kZS5lbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nLm9wZW4oU2hhcmVEaWFsb2dDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJzYwMHB4JyxcbiAgICAgICAgICAgICAgICBwYW5lbENsYXNzOiAnYWRmLXNoYXJlLWxpbmstZGlhbG9nJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VTaGFyZVVybDogdGhpcy5iYXNlU2hhcmVVcmxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLnpvbmUub25TdGFibGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRmlsZSA9IHRoaXMubm9kZS5lbnRyeS5pc0ZpbGU7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NoYXJlZCA9IHRoaXMubm9kZS5lbnRyeS5wcm9wZXJ0aWVzWydxc2hhcmU6c2hhcmVkSWQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgTmdNb2R1bGUsIE1vZHVsZVdpdGhQcm92aWRlcnMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBDb3JlTW9kdWxlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IE1hdGVyaWFsTW9kdWxlIH0gZnJvbSAnLi4vbWF0ZXJpYWwubW9kdWxlJztcbmltcG9ydCB7IFNoYXJlRGlhbG9nQ29tcG9uZW50IH0gZnJvbSAnLi9jb250ZW50LW5vZGUtc2hhcmUuZGlhbG9nJztcbmltcG9ydCB7IE5vZGVTaGFyZWREaXJlY3RpdmUgfSBmcm9tICcuL2NvbnRlbnQtbm9kZS1zaGFyZS5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29yZU1vZHVsZS5mb3JDaGlsZCgpLFxuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIE1hdGVyaWFsTW9kdWxlXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU2hhcmVEaWFsb2dDb21wb25lbnQsXG4gICAgICAgIE5vZGVTaGFyZWREaXJlY3RpdmVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgU2hhcmVEaWFsb2dDb21wb25lbnQsXG4gICAgICAgIE5vZGVTaGFyZWREaXJlY3RpdmVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBTaGFyZURpYWxvZ0NvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQ29udGVudE5vZGVTaGFyZU1vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3QoKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogQ29udGVudE5vZGVTaGFyZU1vZHVsZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBmb3JDaGlsZCgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBDb250ZW50Tm9kZVNoYXJlTW9kdWxlXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBNb2R1bGVXaXRoUHJvdmlkZXJzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IENvcmVNb2R1bGUsIFRSQU5TTEFUSU9OX1BST1ZJREVSIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuaW1wb3J0IHsgTWF0ZXJpYWxNb2R1bGUgfSBmcm9tICcuL21hdGVyaWFsLm1vZHVsZSc7XG5cbmltcG9ydCB7IFNvY2lhbE1vZHVsZSB9IGZyb20gJy4vc29jaWFsL3NvY2lhbC5tb2R1bGUnO1xuaW1wb3J0IHsgVGFnTW9kdWxlIH0gZnJvbSAnLi90YWcvdGFnLm1vZHVsZSc7XG5pbXBvcnQgeyBXZWJTY3JpcHRNb2R1bGUgfSBmcm9tICcuL3dlYnNjcmlwdC93ZWJzY3JpcHQubW9kdWxlJztcbmltcG9ydCB7IERvY3VtZW50TGlzdE1vZHVsZSB9IGZyb20gJy4vZG9jdW1lbnQtbGlzdC9kb2N1bWVudC1saXN0Lm1vZHVsZSc7XG5pbXBvcnQgeyBVcGxvYWRNb2R1bGUgfSBmcm9tICcuL3VwbG9hZC91cGxvYWQubW9kdWxlJztcbmltcG9ydCB7IFNlYXJjaE1vZHVsZSB9IGZyb20gJy4vc2VhcmNoL3NlYXJjaC5tb2R1bGUnO1xuaW1wb3J0IHsgU2l0ZXNEcm9wZG93bk1vZHVsZSB9IGZyb20gJy4vc2l0ZS1kcm9wZG93bi9zaXRlcy1kcm9wZG93bi5tb2R1bGUnO1xuaW1wb3J0IHsgQnJlYWRjcnVtYk1vZHVsZSB9IGZyb20gJy4vYnJlYWRjcnVtYi9icmVhZGNydW1iLm1vZHVsZSc7XG5pbXBvcnQgeyBWZXJzaW9uTWFuYWdlck1vZHVsZSB9IGZyb20gJy4vdmVyc2lvbi1tYW5hZ2VyL3ZlcnNpb24tbWFuYWdlci5tb2R1bGUnO1xuaW1wb3J0IHsgQ29udGVudE5vZGVTZWxlY3Rvck1vZHVsZSB9IGZyb20gJy4vY29udGVudC1ub2RlLXNlbGVjdG9yL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci5tb2R1bGUnO1xuaW1wb3J0IHsgQ29udGVudE5vZGVTaGFyZU1vZHVsZSB9IGZyb20gJy4vY29udGVudC1ub2RlLXNoYXJlL2NvbnRlbnQtbm9kZS1zaGFyZS5tb2R1bGUnO1xuaW1wb3J0IHsgQ29udGVudERpcmVjdGl2ZU1vZHVsZSB9IGZyb20gJy4vZGlyZWN0aXZlcy9jb250ZW50LWRpcmVjdGl2ZS5tb2R1bGUnO1xuaW1wb3J0IHsgRGlhbG9nTW9kdWxlIH0gZnJvbSAnLi9kaWFsb2dzL2RpYWxvZy5tb2R1bGUnO1xuaW1wb3J0IHsgRm9sZGVyRGlyZWN0aXZlTW9kdWxlIH0gZnJvbSAnLi9mb2xkZXItZGlyZWN0aXZlL2ZvbGRlci1kaXJlY3RpdmUubW9kdWxlJztcbmltcG9ydCB7IENvbnRlbnRNZXRhZGF0YU1vZHVsZSB9IGZyb20gJy4vY29udGVudC1tZXRhZGF0YS9jb250ZW50LW1ldGFkYXRhLm1vZHVsZSc7XG5pbXBvcnQgeyBQZXJtaXNzaW9uTWFuYWdlck1vZHVsZSB9IGZyb20gJy4vcGVybWlzc2lvbi1tYW5hZ2VyL3Blcm1pc3Npb24tbWFuYWdlci5tb2R1bGUnO1xuaW1wb3J0IHsgUmF0aW5nU2VydmljZSB9IGZyb20gJy4vc29jaWFsL3NlcnZpY2VzL3JhdGluZy5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRlbnRNZXRhZGF0YVNlcnZpY2UgfSBmcm9tICcuL2NvbnRlbnQtbWV0YWRhdGEvc2VydmljZXMvY29udGVudC1tZXRhZGF0YS5zZXJ2aWNlJztcbmltcG9ydCB7IFByb3BlcnR5RGVzY3JpcHRvcnNTZXJ2aWNlIH0gZnJvbSAnLi9jb250ZW50LW1ldGFkYXRhL3NlcnZpY2VzL3Byb3BlcnR5LWRlc2NyaXB0b3JzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udGVudE1ldGFkYXRhQ29uZmlnRmFjdG9yeSB9IGZyb20gJy4vY29udGVudC1tZXRhZGF0YS9zZXJ2aWNlcy9jb25maWcvY29udGVudC1tZXRhZGF0YS1jb25maWcuZmFjdG9yeSc7XG5pbXBvcnQgeyBCYXNpY1Byb3BlcnRpZXNTZXJ2aWNlIH0gZnJvbSAnLi9jb250ZW50LW1ldGFkYXRhL3NlcnZpY2VzL2Jhc2ljLXByb3BlcnRpZXMuc2VydmljZSc7XG5pbXBvcnQgeyBQcm9wZXJ0eUdyb3VwVHJhbnNsYXRvclNlcnZpY2UgfSBmcm9tICcuL2NvbnRlbnQtbWV0YWRhdGEvc2VydmljZXMvcHJvcGVydHktZ3JvdXBzLXRyYW5zbGF0b3Iuc2VydmljZSc7XG5pbXBvcnQgeyBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi9zZWFyY2gvc2VhcmNoLXF1ZXJ5LWJ1aWxkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBTZWFyY2hGaWx0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9zZWFyY2gvY29tcG9uZW50cy9zZWFyY2gtZmlsdGVyL3NlYXJjaC1maWx0ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDb250ZW50Tm9kZVNlbGVjdG9yU2VydmljZSB9IGZyb20gJy4vY29udGVudC1ub2RlLXNlbGVjdG9yL2NvbnRlbnQtbm9kZS1zZWxlY3Rvci5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRlbnROb2RlRGlhbG9nU2VydmljZSB9IGZyb20gJy4vY29udGVudC1ub2RlLXNlbGVjdG9yL2NvbnRlbnQtbm9kZS1kaWFsb2cuc2VydmljZSc7XG5pbXBvcnQgeyBEb2N1bWVudExpc3RTZXJ2aWNlIH0gZnJvbSAnLi9kb2N1bWVudC1saXN0L3NlcnZpY2VzL2RvY3VtZW50LWxpc3Quc2VydmljZSc7XG5pbXBvcnQgeyBGb2xkZXJBY3Rpb25zU2VydmljZSB9IGZyb20gJy4vZG9jdW1lbnQtbGlzdC9zZXJ2aWNlcy9mb2xkZXItYWN0aW9ucy5zZXJ2aWNlJztcbmltcG9ydCB7IERvY3VtZW50QWN0aW9uc1NlcnZpY2UgfSBmcm9tICcuL2RvY3VtZW50LWxpc3Qvc2VydmljZXMvZG9jdW1lbnQtYWN0aW9ucy5zZXJ2aWNlJztcbmltcG9ydCB7IE5vZGVBY3Rpb25zU2VydmljZSB9IGZyb20gJy4vZG9jdW1lbnQtbGlzdC9zZXJ2aWNlcy9ub2RlLWFjdGlvbnMuc2VydmljZSc7XG5pbXBvcnQgeyBDdXN0b21SZXNvdXJjZXNTZXJ2aWNlIH0gZnJvbSAnLi9kb2N1bWVudC1saXN0L3NlcnZpY2VzL2N1c3RvbS1yZXNvdXJjZXMuc2VydmljZSc7XG5pbXBvcnQgeyBOb2RlUGVybWlzc2lvbkRpYWxvZ1NlcnZpY2UgfSBmcm9tICcuL3Blcm1pc3Npb24tbWFuYWdlci9zZXJ2aWNlcy9ub2RlLXBlcm1pc3Npb24tZGlhbG9nLnNlcnZpY2UnO1xuaW1wb3J0IHsgTm9kZVBlcm1pc3Npb25TZXJ2aWNlIH0gZnJvbSAnLi9wZXJtaXNzaW9uLW1hbmFnZXIvc2VydmljZXMvbm9kZS1wZXJtaXNzaW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgVGFnU2VydmljZSB9IGZyb20gJy4vdGFnL3NlcnZpY2VzL3RhZy5zZXJ2aWNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIHByb3ZpZGVycygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBSYXRpbmdTZXJ2aWNlLFxuICAgICAgICBDb250ZW50TWV0YWRhdGFTZXJ2aWNlLFxuICAgICAgICBQcm9wZXJ0eURlc2NyaXB0b3JzU2VydmljZSxcbiAgICAgICAgQ29udGVudE1ldGFkYXRhQ29uZmlnRmFjdG9yeSxcbiAgICAgICAgQmFzaWNQcm9wZXJ0aWVzU2VydmljZSxcbiAgICAgICAgUHJvcGVydHlHcm91cFRyYW5zbGF0b3JTZXJ2aWNlLFxuICAgICAgICBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlLFxuICAgICAgICBTZWFyY2hGaWx0ZXJTZXJ2aWNlLFxuICAgICAgICBDb250ZW50Tm9kZVNlbGVjdG9yU2VydmljZSxcbiAgICAgICAgQ29udGVudE5vZGVEaWFsb2dTZXJ2aWNlLFxuICAgICAgICBEb2N1bWVudExpc3RTZXJ2aWNlLFxuICAgICAgICBGb2xkZXJBY3Rpb25zU2VydmljZSxcbiAgICAgICAgRG9jdW1lbnRBY3Rpb25zU2VydmljZSxcbiAgICAgICAgTm9kZUFjdGlvbnNTZXJ2aWNlLFxuICAgICAgICBDdXN0b21SZXNvdXJjZXNTZXJ2aWNlLFxuICAgICAgICBOb2RlUGVybWlzc2lvbkRpYWxvZ1NlcnZpY2UsXG4gICAgICAgIE5vZGVQZXJtaXNzaW9uU2VydmljZSxcbiAgICAgICAgVGFnU2VydmljZVxuICAgIF07XG59XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb3JlTW9kdWxlLmZvckNoaWxkKCksXG4gICAgICAgIFNvY2lhbE1vZHVsZSxcbiAgICAgICAgVGFnTW9kdWxlLFxuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFdlYlNjcmlwdE1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIERpYWxvZ01vZHVsZSxcbiAgICAgICAgU2VhcmNoTW9kdWxlLFxuICAgICAgICBEb2N1bWVudExpc3RNb2R1bGUsXG4gICAgICAgIFVwbG9hZE1vZHVsZSxcbiAgICAgICAgTWF0ZXJpYWxNb2R1bGUsXG4gICAgICAgIFNpdGVzRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEJyZWFkY3J1bWJNb2R1bGUsXG4gICAgICAgIENvbnRlbnROb2RlU2VsZWN0b3JNb2R1bGUsXG4gICAgICAgIENvbnRlbnROb2RlU2hhcmVNb2R1bGUsXG4gICAgICAgIENvbnRlbnRNZXRhZGF0YU1vZHVsZSxcbiAgICAgICAgRm9sZGVyRGlyZWN0aXZlTW9kdWxlLFxuICAgICAgICBDb250ZW50RGlyZWN0aXZlTW9kdWxlLFxuICAgICAgICBQZXJtaXNzaW9uTWFuYWdlck1vZHVsZSxcbiAgICAgICAgVmVyc2lvbk1hbmFnZXJNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgU29jaWFsTW9kdWxlLFxuICAgICAgICBUYWdNb2R1bGUsXG4gICAgICAgIFdlYlNjcmlwdE1vZHVsZSxcbiAgICAgICAgRG9jdW1lbnRMaXN0TW9kdWxlLFxuICAgICAgICBVcGxvYWRNb2R1bGUsXG4gICAgICAgIFNlYXJjaE1vZHVsZSxcbiAgICAgICAgU2l0ZXNEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQnJlYWRjcnVtYk1vZHVsZSxcbiAgICAgICAgQ29udGVudE5vZGVTZWxlY3Rvck1vZHVsZSxcbiAgICAgICAgQ29udGVudE5vZGVTaGFyZU1vZHVsZSxcbiAgICAgICAgQ29udGVudE1ldGFkYXRhTW9kdWxlLFxuICAgICAgICBEaWFsb2dNb2R1bGUsXG4gICAgICAgIEZvbGRlckRpcmVjdGl2ZU1vZHVsZSxcbiAgICAgICAgQ29udGVudERpcmVjdGl2ZU1vZHVsZSxcbiAgICAgICAgUGVybWlzc2lvbk1hbmFnZXJNb2R1bGUsXG4gICAgICAgIFZlcnNpb25NYW5hZ2VyTW9kdWxlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBDb250ZW50TW9kdWxlTGF6eSB7fVxuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29yZU1vZHVsZS5mb3JDaGlsZCgpLFxuICAgICAgICBTb2NpYWxNb2R1bGUsXG4gICAgICAgIFRhZ01vZHVsZSxcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBXZWJTY3JpcHRNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBEaWFsb2dNb2R1bGUsXG4gICAgICAgIFNlYXJjaE1vZHVsZSxcbiAgICAgICAgRG9jdW1lbnRMaXN0TW9kdWxlLFxuICAgICAgICBVcGxvYWRNb2R1bGUsXG4gICAgICAgIE1hdGVyaWFsTW9kdWxlLFxuICAgICAgICBTaXRlc0Ryb3Bkb3duTW9kdWxlLFxuICAgICAgICBCcmVhZGNydW1iTW9kdWxlLFxuICAgICAgICBDb250ZW50Tm9kZVNlbGVjdG9yTW9kdWxlLFxuICAgICAgICBDb250ZW50Tm9kZVNoYXJlTW9kdWxlLFxuICAgICAgICBDb250ZW50TWV0YWRhdGFNb2R1bGUsXG4gICAgICAgIEZvbGRlckRpcmVjdGl2ZU1vZHVsZSxcbiAgICAgICAgQ29udGVudERpcmVjdGl2ZU1vZHVsZSxcbiAgICAgICAgUGVybWlzc2lvbk1hbmFnZXJNb2R1bGUsXG4gICAgICAgIFZlcnNpb25NYW5hZ2VyTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgLi4ucHJvdmlkZXJzKCksXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IFRSQU5TTEFUSU9OX1BST1ZJREVSLFxuICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICB1c2VWYWx1ZToge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdhZGYtY29udGVudC1zZXJ2aWNlcycsXG4gICAgICAgICAgICAgICAgc291cmNlOiAnYXNzZXRzL2FkZi1jb250ZW50LXNlcnZpY2VzJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFNvY2lhbE1vZHVsZSxcbiAgICAgICAgVGFnTW9kdWxlLFxuICAgICAgICBXZWJTY3JpcHRNb2R1bGUsXG4gICAgICAgIERvY3VtZW50TGlzdE1vZHVsZSxcbiAgICAgICAgVXBsb2FkTW9kdWxlLFxuICAgICAgICBTZWFyY2hNb2R1bGUsXG4gICAgICAgIFNpdGVzRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEJyZWFkY3J1bWJNb2R1bGUsXG4gICAgICAgIENvbnRlbnROb2RlU2VsZWN0b3JNb2R1bGUsXG4gICAgICAgIENvbnRlbnROb2RlU2hhcmVNb2R1bGUsXG4gICAgICAgIENvbnRlbnRNZXRhZGF0YU1vZHVsZSxcbiAgICAgICAgRGlhbG9nTW9kdWxlLFxuICAgICAgICBGb2xkZXJEaXJlY3RpdmVNb2R1bGUsXG4gICAgICAgIENvbnRlbnREaXJlY3RpdmVNb2R1bGUsXG4gICAgICAgIFBlcm1pc3Npb25NYW5hZ2VyTW9kdWxlLFxuICAgICAgICBWZXJzaW9uTWFuYWdlck1vZHVsZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQ29udGVudE1vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3QoKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogQ29udGVudE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIC4uLnByb3ZpZGVycygpLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogVFJBTlNMQVRJT05fUFJPVklERVIsXG4gICAgICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1c2VWYWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FkZi1jb250ZW50LXNlcnZpY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJ2Fzc2V0cy9hZGYtY29udGVudC1zZXJ2aWNlcydcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZm9yQ2hpbGQoKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogQ29udGVudE1vZHVsZUxhenlcbiAgICAgICAgfTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsibW9tZW50IiwiZmlsdGVyIiwibWVyZ2UiLCJtYXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFrQ0ksWUFBb0IsVUFBOEIsRUFDOUIsV0FDeUIsSUFBUyxFQUNsQztRQUhBLGVBQVUsR0FBVixVQUFVLENBQW9CO1FBQzlCLGNBQVMsR0FBVCxTQUFTO1FBQ2dCLFNBQUksR0FBSixJQUFJLENBQUs7UUFDbEMsZUFBVSxHQUFWLFVBQVU7eUJBTFYsS0FBSztLQU14Qjs7OztJQUVELFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFH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