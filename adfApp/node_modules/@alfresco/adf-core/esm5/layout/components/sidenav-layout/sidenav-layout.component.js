/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ContentChild, Input, Output, ViewChild, EventEmitter } from '@angular/core';
import { MediaMatcher } from '@angular/cdk/layout';
import { SidenavLayoutContentDirective } from '../../directives/sidenav-layout-content.directive';
import { SidenavLayoutHeaderDirective } from '../../directives/sidenav-layout-header.directive';
import { SidenavLayoutNavigationDirective } from '../../directives/sidenav-layout-navigation.directive';
import { BehaviorSubject } from 'rxjs';
var SidenavLayoutComponent = /** @class */ (function () {
    function SidenavLayoutComponent(mediaMatcher) {
        var _this = this;
        this.mediaMatcher = mediaMatcher;
        /**
         * The side that the drawer is attached to. Possible values are 'start' and 'end'.
         */
        this.position = 'start';
        /**
         * Toggles showing/hiding the navigation region.
         */
        this.hideSidenav = false;
        /**
         * Should the navigation region be expanded initially?
         */
        this.expandedSidenav = true;
        /**
         * Emitted when the menu toggle and the collapsed/expanded state of the sideNav changes.
         */
        this.expanded = new EventEmitter();
        this.templateContext = {
            toggleMenu: function () { },
            isMenuMinimized: function () { return _this.isMenuMinimized; }
        };
        this.onMediaQueryChange = this.onMediaQueryChange.bind(this);
    }
    /**
     * @return {?}
     */
    SidenavLayoutComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var initialMenuState = !this.expandedSidenav;
        this.menuOpenStateSubject = new BehaviorSubject(initialMenuState);
        this.menuOpenState$ = this.menuOpenStateSubject.asObservable();
        /** @type {?} */
        var stepOver = this.stepOver || SidenavLayoutComponent.STEP_OVER;
        this.isMenuMinimized = initialMenuState;
        this.mediaQueryList = this.mediaMatcher.matchMedia("(max-width: " + stepOver + "px)");
        this.mediaQueryList.addListener(this.onMediaQueryChange);
    };
    /**
     * @return {?}
     */
    SidenavLayoutComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.templateContext.toggleMenu = this.toggleMenu.bind(this);
    };
    /**
     * @return {?}
     */
    SidenavLayoutComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.mediaQueryList.removeListener(this.onMediaQueryChange);
    };
    /**
     * @return {?}
     */
    SidenavLayoutComponent.prototype.toggleMenu = /**
     * @return {?}
     */
    function () {
        if (!this.mediaQueryList.matches) {
            this.isMenuMinimized = !this.isMenuMinimized;
        }
        else {
            this.isMenuMinimized = false;
        }
        this.container.toggleMenu();
        this.expanded.emit(!this.isMenuMinimized);
    };
    Object.defineProperty(SidenavLayoutComponent.prototype, "isMenuMinimized", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isMenuMinimized;
        },
        set: /**
         * @param {?} menuState
         * @return {?}
         */
        function (menuState) {
            this._isMenuMinimized = menuState;
            this.menuOpenStateSubject.next(!menuState);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SidenavLayoutComponent.prototype, "isHeaderInside", {
        get: /**
         * @return {?}
         */
        function () {
            return this.mediaQueryList.matches;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SidenavLayoutComponent.prototype, "headerTemplate", {
        get: /**
         * @return {?}
         */
        function () {
            return this.headerDirective && this.headerDirective.template || this.emptyTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SidenavLayoutComponent.prototype, "navigationTemplate", {
        get: /**
         * @return {?}
         */
        function () {
            return this.navigationDirective && this.navigationDirective.template || this.emptyTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SidenavLayoutComponent.prototype, "contentTemplate", {
        get: /**
         * @return {?}
         */
        function () {
            return this.contentDirective && this.contentDirective.template || this.emptyTemplate;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SidenavLayoutComponent.prototype.onMediaQueryChange = /**
     * @return {?}
     */
    function () {
        this.isMenuMinimized = false;
        this.expanded.emit(!this.isMenuMinimized);
    };
    SidenavLayoutComponent.STEP_OVER = 600;
    SidenavLayoutComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-sidenav-layout',
                    template: "<div class=\"sidenav-layout\">\n    <ng-container *ngIf=\"!isHeaderInside\">\n        <ng-container class=\"adf-sidenav-layout-outer-header\"\n                      *ngTemplateOutlet=\"headerTemplate; context:templateContext\"></ng-container>\n    </ng-container>\n\n    <adf-layout-container #container\n                          [position]=\"position\"\n                          [sidenavMin]=\"sidenavMin\"\n                          [sidenavMax]=\"sidenavMax\"\n                          [mediaQueryList]=\"mediaQueryList\"\n                          [hideSidenav]=\"hideSidenav\"\n                          [expandedSidenav]=\"expandedSidenav\"\n                          data-automation-id=\"adf-layout-container\"\n                          class=\"layout__content\">\n\n        <ng-container app-layout-navigation\n                      *ngTemplateOutlet=\"navigationTemplate; context:templateContext\"></ng-container>\n\n        <ng-container app-layout-content>\n            <ng-container *ngIf=\"isHeaderInside\">\n                <ng-container *ngTemplateOutlet=\"headerTemplate; context:templateContext\"></ng-container>\n            </ng-container>\n            <ng-container *ngTemplateOutlet=\"contentTemplate; context:templateContext\"></ng-container>\n        </ng-container>\n    </adf-layout-container>\n</div>\n\n<ng-template #emptyTemplate></ng-template>\n",
                    styles: [":host{display:flex;flex:1}:host .sidenav-layout{width:100%;display:flex;flex-direction:column}:host .sidenav-layout .layout__content{flex:1 1 auto}:host router-outlet{flex:0 0}"]
                }] }
    ];
    /** @nocollapse */
    SidenavLayoutComponent.ctorParameters = function () { return [
        { type: MediaMatcher }
    ]; };
    SidenavLayoutComponent.propDecorators = {
        position: [{ type: Input }],
        sidenavMin: [{ type: Input }],
        sidenavMax: [{ type: Input }],
        stepOver: [{ type: Input }],
        hideSidenav: [{ type: Input }],
        expandedSidenav: [{ type: Input }],
        expanded: [{ type: Output }],
        headerDirective: [{ type: ContentChild, args: [SidenavLayoutHeaderDirective,] }],
        navigationDirective: [{ type: ContentChild, args: [SidenavLayoutNavigationDirective,] }],
        contentDirective: [{ type: ContentChild, args: [SidenavLayoutContentDirective,] }],
        container: [{ type: ViewChild, args: ['container',] }],
        emptyTemplate: [{ type: ViewChild, args: ['emptyTemplate',] }]
    };
    return SidenavLayoutComponent;
}());
export { SidenavLayoutComponent };
if (false) {
    /** @type {?} */
    SidenavLayoutComponent.STEP_OVER;
    /**
     * The side that the drawer is attached to. Possible values are 'start' and 'end'.
     * @type {?}
     */
    SidenavLayoutComponent.prototype.position;
    /**
     * Minimum size of the navigation region.
     * @type {?}
     */
    SidenavLayoutComponent.prototype.sidenavMin;
    /**
     * Maximum size of the navigation region.
     * @type {?}
     */
    SidenavLayoutComponent.prototype.sidenavMax;
    /**
     * Screen size at which display switches from small screen to large screen configuration.
     * @type {?}
     */
    SidenavLayoutComponent.prototype.stepOver;
    /**
     * Toggles showing/hiding the navigation region.
     * @type {?}
     */
    SidenavLayoutComponent.prototype.hideSidenav;
    /**
     * Should the navigation region be expanded initially?
     * @type {?}
     */
    SidenavLayoutComponent.prototype.expandedSidenav;
    /**
     * Emitted when the menu toggle and the collapsed/expanded state of the sideNav changes.
     * @type {?}
     */
    SidenavLayoutComponent.prototype.expanded;
    /** @type {?} */
    SidenavLayoutComponent.prototype.headerDirective;
    /** @type {?} */
    SidenavLayoutComponent.prototype.navigationDirective;
    /** @type {?} */
    SidenavLayoutComponent.prototype.contentDirective;
    /** @type {?} */
    SidenavLayoutComponent.prototype.menuOpenStateSubject;
    /** @type {?} */
    SidenavLayoutComponent.prototype.menuOpenState$;
    /** @type {?} */
    SidenavLayoutComponent.prototype.container;
    /** @type {?} */
    SidenavLayoutComponent.prototype.emptyTemplate;
    /** @type {?} */
    SidenavLayoutComponent.prototype.mediaQueryList;
    /** @type {?} */
    SidenavLayoutComponent.prototype._isMenuMinimized;
    /** @type {?} */
    SidenavLayoutComponent.prototype.templateContext;
    /** @type {?} */
    SidenavLayoutComponent.prototype.mediaMatcher;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lkZW5hdi1sYXlvdXQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb3JlLyIsInNvdXJjZXMiOlsibGF5b3V0L2NvbXBvbmVudHMvc2lkZW5hdi1sYXlvdXQvc2lkZW5hdi1sYXlvdXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQXlCLFNBQVMsRUFBMEIsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQy9JLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNuRCxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSxtREFBbUQsQ0FBQztBQUNsRyxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSxrREFBa0QsQ0FBQztBQUNoRyxPQUFPLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSxzREFBc0QsQ0FBQztBQUN4RyxPQUFPLEVBQUUsZUFBZSxFQUFjLE1BQU0sTUFBTSxDQUFDOztJQWtEL0MsZ0NBQW9CLFlBQTBCO1FBQTlDLGlCQUVDO1FBRm1CLGlCQUFZLEdBQVosWUFBWSxDQUFjOzs7O3dCQXRDMUIsT0FBTzs7OzsyQkFZSixLQUFLOzs7OytCQUdELElBQUk7Ozs7d0JBR1YsSUFBSSxZQUFZLEVBQVc7K0JBZTlCO1lBQ2QsVUFBVSxFQUFFLGVBQVE7WUFDcEIsZUFBZSxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsZUFBZSxFQUFwQixDQUFvQjtTQUM5QztRQUdHLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2hFOzs7O0lBRUQseUNBQVE7OztJQUFSOztRQUNJLElBQU0sZ0JBQWdCLEdBQUcsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDO1FBRS9DLElBQUksQ0FBQyxv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c0NBQ3pDLFlBQVksU0FBQyxnQ0FBZ0M7bUNBQzdDLFlBQVksU0FBQyw2QkFBNkI7NEJBSzFDLFNBQVMsU0FBQyxXQUFXO2dDQUNyQixTQUFTLFNBQUMsZUFBZTs7aUNBOUQ5Qjs7U0E2QmEsc0JBQXNCIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIElucHV0LCBPdXRwdXQsIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgVmlld0NoaWxkLCBPbkRlc3Ryb3ksIFRlbXBsYXRlUmVmLCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1lZGlhTWF0Y2hlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9sYXlvdXQnO1xuaW1wb3J0IHsgU2lkZW5hdkxheW91dENvbnRlbnREaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3NpZGVuYXYtbGF5b3V0LWNvbnRlbnQuZGlyZWN0aXZlJztcbmltcG9ydCB7IFNpZGVuYXZMYXlvdXRIZWFkZXJEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3NpZGVuYXYtbGF5b3V0LWhlYWRlci5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgU2lkZW5hdkxheW91dE5hdmlnYXRpb25EaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3NpZGVuYXYtbGF5b3V0LW5hdmlnYXRpb24uZGlyZWN0aXZlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1zaWRlbmF2LWxheW91dCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NpZGVuYXYtbGF5b3V0LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9zaWRlbmF2LWxheW91dC5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIFNpZGVuYXZMYXlvdXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBzdGF0aWMgU1RFUF9PVkVSID0gNjAwO1xuXG4gICAgLyoqIFRoZSBzaWRlIHRoYXQgdGhlIGRyYXdlciBpcyBhdHRhY2hlZCB0by4gUG9zc2libGUgdmFsdWVzIGFyZSAnc3RhcnQnIGFuZCAnZW5kJy4gKi9cbiAgICBASW5wdXQoKSBwb3NpdGlvbiA9ICdzdGFydCc7XG5cbiAgICAvKiogTWluaW11bSBzaXplIG9mIHRoZSBuYXZpZ2F0aW9uIHJlZ2lvbi4gKi9cbiAgICBASW5wdXQoKSBzaWRlbmF2TWluOiBudW1iZXI7XG5cbiAgICAvKiogTWF4aW11bSBzaXplIG9mIHRoZSBuYXZpZ2F0aW9uIHJlZ2lvbi4gKi9cbiAgICBASW5wdXQoKSBzaWRlbmF2TWF4OiBudW1iZXI7XG5cbiAgICAvKiogU2NyZWVuIHNpemUgYXQgd2hpY2ggZGlzcGxheSBzd2l0Y2hlcyBmcm9tIHNtYWxsIHNjcmVlbiB0byBsYXJnZSBzY3JlZW4gY29uZmlndXJhdGlvbi4gKi9cbiAgICBASW5wdXQoKSBzdGVwT3ZlcjogbnVtYmVyO1xuXG4gICAgLyoqIFRvZ2dsZXMgc2hvd2luZy9oaWRpbmcgdGhlIG5hdmlnYXRpb24gcmVnaW9uLiAqL1xuICAgIEBJbnB1dCgpIGhpZGVTaWRlbmF2ID0gZmFsc2U7XG5cbiAgICAvKiogU2hvdWxkIHRoZSBuYXZpZ2F0aW9uIHJlZ2lvbiBiZSBleHBhbmRlZCBpbml0aWFsbHk/ICovXG4gICAgQElucHV0KCkgZXhwYW5kZWRTaWRlbmF2ID0gdHJ1ZTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIG1lbnUgdG9nZ2xlIGFuZCB0aGUgY29sbGFwc2VkL2V4cGFuZGVkIHN0YXRlIG9mIHRoZSBzaWRlTmF2IGNoYW5nZXMuICovXG4gICAgQE91dHB1dCgpIGV4cGFuZGVkID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgQENvbnRlbnRDaGlsZChTaWRlbmF2TGF5b3V0SGVhZGVyRGlyZWN0aXZlKSBoZWFkZXJEaXJlY3RpdmU6IFNpZGVuYXZMYXlvdXRIZWFkZXJEaXJlY3RpdmU7XG4gICAgQENvbnRlbnRDaGlsZChTaWRlbmF2TGF5b3V0TmF2aWdhdGlvbkRpcmVjdGl2ZSkgbmF2aWdhdGlvbkRpcmVjdGl2ZTogU2lkZW5hdkxheW91dE5hdmlnYXRpb25EaXJlY3RpdmU7XG4gICAgQENvbnRlbnRDaGlsZChTaWRlbmF2TGF5b3V0Q29udGVudERpcmVjdGl2ZSkgY29udGVudERpcmVjdGl2ZTogU2lkZW5hdkxheW91dENvbnRlbnREaXJlY3RpdmU7XG5cbiAgICBwcml2YXRlIG1lbnVPcGVuU3RhdGVTdWJqZWN0OiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj47XG4gICAgcHVibGljIG1lbnVPcGVuU3RhdGUkOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuXG4gICAgQFZpZXdDaGlsZCgnY29udGFpbmVyJykgY29udGFpbmVyOiBhbnk7XG4gICAgQFZpZXdDaGlsZCgnZW1wdHlUZW1wbGF0ZScpIGVtcHR5VGVtcGxhdGU6IGFueTtcblxuICAgIG1lZGlhUXVlcnlMaXN0OiBNZWRpYVF1ZXJ5TGlzdDtcbiAgICBfaXNNZW51TWluaW1pemVkO1xuXG4gICAgdGVtcGxhdGVDb250ZXh0ID0ge1xuICAgICAgICB0b2dnbGVNZW51OiAoKSA9PiB7fSxcbiAgICAgICAgaXNNZW51TWluaW1pemVkOiAoKSA9PiB0aGlzLmlzTWVudU1pbmltaXplZFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1lZGlhTWF0Y2hlcjogTWVkaWFNYXRjaGVyKSB7XG4gICAgICAgIHRoaXMub25NZWRpYVF1ZXJ5Q2hhbmdlID0gdGhpcy5vbk1lZGlhUXVlcnlDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgY29uc3QgaW5pdGlhbE1lbnVTdGF0ZSA9ICF0aGlzLmV4cGFuZGVkU2lkZW5hdjtcblxuICAgICAgICB0aGlzLm1lbnVPcGVuU3RhdGVTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihpbml0aWFsTWVudVN0YXRlKTtcbiAgICAgICAgdGhpcy5tZW51T3BlblN0YXRlJCA9IHRoaXMubWVudU9wZW5TdGF0ZVN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG5cbiAgICAgICAgY29uc3Qgc3RlcE92ZXIgPSB0aGlzLnN0ZXBPdmVyIHx8IFNpZGVuYXZMYXlvdXRDb21wb25lbnQuU1RFUF9PVkVSO1xuICAgICAgICB0aGlzLmlzTWVudU1pbmltaXplZCA9IGluaXRpYWxNZW51U3RhdGU7XG5cbiAgICAgICAgdGhpcy5tZWRpYVF1ZXJ5TGlzdCA9IHRoaXMubWVkaWFNYXRjaGVyLm1hdGNoTWVkaWEoYChtYXgtd2lkdGg6ICR7c3RlcE92ZXJ9cHgpYCk7XG4gICAgICAgIHRoaXMubWVkaWFRdWVyeUxpc3QuYWRkTGlzdGVuZXIodGhpcy5vbk1lZGlhUXVlcnlDaGFuZ2UpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUNvbnRleHQudG9nZ2xlTWVudSA9IHRoaXMudG9nZ2xlTWVudS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1lZGlhUXVlcnlMaXN0LnJlbW92ZUxpc3RlbmVyKHRoaXMub25NZWRpYVF1ZXJ5Q2hhbmdlKTtcbiAgICB9XG5cbiAgICB0b2dnbGVNZW51KCkge1xuICAgICAgICBpZiAoIXRoaXMubWVkaWFRdWVyeUxpc3QubWF0Y2hlcykge1xuICAgICAgICAgICAgdGhpcy5pc01lbnVNaW5pbWl6ZWQgPSAhdGhpcy5pc01lbnVNaW5pbWl6ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzTWVudU1pbmltaXplZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb250YWluZXIudG9nZ2xlTWVudSgpO1xuICAgICAgICB0aGlzLmV4cGFuZGVkLmVtaXQoIXRoaXMuaXNNZW51TWluaW1pemVkKTtcbiAgICB9XG5cbiAgICBnZXQgaXNNZW51TWluaW1pemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNNZW51TWluaW1pemVkO1xuICAgIH1cblxuICAgIHNldCBpc01lbnVNaW5pbWl6ZWQobWVudVN0YXRlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2lzTWVudU1pbmltaXplZCA9IG1lbnVTdGF0ZTtcbiAgICAgICAgdGhpcy5tZW51T3BlblN0YXRlU3ViamVjdC5uZXh0KCFtZW51U3RhdGUpO1xuICAgIH1cblxuICAgIGdldCBpc0hlYWRlckluc2lkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWFRdWVyeUxpc3QubWF0Y2hlcztcbiAgICB9XG5cbiAgICBnZXQgaGVhZGVyVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlckRpcmVjdGl2ZSAmJiB0aGlzLmhlYWRlckRpcmVjdGl2ZS50ZW1wbGF0ZSB8fCB0aGlzLmVtcHR5VGVtcGxhdGU7XG4gICAgfVxuXG4gICAgZ2V0IG5hdmlnYXRpb25UZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvbkRpcmVjdGl2ZSAmJiB0aGlzLm5hdmlnYXRpb25EaXJlY3RpdmUudGVtcGxhdGUgfHwgdGhpcy5lbXB0eVRlbXBsYXRlO1xuICAgIH1cblxuICAgIGdldCBjb250ZW50VGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnREaXJlY3RpdmUgJiYgdGhpcy5jb250ZW50RGlyZWN0aXZlLnRlbXBsYXRlIHx8IHRoaXMuZW1wdHlUZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBvbk1lZGlhUXVlcnlDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuaXNNZW51TWluaW1pemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQuZW1pdCghdGhpcy5pc01lbnVNaW5pbWl6ZWQpO1xuICAgIH1cbn1cbiJdfQ==