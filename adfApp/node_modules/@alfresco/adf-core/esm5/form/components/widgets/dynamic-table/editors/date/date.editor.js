/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { UserPreferencesService } from '../../../../../../services/user-preferences.service';
import { MomentDateAdapter } from '../../../../../../utils/momentDateAdapter';
import { MOMENT_DATE_FORMATS } from '../../../../../../utils/moment-date-formats.model';
import { Component, Input } from '@angular/core';
import { DateAdapter, MAT_DATE_FORMATS } from '@angular/material';
import moment from 'moment-es6';
import { DynamicTableModel } from './../../dynamic-table.widget.model';
var ɵ0 = MOMENT_DATE_FORMATS;
var DateEditorComponent = /** @class */ (function () {
    function DateEditorComponent(dateAdapter, preferences) {
        this.dateAdapter = dateAdapter;
        this.preferences = preferences;
        this.DATE_FORMAT = 'DD-MM-YYYY';
    }
    /**
     * @return {?}
     */
    DateEditorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.preferences.locale$.subscribe(function (locale) {
            _this.dateAdapter.setLocale(locale);
        });
        /** @type {?} */
        var momentDateAdapter = /** @type {?} */ (this.dateAdapter);
        momentDateAdapter.overrideDisplyaFormat = this.DATE_FORMAT;
        this.value = moment(this.table.getCellValue(this.row, this.column), 'YYYY-MM-DD');
    };
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    DateEditorComponent.prototype.onDateChanged = /**
     * @param {?} newDateValue
     * @return {?}
     */
    function (newDateValue) {
        if (newDateValue && newDateValue.value) {
            /** @type {?} */
            var momentDate = moment(newDateValue.value, this.DATE_FORMAT, true);
            if (!momentDate.isValid()) {
                this.row.value[this.column.id] = '';
            }
            else {
                this.row.value[this.column.id] = momentDate.format('YYYY-MM-DD') + "T00:00:00.000Z";
                this.table.flushValue();
            }
        }
    };
    DateEditorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-date-editor',
                    template: "<div>\n    <mat-form-field class=\"adf-date-editor\">\n        <label [attr.for]=\"column.id\">{{column.name}} (d-M-yyyy)</label>\n        <input matInput\n            id=\"dateInput\"\n            type=\"text\"\n            [matDatepicker]=\"datePicker\"\n            [value]=\"value\"\n            [id]=\"column.id\"\n            [required]=\"column.required\"\n            [disabled]=\"!column.editable\"\n            (focusout)=\"onDateChanged($event.srcElement.value)\"\n            (dateChange)=\"onDateChanged($event)\">\n        <mat-datepicker-toggle  *ngIf=\"column.editable\" matSuffix [for]=\"datePicker\" class=\"adf-date-editor-button\" ></mat-datepicker-toggle>\n    </mat-form-field>\n    <mat-datepicker #datePicker [touchUi]=\"true\"></mat-datepicker>\n</div>\n",
                    providers: [
                        { provide: DateAdapter, useClass: MomentDateAdapter },
                        { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                    ],
                    styles: [".adf-date-editor{width:100%}.adf-date-editor-button{position:relative;top:25px}"]
                }] }
    ];
    /** @nocollapse */
    DateEditorComponent.ctorParameters = function () { return [
        { type: DateAdapter },
        { type: UserPreferencesService }
    ]; };
    DateEditorComponent.propDecorators = {
        table: [{ type: Input }],
        row: [{ type: Input }],
        column: [{ type: Input }]
    };
    return DateEditorComponent;
}());
export { DateEditorComponent };
if (false) {
    /** @type {?} */
    DateEditorComponent.prototype.DATE_FORMAT;
    /** @type {?} */
    DateEditorComponent.prototype.value;
    /** @type {?} */
    DateEditorComponent.prototype.table;
    /** @type {?} */
    DateEditorComponent.prototype.row;
    /** @type {?} */
    DateEditorComponent.prototype.column;
    /** @type {?} */
    DateEditorComponent.prototype.minDate;
    /** @type {?} */
    DateEditorComponent.prototype.maxDate;
    /** @type {?} */
    DateEditorComponent.prototype.dateAdapter;
    /** @type {?} */
    DateEditorComponent.prototype.preferences;
}
export { ɵ0 };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5lZGl0b3IuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvcmUvIiwic291cmNlcyI6WyJmb3JtL2NvbXBvbmVudHMvd2lkZ2V0cy9keW5hbWljLXRhYmxlL2VkaXRvcnMvZGF0ZS9kYXRlLmVkaXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxxREFBcUQsQ0FBQztBQUM3RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUM5RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtREFBbUQsQ0FBQztBQUN4RixPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUN6RCxPQUFPLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbEUsT0FBTyxNQUFNLE1BQU0sWUFBWSxDQUFDO0FBSWhDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO1NBT3pCLG1CQUFtQjs7SUFxQjdELDZCQUFvQixXQUFnQyxFQUNoQztRQURBLGdCQUFXLEdBQVgsV0FBVyxDQUFxQjtRQUNoQyxnQkFBVyxHQUFYLFdBQVc7MkJBakJULFlBQVk7S0FrQmpDOzs7O0lBRUQsc0NBQVE7OztJQUFSO1FBQUEsaUJBUUM7UUFQRyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsVUFBQyxNQUFNO1lBQ3RDLEtBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3RDLENBQUMsQ0FBQzs7UUFDSCxJQUFJLGlCQUFpQixxQkFBdUIsSUFBSSxDQUFDLFdBQVcsRUFBQztRQUM3RCxpQkFBaUIsQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBRTNELElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDO0tBQ3JGOzs7OztJQUVELDJDQUFhOzs7O0lBQWIsVUFBYyxZQUFZO1FBQ3RCLElBQUksWUFBWSxJQUFJLFlBQVksQ0FBQyxLQUFLLEVBQUU7O1lBQ3BDLElBQUksVUFBVSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFFcEUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRTtnQkFDdkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7YUFDdkM7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBTSxVQUFVLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxtQkFBZ0IsQ0FBQztnQkFDcEYsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQzthQUMzQjtTQUNKO0tBQ0o7O2dCQW5ESixTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLGlCQUFpQjtvQkFDM0IsdXhCQUFpQztvQkFDakMsU0FBUyxFQUFFO3dCQUNQLEVBQUMsT0FBTyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsaUJBQWlCLEVBQUM7d0JBQ25ELEVBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFFBQVEsSUFBcUIsRUFBQztxQkFBQzs7aUJBRWxFOzs7O2dCQWRRLFdBQVc7Z0JBSlgsc0JBQXNCOzs7d0JBeUIxQixLQUFLO3NCQUdMLEtBQUs7eUJBR0wsS0FBSzs7OEJBbERWOztTQXNDYSxtQkFBbUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpjb21wb25lbnQtc2VsZWN0b3IgICovXG5cbmltcG9ydCB7IFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi9zZXJ2aWNlcy91c2VyLXByZWZlcmVuY2VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTW9tZW50RGF0ZUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi91dGlscy9tb21lbnREYXRlQWRhcHRlcic7XG5pbXBvcnQgeyBNT01FTlRfREFURV9GT1JNQVRTIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vdXRpbHMvbW9tZW50LWRhdGUtZm9ybWF0cy5tb2RlbCc7XG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERhdGVBZGFwdGVyLCBNQVRfREFURV9GT1JNQVRTIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQtZXM2JztcbmltcG9ydCB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBEeW5hbWljVGFibGVDb2x1bW4gfSBmcm9tICcuLy4uLy4uL2R5bmFtaWMtdGFibGUtY29sdW1uLm1vZGVsJztcbmltcG9ydCB7IER5bmFtaWNUYWJsZVJvdyB9IGZyb20gJy4vLi4vLi4vZHluYW1pYy10YWJsZS1yb3cubW9kZWwnO1xuaW1wb3J0IHsgRHluYW1pY1RhYmxlTW9kZWwgfSBmcm9tICcuLy4uLy4uL2R5bmFtaWMtdGFibGUud2lkZ2V0Lm1vZGVsJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtZGF0ZS1lZGl0b3InLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9kYXRlLmVkaXRvci5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge3Byb3ZpZGU6IERhdGVBZGFwdGVyLCB1c2VDbGFzczogTW9tZW50RGF0ZUFkYXB0ZXJ9LFxuICAgICAgICB7cHJvdmlkZTogTUFUX0RBVEVfRk9STUFUUywgdXNlVmFsdWU6IE1PTUVOVF9EQVRFX0ZPUk1BVFN9XSxcbiAgICBzdHlsZVVybHM6IFsnLi9kYXRlLmVkaXRvci5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgRGF0ZUVkaXRvckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICBEQVRFX0ZPUk1BVDogc3RyaW5nID0gJ0RELU1NLVlZWVknO1xuXG4gICAgdmFsdWU6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgdGFibGU6IER5bmFtaWNUYWJsZU1vZGVsO1xuXG4gICAgQElucHV0KClcbiAgICByb3c6IER5bmFtaWNUYWJsZVJvdztcblxuICAgIEBJbnB1dCgpXG4gICAgY29sdW1uOiBEeW5hbWljVGFibGVDb2x1bW47XG5cbiAgICBtaW5EYXRlOiBNb21lbnQ7XG4gICAgbWF4RGF0ZTogTW9tZW50O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRlQWRhcHRlcjogRGF0ZUFkYXB0ZXI8TW9tZW50PixcbiAgICAgICAgICAgICAgICBwcml2YXRlIHByZWZlcmVuY2VzOiBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXMubG9jYWxlJC5zdWJzY3JpYmUoKGxvY2FsZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kYXRlQWRhcHRlci5zZXRMb2NhbGUobG9jYWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBtb21lbnREYXRlQWRhcHRlciA9IDxNb21lbnREYXRlQWRhcHRlcj4gdGhpcy5kYXRlQWRhcHRlcjtcbiAgICAgICAgbW9tZW50RGF0ZUFkYXB0ZXIub3ZlcnJpZGVEaXNwbHlhRm9ybWF0ID0gdGhpcy5EQVRFX0ZPUk1BVDtcblxuICAgICAgICB0aGlzLnZhbHVlID0gbW9tZW50KHRoaXMudGFibGUuZ2V0Q2VsbFZhbHVlKHRoaXMucm93LCB0aGlzLmNvbHVtbiksICdZWVlZLU1NLUREJyk7XG4gICAgfVxuXG4gICAgb25EYXRlQ2hhbmdlZChuZXdEYXRlVmFsdWUpIHtcbiAgICAgICAgaWYgKG5ld0RhdGVWYWx1ZSAmJiBuZXdEYXRlVmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtb21lbnREYXRlID0gbW9tZW50KG5ld0RhdGVWYWx1ZS52YWx1ZSwgdGhpcy5EQVRFX0ZPUk1BVCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmICghbW9tZW50RGF0ZS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdy52YWx1ZVt0aGlzLmNvbHVtbi5pZF0gPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3cudmFsdWVbdGhpcy5jb2x1bW4uaWRdID0gYCR7bW9tZW50RGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKX1UMDA6MDA6MDAuMDAwWmA7XG4gICAgICAgICAgICAgICAgdGhpcy50YWJsZS5mbHVzaFZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiJdfQ==