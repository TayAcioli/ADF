/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Directive, ElementRef, forwardRef, HostListener, Input, Renderer2 } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
/** @type {?} */
export var CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return InputMaskDirective; }),
    multi: true
};
var InputMaskDirective = /** @class */ (function () {
    function InputMaskDirective(el, render) {
        this.el = el;
        this.render = render;
        this.translationMask = {
            '0': { pattern: /\d/ },
            '9': { pattern: /\d/, optional: true },
            '#': { pattern: /\d/, recursive: true },
            'A': { pattern: /[a-zA-Z0-9]/ },
            'S': { pattern: /[a-zA-Z]/ }
        };
        this.byPassKeys = [9, 16, 17, 18, 36, 37, 38, 39, 40, 91];
        this.invalidCharacters = [];
        this._onChange = function (_) {
        };
        this._onTouched = function () {
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    InputMaskDirective.prototype.onTextInput = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.inputMask && this.inputMask.mask) {
            this.maskValue(this.el.nativeElement.value, this.el.nativeElement.selectionStart, this.inputMask.mask, this.inputMask.isReversed, event.keyCode);
        }
        else {
            this._onChange(this.el.nativeElement.value);
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    InputMaskDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['inputMask'] && changes['inputMask'].currentValue['mask']) {
            this.inputMask = changes['inputMask'].currentValue;
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    InputMaskDirective.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.el.nativeElement.value = value;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    InputMaskDirective.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    InputMaskDirective.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouched = fn;
    };
    /**
     * @param {?} actualValue
     * @param {?} startCaret
     * @param {?} maskToApply
     * @param {?} isMaskReversed
     * @param {?} keyCode
     * @return {?}
     */
    InputMaskDirective.prototype.maskValue = /**
     * @param {?} actualValue
     * @param {?} startCaret
     * @param {?} maskToApply
     * @param {?} isMaskReversed
     * @param {?} keyCode
     * @return {?}
     */
    function (actualValue, startCaret, maskToApply, isMaskReversed, keyCode) {
        if (this.byPassKeys.indexOf(keyCode) === -1) {
            /** @type {?} */
            var value = this.getMasked(false, actualValue, maskToApply, isMaskReversed);
            /** @type {?} */
            var calculatedCaret = this.calculateCaretPosition(startCaret, actualValue, keyCode);
            this.render.setAttribute(this.el.nativeElement, 'value', value);
            this.el.nativeElement.value = value;
            this.setValue(value);
            this._onChange(value);
            this.setCaretPosition(calculatedCaret);
        }
    };
    /**
     * @param {?} caretPosition
     * @return {?}
     */
    InputMaskDirective.prototype.setCaretPosition = /**
     * @param {?} caretPosition
     * @return {?}
     */
    function (caretPosition) {
        this.el.nativeElement.moveStart = caretPosition;
        this.el.nativeElement.moveEnd = caretPosition;
    };
    /**
     * @param {?} caretPosition
     * @param {?} newValue
     * @param {?} keyCode
     * @return {?}
     */
    InputMaskDirective.prototype.calculateCaretPosition = /**
     * @param {?} caretPosition
     * @param {?} newValue
     * @param {?} keyCode
     * @return {?}
     */
    function (caretPosition, newValue, keyCode) {
        /** @type {?} */
        var newValueLength = newValue.length;
        /** @type {?} */
        var oldValue = this.getValue() || '';
        /** @type {?} */
        var oldValueLength = oldValue.length;
        if (keyCode === 8 && oldValue !== newValue) {
            caretPosition = caretPosition - (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
        }
        else if (oldValue !== newValue) {
            if (caretPosition >= oldValueLength) {
                caretPosition = newValueLength;
            }
            else {
                caretPosition = caretPosition + (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
            }
        }
        return caretPosition;
    };
    /**
     * @param {?} skipMaskChars
     * @param {?} val
     * @param {?} mask
     * @param {?=} isReversed
     * @return {?}
     */
    InputMaskDirective.prototype.getMasked = /**
     * @param {?} skipMaskChars
     * @param {?} val
     * @param {?} mask
     * @param {?=} isReversed
     * @return {?}
     */
    function (skipMaskChars, val, mask, isReversed) {
        if (isReversed === void 0) { isReversed = false; }
        /** @type {?} */
        var buf = [];
        /** @type {?} */
        var value = val;
        /** @type {?} */
        var maskIndex = 0;
        /** @type {?} */
        var maskLen = mask.length;
        /** @type {?} */
        var valueIndex = 0;
        /** @type {?} */
        var valueLength = value.length;
        /** @type {?} */
        var offset = 1;
        /** @type {?} */
        var addMethod = 'push';
        /** @type {?} */
        var resetPos = -1;
        /** @type {?} */
        var lastMaskChar;
        /** @type {?} */
        var lastUntranslatedMaskChar;
        /** @type {?} */
        var check;
        if (isReversed) {
            addMethod = 'unshift';
            offset = -1;
            lastMaskChar = 0;
            maskIndex = maskLen - 1;
            valueIndex = valueLength - 1;
        }
        else {
            lastMaskChar = maskLen - 1;
        }
        check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        while (check) {
            /** @type {?} */
            var maskDigit = mask.charAt(maskIndex);
            /** @type {?} */
            var valDigit = value.charAt(valueIndex);
            /** @type {?} */
            var translation = this.translationMask[maskDigit];
            if (translation) {
                if (valDigit.match(translation.pattern)) {
                    buf[addMethod](valDigit);
                    if (translation.recursive) {
                        if (resetPos === -1) {
                            resetPos = maskIndex;
                        }
                        else if (maskIndex === lastMaskChar) {
                            maskIndex = resetPos - offset;
                        }
                        if (lastMaskChar === resetPos) {
                            maskIndex -= offset;
                        }
                    }
                    maskIndex += offset;
                }
                else if (valDigit === lastUntranslatedMaskChar) {
                    lastUntranslatedMaskChar = undefined;
                }
                else if (translation.optional) {
                    maskIndex += offset;
                    valueIndex -= offset;
                }
                else {
                    this.invalidCharacters.push({
                        index: valueIndex,
                        digit: valDigit,
                        translated: translation.pattern
                    });
                }
                valueIndex += offset;
            }
            else {
                if (!skipMaskChars) {
                    buf[addMethod](maskDigit);
                }
                if (valDigit === maskDigit) {
                    valueIndex += offset;
                }
                else {
                    lastUntranslatedMaskChar = maskDigit;
                }
                maskIndex += offset;
            }
            check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        }
        /** @type {?} */
        var lastMaskCharDigit = mask.charAt(lastMaskChar);
        if (maskLen === valueLength + 1 && !this.translationMask[lastMaskCharDigit]) {
            buf.push(lastMaskCharDigit);
        }
        return buf.join('');
    };
    /**
     * @param {?} isReversed
     * @param {?} maskIndex
     * @param {?} maskLen
     * @param {?} valueIndex
     * @param {?} valueLength
     * @return {?}
     */
    InputMaskDirective.prototype.isToCheck = /**
     * @param {?} isReversed
     * @param {?} maskIndex
     * @param {?} maskLen
     * @param {?} valueIndex
     * @param {?} valueLength
     * @return {?}
     */
    function (isReversed, maskIndex, maskLen, valueIndex, valueLength) {
        /** @type {?} */
        var check = false;
        if (isReversed) {
            check = (maskIndex > -1) && (valueIndex > -1);
        }
        else {
            check = (maskIndex < maskLen) && (valueIndex < valueLength);
        }
        return check;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    InputMaskDirective.prototype.setValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
    };
    /**
     * @return {?}
     */
    InputMaskDirective.prototype.getValue = /**
     * @return {?}
     */
    function () {
        return this.value;
    };
    InputMaskDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[textMask]',
                    providers: [CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR]
                },] }
    ];
    /** @nocollapse */
    InputMaskDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    InputMaskDirective.propDecorators = {
        inputMask: [{ type: Input, args: ['textMask',] }],
        onTextInput: [{ type: HostListener, args: ['input', ['$event'],] }, { type: HostListener, args: ['keyup', ['$event'],] }]
    };
    return InputMaskDirective;
}());
export { InputMaskDirective };
if (false) {
    /**
     * Object defining mask and "reversed" status.
     * @type {?}
     */
    InputMaskDirective.prototype.inputMask;
    /** @type {?} */
    InputMaskDirective.prototype.translationMask;
    /** @type {?} */
    InputMaskDirective.prototype.byPassKeys;
    /** @type {?} */
    InputMaskDirective.prototype.value;
    /** @type {?} */
    InputMaskDirective.prototype.invalidCharacters;
    /** @type {?} */
    InputMaskDirective.prototype._onChange;
    /** @type {?} */
    InputMaskDirective.prototype._onTouched;
    /** @type {?} */
    InputMaskDirective.prototype.el;
    /** @type {?} */
    InputMaskDirective.prototype.render;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dC1tYXNrLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29yZS8iLCJzb3VyY2VzIjpbImZvcm0vY29tcG9uZW50cy93aWRnZXRzL3RleHQvdGV4dC1tYXNrLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxPQUFPLEVBQ0gsU0FBUyxFQUNULFVBQVUsRUFDVixVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFFTCxTQUFTLEVBRVosTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDOztBQUV6RSxXQUFhLG1DQUFtQyxHQUFRO0lBQ3BELE9BQU8sRUFBRSxpQkFBaUI7SUFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxjQUFNLE9BQUEsa0JBQWtCLEVBQWxCLENBQWtCLENBQUM7SUFDakQsS0FBSyxFQUFFLElBQUk7Q0FDZCxDQUFDOztJQTBCRSw0QkFBb0IsRUFBYyxFQUFVLE1BQWlCO1FBQXpDLE9BQUUsR0FBRixFQUFFLENBQVk7UUFBVSxXQUFNLEdBQU4sTUFBTSxDQUFXOytCQVpuQztZQUN0QixHQUFHLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFO1lBQ3RCLEdBQUcsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRTtZQUN0QyxHQUFHLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUU7WUFDdkMsR0FBRyxFQUFFLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRTtZQUMvQixHQUFHLEVBQUUsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFO1NBQy9COzBCQUVvQixDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUs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QUcsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUMvQjtRQUVELE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUN2Qjs7Ozs7Ozs7O0lBRU8sc0NBQVM7Ozs7Ozs7O2NBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVc7O1FBQ3JFLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNsQixJQUFJLFVBQVUsRUFBRTtZQUNaLEtBQUssR0FBRyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakQ7YUFBTTtZQUNILEtBQUssR0FBRyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQztTQUMvRDtRQUNELE9BQU8sS0FBSyxDQUFDOzs7Ozs7SUFHVCxxQ0FBUTs7OztjQUFDLEtBQUs7UUFDbEIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7Ozs7O0lBR2YscUNBQVE7Ozs7UUFDWixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7OztnQkE1THpCLFNBQVMsU0FBQztvQkFDUCxRQUFRLEVBQUUsWUFBWTtvQkFDdEIsU0FBUyxFQUFFLENBQUMsbUNBQW1DLENBQUM7aUJBQ25EOzs7O2dCQW5CRyxVQUFVO2dCQUtWLFNBQVM7Ozs0QkFrQlIsS0FBSyxTQUFDLFVBQVU7OEJBMEJoQixZQUFZLFNBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDLGNBQ2hDLFlBQVksU0FBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUM7OzZCQXZFckM7O1NBeUNhLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbiAvKiB0c2xpbnQ6ZGlzYWJsZTogY29tcG9uZW50LXNlbGVjdG9yIG5vLXVzZS1iZWZvcmUtZGVjbGFyZSBuby1pbnB1dC1yZW5hbWUgICovXG5cbmltcG9ydCB7XG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgZm9yd2FyZFJlZixcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5wdXQsXG4gICAgT25DaGFuZ2VzLFxuICAgIFJlbmRlcmVyMixcbiAgICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5leHBvcnQgY29uc3QgQ1VTVE9NX0lOUFVUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJbnB1dE1hc2tEaXJlY3RpdmUpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t0ZXh0TWFza10nLFxuICAgIHByb3ZpZGVyczogW0NVU1RPTV9JTlBVVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SXVxufSlcbmV4cG9ydCBjbGFzcyBJbnB1dE1hc2tEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICAgIC8qKiBPYmplY3QgZGVmaW5pbmcgbWFzayBhbmQgXCJyZXZlcnNlZFwiIHN0YXR1cy4gKi9cbiAgICBASW5wdXQoJ3RleHRNYXNrJykgaW5wdXRNYXNrOiB7XG4gICAgICAgIG1hc2s6ICcnLFxuICAgICAgICBpc1JldmVyc2VkOiBmYWxzZVxuICAgIH07XG5cbiAgICBwcml2YXRlIHRyYW5zbGF0aW9uTWFzayA9IHtcbiAgICAgICAgJzAnOiB7IHBhdHRlcm46IC9cXGQvIH0sXG4gICAgICAgICc5JzogeyBwYXR0ZXJuOiAvXFxkLywgb3B0aW9uYWw6IHRydWUgfSxcbiAgICAgICAgJyMnOiB7IHBhdHRlcm46IC9cXGQvLCByZWN1cnNpdmU6IHRydWUgfSxcbiAgICAgICAgJ0EnOiB7IHBhdHRlcm46IC9bYS16QS1aMC05XS8gfSxcbiAgICAgICAgJ1MnOiB7IHBhdHRlcm46IC9bYS16QS1aXS8gfVxuICAgIH07XG5cbiAgICBwcml2YXRlIGJ5UGFzc0tleXMgPSBbOSwgMTYsIDE3LCAxOCwgMzYsIDM3LCAzOCwgMzksIDQwLCA5MV07XG4gICAgcHJpdmF0ZSB2YWx1ZTtcbiAgICBwcml2YXRlIGludmFsaWRDaGFyYWN0ZXJzID0gW107XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcjogUmVuZGVyZXIyKSB7XG4gICAgfVxuXG4gICAgX29uQ2hhbmdlID0gKF86IGFueSkgPT4ge1xuICAgIH1cblxuICAgIF9vblRvdWNoZWQgPSAoKSA9PiB7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignaW5wdXQnLCBbJyRldmVudCddKVxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleXVwJywgWyckZXZlbnQnXSkgb25UZXh0SW5wdXQoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRNYXNrICYmIHRoaXMuaW5wdXRNYXNrLm1hc2spIHtcbiAgICAgICAgICAgIHRoaXMubWFza1ZhbHVlKHRoaXMuZWwubmF0aXZlRWxlbWVudC52YWx1ZSwgdGhpcy5lbC5uYXRpdmVFbGVtZW50LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRNYXNrLm1hc2ssIHRoaXMuaW5wdXRNYXNrLmlzUmV2ZXJzZWQsIGV2ZW50LmtleUNvZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UodGhpcy5lbC5uYXRpdmVFbGVtZW50LnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXNbJ2lucHV0TWFzayddICYmIGNoYW5nZXNbJ2lucHV0TWFzayddLmN1cnJlbnRWYWx1ZVsnbWFzayddKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0TWFzayA9IGNoYW5nZXNbJ2lucHV0TWFzayddLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uVG91Y2hlZCA9IGZuO1xuICAgIH1cblxuICAgIHByaXZhdGUgbWFza1ZhbHVlKGFjdHVhbFZhbHVlLCBzdGFydENhcmV0LCBtYXNrVG9BcHBseSwgaXNNYXNrUmV2ZXJzZWQsIGtleUNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYnlQYXNzS2V5cy5pbmRleE9mKGtleUNvZGUpID09PSAtMSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXRNYXNrZWQoZmFsc2UsIGFjdHVhbFZhbHVlLCBtYXNrVG9BcHBseSwgaXNNYXNrUmV2ZXJzZWQpO1xuICAgICAgICAgICAgbGV0IGNhbGN1bGF0ZWRDYXJldCA9IHRoaXMuY2FsY3VsYXRlQ2FyZXRQb3NpdGlvbihzdGFydENhcmV0LCBhY3R1YWxWYWx1ZSwga2V5Q29kZSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlci5zZXRBdHRyaWJ1dGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zZXRDYXJldFBvc2l0aW9uKGNhbGN1bGF0ZWRDYXJldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldENhcmV0UG9zaXRpb24oY2FyZXRQb3NpdGlvbikge1xuICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQubW92ZVN0YXJ0ID0gY2FyZXRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50Lm1vdmVFbmQgPSBjYXJldFBvc2l0aW9uO1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZUNhcmV0UG9zaXRpb24oY2FyZXRQb3NpdGlvbiwgbmV3VmFsdWUsIGtleUNvZGUpIHtcbiAgICAgICAgbGV0IG5ld1ZhbHVlTGVuZ3RoID0gbmV3VmFsdWUubGVuZ3RoO1xuICAgICAgICBsZXQgb2xkVmFsdWUgPSB0aGlzLmdldFZhbHVlKCkgfHwgJyc7XG4gICAgICAgIGxldCBvbGRWYWx1ZUxlbmd0aCA9IG9sZFZhbHVlLmxlbmd0aDtcblxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gOCAmJiBvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBjYXJldFBvc2l0aW9uIC0gKG5ld1ZhbHVlLnNsaWNlKDAsIGNhcmV0UG9zaXRpb24pLmxlbmd0aCAtIG9sZFZhbHVlLnNsaWNlKDAsIGNhcmV0UG9zaXRpb24pLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY2FyZXRQb3NpdGlvbiA+PSBvbGRWYWx1ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBuZXdWYWx1ZUxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IGNhcmV0UG9zaXRpb24gKyAobmV3VmFsdWUuc2xpY2UoMCwgY2FyZXRQb3NpdGlvbikubGVuZ3RoIC0gb2xkVmFsdWUuc2xpY2UoMCwgY2FyZXRQb3NpdGlvbikubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FyZXRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICBnZXRNYXNrZWQoc2tpcE1hc2tDaGFycywgdmFsLCBtYXNrLCBpc1JldmVyc2VkID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGJ1ZiA9IFtdLFxuICAgICAgICAgICAgdmFsdWUgPSB2YWwsXG4gICAgICAgICAgICBtYXNrSW5kZXggPSAwLFxuICAgICAgICAgICAgbWFza0xlbiA9IG1hc2subGVuZ3RoLFxuICAgICAgICAgICAgdmFsdWVJbmRleCA9IDAsXG4gICAgICAgICAgICB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgIG9mZnNldCA9IDEsXG4gICAgICAgICAgICBhZGRNZXRob2QgPSAncHVzaCcsXG4gICAgICAgICAgICByZXNldFBvcyA9IC0xLFxuICAgICAgICAgICAgbGFzdE1hc2tDaGFyLFxuICAgICAgICAgICAgbGFzdFVudHJhbnNsYXRlZE1hc2tDaGFyLFxuICAgICAgICAgICAgY2hlY2s7XG5cbiAgICAgICAgaWYgKGlzUmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIGFkZE1ldGhvZCA9ICd1bnNoaWZ0JztcbiAgICAgICAgICAgIG9mZnNldCA9IC0xO1xuICAgICAgICAgICAgbGFzdE1hc2tDaGFyID0gMDtcbiAgICAgICAgICAgIG1hc2tJbmRleCA9IG1hc2tMZW4gLSAxO1xuICAgICAgICAgICAgdmFsdWVJbmRleCA9IHZhbHVlTGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RNYXNrQ2hhciA9IG1hc2tMZW4gLSAxO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrID0gdGhpcy5pc1RvQ2hlY2soaXNSZXZlcnNlZCwgbWFza0luZGV4LCBtYXNrTGVuLCB2YWx1ZUluZGV4LCB2YWx1ZUxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChjaGVjaykge1xuICAgICAgICAgICAgbGV0IG1hc2tEaWdpdCA9IG1hc2suY2hhckF0KG1hc2tJbmRleCksXG4gICAgICAgICAgICAgICAgdmFsRGlnaXQgPSB2YWx1ZS5jaGFyQXQodmFsdWVJbmRleCksXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gPSB0aGlzLnRyYW5zbGF0aW9uTWFza1ttYXNrRGlnaXRdO1xuXG4gICAgICAgICAgICBpZiAodHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsRGlnaXQubWF0Y2godHJhbnNsYXRpb24ucGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2FkZE1ldGhvZF0odmFsRGlnaXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRpb24ucmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzZXRQb3MgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRQb3MgPSBtYXNrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hc2tJbmRleCA9PT0gbGFzdE1hc2tDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0luZGV4ID0gcmVzZXRQb3MgLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdE1hc2tDaGFyID09PSByZXNldFBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tJbmRleCAtPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFza0luZGV4ICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbERpZ2l0ID09PSBsYXN0VW50cmFuc2xhdGVkTWFza0NoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVudHJhbnNsYXRlZE1hc2tDaGFyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhbnNsYXRpb24ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFza0luZGV4ICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVJbmRleCAtPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkQ2hhcmFjdGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiB2YWx1ZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXQ6IHZhbERpZ2l0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZDogdHJhbnNsYXRpb24ucGF0dGVyblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVJbmRleCArPSBvZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghc2tpcE1hc2tDaGFycykge1xuICAgICAgICAgICAgICAgICAgICBidWZbYWRkTWV0aG9kXShtYXNrRGlnaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsRGlnaXQgPT09IG1hc2tEaWdpdCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUluZGV4ICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VW50cmFuc2xhdGVkTWFza0NoYXIgPSBtYXNrRGlnaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hc2tJbmRleCArPSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVjayA9IHRoaXMuaXNUb0NoZWNrKGlzUmV2ZXJzZWQsIG1hc2tJbmRleCwgbWFza0xlbiwgdmFsdWVJbmRleCwgdmFsdWVMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxhc3RNYXNrQ2hhckRpZ2l0ID0gbWFzay5jaGFyQXQobGFzdE1hc2tDaGFyKTtcbiAgICAgICAgaWYgKG1hc2tMZW4gPT09IHZhbHVlTGVuZ3RoICsgMSAmJiAhdGhpcy50cmFuc2xhdGlvbk1hc2tbbGFzdE1hc2tDaGFyRGlnaXRdKSB7XG4gICAgICAgICAgICBidWYucHVzaChsYXN0TWFza0NoYXJEaWdpdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnVmLmpvaW4oJycpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaXNUb0NoZWNrKGlzUmV2ZXJzZWQsIG1hc2tJbmRleCwgbWFza0xlbiwgdmFsdWVJbmRleCwgdmFsdWVMZW5ndGgpIHtcbiAgICAgICAgbGV0IGNoZWNrID0gZmFsc2U7XG4gICAgICAgIGlmIChpc1JldmVyc2VkKSB7XG4gICAgICAgICAgICBjaGVjayA9IChtYXNrSW5kZXggPiAtMSkgJiYgKHZhbHVlSW5kZXggPiAtMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVjayA9IChtYXNrSW5kZXggPCBtYXNrTGVuKSAmJiAodmFsdWVJbmRleCA8IHZhbHVlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufVxuIl19