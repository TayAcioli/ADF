/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { Subject, from, throwError } from 'rxjs';
import { PermissionsEnum } from '../models/permissions.enum';
import { AlfrescoApiService } from './alfresco-api.service';
import { AuthenticationService } from './authentication.service';
import { LogService } from './log.service';
import { catchError, tap } from 'rxjs/operators';
var ContentService = /** @class */ (function () {
    function ContentService(authService, apiService, logService, sanitizer) {
        this.authService = authService;
        this.apiService = apiService;
        this.logService = logService;
        this.sanitizer = sanitizer;
        this.folderCreated = new Subject();
        this.folderCreate = new Subject();
        this.folderEdit = new Subject();
        this.saveData = (function () {
            /** @type {?} */
            var a = document.createElement('a');
            document.body.appendChild(a);
            a.style.display = 'none';
            return function (data, format, fileName) {
                /** @type {?} */
                var blob = null;
                if (format === 'blob' || format === 'data') {
                    blob = new Blob([data], { type: 'octet/stream' });
                }
                if (format === 'object' || format === 'json') {
                    /** @type {?} */
                    var json = JSON.stringify(data);
                    blob = new Blob([json], { type: 'octet/stream' });
                }
                if (blob) {
                    if (typeof window.navigator !== 'undefined' && window.navigator.msSaveOrOpenBlob) {
                        navigator.msSaveOrOpenBlob(blob, fileName);
                    }
                    else {
                        /** @type {?} */
                        var url = window.URL.createObjectURL(blob);
                        a.href = url;
                        a.download = fileName;
                        a.click();
                        window.URL.revokeObjectURL(url);
                    }
                }
            };
        }());
    }
    /**
     * Invokes content download for a Blob with a file name.
     * @param blob Content to download.
     * @param fileName Name of the resulting file.
     */
    /**
     * Invokes content download for a Blob with a file name.
     * @param {?} blob Content to download.
     * @param {?} fileName Name of the resulting file.
     * @return {?}
     */
    ContentService.prototype.downloadBlob = /**
     * Invokes content download for a Blob with a file name.
     * @param {?} blob Content to download.
     * @param {?} fileName Name of the resulting file.
     * @return {?}
     */
    function (blob, fileName) {
        this.saveData(blob, 'blob', fileName);
    };
    /**
     * Invokes content download for a data array with a file name.
     * @param data Data to download.
     * @param fileName Name of the resulting file.
     */
    /**
     * Invokes content download for a data array with a file name.
     * @param {?} data Data to download.
     * @param {?} fileName Name of the resulting file.
     * @return {?}
     */
    ContentService.prototype.downloadData = /**
     * Invokes content download for a data array with a file name.
     * @param {?} data Data to download.
     * @param {?} fileName Name of the resulting file.
     * @return {?}
     */
    function (data, fileName) {
        this.saveData(data, 'data', fileName);
    };
    /**
     * Invokes content download for a JSON object with a file name.
     * @param json JSON object to download.
     * @param fileName Name of the resulting file.
     */
    /**
     * Invokes content download for a JSON object with a file name.
     * @param {?} json JSON object to download.
     * @param {?} fileName Name of the resulting file.
     * @return {?}
     */
    ContentService.prototype.downloadJSON = /**
     * Invokes content download for a JSON object with a file name.
     * @param {?} json JSON object to download.
     * @param {?} fileName Name of the resulting file.
     * @return {?}
     */
    function (json, fileName) {
        this.saveData(json, 'json', fileName);
    };
    /**
     * Creates a trusted object URL from the Blob.
     * WARNING: calling this method with untrusted user data exposes your application to XSS security risks!
     * @param  blob Data to wrap into object URL
     * @returns URL string
     */
    /**
     * Creates a trusted object URL from the Blob.
     * WARNING: calling this method with untrusted user data exposes your application to XSS security risks!
     * @param {?} blob Data to wrap into object URL
     * @return {?} URL string
     */
    ContentService.prototype.createTrustedUrl = /**
     * Creates a trusted object URL from the Blob.
     * WARNING: calling this method with untrusted user data exposes your application to XSS security risks!
     * @param {?} blob Data to wrap into object URL
     * @return {?} URL string
     */
    function (blob) {
        /** @type {?} */
        var url = window.URL.createObjectURL(blob);
        return /** @type {?} */ (this.sanitizer.bypassSecurityTrustUrl(url));
    };
    Object.defineProperty(ContentService.prototype, "contentApi", {
        get: /**
         * @return {?}
         */
        function () {
            return this.apiService.getInstance().content;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a thumbnail URL for the given document node.
     * @param node Node to get URL for.
     * @param attachment Toggles whether to retrieve content as an attachment for download
     * @param ticket Custom ticket to use for authentication
     * @returns URL string
     */
    /**
     * Gets a thumbnail URL for the given document node.
     * @param {?} node Node to get URL for.
     * @param {?=} attachment Toggles whether to retrieve content as an attachment for download
     * @param {?=} ticket Custom ticket to use for authentication
     * @return {?} URL string
     */
    ContentService.prototype.getDocumentThumbnailUrl = /**
     * Gets a thumbnail URL for the given document node.
     * @param {?} node Node to get URL for.
     * @param {?=} attachment Toggles whether to retrieve content as an attachment for download
     * @param {?=} ticket Custom ticket to use for authentication
     * @return {?} URL string
     */
    function (node, attachment, ticket) {
        if (node && node.entry) {
            node = node.entry.id;
        }
        return this.contentApi.getDocumentThumbnailUrl(node, attachment, ticket);
    };
    /**
     * Gets a content URL for the given node.
     * @param node Node to get URL for.
     * @param attachment Toggles whether to retrieve content as an attachment for download
     * @param ticket Custom ticket to use for authentication
     * @returns URL string
     */
    /**
     * Gets a content URL for the given node.
     * @param {?} node Node to get URL for.
     * @param {?=} attachment Toggles whether to retrieve content as an attachment for download
     * @param {?=} ticket Custom ticket to use for authentication
     * @return {?} URL string
     */
    ContentService.prototype.getContentUrl = /**
     * Gets a content URL for the given node.
     * @param {?} node Node to get URL for.
     * @param {?=} attachment Toggles whether to retrieve content as an attachment for download
     * @param {?=} ticket Custom ticket to use for authentication
     * @return {?} URL string
     */
    function (node, attachment, ticket) {
        if (node && node.entry) {
            node = node.entry.id;
        }
        return this.contentApi.getContentUrl(node, attachment, ticket);
    };
    /**
     * Gets content for the given node.
     * @param nodeId ID of the target node
     * @returns Content data
     */
    /**
     * Gets content for the given node.
     * @param {?} nodeId ID of the target node
     * @return {?} Content data
     */
    ContentService.prototype.getNodeContent = /**
     * Gets content for the given node.
     * @param {?} nodeId ID of the target node
     * @return {?} Content data
     */
    function (nodeId) {
        var _this = this;
        return from(this.apiService.getInstance().core.nodesApi.getFileContent(nodeId))
            .pipe(catchError(function (err) { return _this.handleError(err); }));
    };
    /**
     * Creates a folder.
     * @param relativePath Location to create the folder
     * @param name Folder name
     * @param parentId Node ID of parent folder
     * @returns Information about the new folder
     */
    /**
     * Creates a folder.
     * @param {?} relativePath Location to create the folder
     * @param {?} name Folder name
     * @param {?=} parentId Node ID of parent folder
     * @return {?} Information about the new folder
     */
    ContentService.prototype.createFolder = /**
     * Creates a folder.
     * @param {?} relativePath Location to create the folder
     * @param {?} name Folder name
     * @param {?=} parentId Node ID of parent folder
     * @return {?} Information about the new folder
     */
    function (relativePath, name, parentId) {
        var _this = this;
        return from(this.apiService.getInstance().nodes.createFolder(name, relativePath, parentId))
            .pipe(tap(function (data) {
            _this.folderCreated.next(/** @type {?} */ ({
                relativePath: relativePath,
                name: name,
                parentId: parentId,
                node: data
            }));
        }), catchError(function (err) { return _this.handleError(err); }));
    };
    /**
     * Gets a Node via its node ID.
     * @param nodeId ID of the target node
     * @param opts Options supported by JSAPI
     * @returns Details of the folder
     */
    /**
     * Gets a Node via its node ID.
     * @param {?} nodeId ID of the target node
     * @param {?=} opts Options supported by JSAPI
     * @return {?} Details of the folder
     */
    ContentService.prototype.getNode = /**
     * Gets a Node via its node ID.
     * @param {?} nodeId ID of the target node
     * @param {?=} opts Options supported by JSAPI
     * @return {?} Details of the folder
     */
    function (nodeId, opts) {
        return from(this.apiService.getInstance().nodes.getNode(nodeId, opts));
    };
    /**
     * Checks if the user has permissions on that node
     * @param node Node to check allowableOperations
     * @param permission Create, delete, update, updatePermissions, !create, !delete, !update, !updatePermissions
     * @returns True if the user has the required permissions, false otherwise
     */
    /**
     * Checks if the user has permissions on that node
     * @param {?} node Node to check allowableOperations
     * @param {?} permission Create, delete, update, updatePermissions, !create, !delete, !update, !updatePermissions
     * @return {?} True if the user has the required permissions, false otherwise
     */
    ContentService.prototype.hasPermission = /**
     * Checks if the user has permissions on that node
     * @param {?} node Node to check allowableOperations
     * @param {?} permission Create, delete, update, updatePermissions, !create, !delete, !update, !updatePermissions
     * @return {?} True if the user has the required permissions, false otherwise
     */
    function (node, permission) {
        /** @type {?} */
        var hasPermission = false;
        if (this.hasAllowableOperations(node)) {
            if (permission && permission.startsWith('!')) {
                hasPermission = node.allowableOperations.find(function (currentPermission) { return currentPermission === permission.replace('!', ''); }) ? false : true;
            }
            else {
                hasPermission = node.allowableOperations.find(function (currentPermission) { return currentPermission === permission; }) ? true : false;
            }
        }
        else {
            if (permission && permission.startsWith('!')) {
                hasPermission = true;
            }
        }
        if (permission === PermissionsEnum.COPY) {
            hasPermission = true;
        }
        if (permission === PermissionsEnum.LOCK) {
            hasPermission = node.isFile;
            if (node.isLocked && this.hasAllowableOperations(node)) {
                hasPermission = !!~node.allowableOperations.indexOf('updatePermissions');
            }
        }
        return hasPermission;
    };
    /**
     * Checks if the node has the properties allowableOperations
     * @param node Node to check allowableOperations
     * @returns True if the node has the property, false otherwise
     */
    /**
     * Checks if the node has the properties allowableOperations
     * @param {?} node Node to check allowableOperations
     * @return {?} True if the node has the property, false otherwise
     */
    ContentService.prototype.hasAllowableOperations = /**
     * Checks if the node has the properties allowableOperations
     * @param {?} node Node to check allowableOperations
     * @return {?} True if the node has the property, false otherwise
     */
    function (node) {
        return node && node.allowableOperations ? true : false;
    };
    /**
     * @param {?} error
     * @return {?}
     */
    ContentService.prototype.handleError = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    };
    ContentService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    ContentService.ctorParameters = function () { return [
        { type: AuthenticationService },
        { type: AlfrescoApiService },
        { type: LogService },
        { type: DomSanitizer }
    ]; };
    return ContentService;
}());
export { ContentService };
if (false) {
    /** @type {?} */
    ContentService.prototype.saveData;
    /** @type {?} */
    ContentService.prototype.folderCreated;
    /** @type {?} */
    ContentService.prototype.folderCreate;
    /** @type {?} */
    ContentService.prototype.folderEdit;
    /** @type {?} */
    ContentService.prototype.authService;
    /** @type {?} */
    ContentService.prototype.apiService;
    /** @type {?} */
    ContentService.prototype.logService;
    /** @type {?} */
    ContentService.prototype.sanitizer;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGVudC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb3JlLyIsInNvdXJjZXMiOlsic2VydmljZXMvY29udGVudC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRXpELE9BQU8sRUFBYyxPQUFPLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUU3RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDN0QsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDNUQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDakUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOztJQVc3Qyx3QkFBbUIsV0FBa0MsRUFDbEMsWUFDQyxZQUNBO1FBSEQsZ0JBQVcsR0FBWCxXQUFXLENBQXVCO1FBQ2xDLGVBQVUsR0FBVixVQUFVO1FBQ1QsZUFBVSxHQUFWLFVBQVU7UUFDVixjQUFTLEdBQVQsU0FBUzs2QkFQZ0IsSUFBSSxPQUFPLEVBQXNCOzRCQUM5QixJQUFJLE9BQU8sRUFBMEI7MEJBQ3ZDLElBQUksT0FBTyxFQUEwQjtRQU0vRSxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUM7O1lBQ2IsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNwQyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM3QixDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8s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SjtRQUVELElBQUksVUFBVSxLQUFLLGVBQWUsQ0FBQyxJQUFJLEVBQUU7WUFDckMsYUFBYSxHQUFHLElBQUksQ0FBQztTQUN4QjtRQUVELElBQUksVUFBVSxLQUFLLGVBQWUsQ0FBQyxJQUFJLEVBQUU7WUFDckMsYUFBYSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7WUFFNUIsSUFBSSxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDcEQsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQzthQUM1RTtTQUNKO1FBRUQsT0FBTyxhQUFhLENBQUM7S0FDeEI7SUFFRDs7OztPQUlHOzs7Ozs7SUFDSCwrQ0FBc0I7Ozs7O0lBQXRCLFVBQXVCLElBQVM7UUFDNUIsT0FBTyxJQUFJLElBQUksSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztLQUMxRDs7Ozs7SUFFTyxvQ0FBVzs7OztjQUFDLEtBQVU7UUFDMUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0IsT0FBTyxVQUFVLENBQUMsS0FBSyxJQUFJLGNBQWMsQ0FBQyxDQUFDOzs7Z0JBck5sRCxVQUFVOzs7O2dCQUpGLHFCQUFxQjtnQkFEckIsa0JBQWtCO2dCQUVsQixVQUFVO2dCQVBWLFlBQVk7O3lCQWxCckI7O1NBNkJhLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEb21TYW5pdGl6ZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IENvbnRlbnRBcGksIE1pbmltYWxOb2RlRW50cnlFbnRpdHksIE5vZGUsIE5vZGVFbnRyeSB9IGZyb20gJ2FsZnJlc2NvLWpzLWFwaSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBmcm9tLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBGb2xkZXJDcmVhdGVkRXZlbnQgfSBmcm9tICcuLi9ldmVudHMvZm9sZGVyLWNyZWF0ZWQuZXZlbnQnO1xuaW1wb3J0IHsgUGVybWlzc2lvbnNFbnVtIH0gZnJvbSAnLi4vbW9kZWxzL3Blcm1pc3Npb25zLmVudW0nO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnLi9hbGZyZXNjby1hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBBdXRoZW50aWNhdGlvblNlcnZpY2UgfSBmcm9tICcuL2F1dGhlbnRpY2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9nU2VydmljZSB9IGZyb20gJy4vbG9nLnNlcnZpY2UnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29udGVudFNlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBzYXZlRGF0YTogRnVuY3Rpb247XG5cbiAgICBmb2xkZXJDcmVhdGVkOiBTdWJqZWN0PEZvbGRlckNyZWF0ZWRFdmVudD4gPSBuZXcgU3ViamVjdDxGb2xkZXJDcmVhdGVkRXZlbnQ+KCk7XG4gICAgZm9sZGVyQ3JlYXRlOiBTdWJqZWN0PE1pbmltYWxOb2RlRW50cnlFbnRpdHk+ID0gbmV3IFN1YmplY3Q8TWluaW1hbE5vZGVFbnRyeUVudGl0eT4oKTtcbiAgICBmb2xkZXJFZGl0OiBTdWJqZWN0PE1pbmltYWxOb2RlRW50cnlFbnRpdHk+ID0gbmV3IFN1YmplY3Q8TWluaW1hbE5vZGVFbnRyeUVudGl0eT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBhdXRoU2VydmljZTogQXV0aGVudGljYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgc2FuaXRpemVyOiBEb21TYW5pdGl6ZXIpIHtcbiAgICAgICAgdGhpcy5zYXZlRGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XG4gICAgICAgICAgICBhLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgZm9ybWF0LCBmaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIGxldCBibG9iID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdibG9iJyB8fCBmb3JtYXQgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgICAgICBibG9iID0gbmV3IEJsb2IoW2RhdGFdLCB7IHR5cGU6ICdvY3RldC9zdHJlYW0nIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdvYmplY3QnIHx8IGZvcm1hdCA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBqc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbanNvbl0sIHsgdHlwZTogJ29jdGV0L3N0cmVhbScgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJsb2IpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoYmxvYiwgZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5kb3dubG9hZCA9IGZpbGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5jbGljaygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGNvbnRlbnQgZG93bmxvYWQgZm9yIGEgQmxvYiB3aXRoIGEgZmlsZSBuYW1lLlxuICAgICAqIEBwYXJhbSBibG9iIENvbnRlbnQgdG8gZG93bmxvYWQuXG4gICAgICogQHBhcmFtIGZpbGVOYW1lIE5hbWUgb2YgdGhlIHJlc3VsdGluZyBmaWxlLlxuICAgICAqL1xuICAgIGRvd25sb2FkQmxvYihibG9iOiBCbG9iLCBmaWxlTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2F2ZURhdGEoYmxvYiwgJ2Jsb2InLCBmaWxlTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBjb250ZW50IGRvd25sb2FkIGZvciBhIGRhdGEgYXJyYXkgd2l0aCBhIGZpbGUgbmFtZS5cbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIGRvd25sb2FkLlxuICAgICAqIEBwYXJhbSBmaWxlTmFtZSBOYW1lIG9mIHRoZSByZXN1bHRpbmcgZmlsZS5cbiAgICAgKi9cbiAgICBkb3dubG9hZERhdGEoZGF0YTogYW55LCBmaWxlTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2F2ZURhdGEoZGF0YSwgJ2RhdGEnLCBmaWxlTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBjb250ZW50IGRvd25sb2FkIGZvciBhIEpTT04gb2JqZWN0IHdpdGggYSBmaWxlIG5hbWUuXG4gICAgICogQHBhcmFtIGpzb24gSlNPTiBvYmplY3QgdG8gZG93bmxvYWQuXG4gICAgICogQHBhcmFtIGZpbGVOYW1lIE5hbWUgb2YgdGhlIHJlc3VsdGluZyBmaWxlLlxuICAgICAqL1xuICAgIGRvd25sb2FkSlNPTihqc29uOiBhbnksIGZpbGVOYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zYXZlRGF0YShqc29uLCAnanNvbicsIGZpbGVOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHJ1c3RlZCBvYmplY3QgVVJMIGZyb20gdGhlIEJsb2IuXG4gICAgICogV0FSTklORzogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIHVudHJ1c3RlZCB1c2VyIGRhdGEgZXhwb3NlcyB5b3VyIGFwcGxpY2F0aW9uIHRvIFhTUyBzZWN1cml0eSByaXNrcyFcbiAgICAgKiBAcGFyYW0gIGJsb2IgRGF0YSB0byB3cmFwIGludG8gb2JqZWN0IFVSTFxuICAgICAqIEByZXR1cm5zIFVSTCBzdHJpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVUcnVzdGVkVXJsKGJsb2I6IEJsb2IpOiBzdHJpbmcge1xuICAgICAgICBsZXQgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHJldHVybiA8c3RyaW5nPiB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0VXJsKHVybCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgY29udGVudEFwaSgpOiBDb250ZW50QXBpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLmNvbnRlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHRodW1ibmFpbCBVUkwgZm9yIHRoZSBnaXZlbiBkb2N1bWVudCBub2RlLlxuICAgICAqIEBwYXJhbSBub2RlIE5vZGUgdG8gZ2V0IFVSTCBmb3IuXG4gICAgICogQHBhcmFtIGF0dGFjaG1lbnQgVG9nZ2xlcyB3aGV0aGVyIHRvIHJldHJpZXZlIGNvbnRlbnQgYXMgYW4gYXR0YWNobWVudCBmb3IgZG93bmxvYWRcbiAgICAgKiBAcGFyYW0gdGlja2V0IEN1c3RvbSB0aWNrZXQgdG8gdXNlIGZvciBhdXRoZW50aWNhdGlvblxuICAgICAqIEByZXR1cm5zIFVSTCBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXREb2N1bWVudFRodW1ibmFpbFVybChub2RlOiBhbnksIGF0dGFjaG1lbnQ/OiBib29sZWFuLCB0aWNrZXQ/OiBzdHJpbmcpOiBzdHJpbmcge1xuXG4gICAgICAgIGlmIChub2RlICYmIG5vZGUuZW50cnkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmVudHJ5LmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudEFwaS5nZXREb2N1bWVudFRodW1ibmFpbFVybChub2RlLCBhdHRhY2htZW50LCB0aWNrZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBjb250ZW50IFVSTCBmb3IgdGhlIGdpdmVuIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGUgTm9kZSB0byBnZXQgVVJMIGZvci5cbiAgICAgKiBAcGFyYW0gYXR0YWNobWVudCBUb2dnbGVzIHdoZXRoZXIgdG8gcmV0cmlldmUgY29udGVudCBhcyBhbiBhdHRhY2htZW50IGZvciBkb3dubG9hZFxuICAgICAqIEBwYXJhbSB0aWNrZXQgQ3VzdG9tIHRpY2tldCB0byB1c2UgZm9yIGF1dGhlbnRpY2F0aW9uXG4gICAgICogQHJldHVybnMgVVJMIHN0cmluZ1xuICAgICAqL1xuICAgIGdldENvbnRlbnRVcmwobm9kZTogYW55LCBhdHRhY2htZW50PzogYm9vbGVhbiwgdGlja2V0Pzogc3RyaW5nKTogc3RyaW5nIHtcblxuICAgICAgICBpZiAobm9kZSAmJiBub2RlLmVudHJ5KSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5lbnRyeS5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRBcGkuZ2V0Q29udGVudFVybChub2RlLCBhdHRhY2htZW50LCB0aWNrZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY29udGVudCBmb3IgdGhlIGdpdmVuIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGVJZCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcmV0dXJucyBDb250ZW50IGRhdGFcbiAgICAgKi9cbiAgICBnZXROb2RlQ29udGVudChub2RlSWQ6IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLmNvcmUubm9kZXNBcGkuZ2V0RmlsZUNvbnRlbnQobm9kZUlkKSlcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZvbGRlci5cbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIExvY2F0aW9uIHRvIGNyZWF0ZSB0aGUgZm9sZGVyXG4gICAgICogQHBhcmFtIG5hbWUgRm9sZGVyIG5hbWVcbiAgICAgKiBAcGFyYW0gcGFyZW50SWQgTm9kZSBJRCBvZiBwYXJlbnQgZm9sZGVyXG4gICAgICogQHJldHVybnMgSW5mb3JtYXRpb24gYWJvdXQgdGhlIG5ldyBmb2xkZXJcbiAgICAgKi9cbiAgICBjcmVhdGVGb2xkZXIocmVsYXRpdmVQYXRoOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgcGFyZW50SWQ/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPE5vZGVFbnRyeT4ge1xuICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5ub2Rlcy5jcmVhdGVGb2xkZXIobmFtZSwgcmVsYXRpdmVQYXRoLCBwYXJlbnRJZCkpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICB0YXAoZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9sZGVyQ3JlYXRlZC5uZXh0KDxGb2xkZXJDcmVhdGVkRXZlbnQ+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aDogcmVsYXRpdmVQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnIgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgTm9kZSB2aWEgaXRzIG5vZGUgSUQuXG4gICAgICogQHBhcmFtIG5vZGVJZCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0gb3B0cyBPcHRpb25zIHN1cHBvcnRlZCBieSBKU0FQSVxuICAgICAqIEByZXR1cm5zIERldGFpbHMgb2YgdGhlIGZvbGRlclxuICAgICAqL1xuICAgIGdldE5vZGUobm9kZUlkOiBzdHJpbmcsIG9wdHM/OiBhbnkpOiBPYnNlcnZhYmxlPE5vZGVFbnRyeT4ge1xuICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5ub2Rlcy5nZXROb2RlKG5vZGVJZCwgb3B0cykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgdXNlciBoYXMgcGVybWlzc2lvbnMgb24gdGhhdCBub2RlXG4gICAgICogQHBhcmFtIG5vZGUgTm9kZSB0byBjaGVjayBhbGxvd2FibGVPcGVyYXRpb25zXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gQ3JlYXRlLCBkZWxldGUsIHVwZGF0ZSwgdXBkYXRlUGVybWlzc2lvbnMsICFjcmVhdGUsICFkZWxldGUsICF1cGRhdGUsICF1cGRhdGVQZXJtaXNzaW9uc1xuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHVzZXIgaGFzIHRoZSByZXF1aXJlZCBwZXJtaXNzaW9ucywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaGFzUGVybWlzc2lvbihub2RlOiBOb2RlLCBwZXJtaXNzaW9uOiBQZXJtaXNzaW9uc0VudW0gfCBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGhhc1Blcm1pc3Npb24gPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5oYXNBbGxvd2FibGVPcGVyYXRpb25zKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAocGVybWlzc2lvbiAmJiBwZXJtaXNzaW9uLnN0YXJ0c1dpdGgoJyEnKSkge1xuICAgICAgICAgICAgICAgIGhhc1Blcm1pc3Npb24gPSBub2RlLmFsbG93YWJsZU9wZXJhdGlvbnMuZmluZChjdXJyZW50UGVybWlzc2lvbiA9PiBjdXJyZW50UGVybWlzc2lvbiA9PT0gcGVybWlzc2lvbi5yZXBsYWNlKCchJywgJycpKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFzUGVybWlzc2lvbiA9IG5vZGUuYWxsb3dhYmxlT3BlcmF0aW9ucy5maW5kKGN1cnJlbnRQZXJtaXNzaW9uID0+IGN1cnJlbnRQZXJtaXNzaW9uID09PSBwZXJtaXNzaW9uKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBlcm1pc3Npb24gJiYgcGVybWlzc2lvbi5zdGFydHNXaXRoKCchJykpIHtcbiAgICAgICAgICAgICAgICBoYXNQZXJtaXNzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwZXJtaXNzaW9uID09PSBQZXJtaXNzaW9uc0VudW0uQ09QWSkge1xuICAgICAgICAgICAgaGFzUGVybWlzc2lvbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVybWlzc2lvbiA9PT0gUGVybWlzc2lvbnNFbnVtLkxPQ0spIHtcbiAgICAgICAgICAgIGhhc1Blcm1pc3Npb24gPSBub2RlLmlzRmlsZTtcblxuICAgICAgICAgICAgaWYgKG5vZGUuaXNMb2NrZWQgJiYgdGhpcy5oYXNBbGxvd2FibGVPcGVyYXRpb25zKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaGFzUGVybWlzc2lvbiA9ICEhfm5vZGUuYWxsb3dhYmxlT3BlcmF0aW9ucy5pbmRleE9mKCd1cGRhdGVQZXJtaXNzaW9ucycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhc1Blcm1pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBub2RlIGhhcyB0aGUgcHJvcGVydGllcyBhbGxvd2FibGVPcGVyYXRpb25zXG4gICAgICogQHBhcmFtIG5vZGUgTm9kZSB0byBjaGVjayBhbGxvd2FibGVPcGVyYXRpb25zXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm9kZSBoYXMgdGhlIHByb3BlcnR5LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBoYXNBbGxvd2FibGVPcGVyYXRpb25zKG5vZGU6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLmFsbG93YWJsZU9wZXJhdGlvbnMgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVFcnJvcihlcnJvcjogYW55KSB7XG4gICAgICAgIHRoaXMubG9nU2VydmljZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yIHx8ICdTZXJ2ZXIgZXJyb3InKTtcbiAgICB9XG59XG4iXX0=