/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { getType } from './get-type';
/**
 * @record
 */
export function DynamicComponentModel() { }
/** @type {?} */
DynamicComponentModel.prototype.type;
/** @typedef {?} */
var DynamicComponentResolveFunction;
export { DynamicComponentResolveFunction };
var DynamicComponentResolver = /** @class */ (function () {
    function DynamicComponentResolver() {
    }
    /**
     * @param {?} type
     * @return {?}
     */
    DynamicComponentResolver.fromType = /**
     * @param {?} type
     * @return {?}
     */
    function (type) {
        return getType(type);
    };
    return DynamicComponentResolver;
}());
export { DynamicComponentResolver };
/**
 * @abstract
 */
var /**
 * @abstract
 */
DynamicComponentMapper = /** @class */ (function () {
    function DynamicComponentMapper() {
        this.defaultValue = undefined;
        this.types = {};
    }
    /**
     * Gets the currently active ComponentTypeResolver function for a field type.
     * @param type The type whose resolver you want
     * @param defaultValue Default type returned for types that are not yet mapped
     * @returns Resolver function
     */
    /**
     * Gets the currently active ComponentTypeResolver function for a field type.
     * @param {?} type The type whose resolver you want
     * @param {?=} defaultValue Default type returned for types that are not yet mapped
     * @return {?} Resolver function
     */
    DynamicComponentMapper.prototype.getComponentTypeResolver = /**
     * Gets the currently active ComponentTypeResolver function for a field type.
     * @param {?} type The type whose resolver you want
     * @param {?=} defaultValue Default type returned for types that are not yet mapped
     * @return {?} Resolver function
     */
    function (type, defaultValue) {
        if (defaultValue === void 0) { defaultValue = this.defaultValue; }
        if (type) {
            return this.types[type] || DynamicComponentResolver.fromType(defaultValue);
        }
        return DynamicComponentResolver.fromType(defaultValue);
    };
    /**
     * Sets or optionally replaces a ComponentTypeResolver function for a field type.
     * @param type The type whose resolver you want to set
     * @param resolver The new resolver function
     * @param override The new resolver will only replace an existing one if this parameter is true
     */
    /**
     * Sets or optionally replaces a ComponentTypeResolver function for a field type.
     * @param {?} type The type whose resolver you want to set
     * @param {?} resolver The new resolver function
     * @param {?=} override The new resolver will only replace an existing one if this parameter is true
     * @return {?}
     */
    DynamicComponentMapper.prototype.setComponentTypeResolver = /**
     * Sets or optionally replaces a ComponentTypeResolver function for a field type.
     * @param {?} type The type whose resolver you want to set
     * @param {?} resolver The new resolver function
     * @param {?=} override The new resolver will only replace an existing one if this parameter is true
     * @return {?}
     */
    function (type, resolver, override) {
        if (override === void 0) { override = true; }
        if (!type) {
            throw new Error("type is null or not defined");
        }
        if (!resolver) {
            throw new Error("resolver is null or not defined");
        }
        /** @type {?} */
        var existing = this.types[type];
        if (existing && !override) {
            throw new Error("already mapped, use override option if you intend replacing existing mapping.");
        }
        this.types[type] = resolver;
    };
    /**
     * Finds the component type that is needed to render a form field.
     * @param model Form field model for the field to render
     * @param defaultValue Default type returned for field types that are not yet mapped.
     * @returns Component type
     */
    /**
     * Finds the component type that is needed to render a form field.
     * @param {?} model Form field model for the field to render
     * @param {?=} defaultValue Default type returned for field types that are not yet mapped.
     * @return {?} Component type
     */
    DynamicComponentMapper.prototype.resolveComponentType = /**
     * Finds the component type that is needed to render a form field.
     * @param {?} model Form field model for the field to render
     * @param {?=} defaultValue Default type returned for field types that are not yet mapped.
     * @return {?} Component type
     */
    function (model, defaultValue) {
        if (defaultValue === void 0) { defaultValue = this.defaultValue; }
        if (model) {
            /** @type {?} */
            var resolver = this.getComponentTypeResolver(model.type, defaultValue);
            return resolver(model);
        }
        return defaultValue;
    };
    return DynamicComponentMapper;
}());
/**
 * @abstract
 */
export { DynamicComponentMapper };
if (false) {
    /** @type {?} */
    DynamicComponentMapper.prototype.defaultValue;
    /** @type {?} */
    DynamicComponentMapper.prototype.types;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1jb21wb25lbnQtbWFwcGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvcmUvIiwic291cmNlcyI6WyJzZXJ2aWNlcy9keW5hbWljLWNvbXBvbmVudC1tYXBwZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sWUFBWSxDQUFDOzs7Ozs7Ozs7O0FBSXJDLElBQUE7Ozs7Ozs7SUFDVyxpQ0FBUTs7OztJQUFmLFVBQWdCLElBQWM7UUFDMUIsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDeEI7bUNBekJMO0lBMEJDLENBQUE7QUFKRCxvQ0FJQzs7OztBQUVEOzs7QUFBQTs7NEJBRXVDLFNBQVM7cUJBQzBCLEVBQUU7O0lBRXhFOzs7OztPQUtHOzs7Ozs7O0lBQ0gseURBQXdCOzs7Ozs7SUFBeEIsVUFBeUIsSUFBWSxFQUFFLFlBQTBDO1FBQTFDLDZCQUFBLEVBQUEsZUFBeUIsSUFBSSxDQUFDLFlBQVk7UUFDN0UsSUFBSSxJQUFJLEVBQUU7WUFDTixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksd0JBQXdCLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQzlFO1FBQ0QsT0FBTyx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUM7S0FDMUQ7SUFFRDs7Ozs7T0FLRzs7Ozs7Ozs7SUFDSCx5REFBd0I7Ozs7Ozs7SUFBeEIsVUFBeUIsSUFBWSxFQUFFLFFBQXlDLEVBQUUsUUFBd0I7UUFBeEIseUJBQUEsRUFBQSxlQUF3QjtRQUN0RyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1AsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1NBQ2xEO1FBRUQsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNYLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUN0RDs7UUFFRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hDLElBQUksUUFBUSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsK0VBQStFLENBQUMsQ0FBQztTQUNwRztRQUVELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDO0tBQy9CO0lBRUQ7Ozs7O09BS0c7Ozs7Ozs7SUFDSCxxREFBb0I7Ozs7OztJQUFwQixVQUFxQixLQUE0QixFQUFFLFlBQTBDO1FBQTFDLDZCQUFBLEVBQUEsZUFBeUIsSUFBSSxDQUFDLFlBQVk7UUFDekYsSUFBSSxLQUFLLEVBQUU7O1lBQ1AsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFDdkUsT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDMUI7UUFDRCxPQUFPLFlBQVksQ0FBQztLQUN2QjtpQ0FqRkw7SUFrRkMsQ0FBQTs7OztBQXRERCxrQ0FzREMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBnZXRUeXBlIH0gZnJvbSAnLi9nZXQtdHlwZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHluYW1pY0NvbXBvbmVudE1vZGVsIHsgdHlwZTogc3RyaW5nOyB9XG5leHBvcnQgdHlwZSBEeW5hbWljQ29tcG9uZW50UmVzb2x2ZUZ1bmN0aW9uID0gKG1vZGVsOiBEeW5hbWljQ29tcG9uZW50TW9kZWwpID0+IFR5cGU8e30+O1xuZXhwb3J0IGNsYXNzIER5bmFtaWNDb21wb25lbnRSZXNvbHZlciB7XG4gICAgc3RhdGljIGZyb21UeXBlKHR5cGU6IFR5cGU8e30+KTogRHluYW1pY0NvbXBvbmVudFJlc29sdmVGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiBnZXRUeXBlKHR5cGUpO1xuICAgIH1cbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIER5bmFtaWNDb21wb25lbnRNYXBwZXIge1xuXG4gICAgcHJvdGVjdGVkIGRlZmF1bHRWYWx1ZTogVHlwZTx7fT4gPSB1bmRlZmluZWQ7XG4gICAgcHJvdGVjdGVkIHR5cGVzOiB7IFtrZXk6IHN0cmluZ106IER5bmFtaWNDb21wb25lbnRSZXNvbHZlRnVuY3Rpb24gfSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudGx5IGFjdGl2ZSBDb21wb25lbnRUeXBlUmVzb2x2ZXIgZnVuY3Rpb24gZm9yIGEgZmllbGQgdHlwZS5cbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSB3aG9zZSByZXNvbHZlciB5b3Ugd2FudFxuICAgICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgRGVmYXVsdCB0eXBlIHJldHVybmVkIGZvciB0eXBlcyB0aGF0IGFyZSBub3QgeWV0IG1hcHBlZFxuICAgICAqIEByZXR1cm5zIFJlc29sdmVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZ2V0Q29tcG9uZW50VHlwZVJlc29sdmVyKHR5cGU6IHN0cmluZywgZGVmYXVsdFZhbHVlOiBUeXBlPHt9PiA9IHRoaXMuZGVmYXVsdFZhbHVlKTogRHluYW1pY0NvbXBvbmVudFJlc29sdmVGdW5jdGlvbiB7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlc1t0eXBlXSB8fCBEeW5hbWljQ29tcG9uZW50UmVzb2x2ZXIuZnJvbVR5cGUoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRHluYW1pY0NvbXBvbmVudFJlc29sdmVyLmZyb21UeXBlKGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBvciBvcHRpb25hbGx5IHJlcGxhY2VzIGEgQ29tcG9uZW50VHlwZVJlc29sdmVyIGZ1bmN0aW9uIGZvciBhIGZpZWxkIHR5cGUuXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgd2hvc2UgcmVzb2x2ZXIgeW91IHdhbnQgdG8gc2V0XG4gICAgICogQHBhcmFtIHJlc29sdmVyIFRoZSBuZXcgcmVzb2x2ZXIgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gb3ZlcnJpZGUgVGhlIG5ldyByZXNvbHZlciB3aWxsIG9ubHkgcmVwbGFjZSBhbiBleGlzdGluZyBvbmUgaWYgdGhpcyBwYXJhbWV0ZXIgaXMgdHJ1ZVxuICAgICAqL1xuICAgIHNldENvbXBvbmVudFR5cGVSZXNvbHZlcih0eXBlOiBzdHJpbmcsIHJlc29sdmVyOiBEeW5hbWljQ29tcG9uZW50UmVzb2x2ZUZ1bmN0aW9uLCBvdmVycmlkZTogYm9vbGVhbiA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR5cGUgaXMgbnVsbCBvciBub3QgZGVmaW5lZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXNvbHZlciBpcyBudWxsIG9yIG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXhpc3RpbmcgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZXhpc3RpbmcgJiYgIW92ZXJyaWRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscmVhZHkgbWFwcGVkLCB1c2Ugb3ZlcnJpZGUgb3B0aW9uIGlmIHlvdSBpbnRlbmQgcmVwbGFjaW5nIGV4aXN0aW5nIG1hcHBpbmcuYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnR5cGVzW3R5cGVdID0gcmVzb2x2ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGNvbXBvbmVudCB0eXBlIHRoYXQgaXMgbmVlZGVkIHRvIHJlbmRlciBhIGZvcm0gZmllbGQuXG4gICAgICogQHBhcmFtIG1vZGVsIEZvcm0gZmllbGQgbW9kZWwgZm9yIHRoZSBmaWVsZCB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIERlZmF1bHQgdHlwZSByZXR1cm5lZCBmb3IgZmllbGQgdHlwZXMgdGhhdCBhcmUgbm90IHlldCBtYXBwZWQuXG4gICAgICogQHJldHVybnMgQ29tcG9uZW50IHR5cGVcbiAgICAgKi9cbiAgICByZXNvbHZlQ29tcG9uZW50VHlwZShtb2RlbDogRHluYW1pY0NvbXBvbmVudE1vZGVsLCBkZWZhdWx0VmFsdWU6IFR5cGU8e30+ID0gdGhpcy5kZWZhdWx0VmFsdWUpOiBUeXBlPHt9PiB7XG4gICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVyID0gdGhpcy5nZXRDb21wb25lbnRUeXBlUmVzb2x2ZXIobW9kZWwudHlwZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlcihtb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG59XG4iXX0=