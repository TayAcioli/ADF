/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ComponentFactoryResolver, Input, ViewChild } from '@angular/core';
import { CardItemTypeService } from '../../services/card-item-types.service';
import { CardViewContentProxyDirective } from '../../directives/card-view-content-proxy.directive';
export class CardViewItemDispatcherComponent {
    /**
     * @param {?} cardItemTypeService
     * @param {?} resolver
     */
    constructor(cardItemTypeService, resolver) {
        this.cardItemTypeService = cardItemTypeService;
        this.resolver = resolver;
        this.displayEmpty = true;
        this.loaded = false;
        this.componentReference = null;
        /** @type {?} */
        const dynamicLifecycleMethods = [
            'ngOnInit',
            'ngDoCheck',
            'ngAfterContentInit',
            'ngAfterContentChecked',
            'ngAfterViewInit',
            'ngAfterViewChecked',
            'ngOnDestroy'
        ];
        dynamicLifecycleMethods.forEach((dynamicLifecycleMethod) => {
            this[dynamicLifecycleMethod] = this.proxy.bind(this, dynamicLifecycleMethod);
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.loaded) {
            this.loadComponent();
            this.loaded = true;
        }
        Object.keys(changes)
            .map(changeName => [changeName, changes[changeName]])
            .forEach(([inputParamName, simpleChange]) => {
            this.componentReference.instance[inputParamName] = simpleChange.currentValue;
        });
        this.proxy('ngOnChanges', changes);
    }
    /**
     * @return {?}
     */
    loadComponent() {
        /** @type {?} */
        const factoryClass = this.cardItemTypeService.resolveComponentType(this.property);
        /** @type {?} */
        const factory = this.resolver.resolveComponentFactory(factoryClass);
        this.componentReference = this.content.viewContainerRef.createComponent(factory);
        this.componentReference.instance.editable = this.editable;
        this.componentReference.instance.property = this.property;
        this.componentReference.instance.displayEmpty = this.displayEmpty;
    }
    /**
     * @param {?} methodName
     * @param {...?} args
     * @return {?}
     */
    proxy(methodName, ...args) {
        if (this.componentReference.instance[methodName]) {
            this.componentReference.instance[methodName].apply(this.componentReference.instance, args);
        }
    }
}
CardViewItemDispatcherComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-item-dispatcher',
                template: '<ng-template adf-card-view-content-proxy></ng-template>'
            }] }
];
/** @nocollapse */
CardViewItemDispatcherComponent.ctorParameters = () => [
    { type: CardItemTypeService },
    { type: ComponentFactoryResolver }
];
CardViewItemDispatcherComponent.propDecorators = {
    property: [{ type: Input }],
    editable: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    content: [{ type: ViewChild, args: [CardViewContentProxyDirective,] }]
};
if (false) {
    /** @type {?} */
    CardViewItemDispatcherComponent.prototype.property;
    /** @type {?} */
    CardViewItemDispatcherComponent.prototype.editable;
    /** @type {?} */
    CardViewItemDispatcherComponent.prototype.displayEmpty;
    /** @type {?} */
    CardViewItemDispatcherComponent.prototype.content;
    /** @type {?} */
    CardViewItemDispatcherComponent.prototype.loaded;
    /** @type {?} */
    CardViewItemDispatcherComponent.prototype.componentReference;
    /** @type {?} */
    CardViewItemDispatcherComponent.prototype.ngOnInit;
    /** @type {?} */
    CardViewItemDispatcherComponent.prototype.ngDoCheck;
    /** @type {?} */
    CardViewItemDispatcherComponent.prototype.cardItemTypeService;
    /** @type {?} */
    CardViewItemDispatcherComponent.prototype.resolver;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FyZC12aWV3LWl0ZW0tZGlzcGF0Y2hlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvcmUvIiwic291cmNlcyI6WyJjYXJkLXZpZXcvY29tcG9uZW50cy9jYXJkLXZpZXctaXRlbS1kaXNwYXRjaGVyL2NhcmQtdmlldy1pdGVtLWRpc3BhdGNoZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFDSCxTQUFTLEVBQ1Qsd0JBQXdCLEVBQ3hCLEtBQUssRUFJTCxTQUFTLEVBQ1osTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFDN0UsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0sb0RBQW9ELENBQUM7QUFNbkcsTUFBTTs7Ozs7SUFtQkYsWUFBb0IsbUJBQXdDLEVBQ3hDO1FBREEsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtRQUN4QyxhQUFRLEdBQVIsUUFBUTs0QkFaSixJQUFJO3NCQUtGLEtBQUs7a0NBQ0csSUFBSTs7UUFPbEMsTUFBTSx1QkFBdUIsR0FBRztZQUM1QixVQUFVO1lBQ1YsV0FBVztZQUNYLG9CQUFvQjtZQUNwQix1QkFBdUI7WUFDdkIsaUJBQWlCO1lBQ2pCLG9CQUFvQjtZQUNwQixhQUFhO1NBQ2hCLENBQUM7UUFFRix1QkFBdUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxzQkFBc0IsRUFBRSxFQUFFO1lBQ3ZELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1NBQ2hGLENBQUMsQ0FBQztLQUNOOzs7OztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNkLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUNyQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztTQUN0QjtRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO2FBQ2YsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7YUFDcEQsT0FBTyxDQUFDLENBQUMsQ0FBQyxjQUFjLEVBQUUsWUFBWSxDQUF5QixFQUFFLEVBQUU7WUFDaEUsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsR0FBRyxZQUFZLENBQUMsWUFBWSxDQUFDO1NBQ2hGLENBQUMsQ0FBQztRQUVQLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQ3RDOzs7O0lBRU8sYUFBYTs7UUFDakIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzs7UUFFbEYsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUNwRSxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFakYsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUMxRCxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQzFELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7Ozs7Ozs7SUFHOUQsS0FBSyxDQUFDLFVBQVUsRUFBRSxHQUFHLElBQUk7UUFDN0IsSUFBSSxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzlDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDOUY7Ozs7WUFyRVIsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSwrQkFBK0I7Z0JBQ3pDLFFBQVEsRUFBRSx5REFBeUQ7YUFDdEU7Ozs7WUFOUSxtQkFBbUI7WUFSeEIsd0JBQXdCOzs7dUJBZ0J2QixLQUFLO3VCQUdMLEtBQUs7MkJBR0wsS0FBSztzQkFHTCxTQUFTLFNBQUMsNkJBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBTaW1wbGVDaGFuZ2UsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDYXJkVmlld0l0ZW0gfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2NhcmQtdmlldy1pdGVtLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDYXJkSXRlbVR5cGVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY2FyZC1pdGVtLXR5cGVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2FyZFZpZXdDb250ZW50UHJveHlEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2NhcmQtdmlldy1jb250ZW50LXByb3h5LmRpcmVjdGl2ZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWNhcmQtdmlldy1pdGVtLWRpc3BhdGNoZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLXRlbXBsYXRlIGFkZi1jYXJkLXZpZXctY29udGVudC1wcm94eT48L25nLXRlbXBsYXRlPidcbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFZpZXdJdGVtRGlzcGF0Y2hlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gICAgQElucHV0KClcbiAgICBwcm9wZXJ0eTogQ2FyZFZpZXdJdGVtO1xuXG4gICAgQElucHV0KClcbiAgICBlZGl0YWJsZTogYm9vbGVhbjtcblxuICAgIEBJbnB1dCgpXG4gICAgZGlzcGxheUVtcHR5OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIEBWaWV3Q2hpbGQoQ2FyZFZpZXdDb250ZW50UHJveHlEaXJlY3RpdmUpXG4gICAgcHJpdmF0ZSBjb250ZW50OiBDYXJkVmlld0NvbnRlbnRQcm94eURpcmVjdGl2ZTtcblxuICAgIHByaXZhdGUgbG9hZGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBjb21wb25lbnRSZWZlcmVuY2U6IGFueSA9IG51bGw7XG5cbiAgICBwdWJsaWMgbmdPbkluaXQ7XG4gICAgcHVibGljIG5nRG9DaGVjaztcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY2FyZEl0ZW1UeXBlU2VydmljZTogQ2FyZEl0ZW1UeXBlU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpIHtcbiAgICAgICAgY29uc3QgZHluYW1pY0xpZmVjeWNsZU1ldGhvZHMgPSBbXG4gICAgICAgICAgICAnbmdPbkluaXQnLFxuICAgICAgICAgICAgJ25nRG9DaGVjaycsXG4gICAgICAgICAgICAnbmdBZnRlckNvbnRlbnRJbml0JyxcbiAgICAgICAgICAgICduZ0FmdGVyQ29udGVudENoZWNrZWQnLFxuICAgICAgICAgICAgJ25nQWZ0ZXJWaWV3SW5pdCcsXG4gICAgICAgICAgICAnbmdBZnRlclZpZXdDaGVja2VkJyxcbiAgICAgICAgICAgICduZ09uRGVzdHJveSdcbiAgICAgICAgXTtcblxuICAgICAgICBkeW5hbWljTGlmZWN5Y2xlTWV0aG9kcy5mb3JFYWNoKChkeW5hbWljTGlmZWN5Y2xlTWV0aG9kKSA9PiB7XG4gICAgICAgICAgICB0aGlzW2R5bmFtaWNMaWZlY3ljbGVNZXRob2RdID0gdGhpcy5wcm94eS5iaW5kKHRoaXMsIGR5bmFtaWNMaWZlY3ljbGVNZXRob2QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZENvbXBvbmVudCgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXMoY2hhbmdlcylcbiAgICAgICAgICAgIC5tYXAoY2hhbmdlTmFtZSA9PiBbY2hhbmdlTmFtZSwgY2hhbmdlc1tjaGFuZ2VOYW1lXV0pXG4gICAgICAgICAgICAuZm9yRWFjaCgoW2lucHV0UGFyYW1OYW1lLCBzaW1wbGVDaGFuZ2VdOiBbc3RyaW5nLCBTaW1wbGVDaGFuZ2VdKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRSZWZlcmVuY2UuaW5zdGFuY2VbaW5wdXRQYXJhbU5hbWVdID0gc2ltcGxlQ2hhbmdlLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucHJveHkoJ25nT25DaGFuZ2VzJywgY2hhbmdlcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBsb2FkQ29tcG9uZW50KCkge1xuICAgICAgICBjb25zdCBmYWN0b3J5Q2xhc3MgPSB0aGlzLmNhcmRJdGVtVHlwZVNlcnZpY2UucmVzb2x2ZUNvbXBvbmVudFR5cGUodGhpcy5wcm9wZXJ0eSk7XG5cbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoZmFjdG9yeUNsYXNzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWZlcmVuY2UgPSB0aGlzLmNvbnRlbnQudmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoZmFjdG9yeSk7XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWZlcmVuY2UuaW5zdGFuY2UuZWRpdGFibGUgPSB0aGlzLmVkaXRhYmxlO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlZmVyZW5jZS5pbnN0YW5jZS5wcm9wZXJ0eSA9IHRoaXMucHJvcGVydHk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmZXJlbmNlLmluc3RhbmNlLmRpc3BsYXlFbXB0eSA9IHRoaXMuZGlzcGxheUVtcHR5O1xuICAgIH1cblxuICAgIHByaXZhdGUgcHJveHkobWV0aG9kTmFtZSwgLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnRSZWZlcmVuY2UuaW5zdGFuY2VbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50UmVmZXJlbmNlLmluc3RhbmNlW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMuY29tcG9uZW50UmVmZXJlbmNlLmluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==