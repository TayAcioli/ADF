/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, forkJoin, throwError, of } from 'rxjs';
import { ComponentTranslationModel } from '../models/component.model';
import { ObjectUtils } from '../utils/object-utils';
import { map, catchError, retry } from 'rxjs/operators';
export class TranslateLoaderService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
        this.prefix = 'i18n';
        this.suffix = '.json';
        this.providers = [];
        this.queue = [];
    }
    /**
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    registerProvider(name, path) {
        /** @type {?} */
        let registered = this.providers.find(provider => provider.name === name);
        if (registered) {
            registered.path = path;
        }
        else {
            this.providers.push(new ComponentTranslationModel({ name: name, path: path }));
        }
    }
    /**
     * @param {?} name
     * @return {?}
     */
    providerRegistered(name) {
        return this.providers.find(x => x.name === name) ? true : false;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    getComponentToFetch(lang) {
        /** @type {?} */
        const observableBatch = [];
        if (!this.queue[lang]) {
            this.queue[lang] = [];
        }
        this.providers.forEach((component) => {
            if (!this.isComponentInQueue(lang, component.name)) {
                this.queue[lang].push(component.name);
                /** @type {?} */
                const translationUrl = `${component.path}/${this.prefix}/${lang}${this.suffix}?v=${Date.now()}`;
                observableBatch.push(this.http.get(translationUrl).pipe(map((res) => {
                    component.json[lang] = res;
                }), retry(3), catchError(() => throwError(`Failed to load ${translationUrl}`))));
            }
        });
        return observableBatch;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    init(lang) {
        if (this.queue[lang] === undefined) {
            this.queue[lang] = [];
        }
    }
    /**
     * @param {?} lang
     * @param {?} name
     * @return {?}
     */
    isComponentInQueue(lang, name) {
        return (this.queue[lang] || []).find(x => x === name) ? true : false;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    getFullTranslationJSON(lang) {
        /** @type {?} */
        let result = {};
        this.providers
            .slice(0)
            .sort((a, b) => {
            if (a.name === 'app') {
                return 1;
            }
            if (b.name === 'app') {
                return -1;
            }
            return a.name.localeCompare(b.name);
        })
            .forEach(model => {
            if (model.json && model.json[lang]) {
                result = ObjectUtils.merge(result, model.json[lang]);
            }
        });
        return result;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    getTranslation(lang) {
        /** @type {?} */
        let hasFailures = false;
        /** @type {?} */
        const batch = [
            ...this.getComponentToFetch(lang).map(observable => {
                return observable.pipe(catchError(error => {
                    console.warn(error);
                    hasFailures = true;
                    return of(error);
                }));
            })
        ];
        return Observable.create(observer => {
            if (batch.length > 0) {
                forkJoin(batch).subscribe(() => {
                    /** @type {?} */
                    let fullTranslation = this.getFullTranslationJSON(lang);
                    if (fullTranslation) {
                        observer.next(fullTranslation);
                    }
                    if (hasFailures) {
                        observer.error('Failed to load some resources');
                    }
                    else {
                        observer.complete();
                    }
                }, (err) => {
                    observer.error('Failed to load some resources');
                });
            }
            else {
                /** @type {?} */
                let fullTranslation = this.getFullTranslationJSON(lang);
                if (fullTranslation) {
                    observer.next(fullTranslation);
                    observer.complete();
                }
            }
        });
    }
}
TranslateLoaderService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TranslateLoaderService.ctorParameters = () => [
    { type: HttpClient }
];
if (false) {
    /** @type {?} */
    TranslateLoaderService.prototype.prefix;
    /** @type {?} */
    TranslateLoaderService.prototype.suffix;
    /** @type {?} */
    TranslateLoaderService.prototype.providers;
    /** @type {?} */
    TranslateLoaderService.prototype.queue;
    /** @type {?} */
    TranslateLoaderService.prototype.http;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlLWxvYWRlci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb3JlLyIsInNvdXJjZXMiOlsic2VydmljZXMvdHJhbnNsYXRlLWxvYWRlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzNDLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDdEUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3BELE9BQU8sRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBR3hELE1BQU07Ozs7SUFPRixZQUFvQixJQUFnQjtRQUFoQixTQUFJLEdBQUosSUFBSSxDQUFZO3NCQUxYLE1BQU07c0JBQ04sT0FBTzt5QkFDaUIsRUFBRTtxQkFDdEIsRUFBRTtLQUc5Qjs7Ozs7O0lBRUQsZ0JBQWdCLENBQUMsSUFBWSxFQUFFLElBQVk7O1FBQ3ZDLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQztRQUN6RSxJQUFJLFVBQVUsRUFBRTtZQUNaLFVBQVUsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1NBQzFCO2FBQU07WUFDSCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLHlCQUF5QixDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFB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QztxQkFDdkI7aUJBQ0osRUFDRCxDQUFDLEdBQUcsRUFBRSxFQUFFO29CQUNKLFFBQVEsQ0FBQyxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQztpQkFDbkQsQ0FBQyxDQUFDO2FBQ1Y7aUJBQU07O2dCQUNILElBQUksZUFBZSxHQUFHLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDeEQsSUFBSSxlQUFlLEVBQUU7b0JBQ2pCLFFBQVEsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7b0JBQy9CLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztpQkFDdkI7YUFDSjtTQUNKLENBQUMsQ0FBQztLQUNOOzs7WUEzSEosVUFBVTs7OztZQVRGLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzcG9uc2UgfSBmcm9tICdAYW5ndWxhci9odHRwJztcbmltcG9ydCB7IFRyYW5zbGF0ZUxvYWRlciB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZm9ya0pvaW4sIHRocm93RXJyb3IsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBDb21wb25lbnRUcmFuc2xhdGlvbk1vZGVsIH0gZnJvbSAnLi4vbW9kZWxzL2NvbXBvbmVudC5tb2RlbCc7XG5pbXBvcnQgeyBPYmplY3RVdGlscyB9IGZyb20gJy4uL3V0aWxzL29iamVjdC11dGlscyc7XG5pbXBvcnQgeyBtYXAsIGNhdGNoRXJyb3IsIHJldHJ5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRlTG9hZGVyU2VydmljZSBpbXBsZW1lbnRzIFRyYW5zbGF0ZUxvYWRlciB7XG5cbiAgICBwcml2YXRlIHByZWZpeDogc3RyaW5nID0gJ2kxOG4nO1xuICAgIHByaXZhdGUgc3VmZml4OiBzdHJpbmcgPSAnLmpzb24nO1xuICAgIHByaXZhdGUgcHJvdmlkZXJzOiBDb21wb25lbnRUcmFuc2xhdGlvbk1vZGVsW10gPSBbXTtcbiAgICBwcml2YXRlIHF1ZXVlOiBzdHJpbmcgW11bXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwOiBIdHRwQ2xpZW50KSB7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJQcm92aWRlcihuYW1lOiBzdHJpbmcsIHBhdGg6IHN0cmluZykge1xuICAgICAgICBsZXQgcmVnaXN0ZXJlZCA9IHRoaXMucHJvdmlkZXJzLmZpbmQocHJvdmlkZXIgPT4gcHJvdmlkZXIubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICByZWdpc3RlcmVkLnBhdGggPSBwYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMucHVzaChuZXcgQ29tcG9uZW50VHJhbnNsYXRpb25Nb2RlbCh7IG5hbWU6IG5hbWUsIHBhdGg6IHBhdGggfSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdmlkZXJSZWdpc3RlcmVkKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcnMuZmluZCh4ID0+IHgubmFtZSA9PT0gbmFtZSkgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0Q29tcG9uZW50VG9GZXRjaChsYW5nOiBzdHJpbmcpOiBBcnJheTxPYnNlcnZhYmxlPGFueT4+IHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZUJhdGNoID0gW107XG4gICAgICAgIGlmICghdGhpcy5xdWV1ZVtsYW5nXSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZVtsYW5nXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvdmlkZXJzLmZvckVhY2goKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ29tcG9uZW50SW5RdWV1ZShsYW5nLCBjb21wb25lbnQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlW2xhbmddLnB1c2goY29tcG9uZW50Lm5hbWUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRpb25VcmwgPSBgJHtjb21wb25lbnQucGF0aH0vJHt0aGlzLnByZWZpeH0vJHtsYW5nfSR7dGhpcy5zdWZmaXh9P3Y9JHtEYXRlLm5vdygpfWA7XG5cbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlQmF0Y2gucHVzaChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5odHRwLmdldCh0cmFuc2xhdGlvblVybCkucGlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcCgocmVzOiBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5qc29uW2xhbmddID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeSgzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoRXJyb3IoKCkgPT4gdGhyb3dFcnJvcihgRmFpbGVkIHRvIGxvYWQgJHt0cmFuc2xhdGlvblVybH1gKSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlQmF0Y2g7XG4gICAgfVxuXG4gICAgaW5pdChsYW5nOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMucXVldWVbbGFuZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZVtsYW5nXSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNDb21wb25lbnRJblF1ZXVlKGxhbmc6IHN0cmluZywgbmFtZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5xdWV1ZVtsYW5nXSB8fCBbXSkuZmluZCh4ID0+IHggPT09IG5hbWUpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICAgIGdldEZ1bGxUcmFuc2xhdGlvbkpTT04obGFuZzogc3RyaW5nKTogYW55IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIHRoaXMucHJvdmlkZXJzXG4gICAgICAgICAgICAuc2xpY2UoMClcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGEubmFtZSA9PT0gJ2FwcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiLm5hbWUgPT09ICdhcHAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2gobW9kZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5qc29uICYmIG1vZGVsLmpzb25bbGFuZ10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gT2JqZWN0VXRpbHMubWVyZ2UocmVzdWx0LCBtb2RlbC5qc29uW2xhbmddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGdldFRyYW5zbGF0aW9uKGxhbmc6IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICAgIGxldCBoYXNGYWlsdXJlcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBiYXRjaCA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0Q29tcG9uZW50VG9GZXRjaChsYW5nKS5tYXAob2JzZXJ2YWJsZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGUucGlwZShcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRmFpbHVyZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgXTtcblxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUob2JzZXJ2ZXIgPT4ge1xuXG4gICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvcmtKb2luKGJhdGNoKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmdWxsVHJhbnNsYXRpb24gPSB0aGlzLmdldEZ1bGxUcmFuc2xhdGlvbkpTT04obGFuZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnVsbFRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChmdWxsVHJhbnNsYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0ZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHNvbWUgcmVzb3VyY2VzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBzb21lIHJlc291cmNlcycpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bGxUcmFuc2xhdGlvbiA9IHRoaXMuZ2V0RnVsbFRyYW5zbGF0aW9uSlNPTihsYW5nKTtcbiAgICAgICAgICAgICAgICBpZiAoZnVsbFRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZnVsbFRyYW5zbGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdfQ==