/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { UserPreferencesService } from './user-preferences.service';
/** @type {?} */
export const TRANSLATION_PROVIDER = new InjectionToken('Injection token for translation providers.');
/**
 * @record
 */
export function TranslationProvider() { }
/** @type {?} */
TranslationProvider.prototype.name;
/** @type {?} */
TranslationProvider.prototype.source;
export class TranslationService {
    /**
     * @param {?} translate
     * @param {?} userPreference
     * @param {?} providers
     */
    constructor(translate, userPreference, providers) {
        this.translate = translate;
        this.customLoader = /** @type {?} */ (this.translate.currentLoader);
        this.defaultLang = 'en';
        translate.setDefaultLang(this.defaultLang);
        if (providers && providers.length > 0) {
            for (let provider of providers) {
                this.addTranslationFolder(provider.name, provider.source);
            }
        }
        userPreference.locale$.subscribe((locale) => {
            this.userLang = locale;
            this.use(this.userLang);
        });
    }
    /**
     * Adds a new folder of translation source files.
     * @param {?=} name Name for the translation provider
     * @param {?=} path Path to the folder
     * @return {?}
     */
    addTranslationFolder(name = '', path = '') {
        if (!this.customLoader.providerRegistered(name)) {
            this.customLoader.registerProvider(name, path);
            if (this.userLang) {
                this.loadTranslation(this.userLang, this.defaultLang);
            }
            else {
                this.loadTranslation(this.defaultLang);
            }
        }
    }
    /**
     * @param {?} lang
     * @param {?=} fallback
     * @return {?}
     */
    loadTranslation(lang, fallback) {
        this.translate.getTranslation(lang).subscribe(() => {
            this.translate.use(lang);
            this.onTranslationChanged(lang);
        }, () => {
            if (fallback && fallback !== lang) {
                this.loadTranslation(fallback);
            }
        });
    }
    /**
     * Triggers a notification callback when the translation language changes.
     * @param {?} lang The new language code
     * @return {?}
     */
    onTranslationChanged(lang) {
        this.translate.onTranslationChange.next({
            lang: lang,
            translations: this.customLoader.getFullTranslationJSON(lang)
        });
    }
    /**
     * Sets the target language for translations.
     * @param {?} lang Code name for the language
     * @return {?} Translations available for the language
     */
    use(lang) {
        this.customLoader.init(lang);
        return this.translate.use(lang);
    }
    /**
     * Gets the translation for the supplied key.
     * @param {?} key Key to translate
     * @param {?=} interpolateParams String(s) to be interpolated into the main message
     * @return {?} Translated text
     */
    get(key, interpolateParams) {
        return this.translate.get(key, interpolateParams);
    }
    /**
     * Directly returns the translation for the supplied key.
     * @param {?} key Key to translate
     * @param {?=} interpolateParams String(s) to be interpolated into the main message
     * @return {?} Translated text
     */
    instant(key, interpolateParams) {
        return key ? this.translate.instant(key, interpolateParams) : '';
    }
}
TranslationService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TranslationService.ctorParameters = () => [
    { type: TranslateService },
    { type: UserPreferencesService },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLATION_PROVIDER,] }] }
];
if (false) {
    /** @type {?} */
    TranslationService.prototype.defaultLang;
    /** @type {?} */
    TranslationService.prototype.userLang;
    /** @type {?} */
    TranslationService.prototype.customLoader;
    /** @type {?} */
    TranslationService.prototype.translate;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRpb24uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29yZS8iLCJzb3VyY2VzIjpbInNlcnZpY2VzL3RyYW5zbGF0aW9uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM3RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUd2RCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQzs7QUFFcEUsYUFBYSxvQkFBb0IsR0FBRyxJQUFJLGNBQWMsQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDOzs7Ozs7Ozs7QUFRckcsTUFBTTs7Ozs7O0lBS0YsWUFBbUIsU0FBMkIsRUFDbEMsY0FBc0MsRUFDSSxTQUFnQztRQUZuRSxjQUFTLEdBQVQsU0FBUyxDQUFrQjtRQUcxQyxJQUFJLENBQUMsWUFBWSxxQkFBNEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUEsQ0FBQztRQUUxRSxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztRQUN4QixTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUUzQyxJQUFJLFNBQVMsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNuQyxLQUFLLElBQUksUUFBUSxJQUFJLFNBQVMsRUFBRTtnQkFDNUIsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQzdEO1NBQ0o7UUFFRCxjQUFjLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ3hDLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzNCLENBQUMsQ0FBQztLQUNOOzs7Ozs7O0lBT0Qsb0JBQW9CLENBQUMsT0FBZSxFQUFFLEVBQUUsT0FBZSxFQUFFO1FBQ3JELElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzdDLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBRS9DLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDZixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ3pEO2lCQUFNO2dCQUNILElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQzFDO1NBQ0o7S0FDSjs7Ozs7O0lBRUQsZUFBZSxDQUFDLElBQVksRUFBRSxRQUFpQjtRQUMzQyxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQ3pDLEdBQUcsRUFBRTtZQUNELElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNuQyxFQUNELEdBQUcsRUFBRTtZQUNELElBQUksUUFBUSxJQUFJLFFBQVEsS0FBSyxJQUFJLEVBQUU7Z0JBQy9CLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDbEM7U0FDSixDQUNKLENBQUM7S0FDTDs7Ozs7O0lBTUQsb0JBQW9CLENBQUMsSUFBWTtRQUM3QixJQUFJLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQztZQUNwQyxJQUFJLEVBQUUsSUFBSTtZQUNWLFlBQVksRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQztTQUMvRCxDQUFDLENBQUM7S0FDTjs7Ozs7O0lBT0QsR0FBRyxDQUFDLElBQVk7UUFDWixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ25DOzs7Ozs7O0lBUUQsR0FBRyxDQUFDLEdBQTJCLEVBQUUsaUJBQTBCO1FBQ3ZELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLGlCQUFpQixDQUFDLENBQUM7S0FDckQ7Ozs7Ozs7SUFRRCxPQUFPLENBQUMsR0FBMkIsRUFBRSxpQkFBMEI7UUFDM0QsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7S0FDcEU7OztZQWhHSixVQUFVOzs7O1lBWkYsZ0JBQWdCO1lBR2hCLHNCQUFzQjt3Q0FpQmQsUUFBUSxZQUFJLE1BQU0sU0FBQyxvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgVHJhbnNsYXRlTG9hZGVyU2VydmljZSB9IGZyb20gJy4vdHJhbnNsYXRlLWxvYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UgfSBmcm9tICcuL3VzZXItcHJlZmVyZW5jZXMuc2VydmljZSc7XG5cbmV4cG9ydCBjb25zdCBUUkFOU0xBVElPTl9QUk9WSURFUiA9IG5ldyBJbmplY3Rpb25Ub2tlbignSW5qZWN0aW9uIHRva2VuIGZvciB0cmFuc2xhdGlvbiBwcm92aWRlcnMuJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNsYXRpb25Qcm92aWRlciB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHNvdXJjZTogc3RyaW5nO1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRpb25TZXJ2aWNlIHtcbiAgICBkZWZhdWx0TGFuZzogc3RyaW5nO1xuICAgIHVzZXJMYW5nOiBzdHJpbmc7XG4gICAgY3VzdG9tTG9hZGVyOiBUcmFuc2xhdGVMb2FkZXJTZXJ2aWNlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHRyYW5zbGF0ZTogVHJhbnNsYXRlU2VydmljZSxcbiAgICAgICAgICAgICAgICB1c2VyUHJlZmVyZW5jZTogVXNlclByZWZlcmVuY2VzU2VydmljZSxcbiAgICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFRSQU5TTEFUSU9OX1BST1ZJREVSKSBwcm92aWRlcnM6IFRyYW5zbGF0aW9uUHJvdmlkZXJbXSkge1xuICAgICAgICB0aGlzLmN1c3RvbUxvYWRlciA9IDxUcmFuc2xhdGVMb2FkZXJTZXJ2aWNlPiB0aGlzLnRyYW5zbGF0ZS5jdXJyZW50TG9hZGVyO1xuXG4gICAgICAgIHRoaXMuZGVmYXVsdExhbmcgPSAnZW4nO1xuICAgICAgICB0cmFuc2xhdGUuc2V0RGVmYXVsdExhbmcodGhpcy5kZWZhdWx0TGFuZyk7XG5cbiAgICAgICAgaWYgKHByb3ZpZGVycyAmJiBwcm92aWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvdmlkZXIgb2YgcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUcmFuc2xhdGlvbkZvbGRlcihwcm92aWRlci5uYW1lLCBwcm92aWRlci5zb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdXNlclByZWZlcmVuY2UubG9jYWxlJC5zdWJzY3JpYmUoKGxvY2FsZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy51c2VyTGFuZyA9IGxvY2FsZTtcbiAgICAgICAgICAgIHRoaXMudXNlKHRoaXMudXNlckxhbmcpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGZvbGRlciBvZiB0cmFuc2xhdGlvbiBzb3VyY2UgZmlsZXMuXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBmb3IgdGhlIHRyYW5zbGF0aW9uIHByb3ZpZGVyXG4gICAgICogQHBhcmFtIHBhdGggUGF0aCB0byB0aGUgZm9sZGVyXG4gICAgICovXG4gICAgYWRkVHJhbnNsYXRpb25Gb2xkZXIobmFtZTogc3RyaW5nID0gJycsIHBhdGg6IHN0cmluZyA9ICcnKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXN0b21Mb2FkZXIucHJvdmlkZXJSZWdpc3RlcmVkKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbUxvYWRlci5yZWdpc3RlclByb3ZpZGVyKG5hbWUsIHBhdGgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy51c2VyTGFuZykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZFRyYW5zbGF0aW9uKHRoaXMudXNlckxhbmcsIHRoaXMuZGVmYXVsdExhbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRUcmFuc2xhdGlvbih0aGlzLmRlZmF1bHRMYW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvYWRUcmFuc2xhdGlvbihsYW5nOiBzdHJpbmcsIGZhbGxiYWNrPzogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMudHJhbnNsYXRlLmdldFRyYW5zbGF0aW9uKGxhbmcpLnN1YnNjcmliZShcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZS51c2UobGFuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zbGF0aW9uQ2hhbmdlZChsYW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZhbGxiYWNrICYmIGZhbGxiYWNrICE9PSBsYW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZFRyYW5zbGF0aW9uKGZhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYSBub3RpZmljYXRpb24gY2FsbGJhY2sgd2hlbiB0aGUgdHJhbnNsYXRpb24gbGFuZ3VhZ2UgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gbGFuZyBUaGUgbmV3IGxhbmd1YWdlIGNvZGVcbiAgICAgKi9cbiAgICBvblRyYW5zbGF0aW9uQ2hhbmdlZChsYW5nOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50cmFuc2xhdGUub25UcmFuc2xhdGlvbkNoYW5nZS5uZXh0KHtcbiAgICAgICAgICAgIGxhbmc6IGxhbmcsXG4gICAgICAgICAgICB0cmFuc2xhdGlvbnM6IHRoaXMuY3VzdG9tTG9hZGVyLmdldEZ1bGxUcmFuc2xhdGlvbkpTT04obGFuZylcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGFyZ2V0IGxhbmd1YWdlIGZvciB0cmFuc2xhdGlvbnMuXG4gICAgICogQHBhcmFtIGxhbmcgQ29kZSBuYW1lIGZvciB0aGUgbGFuZ3VhZ2VcbiAgICAgKiBAcmV0dXJucyBUcmFuc2xhdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgbGFuZ3VhZ2VcbiAgICAgKi9cbiAgICB1c2UobGFuZzogc3RyaW5nKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICAgICAgdGhpcy5jdXN0b21Mb2FkZXIuaW5pdChsYW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlLnVzZShsYW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0cmFuc2xhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5IEtleSB0byB0cmFuc2xhdGVcbiAgICAgKiBAcGFyYW0gaW50ZXJwb2xhdGVQYXJhbXMgU3RyaW5nKHMpIHRvIGJlIGludGVycG9sYXRlZCBpbnRvIHRoZSBtYWluIG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyBUcmFuc2xhdGVkIHRleHRcbiAgICAgKi9cbiAgICBnZXQoa2V5OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+LCBpbnRlcnBvbGF0ZVBhcmFtcz86IE9iamVjdCk6IE9ic2VydmFibGU8c3RyaW5nIHwgYW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZS5nZXQoa2V5LCBpbnRlcnBvbGF0ZVBhcmFtcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlyZWN0bHkgcmV0dXJucyB0aGUgdHJhbnNsYXRpb24gZm9yIHRoZSBzdXBwbGllZCBrZXkuXG4gICAgICogQHBhcmFtIGtleSBLZXkgdG8gdHJhbnNsYXRlXG4gICAgICogQHBhcmFtIGludGVycG9sYXRlUGFyYW1zIFN0cmluZyhzKSB0byBiZSBpbnRlcnBvbGF0ZWQgaW50byB0aGUgbWFpbiBtZXNzYWdlXG4gICAgICogQHJldHVybnMgVHJhbnNsYXRlZCB0ZXh0XG4gICAgICovXG4gICAgaW5zdGFudChrZXk6IHN0cmluZyB8IEFycmF5PHN0cmluZz4sIGludGVycG9sYXRlUGFyYW1zPzogT2JqZWN0KTogc3RyaW5nIHwgYW55IHtcbiAgICAgICAgcmV0dXJuIGtleSA/IHRoaXMudHJhbnNsYXRlLmluc3RhbnQoa2V5LCBpbnRlcnBvbGF0ZVBhcmFtcykgOiAnJztcbiAgICB9XG59XG4iXX0=