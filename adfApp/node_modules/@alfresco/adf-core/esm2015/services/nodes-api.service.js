/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { from, throwError } from 'rxjs';
import { AlfrescoApiService } from './alfresco-api.service';
import { UserPreferencesService } from './user-preferences.service';
import { catchError } from 'rxjs/operators';
export class NodesApiService {
    /**
     * @param {?} api
     * @param {?} preferences
     */
    constructor(api, preferences) {
        this.api = api;
        this.preferences = preferences;
    }
    /**
     * @return {?}
     */
    get nodesApi() {
        return this.api.getInstance().core.nodesApi;
    }
    /**
     * @param {?} entity
     * @return {?}
     */
    getEntryFromEntity(entity) {
        return entity.entry;
    }
    /**
     * Gets the stored information about a node.
     * @param {?} nodeId ID of the target node
     * @param {?=} options Optional parameters supported by JSAPI
     * @return {?} Node information
     */
    getNode(nodeId, options = {}) {
        /** @type {?} */
        const defaults = {
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        /** @type {?} */
        const queryOptions = Object.assign(defaults, options);
        /** @type {?} */
        const promise = this.nodesApi
            .getNode(nodeId, queryOptions)
            .then(this.getEntryFromEntity);
        return from(promise).pipe(catchError(err => throwError(err)));
    }
    /**
     * Gets the items contained in a folder node.
     * @param {?} nodeId ID of the target node
     * @param {?=} options Optional parameters supported by JSAPI
     * @return {?} List of child items from the folder
     */
    getNodeChildren(nodeId, options = {}) {
        /** @type {?} */
        const defaults = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        /** @type {?} */
        const queryOptions = Object.assign(defaults, options);
        /** @type {?} */
        const promise = this.nodesApi
            .getNodeChildren(nodeId, queryOptions);
        return from(promise).pipe(catchError(err => throwError(err)));
    }
    /**
     * Creates a new document node inside a folder.
     * @param {?} parentNodeId ID of the parent folder node
     * @param {?} nodeBody Data for the new node
     * @param {?=} options Optional parameters supported by JSAPI
     * @return {?} Details of the new node
     */
    createNode(parentNodeId, nodeBody, options = {}) {
        /** @type {?} */
        const promise = this.nodesApi
            .addNode(parentNodeId, nodeBody, options)
            .then(this.getEntryFromEntity);
        return from(promise).pipe(catchError(err => throwError(err)));
    }
    /**
     * Creates a new folder node inside a parent folder.
     * @param {?} parentNodeId ID of the parent folder node
     * @param {?} nodeBody Data for the new folder
     * @param {?=} options Optional parameters supported by JSAPI
     * @return {?} Details of the new folder
     */
    createFolder(parentNodeId, nodeBody, options = {}) {
        /** @type {?} */
        const body = Object.assign({ nodeType: 'cm:folder' }, nodeBody);
        return this.createNode(parentNodeId, body, options);
    }
    /**
     * Updates the information about a node.
     * @param {?} nodeId ID of the target node
     * @param {?} nodeBody New data for the node
     * @param {?=} options Optional parameters supported by JSAPI
     * @return {?} Updated node information
     */
    updateNode(nodeId, nodeBody, options = {}) {
        /** @type {?} */
        const defaults = {
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        /** @type {?} */
        const queryOptions = Object.assign(defaults, options);
        /** @type {?} */
        const promise = this.nodesApi
            .updateNode(nodeId, nodeBody, queryOptions)
            .then(this.getEntryFromEntity);
        return from(promise).pipe(catchError(err => throwError(err)));
    }
    /**
     * Moves a node to the trashcan.
     * @param {?} nodeId ID of the target node
     * @param {?=} options Optional parameters supported by JSAPI
     * @return {?} Empty result that notifies when the deletion is complete
     */
    deleteNode(nodeId, options = {}) {
        /** @type {?} */
        const promise = this.nodesApi.deleteNode(nodeId, options);
        return from(promise).pipe(catchError(err => throwError(err)));
    }
    /**
     * Restores a node previously moved to the trashcan.
     * @param {?} nodeId ID of the node to restore
     * @return {?} Details of the restored node
     */
    restoreNode(nodeId) {
        /** @type {?} */
        const promise = this.nodesApi
            .restoreNode(nodeId)
            .then(this.getEntryFromEntity);
        return from(promise).pipe(catchError(err => throwError(err)));
    }
}
NodesApiService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NodesApiService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: UserPreferencesService }
];
if (false) {
    /** @type {?} */
    NodesApiService.prototype.api;
    /** @type {?} */
    NodesApiService.prototype.preferences;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZXMtYXBpLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvcmUvIiwic291cmNlcyI6WyJzZXJ2aWNlcy9ub2Rlcy1hcGkuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBYyxJQUFJLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3BELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzVELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUc1QyxNQUFNOzs7OztJQUVGLFlBQ1ksS0FDQTtRQURBLFFBQUcsR0FBSCxHQUFHO1FBQ0gsZ0JBQVcsR0FBWCxXQUFXO0tBQTRCOzs7O1FBRXZDLFFBQVE7UUFDaEIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7Ozs7OztJQUd4QyxrQkFBa0IsQ0FBQyxNQUF5QjtRQUNoRCxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUM7Ozs7Ozs7O0lBU3hCLE9BQU8sQ0FBQyxNQUFjLEVBQUUsVUFBZSxFQUFFOztRQUNyQyxNQUFNLFFBQVEsR0FBRztZQUNiLE9BQU8sRUFBRSxDQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUscUJBQXFCLEVBQUUsYUFBYSxDQUFFO1NBQzFFLENBQUM7O1FBQ0YsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7O1FBQ3RELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRO2FBQ3hCLE9BQU8sQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDO2FBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUVuQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQ3JCLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUNyQyxDQUFDO0tBQ0w7Ozs7Ozs7SUFRRCxlQUFlLENBQUMsTUFBYyxFQUFFLFVBQWUsRUFBRTs7UUFDN0MsTUFBTSxRQUFRLEdBQUc7WUFDYixRQUFRLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjO1lBQ3pDLFNBQVMsRUFBRSxDQUFDO1lBQ1osT0FBTyxFQUFFLENBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxxQkFBcUIsRUFBRSxhQUFhLENBQUU7U0FDMUUsQ0FBQzs7UUFDRixNQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7UUFDdEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVE7YUFDeEIsZUFBZSxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQztRQUUzQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQ3JCLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUNyQyxDQUFDO0tBQ0w7Ozs7Ozs7O0lBU0QsVUFBVSxDQUFDLFlBQW9CLEVBQUUsUUFBYSxFQUFFLFVBQWUsRUFBRTs7UUFDN0QsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVE7YUFDeEIsT0FBTyxDQUFDLFlBQVksRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDO2FBQ3hDLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUVuQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQ3JCLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUNyQyxDQUFDO0tBQ0w7Ozs7Ozs7O0lBU0QsWUFBWSxDQUFDLFlBQW9CLEVBQUUsUUFBYSxFQUFFLFVBQWUsRUFBRTs7UUFDL0QsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNoRSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztLQUN2RDs7Ozs7Ozs7SUFTRCxVQUFVLENBQUMsTUFBYyxFQUFFLFFBQWEsRUFBRSxVQUFlLEVBQUU7O1FBQ3ZELE1BQU0sUUFBUSxHQUFHO1lBQ2IsT0FBTyxFQUFFLENBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxxQkFBcUIsRUFBRSxhQUFhLENBQUU7U0FDMUUsQ0FBQzs7UUFDRixNQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7UUFFdEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVE7YUFDeEIsVUFBVSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsWUFBWSxDQUFDO2FBQzFDLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUVuQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQ3JCLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUNyQyxDQUFDO0tBQ0w7Ozs7Ozs7SUFRRCxVQUFVLENBQUMsTUFBYyxFQUFFLFVBQWUsRUFBRTs7UUFDeEMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRTFELE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FDckIsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQ3JDLENBQUM7S0FDTDs7Ozs7O0lBT0QsV0FBVyxDQUFDLE1BQWM7O1FBQ3RCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRO2FBQ3hCLFdBQVcsQ0FBQyxNQUFNLENBQUM7YUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBRW5DLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FDckIsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQ3JDLENBQUM7S0FDTDs7O1lBdElKLFVBQVU7Ozs7WUFKRixrQkFBa0I7WUFDbEIsc0JBQXNCIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWluaW1hbE5vZGVFbnRpdHksIE1pbmltYWxOb2RlRW50cnlFbnRpdHksIE5vZGVQYWdpbmcgfSBmcm9tICdhbGZyZXNjby1qcy1hcGknO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZnJvbSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnLi9hbGZyZXNjby1hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlIH0gZnJvbSAnLi91c2VyLXByZWZlcmVuY2VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5vZGVzQXBpU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBhcGk6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBwcmVmZXJlbmNlczogVXNlclByZWZlcmVuY2VzU2VydmljZSkge31cblxuICAgIHByaXZhdGUgZ2V0IG5vZGVzQXBpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGkuZ2V0SW5zdGFuY2UoKS5jb3JlLm5vZGVzQXBpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0RW50cnlGcm9tRW50aXR5KGVudGl0eTogTWluaW1hbE5vZGVFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eS5lbnRyeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdG9yZWQgaW5mb3JtYXRpb24gYWJvdXQgYSBub2RlLlxuICAgICAqIEBwYXJhbSBub2RlSWQgSUQgb2YgdGhlIHRhcmdldCBub2RlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgcGFyYW1ldGVycyBzdXBwb3J0ZWQgYnkgSlNBUElcbiAgICAgKiBAcmV0dXJucyBOb2RlIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgZ2V0Tm9kZShub2RlSWQ6IHN0cmluZywgb3B0aW9uczogYW55ID0ge30pOiBPYnNlcnZhYmxlPE1pbmltYWxOb2RlRW50cnlFbnRpdHk+IHtcbiAgICAgICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBpbmNsdWRlOiBbICdwYXRoJywgJ3Byb3BlcnRpZXMnLCAnYWxsb3dhYmxlT3BlcmF0aW9ucycsICdwZXJtaXNzaW9ucycgXVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBxdWVyeU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubm9kZXNBcGlcbiAgICAgICAgICAgIC5nZXROb2RlKG5vZGVJZCwgcXVlcnlPcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5nZXRFbnRyeUZyb21FbnRpdHkpO1xuXG4gICAgICAgIHJldHVybiBmcm9tKHByb21pc2UpLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVyciA9PiB0aHJvd0Vycm9yKGVycikpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaXRlbXMgY29udGFpbmVkIGluIGEgZm9sZGVyIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGVJZCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIHN1cHBvcnRlZCBieSBKU0FQSVxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgY2hpbGQgaXRlbXMgZnJvbSB0aGUgZm9sZGVyXG4gICAgICovXG4gICAgZ2V0Tm9kZUNoaWxkcmVuKG5vZGVJZDogc3RyaW5nLCBvcHRpb25zOiBhbnkgPSB7fSk6IE9ic2VydmFibGU8Tm9kZVBhZ2luZz4ge1xuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIG1heEl0ZW1zOiB0aGlzLnByZWZlcmVuY2VzLnBhZ2luYXRpb25TaXplLFxuICAgICAgICAgICAgc2tpcENvdW50OiAwLFxuICAgICAgICAgICAgaW5jbHVkZTogWyAncGF0aCcsICdwcm9wZXJ0aWVzJywgJ2FsbG93YWJsZU9wZXJhdGlvbnMnLCAncGVybWlzc2lvbnMnIF1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcXVlcnlPcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm5vZGVzQXBpXG4gICAgICAgICAgICAuZ2V0Tm9kZUNoaWxkcmVuKG5vZGVJZCwgcXVlcnlPcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gZnJvbShwcm9taXNlKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnIgPT4gdGhyb3dFcnJvcihlcnIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgbm9kZSBpbnNpZGUgYSBmb2xkZXIuXG4gICAgICogQHBhcmFtIHBhcmVudE5vZGVJZCBJRCBvZiB0aGUgcGFyZW50IGZvbGRlciBub2RlXG4gICAgICogQHBhcmFtIG5vZGVCb2R5IERhdGEgZm9yIHRoZSBuZXcgbm9kZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIHBhcmFtZXRlcnMgc3VwcG9ydGVkIGJ5IEpTQVBJXG4gICAgICogQHJldHVybnMgRGV0YWlscyBvZiB0aGUgbmV3IG5vZGVcbiAgICAgKi9cbiAgICBjcmVhdGVOb2RlKHBhcmVudE5vZGVJZDogc3RyaW5nLCBub2RlQm9keTogYW55LCBvcHRpb25zOiBhbnkgPSB7fSk6IE9ic2VydmFibGU8TWluaW1hbE5vZGVFbnRyeUVudGl0eT4ge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5ub2Rlc0FwaVxuICAgICAgICAgICAgLmFkZE5vZGUocGFyZW50Tm9kZUlkLCBub2RlQm9keSwgb3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKHRoaXMuZ2V0RW50cnlGcm9tRW50aXR5KTtcblxuICAgICAgICByZXR1cm4gZnJvbShwcm9taXNlKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnIgPT4gdGhyb3dFcnJvcihlcnIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZm9sZGVyIG5vZGUgaW5zaWRlIGEgcGFyZW50IGZvbGRlci5cbiAgICAgKiBAcGFyYW0gcGFyZW50Tm9kZUlkIElEIG9mIHRoZSBwYXJlbnQgZm9sZGVyIG5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZUJvZHkgRGF0YSBmb3IgdGhlIG5ldyBmb2xkZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIHN1cHBvcnRlZCBieSBKU0FQSVxuICAgICAqIEByZXR1cm5zIERldGFpbHMgb2YgdGhlIG5ldyBmb2xkZXJcbiAgICAgKi9cbiAgICBjcmVhdGVGb2xkZXIocGFyZW50Tm9kZUlkOiBzdHJpbmcsIG5vZGVCb2R5OiBhbnksIG9wdGlvbnM6IGFueSA9IHt9KTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBPYmplY3QuYXNzaWduKHsgbm9kZVR5cGU6ICdjbTpmb2xkZXInIH0sIG5vZGVCb2R5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTm9kZShwYXJlbnROb2RlSWQsIGJvZHksIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGluZm9ybWF0aW9uIGFib3V0IGEgbm9kZS5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIElEIG9mIHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIEBwYXJhbSBub2RlQm9keSBOZXcgZGF0YSBmb3IgdGhlIG5vZGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIHN1cHBvcnRlZCBieSBKU0FQSVxuICAgICAqIEByZXR1cm5zIFVwZGF0ZWQgbm9kZSBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIHVwZGF0ZU5vZGUobm9kZUlkOiBzdHJpbmcsIG5vZGVCb2R5OiBhbnksIG9wdGlvbnM6IGFueSA9IHt9KTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgaW5jbHVkZTogWyAncGF0aCcsICdwcm9wZXJ0aWVzJywgJ2FsbG93YWJsZU9wZXJhdGlvbnMnLCAncGVybWlzc2lvbnMnIF1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcXVlcnlPcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubm9kZXNBcGlcbiAgICAgICAgICAgIC51cGRhdGVOb2RlKG5vZGVJZCwgbm9kZUJvZHksIHF1ZXJ5T3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKHRoaXMuZ2V0RW50cnlGcm9tRW50aXR5KTtcblxuICAgICAgICByZXR1cm4gZnJvbShwcm9taXNlKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnIgPT4gdGhyb3dFcnJvcihlcnIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgbm9kZSB0byB0aGUgdHJhc2hjYW4uXG4gICAgICogQHBhcmFtIG5vZGVJZCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIHN1cHBvcnRlZCBieSBKU0FQSVxuICAgICAqIEByZXR1cm5zIEVtcHR5IHJlc3VsdCB0aGF0IG5vdGlmaWVzIHdoZW4gdGhlIGRlbGV0aW9uIGlzIGNvbXBsZXRlXG4gICAgICovXG4gICAgZGVsZXRlTm9kZShub2RlSWQ6IHN0cmluZywgb3B0aW9uczogYW55ID0ge30pOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5ub2Rlc0FwaS5kZWxldGVOb2RlKG5vZGVJZCwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIGZyb20ocHJvbWlzZSkucGlwZShcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyID0+IHRocm93RXJyb3IoZXJyKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBhIG5vZGUgcHJldmlvdXNseSBtb3ZlZCB0byB0aGUgdHJhc2hjYW4uXG4gICAgICogQHBhcmFtIG5vZGVJZCBJRCBvZiB0aGUgbm9kZSB0byByZXN0b3JlXG4gICAgICogQHJldHVybnMgRGV0YWlscyBvZiB0aGUgcmVzdG9yZWQgbm9kZVxuICAgICAqL1xuICAgIHJlc3RvcmVOb2RlKG5vZGVJZDogc3RyaW5nKTogT2JzZXJ2YWJsZTxNaW5pbWFsTm9kZUVudHJ5RW50aXR5PiB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm5vZGVzQXBpXG4gICAgICAgICAgICAucmVzdG9yZU5vZGUobm9kZUlkKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5nZXRFbnRyeUZyb21FbnRpdHkpO1xuXG4gICAgICAgIHJldHVybiBmcm9tKHByb21pc2UpLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVyciA9PiB0aHJvd0Vycm9yKGVycikpXG4gICAgICAgICk7XG4gICAgfVxufVxuIl19