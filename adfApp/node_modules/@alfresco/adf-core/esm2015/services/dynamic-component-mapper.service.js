/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { getType } from './get-type';
/**
 * @record
 */
export function DynamicComponentModel() { }
/** @type {?} */
DynamicComponentModel.prototype.type;
/** @typedef {?} */
var DynamicComponentResolveFunction;
export { DynamicComponentResolveFunction };
export class DynamicComponentResolver {
    /**
     * @param {?} type
     * @return {?}
     */
    static fromType(type) {
        return getType(type);
    }
}
/**
 * @abstract
 */
export class DynamicComponentMapper {
    constructor() {
        this.defaultValue = undefined;
        this.types = {};
    }
    /**
     * Gets the currently active ComponentTypeResolver function for a field type.
     * @param {?} type The type whose resolver you want
     * @param {?=} defaultValue Default type returned for types that are not yet mapped
     * @return {?} Resolver function
     */
    getComponentTypeResolver(type, defaultValue = this.defaultValue) {
        if (type) {
            return this.types[type] || DynamicComponentResolver.fromType(defaultValue);
        }
        return DynamicComponentResolver.fromType(defaultValue);
    }
    /**
     * Sets or optionally replaces a ComponentTypeResolver function for a field type.
     * @param {?} type The type whose resolver you want to set
     * @param {?} resolver The new resolver function
     * @param {?=} override The new resolver will only replace an existing one if this parameter is true
     * @return {?}
     */
    setComponentTypeResolver(type, resolver, override = true) {
        if (!type) {
            throw new Error(`type is null or not defined`);
        }
        if (!resolver) {
            throw new Error(`resolver is null or not defined`);
        }
        /** @type {?} */
        let existing = this.types[type];
        if (existing && !override) {
            throw new Error(`already mapped, use override option if you intend replacing existing mapping.`);
        }
        this.types[type] = resolver;
    }
    /**
     * Finds the component type that is needed to render a form field.
     * @param {?} model Form field model for the field to render
     * @param {?=} defaultValue Default type returned for field types that are not yet mapped.
     * @return {?} Component type
     */
    resolveComponentType(model, defaultValue = this.defaultValue) {
        if (model) {
            /** @type {?} */
            let resolver = this.getComponentTypeResolver(model.type, defaultValue);
            return resolver(model);
        }
        return defaultValue;
    }
}
if (false) {
    /** @type {?} */
    DynamicComponentMapper.prototype.defaultValue;
    /** @type {?} */
    DynamicComponentMapper.prototype.types;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1jb21wb25lbnQtbWFwcGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvcmUvIiwic291cmNlcyI6WyJzZXJ2aWNlcy9keW5hbWljLWNvbXBvbmVudC1tYXBwZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sWUFBWSxDQUFDOzs7Ozs7Ozs7O0FBSXJDLE1BQU07Ozs7O0lBQ0YsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFjO1FBQzFCLE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3hCO0NBQ0o7Ozs7QUFFRCxNQUFNOzs0QkFFaUMsU0FBUztxQkFDMEIsRUFBRTs7Ozs7Ozs7SUFReEUsd0JBQXdCLENBQUMsSUFBWSxFQUFFLGVBQXlCLElBQUksQ0FBQyxZQUFZO1FBQzdFLElBQUksSUFBSSxFQUFFO1lBQ04sT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLHdCQUF3QixDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUM5RTtRQUNELE9BQU8sd0JBQXdCLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQzFEOzs7Ozs7OztJQVFELHdCQUF3QixDQUFDLElBQVksRUFBRSxRQUF5QyxFQUFFLFdBQW9CLElBQUk7UUFDdEcsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNQLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztTQUNsRDtRQUVELElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDWCxNQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7U0FDdEQ7O1FBRUQsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoQyxJQUFJLFFBQVEsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLCtFQUErRSxDQUFDLENBQUM7U0FDcEc7UUFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQztLQUMvQjs7Ozs7OztJQVFELG9CQUFvQixDQUFDLEtBQTRCLEVBQUUsZUFBeUIsSUFBSSxDQUFDLFlBQVk7UUFDekYsSUFBSSxLQUFLLEVBQUU7O1lBQ1AsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFDdkUsT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDMUI7UUFDRCxPQUFPLFlBQVksQ0FBQztLQUN2QjtDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZ2V0VHlwZSB9IGZyb20gJy4vZ2V0LXR5cGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIER5bmFtaWNDb21wb25lbnRNb2RlbCB7IHR5cGU6IHN0cmluZzsgfVxuZXhwb3J0IHR5cGUgRHluYW1pY0NvbXBvbmVudFJlc29sdmVGdW5jdGlvbiA9IChtb2RlbDogRHluYW1pY0NvbXBvbmVudE1vZGVsKSA9PiBUeXBlPHt9PjtcbmV4cG9ydCBjbGFzcyBEeW5hbWljQ29tcG9uZW50UmVzb2x2ZXIge1xuICAgIHN0YXRpYyBmcm9tVHlwZSh0eXBlOiBUeXBlPHt9Pik6IER5bmFtaWNDb21wb25lbnRSZXNvbHZlRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gZ2V0VHlwZSh0eXBlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEeW5hbWljQ29tcG9uZW50TWFwcGVyIHtcblxuICAgIHByb3RlY3RlZCBkZWZhdWx0VmFsdWU6IFR5cGU8e30+ID0gdW5kZWZpbmVkO1xuICAgIHByb3RlY3RlZCB0eXBlczogeyBba2V5OiBzdHJpbmddOiBEeW5hbWljQ29tcG9uZW50UmVzb2x2ZUZ1bmN0aW9uIH0gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnRseSBhY3RpdmUgQ29tcG9uZW50VHlwZVJlc29sdmVyIGZ1bmN0aW9uIGZvciBhIGZpZWxkIHR5cGUuXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgd2hvc2UgcmVzb2x2ZXIgeW91IHdhbnRcbiAgICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIERlZmF1bHQgdHlwZSByZXR1cm5lZCBmb3IgdHlwZXMgdGhhdCBhcmUgbm90IHlldCBtYXBwZWRcbiAgICAgKiBAcmV0dXJucyBSZXNvbHZlciBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldENvbXBvbmVudFR5cGVSZXNvbHZlcih0eXBlOiBzdHJpbmcsIGRlZmF1bHRWYWx1ZTogVHlwZTx7fT4gPSB0aGlzLmRlZmF1bHRWYWx1ZSk6IER5bmFtaWNDb21wb25lbnRSZXNvbHZlRnVuY3Rpb24ge1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZXNbdHlwZV0gfHwgRHluYW1pY0NvbXBvbmVudFJlc29sdmVyLmZyb21UeXBlKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIER5bmFtaWNDb21wb25lbnRSZXNvbHZlci5mcm9tVHlwZShkZWZhdWx0VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgb3Igb3B0aW9uYWxseSByZXBsYWNlcyBhIENvbXBvbmVudFR5cGVSZXNvbHZlciBmdW5jdGlvbiBmb3IgYSBmaWVsZCB0eXBlLlxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIHdob3NlIHJlc29sdmVyIHlvdSB3YW50IHRvIHNldFxuICAgICAqIEBwYXJhbSByZXNvbHZlciBUaGUgbmV3IHJlc29sdmVyIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIG92ZXJyaWRlIFRoZSBuZXcgcmVzb2x2ZXIgd2lsbCBvbmx5IHJlcGxhY2UgYW4gZXhpc3Rpbmcgb25lIGlmIHRoaXMgcGFyYW1ldGVyIGlzIHRydWVcbiAgICAgKi9cbiAgICBzZXRDb21wb25lbnRUeXBlUmVzb2x2ZXIodHlwZTogc3RyaW5nLCByZXNvbHZlcjogRHluYW1pY0NvbXBvbmVudFJlc29sdmVGdW5jdGlvbiwgb3ZlcnJpZGU6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eXBlIGlzIG51bGwgb3Igbm90IGRlZmluZWRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVzb2x2ZXIgaXMgbnVsbCBvciBub3QgZGVmaW5lZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGV4aXN0aW5nID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGV4aXN0aW5nICYmICFvdmVycmlkZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbHJlYWR5IG1hcHBlZCwgdXNlIG92ZXJyaWRlIG9wdGlvbiBpZiB5b3UgaW50ZW5kIHJlcGxhY2luZyBleGlzdGluZyBtYXBwaW5nLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50eXBlc1t0eXBlXSA9IHJlc29sdmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBjb21wb25lbnQgdHlwZSB0aGF0IGlzIG5lZWRlZCB0byByZW5kZXIgYSBmb3JtIGZpZWxkLlxuICAgICAqIEBwYXJhbSBtb2RlbCBGb3JtIGZpZWxkIG1vZGVsIGZvciB0aGUgZmllbGQgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBEZWZhdWx0IHR5cGUgcmV0dXJuZWQgZm9yIGZpZWxkIHR5cGVzIHRoYXQgYXJlIG5vdCB5ZXQgbWFwcGVkLlxuICAgICAqIEByZXR1cm5zIENvbXBvbmVudCB0eXBlXG4gICAgICovXG4gICAgcmVzb2x2ZUNvbXBvbmVudFR5cGUobW9kZWw6IER5bmFtaWNDb21wb25lbnRNb2RlbCwgZGVmYXVsdFZhbHVlOiBUeXBlPHt9PiA9IHRoaXMuZGVmYXVsdFZhbHVlKTogVHlwZTx7fT4ge1xuICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlciA9IHRoaXMuZ2V0Q29tcG9uZW50VHlwZVJlc29sdmVyKG1vZGVsLnR5cGUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXIobW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxufVxuIl19