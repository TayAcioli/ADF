/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { AlfrescoApiService } from '../../services/alfresco-api.service';
import { Injectable } from '@angular/core';
import { from } from 'rxjs';
import { NodeMetadata } from '../models/node-metadata.model';
import { map } from 'rxjs/operators';
export class NodeService {
    /**
     * @param {?} apiService
     */
    constructor(apiService) {
        this.apiService = apiService;
    }
    /**
     * Get the metadata and the nodeType for a nodeId cleaned by the prefix.
     * @param {?} nodeId ID of the target node
     * @return {?} Node metadata
     */
    getNodeMetadata(nodeId) {
        return from(this.apiService.getInstance().nodes.getNodeInfo(nodeId))
            .pipe(map(this.cleanMetadataFromSemicolon));
    }
    /**
     * Create a new Node from form metadata.
     * @param {?} nodeType Node type
     * @param {?} nameSpace Namespace for properties
     * @param {?} data Property data to store in the node under namespace
     * @param {?} path Path to the node
     * @param {?=} name Node name
     * @return {?} The created node
     */
    createNodeMetadata(nodeType, nameSpace, data, path, name) {
        /** @type {?} */
        let properties = {};
        for (let key in data) {
            if (data[key]) {
                properties[nameSpace + ':' + key] = data[key];
            }
        }
        return this.createNode(name || this.generateUuid(), nodeType, properties, path);
    }
    /**
     * Create a new Node from form metadata
     * @param {?} name Node name
     * @param {?} nodeType Node type
     * @param {?} properties Node body properties
     * @param {?} path Path to the node
     * @return {?} The created node
     */
    createNode(name, nodeType, properties, path) {
        /** @type {?} */
        let body = {
            name: name,
            nodeType: nodeType,
            properties: properties,
            relativePath: path
        };
        /** @type {?} */
        let apiService = this.apiService.getInstance();
        return from(apiService.nodes.addNode('-root-', body, {}));
    }
    /**
     * @return {?}
     */
    generateUuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            /** @type {?} */
            let r = Math.random() * 16 | 0;
            /** @type {?} */
            let v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    cleanMetadataFromSemicolon(data) {
        /** @type {?} */
        let metadata = {};
        if (data && data.properties) {
            for (let key in data.properties) {
                if (key) {
                    if (key.indexOf(':') !== -1) {
                        metadata[key.split(':')[1]] = data.properties[key];
                    }
                    else {
                        metadata[key] = data.properties[key];
                    }
                }
            }
        }
        return new NodeMetadata(metadata, data.nodeType);
    }
}
NodeService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NodeService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
if (false) {
    /** @type {?} */
    NodeService.prototype.apiService;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb3JlLyIsInNvdXJjZXMiOlsiZm9ybS9zZXJ2aWNlcy9ub2RlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDekUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQWMsSUFBSSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUM3RCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFHckMsTUFBTTs7OztJQUVGLFlBQW9CLFVBQThCO1FBQTlCLGVBQVUsR0FBVixVQUFVLENBQW9CO0tBQ2pEOzs7Ozs7SUFPTSxlQUFlLENBQUMsTUFBYztRQUNqQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDL0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7OztJQVk3QyxrQkFBa0IsQ0FBQyxRQUFnQixFQUFFLFNBQWMsRUFBRSxJQUFTLEVBQUUsSUFBWSxFQUFFLElBQWE7O1FBQzlGLElBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQztRQUNwQixLQUFLLElBQUksR0FBRyxJQUFJLElBQUksRUFBRTtZQUNsQixJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDWCxVQUFVLENBQUMsU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDakQ7U0FDSjtRQUVELE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRSxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7Ozs7Ozs7Ozs7SUFXN0UsVUFBVSxDQUFDLElBQVksRUFBRSxRQUFnQixFQUFFLFVBQWUsRUFBRSxJQUFZOztRQUMzRSxJQUFJLElBQUksR0FBRztZQUNQLElBQUksRUFBRSxJQUFJO1lBQ1YsUUFBUSxFQUFFLFFBQVE7WUFDbEIsVUFBVSxFQUFFLFVBQVU7WUFDdEIsWUFBWSxFQUFFLElBQUk7U0FDckIsQ0FBQzs7UUFHRixJQUFJLFVBQVUsR0FBUSxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3BELE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQzs7Ozs7SUFHdEQsWUFBWTtRQUNoQixPQUFPLHNDQUFzQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDOztZQUN0RSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBc0M7O1lBQXBFLElBQWdDLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztZQUNwRSxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDekIsQ0FBQyxDQUFDOzs7Ozs7SUFHQywwQkFBMEIsQ0FBQyxJQUFTOztRQUN4QyxJQUFJLFFBQVEsR0FBRyxFQUFFLENBQUM7UUFFbEIsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUN6QixLQUFLLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQzdCLElBQUksR0FBRyxFQUFFO29CQUNMLElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTt3QkFDekIsUUFBUSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO3FCQUN2RDt5QkFBTTt3QkFDSCxRQUFRLENBQUUsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztxQkFDekM7aUJBQ0o7YUFDSjtTQUNKO1FBRUQsT0FBTyxJQUFJLFlBQVksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDOzs7O1lBL0V4RCxVQUFVOzs7O1lBTkYsa0JBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYWxmcmVzY28tYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZnJvbSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTm9kZU1ldGFkYXRhIH0gZnJvbSAnLi4vbW9kZWxzL25vZGUtbWV0YWRhdGEubW9kZWwnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTm9kZVNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1ldGFkYXRhIGFuZCB0aGUgbm9kZVR5cGUgZm9yIGEgbm9kZUlkIGNsZWFuZWQgYnkgdGhlIHByZWZpeC5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIElEIG9mIHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIEByZXR1cm5zIE5vZGUgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Tm9kZU1ldGFkYXRhKG5vZGVJZDogc3RyaW5nKTogT2JzZXJ2YWJsZTxOb2RlTWV0YWRhdGE+IHtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkubm9kZXMuZ2V0Tm9kZUluZm8obm9kZUlkKSlcbiAgICAgICAgICAgIC5waXBlKG1hcCh0aGlzLmNsZWFuTWV0YWRhdGFGcm9tU2VtaWNvbG9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE5vZGUgZnJvbSBmb3JtIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSBwYXRoIFBhdGggdG8gdGhlIG5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZVR5cGUgTm9kZSB0eXBlXG4gICAgICogQHBhcmFtIG5hbWUgTm9kZSBuYW1lXG4gICAgICogQHBhcmFtIG5hbWVTcGFjZSBOYW1lc3BhY2UgZm9yIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0gZGF0YSBQcm9wZXJ0eSBkYXRhIHRvIHN0b3JlIGluIHRoZSBub2RlIHVuZGVyIG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIG5vZGVcbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlTm9kZU1ldGFkYXRhKG5vZGVUeXBlOiBzdHJpbmcsIG5hbWVTcGFjZTogYW55LCBkYXRhOiBhbnksIHBhdGg6IHN0cmluZywgbmFtZT86IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICAgIGxldCBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtrZXldKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllc1tuYW1lU3BhY2UgKyAnOicgKyBrZXldID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTm9kZShuYW1lIHx8IHRoaXMuZ2VuZXJhdGVVdWlkKCksIG5vZGVUeXBlLCBwcm9wZXJ0aWVzLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgTm9kZSBmcm9tIGZvcm0gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gbmFtZSBOb2RlIG5hbWVcbiAgICAgKiBAcGFyYW0gbm9kZVR5cGUgTm9kZSB0eXBlXG4gICAgICogQHBhcmFtIHByb3BlcnRpZXMgTm9kZSBib2R5IHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0gcGF0aCBQYXRoIHRvIHRoZSBub2RlXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbm9kZVxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVOb2RlKG5hbWU6IHN0cmluZywgbm9kZVR5cGU6IHN0cmluZywgcHJvcGVydGllczogYW55LCBwYXRoOiBzdHJpbmcpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgICAgICBsZXQgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBub2RlVHlwZTogbm9kZVR5cGUsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgcmVsYXRpdmVQYXRoOiBwYXRoXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVE9ETzogcmVxdWlyZXMgdXBkYXRlIHRvIGFsZnJlc2NvLWpzLWFwaSB0eXBpbmdzXG4gICAgICAgIGxldCBhcGlTZXJ2aWNlOiBhbnkgPSB0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgcmV0dXJuIGZyb20oYXBpU2VydmljZS5ub2Rlcy5hZGROb2RlKCctcm9vdC0nLCBib2R5LCB7fSkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2VuZXJhdGVVdWlkKCkge1xuICAgICAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgbGV0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjbGVhbk1ldGFkYXRhRnJvbVNlbWljb2xvbihkYXRhOiBhbnkpOiBOb2RlTWV0YWRhdGEge1xuICAgICAgICBsZXQgbWV0YWRhdGEgPSB7fTtcblxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBkYXRhLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgW2tleS5zcGxpdCgnOicpWzFdXSA9IGRhdGEucHJvcGVydGllc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgW2tleV0gPSBkYXRhLnByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTm9kZU1ldGFkYXRhKG1ldGFkYXRhLCBkYXRhLm5vZGVUeXBlKTtcbiAgICB9XG59XG4iXX0=