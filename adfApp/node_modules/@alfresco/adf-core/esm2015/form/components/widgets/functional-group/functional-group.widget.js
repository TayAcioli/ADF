/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ENTER, ESCAPE } from '@angular/cdk/keycodes';
import { Component, ElementRef, ViewEncapsulation } from '@angular/core';
import { FormService } from '../../../services/form.service';
import { baseHost, WidgetComponent } from './../widget.component';
export class FunctionalGroupWidgetComponent extends WidgetComponent {
    /**
     * @param {?} formService
     * @param {?} elementRef
     */
    constructor(formService, elementRef) {
        super(formService);
        this.formService = formService;
        this.elementRef = elementRef;
        this.groups = [];
        this.minTermLength = 1;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.field) {
            /** @type {?} */
            let group = this.field.value;
            if (group) {
                this.value = group.name;
            }
            /** @type {?} */
            let params = this.field.params;
            if (params && params['restrictWithGroup']) {
                /** @type {?} */
                let restrictWithGroup = /** @type {?} */ (params['restrictWithGroup']);
                this.groupId = restrictWithGroup.id;
            }
            // Load auto-completion for previously saved value
            if (this.value) {
                this.formService
                    .getWorkflowGroups(this.value, this.groupId)
                    .subscribe((result) => this.groups = result || []);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyUp(event) {
        if (this.value && this.value.length >= this.minTermLength && this.oldValue !== this.value) {
            if (event.keyCode !== ESCAPE && event.keyCode !== ENTER) {
                this.oldValue = this.value;
                this.formService.getWorkflowGroups(this.value, this.groupId)
                    .subscribe((result) => {
                    this.groups = result || [];
                });
            }
        }
    }
    /**
     * @return {?}
     */
    flushValue() {
        /** @type {?} */
        let option = this.groups.find(item => item.name.toLocaleLowerCase() === this.value.toLocaleLowerCase());
        if (option) {
            this.field.value = option;
            this.value = option.name;
        }
        else {
            this.field.value = null;
            this.value = null;
        }
        this.field.updateForm();
    }
    /**
     * @param {?} item
     * @param {?} event
     * @return {?}
     */
    onItemClick(item, event) {
        if (item) {
            this.field.value = item;
            this.value = item.name;
        }
        if (event) {
            event.preventDefault();
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onItemSelect(item) {
        if (item) {
            this.field.value = item;
            this.value = item.name;
        }
    }
}
FunctionalGroupWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'functional-group-widget',
                template: "<div class=\"adf-group-widget {{field.className}}\"\n     [class.is-dirty]=\"value\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\" id=\"functional-group-div\">\n    <mat-form-field>\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               class=\"adf-input\"\n               type=\"text\"\n               [id]=\"field.id\"\n               [(ngModel)]=\"value\"\n               (keyup)=\"onKeyUp($event)\"\n               [disabled]=\"field.readOnly\"\n               placeholder=\"{{field.placeholder}}\"\n               [matAutocomplete]=\"auto\">\n        <mat-autocomplete #auto=\"matAutocomplete\" (optionSelected)=\"onItemSelect($event.option.value)\">\n            <mat-option *ngFor=\"let item of groups\"\n                       [id]=\"field.id +'-'+item.id\"\n                       (click)=\"onItemClick(item, $event)\"  [value]=\"item\">\n                <span>{{item.name}}</span>\n            </mat-option>\n        </mat-autocomplete>\n\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: baseHost,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-group-widget{width:100%}"]
            }] }
];
/** @nocollapse */
FunctionalGroupWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: ElementRef }
];
if (false) {
    /** @type {?} */
    FunctionalGroupWidgetComponent.prototype.value;
    /** @type {?} */
    FunctionalGroupWidgetComponent.prototype.oldValue;
    /** @type {?} */
    FunctionalGroupWidgetComponent.prototype.groups;
    /** @type {?} */
    FunctionalGroupWidgetComponent.prototype.minTermLength;
    /** @type {?} */
    FunctionalGroupWidgetComponent.prototype.groupId;
    /** @type {?} */
    FunctionalGroupWidgetComponent.prototype.formService;
    /** @type {?} */
    FunctionalGroupWidgetComponent.prototype.elementRef;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuY3Rpb25hbC1ncm91cC53aWRnZXQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvcmUvIiwic291cmNlcyI6WyJmb3JtL2NvbXBvbmVudHMvd2lkZ2V0cy9mdW5jdGlvbmFsLWdyb3VwL2Z1bmN0aW9uYWwtZ3JvdXAud2lkZ2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQVUsaUJBQWlCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDakYsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRTdELE9BQU8sRUFBRSxRQUFRLEVBQUcsZUFBZSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFTbkUsTUFBTSxxQ0FBc0MsU0FBUSxlQUFlOzs7OztJQVEvRCxZQUFtQixXQUF3QixFQUN4QjtRQUNkLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUZMLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3hCLGVBQVUsR0FBVixVQUFVO3NCQUxOLEVBQUU7NkJBQ0QsQ0FBQztLQU14Qjs7OztJQUVELFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7O1lBQ1osSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7WUFDN0IsSUFBSSxLQUFLLEVBQUU7Z0JBQ1AsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO2FBQzNCOztZQUVELElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO1lBQy9CLElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFOztnQkFDdkMsSUFBSSxpQkFBaUIscUJBQWdCLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxFQUFDO2dCQUNqRSxJQUFJLENBQUMsT0FBTyxHQUFHLGlCQUFpQixDQUFDLEVBQUUsQ0FBQzthQUN2Qzs7WUFHRCxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ1osSUFBSSxDQUFDLFdBQVc7cUJBQ1gsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDO3FCQUMzQyxTQUFTLENBQUMsQ0FBQyxNQUFvQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQzthQUN4RTtTQUNKO0tBQ0o7Ozs7O0lBRUQsT0FBTyxDQUFDLEtBQW9CO1FBQ3hCLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFLLElBQUksQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLEtBQUssRUFBRTtZQUN4RixJQUFJLEtBQUssQ0FBQyxPQUFPLEtBQUssTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLEtBQUssS0FBSyxFQUFFO2dCQUNyRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7Z0JBQzNCLElBQUksQ0FBQyxXQUFXLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDO3FCQUN2RCxTQUFTLENBQUMsQ0FBQyxNQUFvQixFQUFFLEVBQUU7b0JBQ2hDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxJQUFJLEVBQUUsQ0FBQztpQkFDOUIsQ0FBQyxDQUFDO2FBQ1Y7U0FDSjtLQUNKOzs7O0lBRUQsVUFBVTs7UUFDTixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLGlCQUFpQixFQUFFLENBQUMsQ0FBQztRQUV4RyxJQUFJLE1BQU0sRUFBRTtZQUNSLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQztZQUMxQixJQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUM7U0FDNUI7YUFBTTtZQUNILElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztZQUN4QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztTQUNyQjtRQUVELElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7S0FDM0I7Ozs7OztJQUVELFdBQVcsQ0FBQyxJQUFnQixFQUFFLEtBQVk7UUFDdEMsSUFBSSxJQUFJLEVBQUU7WUFDTixJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7WUFDeEIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1NBQzFCO1FBQ0QsSUFBSSxLQUFLLEVBQUU7WUFDUCxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7U0FDMUI7S0FDSjs7Ozs7SUFFRCxZQUFZLENBQUMsSUFBZ0I7UUFDekIsSUFBSSxJQUFJLEVBQUU7WUFDTixJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7WUFDeEIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1NBQzFCO0tBQ0o7OztZQW5GSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLHlCQUF5QjtnQkFDbkMsb3pDQUE2QztnQkFFN0MsSUFBSSxFQUFFLFFBQVE7Z0JBQ2QsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7O2FBQ3hDOzs7O1lBVlEsV0FBVztZQURBLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4gLyogdHNsaW50OmRpc2FibGU6Y29tcG9uZW50LXNlbGVjdG9yICAqL1xuXG5pbXBvcnQgeyBFTlRFUiwgRVNDQVBFIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgT25Jbml0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9zZXJ2aWNlcy9mb3JtLnNlcnZpY2UnO1xuaW1wb3J0IHsgR3JvdXBNb2RlbCB9IGZyb20gJy4vLi4vY29yZS9ncm91cC5tb2RlbCc7XG5pbXBvcnQgeyBiYXNlSG9zdCAsIFdpZGdldENvbXBvbmVudCB9IGZyb20gJy4vLi4vd2lkZ2V0LmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnZnVuY3Rpb25hbC1ncm91cC13aWRnZXQnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9mdW5jdGlvbmFsLWdyb3VwLndpZGdldC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9mdW5jdGlvbmFsLWdyb3VwLndpZGdldC5zY3NzJ10sXG4gICAgaG9zdDogYmFzZUhvc3QsXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBGdW5jdGlvbmFsR3JvdXBXaWRnZXRDb21wb25lbnQgZXh0ZW5kcyBXaWRnZXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgdmFsdWU6IHN0cmluZztcbiAgICBvbGRWYWx1ZTogc3RyaW5nO1xuICAgIGdyb3VwczogR3JvdXBNb2RlbFtdID0gW107XG4gICAgbWluVGVybUxlbmd0aDogbnVtYmVyID0gMTtcbiAgICBncm91cElkOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZm9ybVNlcnZpY2U6IEZvcm1TZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG4gICAgICAgICBzdXBlcihmb3JtU2VydmljZSk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpZWxkKSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLmZpZWxkLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGdyb3VwLm5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSB0aGlzLmZpZWxkLnBhcmFtcztcbiAgICAgICAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zWydyZXN0cmljdFdpdGhHcm91cCddKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3RyaWN0V2l0aEdyb3VwID0gPEdyb3VwTW9kZWw+IHBhcmFtc1sncmVzdHJpY3RXaXRoR3JvdXAnXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwSWQgPSByZXN0cmljdFdpdGhHcm91cC5pZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9hZCBhdXRvLWNvbXBsZXRpb24gZm9yIHByZXZpb3VzbHkgc2F2ZWQgdmFsdWVcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtU2VydmljZVxuICAgICAgICAgICAgICAgICAgICAuZ2V0V29ya2Zsb3dHcm91cHModGhpcy52YWx1ZSwgdGhpcy5ncm91cElkKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXN1bHQ6IEdyb3VwTW9kZWxbXSkgPT4gdGhpcy5ncm91cHMgPSByZXN1bHQgfHwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25LZXlVcChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmxlbmd0aCA+PSB0aGlzLm1pblRlcm1MZW5ndGggICYmIHRoaXMub2xkVmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlICE9PSBFU0NBUEUgJiYgZXZlbnQua2V5Q29kZSAhPT0gRU5URVIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1TZXJ2aWNlLmdldFdvcmtmbG93R3JvdXBzKHRoaXMudmFsdWUsIHRoaXMuZ3JvdXBJZClcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzdWx0OiBHcm91cE1vZGVsW10pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzID0gcmVzdWx0IHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoVmFsdWUoKSB7XG4gICAgICAgIGxldCBvcHRpb24gPSB0aGlzLmdyb3Vwcy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHRoaXMudmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5maWVsZC52YWx1ZSA9IG9wdGlvbjtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBvcHRpb24ubmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGQudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpZWxkLnVwZGF0ZUZvcm0oKTtcbiAgICB9XG5cbiAgICBvbkl0ZW1DbGljayhpdGVtOiBHcm91cE1vZGVsLCBldmVudDogRXZlbnQpIHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGQudmFsdWUgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGl0ZW0ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkl0ZW1TZWxlY3QoaXRlbTogR3JvdXBNb2RlbCkge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5maWVsZC52YWx1ZSA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gaXRlbS5uYW1lO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19