/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import moment from 'moment-es6';
export class DateCellValidator {
    constructor() {
        this.supportedTypes = [
            'Date'
        ];
    }
    /**
     * @param {?} column
     * @return {?}
     */
    isSupported(column) {
        return column && column.editable && this.supportedTypes.indexOf(column.type) > -1;
    }
    /**
     * @param {?} row
     * @param {?} column
     * @param {?=} summary
     * @return {?}
     */
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            /** @type {?} */
            let value = row.value[column.id];
            /** @type {?} */
            let dateValue = moment(value, 'D-M-YYYY');
            if (!dateValue.isValid()) {
                if (summary) {
                    summary.isValid = false;
                    summary.message = `Invalid '${column.name}' format.`;
                }
                return false;
            }
        }
        return true;
    }
}
if (false) {
    /** @type {?} */
    DateCellValidator.prototype.supportedTypes;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1jZWxsLXZhbGlkYXRvci1tb2RlbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29yZS8iLCJzb3VyY2VzIjpbImZvcm0vY29tcG9uZW50cy93aWRnZXRzL2R5bmFtaWMtdGFibGUvZGF0ZS1jZWxsLXZhbGlkYXRvci1tb2RlbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxPQUFPLE1BQU0sTUFBTSxZQUFZLENBQUM7QUFNaEMsTUFBTTs7OEJBRWlDO1lBQy9CLE1BQU07U0FDVDs7Ozs7O0lBRUQsV0FBVyxDQUFDLE1BQTBCO1FBQ2xDLE9BQU8sTUFBTSxJQUFJLE1BQU0sQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQ3JGOzs7Ozs7O0lBRUQsUUFBUSxDQUFDLEdBQW9CLEVBQUUsTUFBMEIsRUFBRSxPQUFxQztRQUU1RixJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEVBQUU7O1lBQzFCLElBQUksS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDOztZQUNqQyxJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQzFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ3RCLElBQUksT0FBTyxFQUFFO29CQUNULE9BQU8sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO29CQUN4QixPQUFPLENBQUMsT0FBTyxHQUFHLFlBQVksTUFBTSxDQUFDLElBQUksV0FBVyxDQUFDO2lCQUN4RDtnQkFDRCxPQUFPLEtBQUssQ0FBQzthQUNoQjtTQUNKO1FBRUQsT0FBTyxJQUFJLENBQUM7S0FDZjtDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogdHNsaW50OmRpc2FibGU6Y29tcG9uZW50LXNlbGVjdG9yICAqL1xuXG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudC1lczYnO1xuaW1wb3J0IHsgQ2VsbFZhbGlkYXRvciB9IGZyb20gJy4vY2VsbC12YWxpZGF0b3IubW9kZWwnO1xuaW1wb3J0IHsgRHluYW1pY1Jvd1ZhbGlkYXRpb25TdW1tYXJ5IH0gZnJvbSAnLi9keW5hbWljLXJvdy12YWxpZGF0aW9uLXN1bW1hcnkubW9kZWwnO1xuaW1wb3J0IHsgRHluYW1pY1RhYmxlQ29sdW1uIH0gZnJvbSAnLi9keW5hbWljLXRhYmxlLWNvbHVtbi5tb2RlbCc7XG5pbXBvcnQgeyBEeW5hbWljVGFibGVSb3cgfSBmcm9tICcuL2R5bmFtaWMtdGFibGUtcm93Lm1vZGVsJztcblxuZXhwb3J0IGNsYXNzIERhdGVDZWxsVmFsaWRhdG9yIGltcGxlbWVudHMgQ2VsbFZhbGlkYXRvciB7XG5cbiAgICBwcml2YXRlIHN1cHBvcnRlZFR5cGVzOiBzdHJpbmdbXSA9IFtcbiAgICAgICAgJ0RhdGUnXG4gICAgXTtcblxuICAgIGlzU3VwcG9ydGVkKGNvbHVtbjogRHluYW1pY1RhYmxlQ29sdW1uKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBjb2x1bW4gJiYgY29sdW1uLmVkaXRhYmxlICYmIHRoaXMuc3VwcG9ydGVkVHlwZXMuaW5kZXhPZihjb2x1bW4udHlwZSkgPiAtMTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZShyb3c6IER5bmFtaWNUYWJsZVJvdywgY29sdW1uOiBEeW5hbWljVGFibGVDb2x1bW4sIHN1bW1hcnk/OiBEeW5hbWljUm93VmFsaWRhdGlvblN1bW1hcnkpOiBib29sZWFuIHtcblxuICAgICAgICBpZiAodGhpcy5pc1N1cHBvcnRlZChjb2x1bW4pKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSByb3cudmFsdWVbY29sdW1uLmlkXTtcbiAgICAgICAgICAgIGxldCBkYXRlVmFsdWUgPSBtb21lbnQodmFsdWUsICdELU0tWVlZWScpO1xuICAgICAgICAgICAgaWYgKCFkYXRlVmFsdWUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeS5pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnkubWVzc2FnZSA9IGBJbnZhbGlkICcke2NvbHVtbi5uYW1lfScgZm9ybWF0LmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiJdfQ==