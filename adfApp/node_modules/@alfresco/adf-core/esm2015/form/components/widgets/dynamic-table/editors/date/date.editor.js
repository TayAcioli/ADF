/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { UserPreferencesService } from '../../../../../../services/user-preferences.service';
import { MomentDateAdapter } from '../../../../../../utils/momentDateAdapter';
import { MOMENT_DATE_FORMATS } from '../../../../../../utils/moment-date-formats.model';
import { Component, Input } from '@angular/core';
import { DateAdapter, MAT_DATE_FORMATS } from '@angular/material';
import moment from 'moment-es6';
import { DynamicTableModel } from './../../dynamic-table.widget.model';
const ɵ0 = MOMENT_DATE_FORMATS;
export class DateEditorComponent {
    /**
     * @param {?} dateAdapter
     * @param {?} preferences
     */
    constructor(dateAdapter, preferences) {
        this.dateAdapter = dateAdapter;
        this.preferences = preferences;
        this.DATE_FORMAT = 'DD-MM-YYYY';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.preferences.locale$.subscribe((locale) => {
            this.dateAdapter.setLocale(locale);
        });
        /** @type {?} */
        let momentDateAdapter = /** @type {?} */ (this.dateAdapter);
        momentDateAdapter.overrideDisplyaFormat = this.DATE_FORMAT;
        this.value = moment(this.table.getCellValue(this.row, this.column), 'YYYY-MM-DD');
    }
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    onDateChanged(newDateValue) {
        if (newDateValue && newDateValue.value) {
            /** @type {?} */
            let momentDate = moment(newDateValue.value, this.DATE_FORMAT, true);
            if (!momentDate.isValid()) {
                this.row.value[this.column.id] = '';
            }
            else {
                this.row.value[this.column.id] = `${momentDate.format('YYYY-MM-DD')}T00:00:00.000Z`;
                this.table.flushValue();
            }
        }
    }
}
DateEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-date-editor',
                template: "<div>\n    <mat-form-field class=\"adf-date-editor\">\n        <label [attr.for]=\"column.id\">{{column.name}} (d-M-yyyy)</label>\n        <input matInput\n            id=\"dateInput\"\n            type=\"text\"\n            [matDatepicker]=\"datePicker\"\n            [value]=\"value\"\n            [id]=\"column.id\"\n            [required]=\"column.required\"\n            [disabled]=\"!column.editable\"\n            (focusout)=\"onDateChanged($event.srcElement.value)\"\n            (dateChange)=\"onDateChanged($event)\">\n        <mat-datepicker-toggle  *ngIf=\"column.editable\" matSuffix [for]=\"datePicker\" class=\"adf-date-editor-button\" ></mat-datepicker-toggle>\n    </mat-form-field>\n    <mat-datepicker #datePicker [touchUi]=\"true\"></mat-datepicker>\n</div>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                ],
                styles: [".adf-date-editor{width:100%}.adf-date-editor-button{position:relative;top:25px}"]
            }] }
];
/** @nocollapse */
DateEditorComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: UserPreferencesService }
];
DateEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    DateEditorComponent.prototype.DATE_FORMAT;
    /** @type {?} */
    DateEditorComponent.prototype.value;
    /** @type {?} */
    DateEditorComponent.prototype.table;
    /** @type {?} */
    DateEditorComponent.prototype.row;
    /** @type {?} */
    DateEditorComponent.prototype.column;
    /** @type {?} */
    DateEditorComponent.prototype.minDate;
    /** @type {?} */
    DateEditorComponent.prototype.maxDate;
    /** @type {?} */
    DateEditorComponent.prototype.dateAdapter;
    /** @type {?} */
    DateEditorComponent.prototype.preferences;
}
export { ɵ0 };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5lZGl0b3IuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvcmUvIiwic291cmNlcyI6WyJmb3JtL2NvbXBvbmVudHMvd2lkZ2V0cy9keW5hbWljLXRhYmxlL2VkaXRvcnMvZGF0ZS9kYXRlLmVkaXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxxREFBcUQsQ0FBQztBQUM3RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUM5RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtREFBbUQsQ0FBQztBQUN4RixPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUN6RCxPQUFPLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbEUsT0FBTyxNQUFNLE1BQU0sWUFBWSxDQUFDO0FBSWhDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO1dBT3pCLG1CQUFtQjtBQUdqRSxNQUFNOzs7OztJQWtCRixZQUFvQixXQUFnQyxFQUNoQztRQURBLGdCQUFXLEdBQVgsV0FBVyxDQUFxQjtRQUNoQyxnQkFBVyxHQUFYLFdBQVc7MkJBakJULFlBQVk7S0FrQmpDOzs7O0lBRUQsUUFBUTtRQUNKLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQzFDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3RDLENBQUMsQ0FBQzs7UUFDSCxJQUFJLGlCQUFpQixxQkFBdUIsSUFBSSxDQUFDLFdBQVcsRUFBQztRQUM3RCxpQkFBaUIsQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBRTNELElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDO0tBQ3JGOzs7OztJQUVELGFBQWEsQ0FBQyxZQUFZO1FBQ3RCLElBQUksWUFBWSxJQUFJLFlBQVksQ0FBQyxLQUFLLEVBQUU7O1lBQ3BDLElBQUksVUFBVSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFFcEUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRTtnQkFDdkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7YUFDdkM7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDO2dCQUNwRixJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO2FBQzNCO1NBQ0o7S0FDSjs7O1lBbkRKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsaUJBQWlCO2dCQUMzQix1eEJBQWlDO2dCQUNqQyxTQUFTLEVBQUU7b0JBQ1AsRUFBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBQztvQkFDbkQsRUFBQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxJQUFxQixFQUFDO2lCQUFDOzthQUVsRTs7OztZQWRRLFdBQVc7WUFKWCxzQkFBc0I7OztvQkF5QjFCLEtBQUs7a0JBR0wsS0FBSztxQkFHTCxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogdHNsaW50OmRpc2FibGU6Y29tcG9uZW50LXNlbGVjdG9yICAqL1xuXG5pbXBvcnQgeyBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vc2VydmljZXMvdXNlci1wcmVmZXJlbmNlcy5zZXJ2aWNlJztcbmltcG9ydCB7IE1vbWVudERhdGVBZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vdXRpbHMvbW9tZW50RGF0ZUFkYXB0ZXInO1xuaW1wb3J0IHsgTU9NRU5UX0RBVEVfRk9STUFUUyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL3V0aWxzL21vbWVudC1kYXRlLWZvcm1hdHMubW9kZWwnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRlQWRhcHRlciwgTUFUX0RBVEVfRk9STUFUUyB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50LWVzNic7XG5pbXBvcnQgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgRHluYW1pY1RhYmxlQ29sdW1uIH0gZnJvbSAnLi8uLi8uLi9keW5hbWljLXRhYmxlLWNvbHVtbi5tb2RlbCc7XG5pbXBvcnQgeyBEeW5hbWljVGFibGVSb3cgfSBmcm9tICcuLy4uLy4uL2R5bmFtaWMtdGFibGUtcm93Lm1vZGVsJztcbmltcG9ydCB7IER5bmFtaWNUYWJsZU1vZGVsIH0gZnJvbSAnLi8uLi8uLi9keW5hbWljLXRhYmxlLndpZGdldC5tb2RlbCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWRhdGUtZWRpdG9yJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZGF0ZS5lZGl0b3IuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBEYXRlQWRhcHRlciwgdXNlQ2xhc3M6IE1vbWVudERhdGVBZGFwdGVyfSxcbiAgICAgICAge3Byb3ZpZGU6IE1BVF9EQVRFX0ZPUk1BVFMsIHVzZVZhbHVlOiBNT01FTlRfREFURV9GT1JNQVRTfV0sXG4gICAgc3R5bGVVcmxzOiBbJy4vZGF0ZS5lZGl0b3Iuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIERhdGVFZGl0b3JDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgREFURV9GT1JNQVQ6IHN0cmluZyA9ICdERC1NTS1ZWVlZJztcblxuICAgIHZhbHVlOiBhbnk7XG5cbiAgICBASW5wdXQoKVxuICAgIHRhYmxlOiBEeW5hbWljVGFibGVNb2RlbDtcblxuICAgIEBJbnB1dCgpXG4gICAgcm93OiBEeW5hbWljVGFibGVSb3c7XG5cbiAgICBASW5wdXQoKVxuICAgIGNvbHVtbjogRHluYW1pY1RhYmxlQ29sdW1uO1xuXG4gICAgbWluRGF0ZTogTW9tZW50O1xuICAgIG1heERhdGU6IE1vbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0ZUFkYXB0ZXI6IERhdGVBZGFwdGVyPE1vbWVudD4sXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBwcmVmZXJlbmNlczogVXNlclByZWZlcmVuY2VzU2VydmljZSkge1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnByZWZlcmVuY2VzLmxvY2FsZSQuc3Vic2NyaWJlKChsb2NhbGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZUFkYXB0ZXIuc2V0TG9jYWxlKGxvY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbW9tZW50RGF0ZUFkYXB0ZXIgPSA8TW9tZW50RGF0ZUFkYXB0ZXI+IHRoaXMuZGF0ZUFkYXB0ZXI7XG4gICAgICAgIG1vbWVudERhdGVBZGFwdGVyLm92ZXJyaWRlRGlzcGx5YUZvcm1hdCA9IHRoaXMuREFURV9GT1JNQVQ7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IG1vbWVudCh0aGlzLnRhYmxlLmdldENlbGxWYWx1ZSh0aGlzLnJvdywgdGhpcy5jb2x1bW4pLCAnWVlZWS1NTS1ERCcpO1xuICAgIH1cblxuICAgIG9uRGF0ZUNoYW5nZWQobmV3RGF0ZVZhbHVlKSB7XG4gICAgICAgIGlmIChuZXdEYXRlVmFsdWUgJiYgbmV3RGF0ZVZhbHVlLnZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbW9tZW50RGF0ZSA9IG1vbWVudChuZXdEYXRlVmFsdWUudmFsdWUsIHRoaXMuREFURV9GT1JNQVQsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAoIW1vbWVudERhdGUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3cudmFsdWVbdGhpcy5jb2x1bW4uaWRdID0gJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucm93LnZhbHVlW3RoaXMuY29sdW1uLmlkXSA9IGAke21vbWVudERhdGUuZm9ybWF0KCdZWVlZLU1NLUREJyl9VDAwOjAwOjAwLjAwMFpgO1xuICAgICAgICAgICAgICAgIHRoaXMudGFibGUuZmx1c2hWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iXX0=