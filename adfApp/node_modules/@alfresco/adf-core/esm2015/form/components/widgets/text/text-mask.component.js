/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Directive, ElementRef, forwardRef, HostListener, Input, Renderer2 } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
/** @type {?} */
export const CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => InputMaskDirective),
    multi: true
};
export class InputMaskDirective {
    /**
     * @param {?} el
     * @param {?} render
     */
    constructor(el, render) {
        this.el = el;
        this.render = render;
        this.translationMask = {
            '0': { pattern: /\d/ },
            '9': { pattern: /\d/, optional: true },
            '#': { pattern: /\d/, recursive: true },
            'A': { pattern: /[a-zA-Z0-9]/ },
            'S': { pattern: /[a-zA-Z]/ }
        };
        this.byPassKeys = [9, 16, 17, 18, 36, 37, 38, 39, 40, 91];
        this.invalidCharacters = [];
        this._onChange = (_) => {
        };
        this._onTouched = () => {
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTextInput(event) {
        if (this.inputMask && this.inputMask.mask) {
            this.maskValue(this.el.nativeElement.value, this.el.nativeElement.selectionStart, this.inputMask.mask, this.inputMask.isReversed, event.keyCode);
        }
        else {
            this._onChange(this.el.nativeElement.value);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['inputMask'] && changes['inputMask'].currentValue['mask']) {
            this.inputMask = changes['inputMask'].currentValue;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.el.nativeElement.value = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} actualValue
     * @param {?} startCaret
     * @param {?} maskToApply
     * @param {?} isMaskReversed
     * @param {?} keyCode
     * @return {?}
     */
    maskValue(actualValue, startCaret, maskToApply, isMaskReversed, keyCode) {
        if (this.byPassKeys.indexOf(keyCode) === -1) {
            /** @type {?} */
            let value = this.getMasked(false, actualValue, maskToApply, isMaskReversed);
            /** @type {?} */
            let calculatedCaret = this.calculateCaretPosition(startCaret, actualValue, keyCode);
            this.render.setAttribute(this.el.nativeElement, 'value', value);
            this.el.nativeElement.value = value;
            this.setValue(value);
            this._onChange(value);
            this.setCaretPosition(calculatedCaret);
        }
    }
    /**
     * @param {?} caretPosition
     * @return {?}
     */
    setCaretPosition(caretPosition) {
        this.el.nativeElement.moveStart = caretPosition;
        this.el.nativeElement.moveEnd = caretPosition;
    }
    /**
     * @param {?} caretPosition
     * @param {?} newValue
     * @param {?} keyCode
     * @return {?}
     */
    calculateCaretPosition(caretPosition, newValue, keyCode) {
        /** @type {?} */
        let newValueLength = newValue.length;
        /** @type {?} */
        let oldValue = this.getValue() || '';
        /** @type {?} */
        let oldValueLength = oldValue.length;
        if (keyCode === 8 && oldValue !== newValue) {
            caretPosition = caretPosition - (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
        }
        else if (oldValue !== newValue) {
            if (caretPosition >= oldValueLength) {
                caretPosition = newValueLength;
            }
            else {
                caretPosition = caretPosition + (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
            }
        }
        return caretPosition;
    }
    /**
     * @param {?} skipMaskChars
     * @param {?} val
     * @param {?} mask
     * @param {?=} isReversed
     * @return {?}
     */
    getMasked(skipMaskChars, val, mask, isReversed = false) {
        /** @type {?} */
        let buf = [];
        /** @type {?} */
        let value = val;
        /** @type {?} */
        let maskIndex = 0;
        /** @type {?} */
        let maskLen = mask.length;
        /** @type {?} */
        let valueIndex = 0;
        /** @type {?} */
        let valueLength = value.length;
        /** @type {?} */
        let offset = 1;
        /** @type {?} */
        let addMethod = 'push';
        /** @type {?} */
        let resetPos = -1;
        /** @type {?} */
        let lastMaskChar;
        /** @type {?} */
        let lastUntranslatedMaskChar;
        /** @type {?} */
        let check;
        if (isReversed) {
            addMethod = 'unshift';
            offset = -1;
            lastMaskChar = 0;
            maskIndex = maskLen - 1;
            valueIndex = valueLength - 1;
        }
        else {
            lastMaskChar = maskLen - 1;
        }
        check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        while (check) {
            /** @type {?} */
            let maskDigit = mask.charAt(maskIndex);
            /** @type {?} */
            let valDigit = value.charAt(valueIndex);
            /** @type {?} */
            let translation = this.translationMask[maskDigit];
            if (translation) {
                if (valDigit.match(translation.pattern)) {
                    buf[addMethod](valDigit);
                    if (translation.recursive) {
                        if (resetPos === -1) {
                            resetPos = maskIndex;
                        }
                        else if (maskIndex === lastMaskChar) {
                            maskIndex = resetPos - offset;
                        }
                        if (lastMaskChar === resetPos) {
                            maskIndex -= offset;
                        }
                    }
                    maskIndex += offset;
                }
                else if (valDigit === lastUntranslatedMaskChar) {
                    lastUntranslatedMaskChar = undefined;
                }
                else if (translation.optional) {
                    maskIndex += offset;
                    valueIndex -= offset;
                }
                else {
                    this.invalidCharacters.push({
                        index: valueIndex,
                        digit: valDigit,
                        translated: translation.pattern
                    });
                }
                valueIndex += offset;
            }
            else {
                if (!skipMaskChars) {
                    buf[addMethod](maskDigit);
                }
                if (valDigit === maskDigit) {
                    valueIndex += offset;
                }
                else {
                    lastUntranslatedMaskChar = maskDigit;
                }
                maskIndex += offset;
            }
            check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        }
        /** @type {?} */
        let lastMaskCharDigit = mask.charAt(lastMaskChar);
        if (maskLen === valueLength + 1 && !this.translationMask[lastMaskCharDigit]) {
            buf.push(lastMaskCharDigit);
        }
        return buf.join('');
    }
    /**
     * @param {?} isReversed
     * @param {?} maskIndex
     * @param {?} maskLen
     * @param {?} valueIndex
     * @param {?} valueLength
     * @return {?}
     */
    isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength) {
        /** @type {?} */
        let check = false;
        if (isReversed) {
            check = (maskIndex > -1) && (valueIndex > -1);
        }
        else {
            check = (maskIndex < maskLen) && (valueIndex < valueLength);
        }
        return check;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setValue(value) {
        this.value = value;
    }
    /**
     * @return {?}
     */
    getValue() {
        return this.value;
    }
}
InputMaskDirective.decorators = [
    { type: Directive, args: [{
                selector: '[textMask]',
                providers: [CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR]
            },] }
];
/** @nocollapse */
InputMaskDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
InputMaskDirective.propDecorators = {
    inputMask: [{ type: Input, args: ['textMask',] }],
    onTextInput: [{ type: HostListener, args: ['input', ['$event'],] }, { type: HostListener, args: ['keyup', ['$event'],] }]
};
if (false) {
    /**
     * Object defining mask and "reversed" status.
     * @type {?}
     */
    InputMaskDirective.prototype.inputMask;
    /** @type {?} */
    InputMaskDirective.prototype.translationMask;
    /** @type {?} */
    InputMaskDirective.prototype.byPassKeys;
    /** @type {?} */
    InputMaskDirective.prototype.value;
    /** @type {?} */
    InputMaskDirective.prototype.invalidCharacters;
    /** @type {?} */
    InputMaskDirective.prototype._onChange;
    /** @type {?} */
    InputMaskDirective.prototype._onTouched;
    /** @type {?} */
    InputMaskDirective.prototype.el;
    /** @type {?} */
    InputMaskDirective.prototype.render;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dC1tYXNrLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29yZS8iLCJzb3VyY2VzIjpbImZvcm0vY29tcG9uZW50cy93aWRnZXRzL3RleHQvdGV4dC1tYXNrLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxPQUFPLEVBQ0gsU0FBUyxFQUNULFVBQVUsRUFDVixVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFFTCxTQUFTLEVBRVosTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDOztBQUV6RSxhQUFhLG1DQUFtQyxHQUFRO0lBQ3BELE9BQU8sRUFBRSxpQkFBaUI7SUFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQztJQUNqRCxLQUFLLEVBQUUsSUFBSTtDQUNkLENBQUM7QUFNRixNQUFNOzs7OztJQW9CRixZQUFvQixFQUFjLEVBQVUsTUFBaUI7UUFBekMsT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQUFVLFdBQU0sR0FBTixNQUFNLENBQVc7K0JBWm5DO1lBQ3RCLEdBQUcsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUU7WUFDdEIsR0FBRyxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFO1lBQ3RDLEdBQUcsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRTtZQUN2QyxHQUFHLEVBQUUsRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFO1lBQy9CLEdBQUcsRUFBRSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUU7U0FDL0I7MEJBRW9CLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUs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QUUsQ0FBQyxDQUFDO0tBQ3ZCOzs7Ozs7Ozs7SUFFTyxTQUFTLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVc7O1FBQ3JFLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNsQixJQUFJLFVBQVUsRUFBRTtZQUNaLEtBQUssR0FBRyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakQ7YUFBTTtZQUNILEtBQUssR0FBRyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQztTQUMvRDtRQUNELE9BQU8sS0FBSyxDQUFDOzs7Ozs7SUFHVCxRQUFRLENBQUMsS0FBSztRQUNsQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzs7Ozs7SUFHZixRQUFRO1FBQ1osT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDOzs7O1lBNUx6QixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLFlBQVk7Z0JBQ3RCLFNBQVMsRUFBRSxDQUFDLG1DQUFtQyxDQUFDO2FBQ25EOzs7O1lBbkJHLFVBQVU7WUFLVixTQUFTOzs7d0JBa0JSLEtBQUssU0FBQyxVQUFVOzBCQTBCaEIsWUFBWSxTQUFDLE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQyxjQUNoQyxZQUFZLFNBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuIC8qIHRzbGludDpkaXNhYmxlOiBjb21wb25lbnQtc2VsZWN0b3Igbm8tdXNlLWJlZm9yZS1kZWNsYXJlIG5vLWlucHV0LXJlbmFtZSAgKi9cblxuaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBJbnB1dCxcbiAgICBPbkNoYW5nZXMsXG4gICAgUmVuZGVyZXIyLFxuICAgIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmV4cG9ydCBjb25zdCBDVVNUT01fSU5QVVRfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElucHV0TWFza0RpcmVjdGl2ZSksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3RleHRNYXNrXScsXG4gICAgcHJvdmlkZXJzOiBbQ1VTVE9NX0lOUFVUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1JdXG59KVxuZXhwb3J0IGNsYXNzIElucHV0TWFza0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgLyoqIE9iamVjdCBkZWZpbmluZyBtYXNrIGFuZCBcInJldmVyc2VkXCIgc3RhdHVzLiAqL1xuICAgIEBJbnB1dCgndGV4dE1hc2snKSBpbnB1dE1hc2s6IHtcbiAgICAgICAgbWFzazogJycsXG4gICAgICAgIGlzUmV2ZXJzZWQ6IGZhbHNlXG4gICAgfTtcblxuICAgIHByaXZhdGUgdHJhbnNsYXRpb25NYXNrID0ge1xuICAgICAgICAnMCc6IHsgcGF0dGVybjogL1xcZC8gfSxcbiAgICAgICAgJzknOiB7IHBhdHRlcm46IC9cXGQvLCBvcHRpb25hbDogdHJ1ZSB9LFxuICAgICAgICAnIyc6IHsgcGF0dGVybjogL1xcZC8sIHJlY3Vyc2l2ZTogdHJ1ZSB9LFxuICAgICAgICAnQSc6IHsgcGF0dGVybjogL1thLXpBLVowLTldLyB9LFxuICAgICAgICAnUyc6IHsgcGF0dGVybjogL1thLXpBLVpdLyB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgYnlQYXNzS2V5cyA9IFs5LCAxNiwgMTcsIDE4LCAzNiwgMzcsIDM4LCAzOSwgNDAsIDkxXTtcbiAgICBwcml2YXRlIHZhbHVlO1xuICAgIHByaXZhdGUgaW52YWxpZENoYXJhY3RlcnMgPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsIHByaXZhdGUgcmVuZGVyOiBSZW5kZXJlcjIpIHtcbiAgICB9XG5cbiAgICBfb25DaGFuZ2UgPSAoXzogYW55KSA9PiB7XG4gICAgfVxuXG4gICAgX29uVG91Y2hlZCA9ICgpID0+IHtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdpbnB1dCcsIFsnJGV2ZW50J10pXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5dXAnLCBbJyRldmVudCddKSBvblRleHRJbnB1dChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dE1hc2sgJiYgdGhpcy5pbnB1dE1hc2subWFzaykge1xuICAgICAgICAgICAgdGhpcy5tYXNrVmFsdWUodGhpcy5lbC5uYXRpdmVFbGVtZW50LnZhbHVlLCB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dE1hc2subWFzaywgdGhpcy5pbnB1dE1hc2suaXNSZXZlcnNlZCwgZXZlbnQua2V5Q29kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snaW5wdXRNYXNrJ10gJiYgY2hhbmdlc1snaW5wdXRNYXNrJ10uY3VycmVudFZhbHVlWydtYXNrJ10pIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRNYXNrID0gY2hhbmdlc1snaW5wdXRNYXNrJ10uY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkID0gZm47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtYXNrVmFsdWUoYWN0dWFsVmFsdWUsIHN0YXJ0Q2FyZXQsIG1hc2tUb0FwcGx5LCBpc01hc2tSZXZlcnNlZCwga2V5Q29kZSkge1xuICAgICAgICBpZiAodGhpcy5ieVBhc3NLZXlzLmluZGV4T2Yoa2V5Q29kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldE1hc2tlZChmYWxzZSwgYWN0dWFsVmFsdWUsIG1hc2tUb0FwcGx5LCBpc01hc2tSZXZlcnNlZCk7XG4gICAgICAgICAgICBsZXQgY2FsY3VsYXRlZENhcmV0ID0gdGhpcy5jYWxjdWxhdGVDYXJldFBvc2l0aW9uKHN0YXJ0Q2FyZXQsIGFjdHVhbFZhbHVlLCBrZXlDb2RlKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyLnNldEF0dHJpYnV0ZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNldENhcmV0UG9zaXRpb24oY2FsY3VsYXRlZENhcmV0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2V0Q2FyZXRQb3NpdGlvbihjYXJldFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5tb3ZlU3RhcnQgPSBjYXJldFBvc2l0aW9uO1xuICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQubW92ZUVuZCA9IGNhcmV0UG9zaXRpb247XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlQ2FyZXRQb3NpdGlvbihjYXJldFBvc2l0aW9uLCBuZXdWYWx1ZSwga2V5Q29kZSkge1xuICAgICAgICBsZXQgbmV3VmFsdWVMZW5ndGggPSBuZXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGxldCBvbGRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKSB8fCAnJztcbiAgICAgICAgbGV0IG9sZFZhbHVlTGVuZ3RoID0gb2xkVmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGlmIChrZXlDb2RlID09PSA4ICYmIG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IGNhcmV0UG9zaXRpb24gLSAobmV3VmFsdWUuc2xpY2UoMCwgY2FyZXRQb3NpdGlvbikubGVuZ3RoIC0gb2xkVmFsdWUuc2xpY2UoMCwgY2FyZXRQb3NpdGlvbikubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYXJldFBvc2l0aW9uID49IG9sZFZhbHVlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IG5ld1ZhbHVlTGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gY2FyZXRQb3NpdGlvbiArIChuZXdWYWx1ZS5zbGljZSgwLCBjYXJldFBvc2l0aW9uKS5sZW5ndGggLSBvbGRWYWx1ZS5zbGljZSgwLCBjYXJldFBvc2l0aW9uKS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYXJldFBvc2l0aW9uO1xuICAgIH1cblxuICAgIGdldE1hc2tlZChza2lwTWFza0NoYXJzLCB2YWwsIG1hc2ssIGlzUmV2ZXJzZWQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgYnVmID0gW10sXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbCxcbiAgICAgICAgICAgIG1hc2tJbmRleCA9IDAsXG4gICAgICAgICAgICBtYXNrTGVuID0gbWFzay5sZW5ndGgsXG4gICAgICAgICAgICB2YWx1ZUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgb2Zmc2V0ID0gMSxcbiAgICAgICAgICAgIGFkZE1ldGhvZCA9ICdwdXNoJyxcbiAgICAgICAgICAgIHJlc2V0UG9zID0gLTEsXG4gICAgICAgICAgICBsYXN0TWFza0NoYXIsXG4gICAgICAgICAgICBsYXN0VW50cmFuc2xhdGVkTWFza0NoYXIsXG4gICAgICAgICAgICBjaGVjaztcblxuICAgICAgICBpZiAoaXNSZXZlcnNlZCkge1xuICAgICAgICAgICAgYWRkTWV0aG9kID0gJ3Vuc2hpZnQnO1xuICAgICAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICBsYXN0TWFza0NoYXIgPSAwO1xuICAgICAgICAgICAgbWFza0luZGV4ID0gbWFza0xlbiAtIDE7XG4gICAgICAgICAgICB2YWx1ZUluZGV4ID0gdmFsdWVMZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdE1hc2tDaGFyID0gbWFza0xlbiAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2sgPSB0aGlzLmlzVG9DaGVjayhpc1JldmVyc2VkLCBtYXNrSW5kZXgsIG1hc2tMZW4sIHZhbHVlSW5kZXgsIHZhbHVlTGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGNoZWNrKSB7XG4gICAgICAgICAgICBsZXQgbWFza0RpZ2l0ID0gbWFzay5jaGFyQXQobWFza0luZGV4KSxcbiAgICAgICAgICAgICAgICB2YWxEaWdpdCA9IHZhbHVlLmNoYXJBdCh2YWx1ZUluZGV4KSxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbiA9IHRoaXMudHJhbnNsYXRpb25NYXNrW21hc2tEaWdpdF07XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh2YWxEaWdpdC5tYXRjaCh0cmFuc2xhdGlvbi5wYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgICAgICBidWZbYWRkTWV0aG9kXSh2YWxEaWdpdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbi5yZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNldFBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldFBvcyA9IG1hc2tJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWFza0luZGV4ID09PSBsYXN0TWFza0NoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrSW5kZXggPSByZXNldFBvcyAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0TWFza0NoYXIgPT09IHJlc2V0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0luZGV4IC09IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5kZXggKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsRGlnaXQgPT09IGxhc3RVbnRyYW5zbGF0ZWRNYXNrQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VW50cmFuc2xhdGVkTWFza0NoYXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGlvbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICBtYXNrSW5kZXggKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUluZGV4IC09IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRDaGFyYWN0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHZhbHVlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWdpdDogdmFsRGlnaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkOiB0cmFuc2xhdGlvbi5wYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZUluZGV4ICs9IG9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFza2lwTWFza0NoYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZlthZGRNZXRob2RdKG1hc2tEaWdpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWxEaWdpdCA9PT0gbWFza0RpZ2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSW5kZXggKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RVbnRyYW5zbGF0ZWRNYXNrQ2hhciA9IG1hc2tEaWdpdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFza0luZGV4ICs9IG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrID0gdGhpcy5pc1RvQ2hlY2soaXNSZXZlcnNlZCwgbWFza0luZGV4LCBtYXNrTGVuLCB2YWx1ZUluZGV4LCB2YWx1ZUxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGFzdE1hc2tDaGFyRGlnaXQgPSBtYXNrLmNoYXJBdChsYXN0TWFza0NoYXIpO1xuICAgICAgICBpZiAobWFza0xlbiA9PT0gdmFsdWVMZW5ndGggKyAxICYmICF0aGlzLnRyYW5zbGF0aW9uTWFza1tsYXN0TWFza0NoYXJEaWdpdF0pIHtcbiAgICAgICAgICAgIGJ1Zi5wdXNoKGxhc3RNYXNrQ2hhckRpZ2l0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidWYuam9pbignJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc1RvQ2hlY2soaXNSZXZlcnNlZCwgbWFza0luZGV4LCBtYXNrTGVuLCB2YWx1ZUluZGV4LCB2YWx1ZUxlbmd0aCkge1xuICAgICAgICBsZXQgY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzUmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIGNoZWNrID0gKG1hc2tJbmRleCA+IC0xKSAmJiAodmFsdWVJbmRleCA+IC0xKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrID0gKG1hc2tJbmRleCA8IG1hc2tMZW4pICYmICh2YWx1ZUluZGV4IDwgdmFsdWVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGVjaztcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG59XG4iXX0=