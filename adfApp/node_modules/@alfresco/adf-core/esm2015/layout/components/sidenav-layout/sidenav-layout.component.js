/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ContentChild, Input, Output, ViewChild, EventEmitter } from '@angular/core';
import { MediaMatcher } from '@angular/cdk/layout';
import { SidenavLayoutContentDirective } from '../../directives/sidenav-layout-content.directive';
import { SidenavLayoutHeaderDirective } from '../../directives/sidenav-layout-header.directive';
import { SidenavLayoutNavigationDirective } from '../../directives/sidenav-layout-navigation.directive';
import { BehaviorSubject } from 'rxjs';
export class SidenavLayoutComponent {
    /**
     * @param {?} mediaMatcher
     */
    constructor(mediaMatcher) {
        this.mediaMatcher = mediaMatcher;
        /**
         * The side that the drawer is attached to. Possible values are 'start' and 'end'.
         */
        this.position = 'start';
        /**
         * Toggles showing/hiding the navigation region.
         */
        this.hideSidenav = false;
        /**
         * Should the navigation region be expanded initially?
         */
        this.expandedSidenav = true;
        /**
         * Emitted when the menu toggle and the collapsed/expanded state of the sideNav changes.
         */
        this.expanded = new EventEmitter();
        this.templateContext = {
            toggleMenu: () => { },
            isMenuMinimized: () => this.isMenuMinimized
        };
        this.onMediaQueryChange = this.onMediaQueryChange.bind(this);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const initialMenuState = !this.expandedSidenav;
        this.menuOpenStateSubject = new BehaviorSubject(initialMenuState);
        this.menuOpenState$ = this.menuOpenStateSubject.asObservable();
        /** @type {?} */
        const stepOver = this.stepOver || SidenavLayoutComponent.STEP_OVER;
        this.isMenuMinimized = initialMenuState;
        this.mediaQueryList = this.mediaMatcher.matchMedia(`(max-width: ${stepOver}px)`);
        this.mediaQueryList.addListener(this.onMediaQueryChange);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.templateContext.toggleMenu = this.toggleMenu.bind(this);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.mediaQueryList.removeListener(this.onMediaQueryChange);
    }
    /**
     * @return {?}
     */
    toggleMenu() {
        if (!this.mediaQueryList.matches) {
            this.isMenuMinimized = !this.isMenuMinimized;
        }
        else {
            this.isMenuMinimized = false;
        }
        this.container.toggleMenu();
        this.expanded.emit(!this.isMenuMinimized);
    }
    /**
     * @return {?}
     */
    get isMenuMinimized() {
        return this._isMenuMinimized;
    }
    /**
     * @param {?} menuState
     * @return {?}
     */
    set isMenuMinimized(menuState) {
        this._isMenuMinimized = menuState;
        this.menuOpenStateSubject.next(!menuState);
    }
    /**
     * @return {?}
     */
    get isHeaderInside() {
        return this.mediaQueryList.matches;
    }
    /**
     * @return {?}
     */
    get headerTemplate() {
        return this.headerDirective && this.headerDirective.template || this.emptyTemplate;
    }
    /**
     * @return {?}
     */
    get navigationTemplate() {
        return this.navigationDirective && this.navigationDirective.template || this.emptyTemplate;
    }
    /**
     * @return {?}
     */
    get contentTemplate() {
        return this.contentDirective && this.contentDirective.template || this.emptyTemplate;
    }
    /**
     * @return {?}
     */
    onMediaQueryChange() {
        this.isMenuMinimized = false;
        this.expanded.emit(!this.isMenuMinimized);
    }
}
SidenavLayoutComponent.STEP_OVER = 600;
SidenavLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sidenav-layout',
                template: "<div class=\"sidenav-layout\">\n    <ng-container *ngIf=\"!isHeaderInside\">\n        <ng-container class=\"adf-sidenav-layout-outer-header\"\n                      *ngTemplateOutlet=\"headerTemplate; context:templateContext\"></ng-container>\n    </ng-container>\n\n    <adf-layout-container #container\n                          [position]=\"position\"\n                          [sidenavMin]=\"sidenavMin\"\n                          [sidenavMax]=\"sidenavMax\"\n                          [mediaQueryList]=\"mediaQueryList\"\n                          [hideSidenav]=\"hideSidenav\"\n                          [expandedSidenav]=\"expandedSidenav\"\n                          data-automation-id=\"adf-layout-container\"\n                          class=\"layout__content\">\n\n        <ng-container app-layout-navigation\n                      *ngTemplateOutlet=\"navigationTemplate; context:templateContext\"></ng-container>\n\n        <ng-container app-layout-content>\n            <ng-container *ngIf=\"isHeaderInside\">\n                <ng-container *ngTemplateOutlet=\"headerTemplate; context:templateContext\"></ng-container>\n            </ng-container>\n            <ng-container *ngTemplateOutlet=\"contentTemplate; context:templateContext\"></ng-container>\n        </ng-container>\n    </adf-layout-container>\n</div>\n\n<ng-template #emptyTemplate></ng-template>\n",
                styles: [":host{display:flex;flex:1}:host .sidenav-layout{width:100%;display:flex;flex-direction:column}:host .sidenav-layout .layout__content{flex:1 1 auto}:host router-outlet{flex:0 0}"]
            }] }
];
/** @nocollapse */
SidenavLayoutComponent.ctorParameters = () => [
    { type: MediaMatcher }
];
SidenavLayoutComponent.propDecorators = {
    position: [{ type: Input }],
    sidenavMin: [{ type: Input }],
    sidenavMax: [{ type: Input }],
    stepOver: [{ type: Input }],
    hideSidenav: [{ type: Input }],
    expandedSidenav: [{ type: Input }],
    expanded: [{ type: Output }],
    headerDirective: [{ type: ContentChild, args: [SidenavLayoutHeaderDirective,] }],
    navigationDirective: [{ type: ContentChild, args: [SidenavLayoutNavigationDirective,] }],
    contentDirective: [{ type: ContentChild, args: [SidenavLayoutContentDirective,] }],
    container: [{ type: ViewChild, args: ['container',] }],
    emptyTemplate: [{ type: ViewChild, args: ['emptyTemplate',] }]
};
if (false) {
    /** @type {?} */
    SidenavLayoutComponent.STEP_OVER;
    /**
     * The side that the drawer is attached to. Possible values are 'start' and 'end'.
     * @type {?}
     */
    SidenavLayoutComponent.prototype.position;
    /**
     * Minimum size of the navigation region.
     * @type {?}
     */
    SidenavLayoutComponent.prototype.sidenavMin;
    /**
     * Maximum size of the navigation region.
     * @type {?}
     */
    SidenavLayoutComponent.prototype.sidenavMax;
    /**
     * Screen size at which display switches from small screen to large screen configuration.
     * @type {?}
     */
    SidenavLayoutComponent.prototype.stepOver;
    /**
     * Toggles showing/hiding the navigation region.
     * @type {?}
     */
    SidenavLayoutComponent.prototype.hideSidenav;
    /**
     * Should the navigation region be expanded initially?
     * @type {?}
     */
    SidenavLayoutComponent.prototype.expandedSidenav;
    /**
     * Emitted when the menu toggle and the collapsed/expanded state of the sideNav changes.
     * @type {?}
     */
    SidenavLayoutComponent.prototype.expanded;
    /** @type {?} */
    SidenavLayoutComponent.prototype.headerDirective;
    /** @type {?} */
    SidenavLayoutComponent.prototype.navigationDirective;
    /** @type {?} */
    SidenavLayoutComponent.prototype.contentDirective;
    /** @type {?} */
    SidenavLayoutComponent.prototype.menuOpenStateSubject;
    /** @type {?} */
    SidenavLayoutComponent.prototype.menuOpenState$;
    /** @type {?} */
    SidenavLayoutComponent.prototype.container;
    /** @type {?} */
    SidenavLayoutComponent.prototype.emptyTemplate;
    /** @type {?} */
    SidenavLayoutComponent.prototype.mediaQueryList;
    /** @type {?} */
    SidenavLayoutComponent.prototype._isMenuMinimized;
    /** @type {?} */
    SidenavLayoutComponent.prototype.templateContext;
    /** @type {?} */
    SidenavLayoutComponent.prototype.mediaMatcher;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lkZW5hdi1sYXlvdXQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb3JlLyIsInNvdXJjZXMiOlsibGF5b3V0L2NvbXBvbmVudHMvc2lkZW5hdi1sYXlvdXQvc2lkZW5hdi1sYXlvdXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQXlCLFNBQVMsRUFBMEIsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQy9JLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNuRCxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSxtREFBbUQsQ0FBQztBQUNsRyxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSxrREFBa0QsQ0FBQztBQUNoRyxPQUFPLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSxzREFBc0QsQ0FBQztBQUN4RyxPQUFPLEVBQUUsZUFBZSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBT25ELE1BQU07Ozs7SUEyQ0YsWUFBb0IsWUFBMEI7UUFBMUIsaUJBQVksR0FBWixZQUFZLENBQWM7Ozs7d0JBdEMxQixPQUFPOzs7OzJCQVlKLEtBQUs7Ozs7K0JBR0QsSUFBSTs7Ozt3QkFHVixJQUFJLFlBQVksRUFBVzsrQkFlOUI7WUFDZCxVQUFVLEVBQUUsR0FBRyxFQUFFLElBQUc7WUFDcEIsZUFBZSxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlO1NBQzlDO1FBR0csSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDaEU7Ozs7SUFFRCxRQUFROztRQUNKLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDO1FBRS9DLElBQUksQ0FBQyxvQkFBb0Is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ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBJbnB1dCwgT3V0cHV0LCBPbkluaXQsIEFmdGVyVmlld0luaXQsIFZpZXdDaGlsZCwgT25EZXN0cm95LCBUZW1wbGF0ZVJlZiwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNZWRpYU1hdGNoZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvbGF5b3V0JztcbmltcG9ydCB7IFNpZGVuYXZMYXlvdXRDb250ZW50RGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9zaWRlbmF2LWxheW91dC1jb250ZW50LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTaWRlbmF2TGF5b3V0SGVhZGVyRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9zaWRlbmF2LWxheW91dC1oZWFkZXIuZGlyZWN0aXZlJztcbmltcG9ydCB7IFNpZGVuYXZMYXlvdXROYXZpZ2F0aW9uRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9zaWRlbmF2LWxheW91dC1uYXZpZ2F0aW9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtc2lkZW5hdi1sYXlvdXQnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zaWRlbmF2LWxheW91dC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vc2lkZW5hdi1sYXlvdXQuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBTaWRlbmF2TGF5b3V0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgc3RhdGljIFNURVBfT1ZFUiA9IDYwMDtcblxuICAgIC8qKiBUaGUgc2lkZSB0aGF0IHRoZSBkcmF3ZXIgaXMgYXR0YWNoZWQgdG8uIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3N0YXJ0JyBhbmQgJ2VuZCcuICovXG4gICAgQElucHV0KCkgcG9zaXRpb24gPSAnc3RhcnQnO1xuXG4gICAgLyoqIE1pbmltdW0gc2l6ZSBvZiB0aGUgbmF2aWdhdGlvbiByZWdpb24uICovXG4gICAgQElucHV0KCkgc2lkZW5hdk1pbjogbnVtYmVyO1xuXG4gICAgLyoqIE1heGltdW0gc2l6ZSBvZiB0aGUgbmF2aWdhdGlvbiByZWdpb24uICovXG4gICAgQElucHV0KCkgc2lkZW5hdk1heDogbnVtYmVyO1xuXG4gICAgLyoqIFNjcmVlbiBzaXplIGF0IHdoaWNoIGRpc3BsYXkgc3dpdGNoZXMgZnJvbSBzbWFsbCBzY3JlZW4gdG8gbGFyZ2Ugc2NyZWVuIGNvbmZpZ3VyYXRpb24uICovXG4gICAgQElucHV0KCkgc3RlcE92ZXI6IG51bWJlcjtcblxuICAgIC8qKiBUb2dnbGVzIHNob3dpbmcvaGlkaW5nIHRoZSBuYXZpZ2F0aW9uIHJlZ2lvbi4gKi9cbiAgICBASW5wdXQoKSBoaWRlU2lkZW5hdiA9IGZhbHNlO1xuXG4gICAgLyoqIFNob3VsZCB0aGUgbmF2aWdhdGlvbiByZWdpb24gYmUgZXhwYW5kZWQgaW5pdGlhbGx5PyAqL1xuICAgIEBJbnB1dCgpIGV4cGFuZGVkU2lkZW5hdiA9IHRydWU7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSBtZW51IHRvZ2dsZSBhbmQgdGhlIGNvbGxhcHNlZC9leHBhbmRlZCBzdGF0ZSBvZiB0aGUgc2lkZU5hdiBjaGFuZ2VzLiAqL1xuICAgIEBPdXRwdXQoKSBleHBhbmRlZCA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIEBDb250ZW50Q2hpbGQoU2lkZW5hdkxheW91dEhlYWRlckRpcmVjdGl2ZSkgaGVhZGVyRGlyZWN0aXZlOiBTaWRlbmF2TGF5b3V0SGVhZGVyRGlyZWN0aXZlO1xuICAgIEBDb250ZW50Q2hpbGQoU2lkZW5hdkxheW91dE5hdmlnYXRpb25EaXJlY3RpdmUpIG5hdmlnYXRpb25EaXJlY3RpdmU6IFNpZGVuYXZMYXlvdXROYXZpZ2F0aW9uRGlyZWN0aXZlO1xuICAgIEBDb250ZW50Q2hpbGQoU2lkZW5hdkxheW91dENvbnRlbnREaXJlY3RpdmUpIGNvbnRlbnREaXJlY3RpdmU6IFNpZGVuYXZMYXlvdXRDb250ZW50RGlyZWN0aXZlO1xuXG4gICAgcHJpdmF0ZSBtZW51T3BlblN0YXRlU3ViamVjdDogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+O1xuICAgIHB1YmxpYyBtZW51T3BlblN0YXRlJDogT2JzZXJ2YWJsZTxib29sZWFuPjtcblxuICAgIEBWaWV3Q2hpbGQoJ2NvbnRhaW5lcicpIGNvbnRhaW5lcjogYW55O1xuICAgIEBWaWV3Q2hpbGQoJ2VtcHR5VGVtcGxhdGUnKSBlbXB0eVRlbXBsYXRlOiBhbnk7XG5cbiAgICBtZWRpYVF1ZXJ5TGlzdDogTWVkaWFRdWVyeUxpc3Q7XG4gICAgX2lzTWVudU1pbmltaXplZDtcblxuICAgIHRlbXBsYXRlQ29udGV4dCA9IHtcbiAgICAgICAgdG9nZ2xlTWVudTogKCkgPT4ge30sXG4gICAgICAgIGlzTWVudU1pbmltaXplZDogKCkgPT4gdGhpcy5pc01lbnVNaW5pbWl6ZWRcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBtZWRpYU1hdGNoZXI6IE1lZGlhTWF0Y2hlcikge1xuICAgICAgICB0aGlzLm9uTWVkaWFRdWVyeUNoYW5nZSA9IHRoaXMub25NZWRpYVF1ZXJ5Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxNZW51U3RhdGUgPSAhdGhpcy5leHBhbmRlZFNpZGVuYXY7XG5cbiAgICAgICAgdGhpcy5tZW51T3BlblN0YXRlU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oaW5pdGlhbE1lbnVTdGF0ZSk7XG4gICAgICAgIHRoaXMubWVudU9wZW5TdGF0ZSQgPSB0aGlzLm1lbnVPcGVuU3RhdGVTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuXG4gICAgICAgIGNvbnN0IHN0ZXBPdmVyID0gdGhpcy5zdGVwT3ZlciB8fCBTaWRlbmF2TGF5b3V0Q29tcG9uZW50LlNURVBfT1ZFUjtcbiAgICAgICAgdGhpcy5pc01lbnVNaW5pbWl6ZWQgPSBpbml0aWFsTWVudVN0YXRlO1xuXG4gICAgICAgIHRoaXMubWVkaWFRdWVyeUxpc3QgPSB0aGlzLm1lZGlhTWF0Y2hlci5tYXRjaE1lZGlhKGAobWF4LXdpZHRoOiAke3N0ZXBPdmVyfXB4KWApO1xuICAgICAgICB0aGlzLm1lZGlhUXVlcnlMaXN0LmFkZExpc3RlbmVyKHRoaXMub25NZWRpYVF1ZXJ5Q2hhbmdlKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVDb250ZXh0LnRvZ2dsZU1lbnUgPSB0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tZWRpYVF1ZXJ5TGlzdC5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uTWVkaWFRdWVyeUNoYW5nZSk7XG4gICAgfVxuXG4gICAgdG9nZ2xlTWVudSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhUXVlcnlMaXN0Lm1hdGNoZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaXNNZW51TWluaW1pemVkID0gIXRoaXMuaXNNZW51TWluaW1pemVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc01lbnVNaW5pbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnRvZ2dsZU1lbnUoKTtcbiAgICAgICAgdGhpcy5leHBhbmRlZC5lbWl0KCF0aGlzLmlzTWVudU1pbmltaXplZCk7XG4gICAgfVxuXG4gICAgZ2V0IGlzTWVudU1pbmltaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzTWVudU1pbmltaXplZDtcbiAgICB9XG5cbiAgICBzZXQgaXNNZW51TWluaW1pemVkKG1lbnVTdGF0ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9pc01lbnVNaW5pbWl6ZWQgPSBtZW51U3RhdGU7XG4gICAgICAgIHRoaXMubWVudU9wZW5TdGF0ZVN1YmplY3QubmV4dCghbWVudVN0YXRlKTtcbiAgICB9XG5cbiAgICBnZXQgaXNIZWFkZXJJbnNpZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhUXVlcnlMaXN0Lm1hdGNoZXM7XG4gICAgfVxuXG4gICAgZ2V0IGhlYWRlclRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJEaXJlY3RpdmUgJiYgdGhpcy5oZWFkZXJEaXJlY3RpdmUudGVtcGxhdGUgfHwgdGhpcy5lbXB0eVRlbXBsYXRlO1xuICAgIH1cblxuICAgIGdldCBuYXZpZ2F0aW9uVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25EaXJlY3RpdmUgJiYgdGhpcy5uYXZpZ2F0aW9uRGlyZWN0aXZlLnRlbXBsYXRlIHx8IHRoaXMuZW1wdHlUZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBnZXQgY29udGVudFRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RGlyZWN0aXZlICYmIHRoaXMuY29udGVudERpcmVjdGl2ZS50ZW1wbGF0ZSB8fCB0aGlzLmVtcHR5VGVtcGxhdGU7XG4gICAgfVxuXG4gICAgb25NZWRpYVF1ZXJ5Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLmlzTWVudU1pbmltaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV4cGFuZGVkLmVtaXQoIXRoaXMuaXNNZW51TWluaW1pemVkKTtcbiAgICB9XG59XG4iXX0=